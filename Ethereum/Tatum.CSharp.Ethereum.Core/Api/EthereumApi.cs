/*
 * Tatum API Reference
 *
 * # Welcome to the Tatum API Reference!  ## What is Tatum?  Tatum offers a flexible framework to build, run, and scale blockchain apps fast. To learn more about the Tatum blockchain development framework, visit [our website](https://tatum.io/framework).  The Tatum API features powerful endpoints that simplify a complex blockchain into single API requests. Code for all supported blockchains using unified API calls.  ## Supported blockchains  Tatum supports multiple blockchains and various blockchain features.  Because not all blockchains function identically, Tatum supports a different set of features on each blockchain.  To see all the blockchains that Tatum supports, please refer to [this article](https://docs.tatum.io/introduction/supported-blockchains).  ## Need help?  To chat with other developers, get help from the Support team, and engage with the thriving Tatum community, join  our [Discord server](https://discord.com/invite/tatum). For more information about how to work with Tatum, review the [online documentation](https://docs.tatum.io/).  # Authentication  When using the Tatum API, you authenticate yourself with an **API key**. <SecurityDefinitions /> 
 *
 * The version of the OpenAPI document: 3.17.2
 * Generated by: https://github.com/openapitools/openapi-generator.git
 */


using System;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.Linq;
using System.Net;
using System.Net.Http;
using System.Net.Mime;
using Tatum.CSharp.Ethereum.Core.Client;
using Tatum.CSharp.Ethereum.Core.Model;

namespace Tatum.CSharp.Ethereum.Core.Api
{

    /// <summary>
    /// Represents a collection of functions to interact with the API endpoints
    /// </summary>
    public interface IEthereumApiSync : IApiAccessor
    {
        #region Synchronous Operations
        /// <summary>
        /// Invoke a method in a smart contract on Ethereum
        /// </summary>
        /// <remarks>
        /// 2 credits per API call Invoke a method in an existing smart contract on Ethereum. You can call a read-only or write method. For read-only methods, the output of the invoked method is returned. For write methods, the ID of the associated transaction is returned. Troubleshooting a failed transaction Tatum ensures that this API works against the blockchain (accesses the blockchain, finds the specified smart contract, and executes the specified ABI method with the provided parameters). However, because this API can be run against any smart contract on the blockchain, Tatum cannot in any way guarantee that the method itself will be executed successfully. If you have issues with invoking the method, refer to the user documentation for this method, or contact the author of the smart contract. For more information about invoking methods in smart contracts, see this article on our Support Portal. Signing a transaction When invoking a method in a smart contract, you are charged a fee for the transaction, and you must sign the transaction with the private key of the blockchain address from which the fee will be deducted. Providing the private key in the API is not a secure way of signing transactions, because the private key can be stolen or exposed. Your private keys should never leave your security perimeter. You should use the private keys only for testing a solution you are building on the testnet of a blockchain. For signing transactions on the mainnet, we strongly recommend that you use the Tatum Key Management System (KMS) and provide the signature ID instead of the private key in the API. Alternatively, you can use the Tatum JavaScript client.
        /// </remarks>
        /// <exception cref="Tatum.CSharp.Ethereum.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="callSmartContractMethod"></param>
        /// <param name="xTestnetType">Type of Ethereum testnet. Defaults to ethereum-sepolia. (optional, default to ethereum-sepolia)</param>
        /// <returns>TransactionHash</returns>
        TransactionHash EthBlockchainSmartContractInvocation(CallSmartContractMethod callSmartContractMethod, string xTestnetType = default(string));
        /// <summary>
        /// Invoke a method in a smart contract on Ethereum
        /// </summary>
        /// <remarks>
        /// 2 credits per API call Invoke a method in an existing smart contract on Ethereum. You can call a read-only or write method. For read-only methods, the output of the invoked method is returned. For write methods, the ID of the associated transaction is returned. Troubleshooting a failed transaction Tatum ensures that this API works against the blockchain (accesses the blockchain, finds the specified smart contract, and executes the specified ABI method with the provided parameters). However, because this API can be run against any smart contract on the blockchain, Tatum cannot in any way guarantee that the method itself will be executed successfully. If you have issues with invoking the method, refer to the user documentation for this method, or contact the author of the smart contract. For more information about invoking methods in smart contracts, see this article on our Support Portal. Signing a transaction When invoking a method in a smart contract, you are charged a fee for the transaction, and you must sign the transaction with the private key of the blockchain address from which the fee will be deducted. Providing the private key in the API is not a secure way of signing transactions, because the private key can be stolen or exposed. Your private keys should never leave your security perimeter. You should use the private keys only for testing a solution you are building on the testnet of a blockchain. For signing transactions on the mainnet, we strongly recommend that you use the Tatum Key Management System (KMS) and provide the signature ID instead of the private key in the API. Alternatively, you can use the Tatum JavaScript client.
        /// </remarks>
        /// <exception cref="Tatum.CSharp.Ethereum.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="callReadSmartContractMethod"></param>
        /// <param name="xTestnetType">Type of Ethereum testnet. Defaults to ethereum-sepolia. (optional, default to ethereum-sepolia)</param>
        /// <returns>Data</returns>
        Data EthBlockchainSmartContractInvocation(CallReadSmartContractMethod callReadSmartContractMethod, string xTestnetType = default(string));
        /// <summary>
        /// Invoke a method in a smart contract on Ethereum
        /// </summary>
        /// <remarks>
        /// 2 credits per API call Invoke a method in an existing smart contract on Ethereum. You can call a read-only or write method. For read-only methods, the output of the invoked method is returned. For write methods, the ID of the associated transaction is returned. Troubleshooting a failed transaction Tatum ensures that this API works against the blockchain (accesses the blockchain, finds the specified smart contract, and executes the specified ABI method with the provided parameters). However, because this API can be run against any smart contract on the blockchain, Tatum cannot in any way guarantee that the method itself will be executed successfully. If you have issues with invoking the method, refer to the user documentation for this method, or contact the author of the smart contract. For more information about invoking methods in smart contracts, see this article on our Support Portal. Signing a transaction When invoking a method in a smart contract, you are charged a fee for the transaction, and you must sign the transaction with the private key of the blockchain address from which the fee will be deducted. Providing the private key in the API is not a secure way of signing transactions, because the private key can be stolen or exposed. Your private keys should never leave your security perimeter. You should use the private keys only for testing a solution you are building on the testnet of a blockchain. For signing transactions on the mainnet, we strongly recommend that you use the Tatum Key Management System (KMS) and provide the signature ID instead of the private key in the API. Alternatively, you can use the Tatum JavaScript client.
        /// </remarks>
        /// <exception cref="Tatum.CSharp.Ethereum.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="callSmartContractMethodKMS"></param>
        /// <param name="xTestnetType">Type of Ethereum testnet. Defaults to ethereum-sepolia. (optional, default to ethereum-sepolia)</param>
        /// <returns>SignatureId</returns>
        SignatureId EthBlockchainSmartContractInvocation(CallSmartContractMethodKMS callSmartContractMethodKMS, string xTestnetType = default(string));
        /// <summary>
        /// Send Ethereum / ERC20 from account to account
        /// </summary>
        /// <remarks>
        /// 2 credits per API call Send Ethereum or Tatum supported ERC20 token from account to account. Signing a transaction When sending ETH, you are charged a fee for the transaction, and you must sign the transaction with the private key of the blockchain address from which the fee will be deducted. Providing the private key in the API is not a secure way of signing transactions, because the private key can be stolen or exposed. Your private keys should never leave your security perimeter. You should use the private keys only for testing a solution you are building on the testnet of a blockchain. For signing transactions on the mainnet, we strongly recommend that you use the Tatum Key Management System (KMS) and provide the signature ID instead of the private key in the API. Alternatively, you can use the Tatum JavaScript client.
        /// </remarks>
        /// <exception cref="Tatum.CSharp.Ethereum.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="transferEthBlockchain"></param>
        /// <param name="xTestnetType">Type of Ethereum testnet. Defaults to ethereum-sepolia. (optional, default to ethereum-sepolia)</param>
        /// <returns>TransactionHash</returns>
        TransactionHash EthBlockchainTransfer(TransferEthBlockchain transferEthBlockchain, string xTestnetType = default(string));
        /// <summary>
        /// Send Ethereum / ERC20 from account to account
        /// </summary>
        /// <remarks>
        /// 2 credits per API call Send Ethereum or Tatum supported ERC20 token from account to account. Signing a transaction When sending ETH, you are charged a fee for the transaction, and you must sign the transaction with the private key of the blockchain address from which the fee will be deducted. Providing the private key in the API is not a secure way of signing transactions, because the private key can be stolen or exposed. Your private keys should never leave your security perimeter. You should use the private keys only for testing a solution you are building on the testnet of a blockchain. For signing transactions on the mainnet, we strongly recommend that you use the Tatum Key Management System (KMS) and provide the signature ID instead of the private key in the API. Alternatively, you can use the Tatum JavaScript client.
        /// </remarks>
        /// <exception cref="Tatum.CSharp.Ethereum.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="transferEthBlockchainKMS"></param>
        /// <param name="xTestnetType">Type of Ethereum testnet. Defaults to ethereum-sepolia. (optional, default to ethereum-sepolia)</param>
        /// <returns>SignatureId</returns>
        SignatureId EthBlockchainTransfer(TransferEthBlockchainKMS transferEthBlockchainKMS, string xTestnetType = default(string));
        /// <summary>
        /// Broadcast signed Ethereum transaction
        /// </summary>
        /// <remarks>
        /// 2 credits per API call Broadcast signed transaction to Ethereum blockchain. This method is used internally from Tatum KMS or Tatum client libraries. It is possible to create custom signing mechanism and use this method only for broadcasting data to the blockchain.
        /// </remarks>
        /// <exception cref="Tatum.CSharp.Ethereum.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="broadcastKMS"></param>
        /// <param name="xTestnetType">Type of Ethereum testnet. Defaults to ethereum-sepolia. (optional, default to ethereum-sepolia)</param>
        /// <returns>TransactionHash</returns>
        TransactionHash EthBroadcast(BroadcastKMS broadcastKMS, string xTestnetType = default(string));
        /// <summary>
        /// Generate Ethereum account address from Extended public key
        /// </summary>
        /// <remarks>
        /// 1 credit per API call. Generates an Ethereum account deposit address from an Extended public key. The deposit address is generated for the specific index - each extended public key can generate up to 2^31 addresses starting from index 0 until 2^31 - 1.
        /// </remarks>
        /// <exception cref="Tatum.CSharp.Ethereum.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="xpub">Extended public key of wallet.</param>
        /// <param name="index">Derivation index of the address to be generated.</param>
        /// <param name="xTestnetType">Type of Ethereum testnet. Defaults to ethereum-sepolia. (optional, default to ethereum-sepolia)</param>
        /// <returns>GeneratedAddressEth</returns>
        GeneratedAddressEth EthGenerateAddress(string xpub, decimal index, string xTestnetType = default(string));
        /// <summary>
        /// Generate Ethereum private key
        /// </summary>
        /// <remarks>
        /// 1 credit per API call. Generates the private key of an address from a mnemonic for a given derivation path index. The private key is generated for the specific index - each mnemonic can generate up to 2^32 private keys starting from index 0 until 2^31 - 1.
        /// </remarks>
        /// <exception cref="Tatum.CSharp.Ethereum.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="privKeyRequest"></param>
        /// <param name="xTestnetType">Type of Ethereum testnet. Defaults to ethereum-sepolia. (optional, default to ethereum-sepolia)</param>
        /// <returns>PrivKey</returns>
        PrivKey EthGenerateAddressPrivateKey(PrivKeyRequest privKeyRequest, string xTestnetType = default(string));
        /// <summary>
        /// Generate Ethereum wallet
        /// </summary>
        /// <remarks>
        /// 1 credit per API call. Tatum supports BIP44 HD wallets. Because they can generate 2^31 addresses from 1 mnemonic phrase, they are very convenient and secure. A mnemonic phrase consists of 24 special words in a defined order and can restore access to all generated addresses and private keys. Each address is identified by 3 main values: Private Key - your secret value which should never be revealed Public Key - a public address to be published Derivation index - an index of generated address Tatum follows the BIP44 specification and generates for Ethereum wallets with the derivation path m/44&#39;/60&#39;/0&#39;/0. More about BIP44 HD wallets can be found here - https://github.com/bitcoin/bips/blob/master/bip-0044.mediawiki. Generates a BIP44 compatible Ethereum wallet.
        /// </remarks>
        /// <exception cref="Tatum.CSharp.Ethereum.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="mnemonic">Mnemonic to use for generating extended public and private keys. (optional)</param>
        /// <param name="xTestnetType">Type of Ethereum testnet. Defaults to ethereum-sepolia. (optional, default to ethereum-sepolia)</param>
        /// <returns>Wallet</returns>
        Wallet EthGenerateWallet(string mnemonic = default(string), string xTestnetType = default(string));
        /// <summary>
        /// Get the ETH balance of an Ethereum account
        /// </summary>
        /// <remarks>
        /// 1 credit per API call Get the balance of ETH of an Ethereum account. To get the balance of tokens, use the APIs for getting the balance of fungible tokens (ERC-20) and NFTs (ERC-721).
        /// </remarks>
        /// <exception cref="Tatum.CSharp.Ethereum.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="address">Account address you want to get balance of</param>
        /// <param name="xTestnetType">Type of Ethereum testnet. Defaults to ethereum-sepolia. (optional, default to ethereum-sepolia)</param>
        /// <returns>EthBalance</returns>
        EthBalance EthGetBalance(string address, string xTestnetType = default(string));
        /// <summary>
        /// Get Ethereum block by hash
        /// </summary>
        /// <remarks>
        /// 1 credit per API call. Gets an Ethereum block-by-block hash or block number.
        /// </remarks>
        /// <exception cref="Tatum.CSharp.Ethereum.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="hash">Block hash or block number</param>
        /// <param name="xTestnetType">Type of Ethereum testnet. Defaults to ethereum-sepolia. (optional, default to ethereum-sepolia)</param>
        /// <returns>EthBlock</returns>
        EthBlock EthGetBlock(string hash, string xTestnetType = default(string));
        /// <summary>
        /// Get current block number
        /// </summary>
        /// <remarks>
        /// 1 credit per API call. Gets the current Ethereum block number. This is the number of the latest block in the blockchain.
        /// </remarks>
        /// <exception cref="Tatum.CSharp.Ethereum.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="xTestnetType">Type of Ethereum testnet. Defaults to ethereum-sepolia. (optional, default to ethereum-sepolia)</param>
        /// <returns>decimal</returns>
        decimal EthGetCurrentBlock(string xTestnetType = default(string));
        /// <summary>
        /// Get Ethereum internal transactions by address
        /// </summary>
        /// <remarks>
        /// 1 credit per API call. Get Ethereum internal transactions by address.
        /// </remarks>
        /// <exception cref="Tatum.CSharp.Ethereum.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="address">Account address you want to get balance of</param>
        /// <param name="pageSize">Max number of items per page is 50.</param>
        /// <param name="offset">Offset to obtain next page of the data. (optional)</param>
        /// <param name="xTestnetType">Type of Ethereum testnet. Defaults to ethereum-sepolia. (optional, default to ethereum-sepolia)</param>
        /// <returns>List&lt;EthTxInternal&gt;</returns>
        List<EthTxInternal> EthGetInternalTransactionByAddress(string address, decimal pageSize, decimal? offset = default(decimal?), string xTestnetType = default(string));
        /// <summary>
        /// Get Ethereum Transaction
        /// </summary>
        /// <remarks>
        /// 1 credit per API call. Get Ethereum transaction by transaction hash.
        /// </remarks>
        /// <exception cref="Tatum.CSharp.Ethereum.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="hash">Transaction hash</param>
        /// <param name="xTestnetType">Type of Ethereum testnet. Defaults to ethereum-sepolia. (optional, default to ethereum-sepolia)</param>
        /// <returns>EthTx</returns>
        EthTx EthGetTransaction(string hash, string xTestnetType = default(string));
        /// <summary>
        /// Get Ethereum transactions by address
        /// </summary>
        /// <remarks>
        /// 1 credit per API call. Get Ethereum transactions by address. This includes incoming and outgoing transactions for the address.
        /// </remarks>
        /// <exception cref="Tatum.CSharp.Ethereum.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="address">Account address you want to get balance of</param>
        /// <param name="pageSize">Max number of items per page is 50.</param>
        /// <param name="offset">Offset to obtain next page of the data. (optional)</param>
        /// <param name="from">Transactions from this block onwards will be included. (optional)</param>
        /// <param name="to">Transactions up to this block will be included. (optional)</param>
        /// <param name="sort">Sorting of the data. ASC - oldest first, DESC - newest first. (optional, default to DESC)</param>
        /// <param name="xTestnetType">Type of Ethereum testnet. Defaults to ethereum-sepolia. (optional, default to ethereum-sepolia)</param>
        /// <returns>List&lt;EthTx&gt;</returns>
        List<EthTx> EthGetTransactionByAddress(string address, decimal pageSize, decimal? offset = default(decimal?), decimal? from = default(decimal?), decimal? to = default(decimal?), string sort = default(string), string xTestnetType = default(string));
        /// <summary>
        /// Get count of outgoing Ethereum transactions
        /// </summary>
        /// <remarks>
        /// 1 credit per API call. Get a number of outgoing Ethereum transactions for the address. When a transaction is sent, there can be multiple outgoing transactions, which are not yet processed by the blockchain. To distinguish between them, there is a counter called a nonce, which represents the order of the transaction in the list of outgoing transactions.
        /// </remarks>
        /// <exception cref="Tatum.CSharp.Ethereum.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="address">address</param>
        /// <param name="xTestnetType">Type of Ethereum testnet. Defaults to ethereum-sepolia. (optional, default to ethereum-sepolia)</param>
        /// <returns>decimal</returns>
        decimal EthGetTransactionCount(string address, string xTestnetType = default(string));
        #endregion Synchronous Operations
    }

    /// <summary>
    /// Represents a collection of functions to interact with the API endpoints
    /// </summary>
    public interface IEthereumApiWithHttpInfoSync : IApiAccessor
    {
        #region Synchronous Operations With Http Info
        /// <summary>
        /// Invoke a method in a smart contract on Ethereum
        /// </summary>
        /// <remarks>
        /// 2 credits per API call Invoke a method in an existing smart contract on Ethereum. You can call a read-only or write method. For read-only methods, the output of the invoked method is returned. For write methods, the ID of the associated transaction is returned. Troubleshooting a failed transaction Tatum ensures that this API works against the blockchain (accesses the blockchain, finds the specified smart contract, and executes the specified ABI method with the provided parameters). However, because this API can be run against any smart contract on the blockchain, Tatum cannot in any way guarantee that the method itself will be executed successfully. If you have issues with invoking the method, refer to the user documentation for this method, or contact the author of the smart contract. For more information about invoking methods in smart contracts, see this article on our Support Portal. Signing a transaction When invoking a method in a smart contract, you are charged a fee for the transaction, and you must sign the transaction with the private key of the blockchain address from which the fee will be deducted. Providing the private key in the API is not a secure way of signing transactions, because the private key can be stolen or exposed. Your private keys should never leave your security perimeter. You should use the private keys only for testing a solution you are building on the testnet of a blockchain. For signing transactions on the mainnet, we strongly recommend that you use the Tatum Key Management System (KMS) and provide the signature ID instead of the private key in the API. Alternatively, you can use the Tatum JavaScript client.
        /// </remarks>
        /// <exception cref="Tatum.CSharp.Ethereum.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="callSmartContractMethod"></param>
        /// <param name="xTestnetType">Type of Ethereum testnet. Defaults to ethereum-sepolia. (optional, default to ethereum-sepolia)</param>
        /// <returns>ApiResponse of TransactionHash</returns>
        ApiResponse<TransactionHash> EthBlockchainSmartContractInvocationWithHttpInfo(CallSmartContractMethod callSmartContractMethod, string xTestnetType = default(string));
        /// <summary>
        /// Invoke a method in a smart contract on Ethereum
        /// </summary>
        /// <remarks>
        /// 2 credits per API call Invoke a method in an existing smart contract on Ethereum. You can call a read-only or write method. For read-only methods, the output of the invoked method is returned. For write methods, the ID of the associated transaction is returned. Troubleshooting a failed transaction Tatum ensures that this API works against the blockchain (accesses the blockchain, finds the specified smart contract, and executes the specified ABI method with the provided parameters). However, because this API can be run against any smart contract on the blockchain, Tatum cannot in any way guarantee that the method itself will be executed successfully. If you have issues with invoking the method, refer to the user documentation for this method, or contact the author of the smart contract. For more information about invoking methods in smart contracts, see this article on our Support Portal. Signing a transaction When invoking a method in a smart contract, you are charged a fee for the transaction, and you must sign the transaction with the private key of the blockchain address from which the fee will be deducted. Providing the private key in the API is not a secure way of signing transactions, because the private key can be stolen or exposed. Your private keys should never leave your security perimeter. You should use the private keys only for testing a solution you are building on the testnet of a blockchain. For signing transactions on the mainnet, we strongly recommend that you use the Tatum Key Management System (KMS) and provide the signature ID instead of the private key in the API. Alternatively, you can use the Tatum JavaScript client.
        /// </remarks>
        /// <exception cref="Tatum.CSharp.Ethereum.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="callReadSmartContractMethod"></param>
        /// <param name="xTestnetType">Type of Ethereum testnet. Defaults to ethereum-sepolia. (optional, default to ethereum-sepolia)</param>
        /// <returns>ApiResponse of Data</returns>
        ApiResponse<Data> EthBlockchainSmartContractInvocationWithHttpInfo(CallReadSmartContractMethod callReadSmartContractMethod, string xTestnetType = default(string));
        /// <summary>
        /// Invoke a method in a smart contract on Ethereum
        /// </summary>
        /// <remarks>
        /// 2 credits per API call Invoke a method in an existing smart contract on Ethereum. You can call a read-only or write method. For read-only methods, the output of the invoked method is returned. For write methods, the ID of the associated transaction is returned. Troubleshooting a failed transaction Tatum ensures that this API works against the blockchain (accesses the blockchain, finds the specified smart contract, and executes the specified ABI method with the provided parameters). However, because this API can be run against any smart contract on the blockchain, Tatum cannot in any way guarantee that the method itself will be executed successfully. If you have issues with invoking the method, refer to the user documentation for this method, or contact the author of the smart contract. For more information about invoking methods in smart contracts, see this article on our Support Portal. Signing a transaction When invoking a method in a smart contract, you are charged a fee for the transaction, and you must sign the transaction with the private key of the blockchain address from which the fee will be deducted. Providing the private key in the API is not a secure way of signing transactions, because the private key can be stolen or exposed. Your private keys should never leave your security perimeter. You should use the private keys only for testing a solution you are building on the testnet of a blockchain. For signing transactions on the mainnet, we strongly recommend that you use the Tatum Key Management System (KMS) and provide the signature ID instead of the private key in the API. Alternatively, you can use the Tatum JavaScript client.
        /// </remarks>
        /// <exception cref="Tatum.CSharp.Ethereum.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="callSmartContractMethodKMS"></param>
        /// <param name="xTestnetType">Type of Ethereum testnet. Defaults to ethereum-sepolia. (optional, default to ethereum-sepolia)</param>
        /// <returns>ApiResponse of SignatureId</returns>
        ApiResponse<SignatureId> EthBlockchainSmartContractInvocationWithHttpInfo(CallSmartContractMethodKMS callSmartContractMethodKMS, string xTestnetType = default(string));
        /// <summary>
        /// Send Ethereum / ERC20 from account to account
        /// </summary>
        /// <remarks>
        /// 2 credits per API call Send Ethereum or Tatum supported ERC20 token from account to account. Signing a transaction When sending ETH, you are charged a fee for the transaction, and you must sign the transaction with the private key of the blockchain address from which the fee will be deducted. Providing the private key in the API is not a secure way of signing transactions, because the private key can be stolen or exposed. Your private keys should never leave your security perimeter. You should use the private keys only for testing a solution you are building on the testnet of a blockchain. For signing transactions on the mainnet, we strongly recommend that you use the Tatum Key Management System (KMS) and provide the signature ID instead of the private key in the API. Alternatively, you can use the Tatum JavaScript client.
        /// </remarks>
        /// <exception cref="Tatum.CSharp.Ethereum.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="transferEthBlockchain"></param>
        /// <param name="xTestnetType">Type of Ethereum testnet. Defaults to ethereum-sepolia. (optional, default to ethereum-sepolia)</param>
        /// <returns>ApiResponse of TransactionHash</returns>
        ApiResponse<TransactionHash> EthBlockchainTransferWithHttpInfo(TransferEthBlockchain transferEthBlockchain, string xTestnetType = default(string));
        /// <summary>
        /// Send Ethereum / ERC20 from account to account
        /// </summary>
        /// <remarks>
        /// 2 credits per API call Send Ethereum or Tatum supported ERC20 token from account to account. Signing a transaction When sending ETH, you are charged a fee for the transaction, and you must sign the transaction with the private key of the blockchain address from which the fee will be deducted. Providing the private key in the API is not a secure way of signing transactions, because the private key can be stolen or exposed. Your private keys should never leave your security perimeter. You should use the private keys only for testing a solution you are building on the testnet of a blockchain. For signing transactions on the mainnet, we strongly recommend that you use the Tatum Key Management System (KMS) and provide the signature ID instead of the private key in the API. Alternatively, you can use the Tatum JavaScript client.
        /// </remarks>
        /// <exception cref="Tatum.CSharp.Ethereum.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="transferEthBlockchainKMS"></param>
        /// <param name="xTestnetType">Type of Ethereum testnet. Defaults to ethereum-sepolia. (optional, default to ethereum-sepolia)</param>
        /// <returns>ApiResponse of SignatureId</returns>
        ApiResponse<SignatureId> EthBlockchainTransferWithHttpInfo(TransferEthBlockchainKMS transferEthBlockchainKMS, string xTestnetType = default(string));
        /// <summary>
        /// Broadcast signed Ethereum transaction
        /// </summary>
        /// <remarks>
        /// 2 credits per API call Broadcast signed transaction to Ethereum blockchain. This method is used internally from Tatum KMS or Tatum client libraries. It is possible to create custom signing mechanism and use this method only for broadcasting data to the blockchain.
        /// </remarks>
        /// <exception cref="Tatum.CSharp.Ethereum.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="broadcastKMS"></param>
        /// <param name="xTestnetType">Type of Ethereum testnet. Defaults to ethereum-sepolia. (optional, default to ethereum-sepolia)</param>
        /// <returns>ApiResponse of TransactionHash</returns>
        ApiResponse<TransactionHash> EthBroadcastWithHttpInfo(BroadcastKMS broadcastKMS, string xTestnetType = default(string));
        /// <summary>
        /// Generate Ethereum account address from Extended public key
        /// </summary>
        /// <remarks>
        /// 1 credit per API call. Generates an Ethereum account deposit address from an Extended public key. The deposit address is generated for the specific index - each extended public key can generate up to 2^31 addresses starting from index 0 until 2^31 - 1.
        /// </remarks>
        /// <exception cref="Tatum.CSharp.Ethereum.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="xpub">Extended public key of wallet.</param>
        /// <param name="index">Derivation index of the address to be generated.</param>
        /// <param name="xTestnetType">Type of Ethereum testnet. Defaults to ethereum-sepolia. (optional, default to ethereum-sepolia)</param>
        /// <returns>ApiResponse of GeneratedAddressEth</returns>
        ApiResponse<GeneratedAddressEth> EthGenerateAddressWithHttpInfo(string xpub, decimal index, string xTestnetType = default(string));
        /// <summary>
        /// Generate Ethereum private key
        /// </summary>
        /// <remarks>
        /// 1 credit per API call. Generates the private key of an address from a mnemonic for a given derivation path index. The private key is generated for the specific index - each mnemonic can generate up to 2^32 private keys starting from index 0 until 2^31 - 1.
        /// </remarks>
        /// <exception cref="Tatum.CSharp.Ethereum.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="privKeyRequest"></param>
        /// <param name="xTestnetType">Type of Ethereum testnet. Defaults to ethereum-sepolia. (optional, default to ethereum-sepolia)</param>
        /// <returns>ApiResponse of PrivKey</returns>
        ApiResponse<PrivKey> EthGenerateAddressPrivateKeyWithHttpInfo(PrivKeyRequest privKeyRequest, string xTestnetType = default(string));
        /// <summary>
        /// Generate Ethereum wallet
        /// </summary>
        /// <remarks>
        /// 1 credit per API call. Tatum supports BIP44 HD wallets. Because they can generate 2^31 addresses from 1 mnemonic phrase, they are very convenient and secure. A mnemonic phrase consists of 24 special words in a defined order and can restore access to all generated addresses and private keys. Each address is identified by 3 main values: Private Key - your secret value which should never be revealed Public Key - a public address to be published Derivation index - an index of generated address Tatum follows the BIP44 specification and generates for Ethereum wallets with the derivation path m/44&#39;/60&#39;/0&#39;/0. More about BIP44 HD wallets can be found here - https://github.com/bitcoin/bips/blob/master/bip-0044.mediawiki. Generates a BIP44 compatible Ethereum wallet.
        /// </remarks>
        /// <exception cref="Tatum.CSharp.Ethereum.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="mnemonic">Mnemonic to use for generating extended public and private keys. (optional)</param>
        /// <param name="xTestnetType">Type of Ethereum testnet. Defaults to ethereum-sepolia. (optional, default to ethereum-sepolia)</param>
        /// <returns>ApiResponse of Wallet</returns>
        ApiResponse<Wallet> EthGenerateWalletWithHttpInfo(string mnemonic = default(string), string xTestnetType = default(string));
        /// <summary>
        /// Get the ETH balance of an Ethereum account
        /// </summary>
        /// <remarks>
        /// 1 credit per API call Get the balance of ETH of an Ethereum account. To get the balance of tokens, use the APIs for getting the balance of fungible tokens (ERC-20) and NFTs (ERC-721).
        /// </remarks>
        /// <exception cref="Tatum.CSharp.Ethereum.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="address">Account address you want to get balance of</param>
        /// <param name="xTestnetType">Type of Ethereum testnet. Defaults to ethereum-sepolia. (optional, default to ethereum-sepolia)</param>
        /// <returns>ApiResponse of EthBalance</returns>
        ApiResponse<EthBalance> EthGetBalanceWithHttpInfo(string address, string xTestnetType = default(string));
        /// <summary>
        /// Get Ethereum block by hash
        /// </summary>
        /// <remarks>
        /// 1 credit per API call. Gets an Ethereum block-by-block hash or block number.
        /// </remarks>
        /// <exception cref="Tatum.CSharp.Ethereum.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="hash">Block hash or block number</param>
        /// <param name="xTestnetType">Type of Ethereum testnet. Defaults to ethereum-sepolia. (optional, default to ethereum-sepolia)</param>
        /// <returns>ApiResponse of EthBlock</returns>
        ApiResponse<EthBlock> EthGetBlockWithHttpInfo(string hash, string xTestnetType = default(string));
        /// <summary>
        /// Get current block number
        /// </summary>
        /// <remarks>
        /// 1 credit per API call. Gets the current Ethereum block number. This is the number of the latest block in the blockchain.
        /// </remarks>
        /// <exception cref="Tatum.CSharp.Ethereum.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="xTestnetType">Type of Ethereum testnet. Defaults to ethereum-sepolia. (optional, default to ethereum-sepolia)</param>
        /// <returns>ApiResponse of decimal</returns>
        ApiResponse<decimal> EthGetCurrentBlockWithHttpInfo(string xTestnetType = default(string));
        /// <summary>
        /// Get Ethereum internal transactions by address
        /// </summary>
        /// <remarks>
        /// 1 credit per API call. Get Ethereum internal transactions by address.
        /// </remarks>
        /// <exception cref="Tatum.CSharp.Ethereum.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="address">Account address you want to get balance of</param>
        /// <param name="pageSize">Max number of items per page is 50.</param>
        /// <param name="offset">Offset to obtain next page of the data. (optional)</param>
        /// <param name="xTestnetType">Type of Ethereum testnet. Defaults to ethereum-sepolia. (optional, default to ethereum-sepolia)</param>
        /// <returns>ApiResponse of List&lt;EthTxInternal&gt;</returns>
        ApiResponse<List<EthTxInternal>> EthGetInternalTransactionByAddressWithHttpInfo(string address, decimal pageSize, decimal? offset = default(decimal?), string xTestnetType = default(string));
        /// <summary>
        /// Get Ethereum Transaction
        /// </summary>
        /// <remarks>
        /// 1 credit per API call. Get Ethereum transaction by transaction hash.
        /// </remarks>
        /// <exception cref="Tatum.CSharp.Ethereum.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="hash">Transaction hash</param>
        /// <param name="xTestnetType">Type of Ethereum testnet. Defaults to ethereum-sepolia. (optional, default to ethereum-sepolia)</param>
        /// <returns>ApiResponse of EthTx</returns>
        ApiResponse<EthTx> EthGetTransactionWithHttpInfo(string hash, string xTestnetType = default(string));
        /// <summary>
        /// Get Ethereum transactions by address
        /// </summary>
        /// <remarks>
        /// 1 credit per API call. Get Ethereum transactions by address. This includes incoming and outgoing transactions for the address.
        /// </remarks>
        /// <exception cref="Tatum.CSharp.Ethereum.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="address">Account address you want to get balance of</param>
        /// <param name="pageSize">Max number of items per page is 50.</param>
        /// <param name="offset">Offset to obtain next page of the data. (optional)</param>
        /// <param name="from">Transactions from this block onwards will be included. (optional)</param>
        /// <param name="to">Transactions up to this block will be included. (optional)</param>
        /// <param name="sort">Sorting of the data. ASC - oldest first, DESC - newest first. (optional, default to DESC)</param>
        /// <param name="xTestnetType">Type of Ethereum testnet. Defaults to ethereum-sepolia. (optional, default to ethereum-sepolia)</param>
        /// <returns>ApiResponse of List&lt;EthTx&gt;</returns>
        ApiResponse<List<EthTx>> EthGetTransactionByAddressWithHttpInfo(string address, decimal pageSize, decimal? offset = default(decimal?), decimal? from = default(decimal?), decimal? to = default(decimal?), string sort = default(string), string xTestnetType = default(string));
        /// <summary>
        /// Get count of outgoing Ethereum transactions
        /// </summary>
        /// <remarks>
        /// 1 credit per API call. Get a number of outgoing Ethereum transactions for the address. When a transaction is sent, there can be multiple outgoing transactions, which are not yet processed by the blockchain. To distinguish between them, there is a counter called a nonce, which represents the order of the transaction in the list of outgoing transactions.
        /// </remarks>
        /// <exception cref="Tatum.CSharp.Ethereum.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="address">address</param>
        /// <param name="xTestnetType">Type of Ethereum testnet. Defaults to ethereum-sepolia. (optional, default to ethereum-sepolia)</param>
        /// <returns>ApiResponse of decimal</returns>
        ApiResponse<decimal> EthGetTransactionCountWithHttpInfo(string address, string xTestnetType = default(string));
        #endregion Synchronous Operations With Http Info
    }

    /// <summary>
    /// Represents a collection of functions to interact with the API endpoints
    /// </summary>
    public interface IEthereumApiAsync : IApiAccessor
    {
        #region Asynchronous Operations
        /// <summary>
        /// Invoke a method in a smart contract on Ethereum
        /// </summary>
        /// <remarks>
        /// 2 credits per API call Invoke a method in an existing smart contract on Ethereum. You can call a read-only or write method. For read-only methods, the output of the invoked method is returned. For write methods, the ID of the associated transaction is returned. Troubleshooting a failed transaction Tatum ensures that this API works against the blockchain (accesses the blockchain, finds the specified smart contract, and executes the specified ABI method with the provided parameters). However, because this API can be run against any smart contract on the blockchain, Tatum cannot in any way guarantee that the method itself will be executed successfully. If you have issues with invoking the method, refer to the user documentation for this method, or contact the author of the smart contract. For more information about invoking methods in smart contracts, see this article on our Support Portal. Signing a transaction When invoking a method in a smart contract, you are charged a fee for the transaction, and you must sign the transaction with the private key of the blockchain address from which the fee will be deducted. Providing the private key in the API is not a secure way of signing transactions, because the private key can be stolen or exposed. Your private keys should never leave your security perimeter. You should use the private keys only for testing a solution you are building on the testnet of a blockchain. For signing transactions on the mainnet, we strongly recommend that you use the Tatum Key Management System (KMS) and provide the signature ID instead of the private key in the API. Alternatively, you can use the Tatum JavaScript client.
        /// </remarks>
        /// <exception cref="Tatum.CSharp.Ethereum.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="callSmartContractMethod"></param>
        /// <param name="xTestnetType">Type of Ethereum testnet. Defaults to ethereum-sepolia. (optional, default to ethereum-sepolia)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of TransactionHash</returns>
        System.Threading.Tasks.Task<TransactionHash> EthBlockchainSmartContractInvocationAsync(CallSmartContractMethod callSmartContractMethod, string xTestnetType = default(string), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        /// <summary>
        /// Invoke a method in a smart contract on Ethereum
        /// </summary>
        /// <remarks>
        /// 2 credits per API call Invoke a method in an existing smart contract on Ethereum. You can call a read-only or write method. For read-only methods, the output of the invoked method is returned. For write methods, the ID of the associated transaction is returned. Troubleshooting a failed transaction Tatum ensures that this API works against the blockchain (accesses the blockchain, finds the specified smart contract, and executes the specified ABI method with the provided parameters). However, because this API can be run against any smart contract on the blockchain, Tatum cannot in any way guarantee that the method itself will be executed successfully. If you have issues with invoking the method, refer to the user documentation for this method, or contact the author of the smart contract. For more information about invoking methods in smart contracts, see this article on our Support Portal. Signing a transaction When invoking a method in a smart contract, you are charged a fee for the transaction, and you must sign the transaction with the private key of the blockchain address from which the fee will be deducted. Providing the private key in the API is not a secure way of signing transactions, because the private key can be stolen or exposed. Your private keys should never leave your security perimeter. You should use the private keys only for testing a solution you are building on the testnet of a blockchain. For signing transactions on the mainnet, we strongly recommend that you use the Tatum Key Management System (KMS) and provide the signature ID instead of the private key in the API. Alternatively, you can use the Tatum JavaScript client.
        /// </remarks>
        /// <exception cref="Tatum.CSharp.Ethereum.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="callReadSmartContractMethod"></param>
        /// <param name="xTestnetType">Type of Ethereum testnet. Defaults to ethereum-sepolia. (optional, default to ethereum-sepolia)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of Data</returns>
        System.Threading.Tasks.Task<Data> EthBlockchainSmartContractInvocationAsync(CallReadSmartContractMethod callReadSmartContractMethod, string xTestnetType = default(string), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        /// <summary>
        /// Invoke a method in a smart contract on Ethereum
        /// </summary>
        /// <remarks>
        /// 2 credits per API call Invoke a method in an existing smart contract on Ethereum. You can call a read-only or write method. For read-only methods, the output of the invoked method is returned. For write methods, the ID of the associated transaction is returned. Troubleshooting a failed transaction Tatum ensures that this API works against the blockchain (accesses the blockchain, finds the specified smart contract, and executes the specified ABI method with the provided parameters). However, because this API can be run against any smart contract on the blockchain, Tatum cannot in any way guarantee that the method itself will be executed successfully. If you have issues with invoking the method, refer to the user documentation for this method, or contact the author of the smart contract. For more information about invoking methods in smart contracts, see this article on our Support Portal. Signing a transaction When invoking a method in a smart contract, you are charged a fee for the transaction, and you must sign the transaction with the private key of the blockchain address from which the fee will be deducted. Providing the private key in the API is not a secure way of signing transactions, because the private key can be stolen or exposed. Your private keys should never leave your security perimeter. You should use the private keys only for testing a solution you are building on the testnet of a blockchain. For signing transactions on the mainnet, we strongly recommend that you use the Tatum Key Management System (KMS) and provide the signature ID instead of the private key in the API. Alternatively, you can use the Tatum JavaScript client.
        /// </remarks>
        /// <exception cref="Tatum.CSharp.Ethereum.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="callSmartContractMethodKMS"></param>
        /// <param name="xTestnetType">Type of Ethereum testnet. Defaults to ethereum-sepolia. (optional, default to ethereum-sepolia)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of SignatureId</returns>
        System.Threading.Tasks.Task<SignatureId> EthBlockchainSmartContractInvocationAsync(CallSmartContractMethodKMS callSmartContractMethodKMS, string xTestnetType = default(string), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        /// <summary>
        /// Send Ethereum / ERC20 from account to account
        /// </summary>
        /// <remarks>
        /// 2 credits per API call Send Ethereum or Tatum supported ERC20 token from account to account. Signing a transaction When sending ETH, you are charged a fee for the transaction, and you must sign the transaction with the private key of the blockchain address from which the fee will be deducted. Providing the private key in the API is not a secure way of signing transactions, because the private key can be stolen or exposed. Your private keys should never leave your security perimeter. You should use the private keys only for testing a solution you are building on the testnet of a blockchain. For signing transactions on the mainnet, we strongly recommend that you use the Tatum Key Management System (KMS) and provide the signature ID instead of the private key in the API. Alternatively, you can use the Tatum JavaScript client.
        /// </remarks>
        /// <exception cref="Tatum.CSharp.Ethereum.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="transferEthBlockchain"></param>
        /// <param name="xTestnetType">Type of Ethereum testnet. Defaults to ethereum-sepolia. (optional, default to ethereum-sepolia)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of TransactionHash</returns>
        System.Threading.Tasks.Task<TransactionHash> EthBlockchainTransferAsync(TransferEthBlockchain transferEthBlockchain, string xTestnetType = default(string), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        /// <summary>
        /// Send Ethereum / ERC20 from account to account
        /// </summary>
        /// <remarks>
        /// 2 credits per API call Send Ethereum or Tatum supported ERC20 token from account to account. Signing a transaction When sending ETH, you are charged a fee for the transaction, and you must sign the transaction with the private key of the blockchain address from which the fee will be deducted. Providing the private key in the API is not a secure way of signing transactions, because the private key can be stolen or exposed. Your private keys should never leave your security perimeter. You should use the private keys only for testing a solution you are building on the testnet of a blockchain. For signing transactions on the mainnet, we strongly recommend that you use the Tatum Key Management System (KMS) and provide the signature ID instead of the private key in the API. Alternatively, you can use the Tatum JavaScript client.
        /// </remarks>
        /// <exception cref="Tatum.CSharp.Ethereum.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="transferEthBlockchainKMS"></param>
        /// <param name="xTestnetType">Type of Ethereum testnet. Defaults to ethereum-sepolia. (optional, default to ethereum-sepolia)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of SignatureId</returns>
        System.Threading.Tasks.Task<SignatureId> EthBlockchainTransferAsync(TransferEthBlockchainKMS transferEthBlockchainKMS, string xTestnetType = default(string), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        /// <summary>
        /// Broadcast signed Ethereum transaction
        /// </summary>
        /// <remarks>
        /// 2 credits per API call Broadcast signed transaction to Ethereum blockchain. This method is used internally from Tatum KMS or Tatum client libraries. It is possible to create custom signing mechanism and use this method only for broadcasting data to the blockchain.
        /// </remarks>
        /// <exception cref="Tatum.CSharp.Ethereum.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="broadcastKMS"></param>
        /// <param name="xTestnetType">Type of Ethereum testnet. Defaults to ethereum-sepolia. (optional, default to ethereum-sepolia)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of TransactionHash</returns>
        System.Threading.Tasks.Task<TransactionHash> EthBroadcastAsync(BroadcastKMS broadcastKMS, string xTestnetType = default(string), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        /// <summary>
        /// Generate Ethereum account address from Extended public key
        /// </summary>
        /// <remarks>
        /// 1 credit per API call. Generates an Ethereum account deposit address from an Extended public key. The deposit address is generated for the specific index - each extended public key can generate up to 2^31 addresses starting from index 0 until 2^31 - 1.
        /// </remarks>
        /// <exception cref="Tatum.CSharp.Ethereum.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="xpub">Extended public key of wallet.</param>
        /// <param name="index">Derivation index of the address to be generated.</param>
        /// <param name="xTestnetType">Type of Ethereum testnet. Defaults to ethereum-sepolia. (optional, default to ethereum-sepolia)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of GeneratedAddressEth</returns>
        System.Threading.Tasks.Task<GeneratedAddressEth> EthGenerateAddressAsync(string xpub, decimal index, string xTestnetType = default(string), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        /// <summary>
        /// Generate Ethereum private key
        /// </summary>
        /// <remarks>
        /// 1 credit per API call. Generates the private key of an address from a mnemonic for a given derivation path index. The private key is generated for the specific index - each mnemonic can generate up to 2^32 private keys starting from index 0 until 2^31 - 1.
        /// </remarks>
        /// <exception cref="Tatum.CSharp.Ethereum.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="privKeyRequest"></param>
        /// <param name="xTestnetType">Type of Ethereum testnet. Defaults to ethereum-sepolia. (optional, default to ethereum-sepolia)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of PrivKey</returns>
        System.Threading.Tasks.Task<PrivKey> EthGenerateAddressPrivateKeyAsync(PrivKeyRequest privKeyRequest, string xTestnetType = default(string), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        /// <summary>
        /// Generate Ethereum wallet
        /// </summary>
        /// <remarks>
        /// 1 credit per API call. Tatum supports BIP44 HD wallets. Because they can generate 2^31 addresses from 1 mnemonic phrase, they are very convenient and secure. A mnemonic phrase consists of 24 special words in a defined order and can restore access to all generated addresses and private keys. Each address is identified by 3 main values: Private Key - your secret value which should never be revealed Public Key - a public address to be published Derivation index - an index of generated address Tatum follows the BIP44 specification and generates for Ethereum wallets with the derivation path m/44&#39;/60&#39;/0&#39;/0. More about BIP44 HD wallets can be found here - https://github.com/bitcoin/bips/blob/master/bip-0044.mediawiki. Generates a BIP44 compatible Ethereum wallet.
        /// </remarks>
        /// <exception cref="Tatum.CSharp.Ethereum.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="mnemonic">Mnemonic to use for generating extended public and private keys. (optional)</param>
        /// <param name="xTestnetType">Type of Ethereum testnet. Defaults to ethereum-sepolia. (optional, default to ethereum-sepolia)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of Wallet</returns>
        System.Threading.Tasks.Task<Wallet> EthGenerateWalletAsync(string mnemonic = default(string), string xTestnetType = default(string), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        /// <summary>
        /// Get the ETH balance of an Ethereum account
        /// </summary>
        /// <remarks>
        /// 1 credit per API call Get the balance of ETH of an Ethereum account. To get the balance of tokens, use the APIs for getting the balance of fungible tokens (ERC-20) and NFTs (ERC-721).
        /// </remarks>
        /// <exception cref="Tatum.CSharp.Ethereum.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="address">Account address you want to get balance of</param>
        /// <param name="xTestnetType">Type of Ethereum testnet. Defaults to ethereum-sepolia. (optional, default to ethereum-sepolia)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of EthBalance</returns>
        System.Threading.Tasks.Task<EthBalance> EthGetBalanceAsync(string address, string xTestnetType = default(string), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        /// <summary>
        /// Get Ethereum block by hash
        /// </summary>
        /// <remarks>
        /// 1 credit per API call. Gets an Ethereum block-by-block hash or block number.
        /// </remarks>
        /// <exception cref="Tatum.CSharp.Ethereum.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="hash">Block hash or block number</param>
        /// <param name="xTestnetType">Type of Ethereum testnet. Defaults to ethereum-sepolia. (optional, default to ethereum-sepolia)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of EthBlock</returns>
        System.Threading.Tasks.Task<EthBlock> EthGetBlockAsync(string hash, string xTestnetType = default(string), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        /// <summary>
        /// Get current block number
        /// </summary>
        /// <remarks>
        /// 1 credit per API call. Gets the current Ethereum block number. This is the number of the latest block in the blockchain.
        /// </remarks>
        /// <exception cref="Tatum.CSharp.Ethereum.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="xTestnetType">Type of Ethereum testnet. Defaults to ethereum-sepolia. (optional, default to ethereum-sepolia)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of decimal</returns>
        System.Threading.Tasks.Task<decimal> EthGetCurrentBlockAsync(string xTestnetType = default(string), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        /// <summary>
        /// Get Ethereum internal transactions by address
        /// </summary>
        /// <remarks>
        /// 1 credit per API call. Get Ethereum internal transactions by address.
        /// </remarks>
        /// <exception cref="Tatum.CSharp.Ethereum.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="address">Account address you want to get balance of</param>
        /// <param name="pageSize">Max number of items per page is 50.</param>
        /// <param name="offset">Offset to obtain next page of the data. (optional)</param>
        /// <param name="xTestnetType">Type of Ethereum testnet. Defaults to ethereum-sepolia. (optional, default to ethereum-sepolia)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of List&lt;EthTxInternal&gt;</returns>
        System.Threading.Tasks.Task<List<EthTxInternal>> EthGetInternalTransactionByAddressAsync(string address, decimal pageSize, decimal? offset = default(decimal?), string xTestnetType = default(string), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        /// <summary>
        /// Get Ethereum Transaction
        /// </summary>
        /// <remarks>
        /// 1 credit per API call. Get Ethereum transaction by transaction hash.
        /// </remarks>
        /// <exception cref="Tatum.CSharp.Ethereum.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="hash">Transaction hash</param>
        /// <param name="xTestnetType">Type of Ethereum testnet. Defaults to ethereum-sepolia. (optional, default to ethereum-sepolia)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of EthTx</returns>
        System.Threading.Tasks.Task<EthTx> EthGetTransactionAsync(string hash, string xTestnetType = default(string), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        /// <summary>
        /// Get Ethereum transactions by address
        /// </summary>
        /// <remarks>
        /// 1 credit per API call. Get Ethereum transactions by address. This includes incoming and outgoing transactions for the address.
        /// </remarks>
        /// <exception cref="Tatum.CSharp.Ethereum.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="address">Account address you want to get balance of</param>
        /// <param name="pageSize">Max number of items per page is 50.</param>
        /// <param name="offset">Offset to obtain next page of the data. (optional)</param>
        /// <param name="from">Transactions from this block onwards will be included. (optional)</param>
        /// <param name="to">Transactions up to this block will be included. (optional)</param>
        /// <param name="sort">Sorting of the data. ASC - oldest first, DESC - newest first. (optional, default to DESC)</param>
        /// <param name="xTestnetType">Type of Ethereum testnet. Defaults to ethereum-sepolia. (optional, default to ethereum-sepolia)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of List&lt;EthTx&gt;</returns>
        System.Threading.Tasks.Task<List<EthTx>> EthGetTransactionByAddressAsync(string address, decimal pageSize, decimal? offset = default(decimal?), decimal? from = default(decimal?), decimal? to = default(decimal?), string sort = default(string), string xTestnetType = default(string), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        /// <summary>
        /// Get count of outgoing Ethereum transactions
        /// </summary>
        /// <remarks>
        /// 1 credit per API call. Get a number of outgoing Ethereum transactions for the address. When a transaction is sent, there can be multiple outgoing transactions, which are not yet processed by the blockchain. To distinguish between them, there is a counter called a nonce, which represents the order of the transaction in the list of outgoing transactions.
        /// </remarks>
        /// <exception cref="Tatum.CSharp.Ethereum.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="address">address</param>
        /// <param name="xTestnetType">Type of Ethereum testnet. Defaults to ethereum-sepolia. (optional, default to ethereum-sepolia)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of decimal</returns>
        System.Threading.Tasks.Task<decimal> EthGetTransactionCountAsync(string address, string xTestnetType = default(string), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        #endregion Asynchronous Operations
    }

    /// <summary>
    /// Represents a collection of functions to interact with the API endpoints
    /// </summary>
    public interface IEthereumApiWithHttpInfoAsync : IApiAccessor
    {
        #region Asynchronous Operations With Http Info
        /// <summary>
        /// Invoke a method in a smart contract on Ethereum
        /// </summary>
        /// <remarks>
        /// 2 credits per API call Invoke a method in an existing smart contract on Ethereum. You can call a read-only or write method. For read-only methods, the output of the invoked method is returned. For write methods, the ID of the associated transaction is returned. Troubleshooting a failed transaction Tatum ensures that this API works against the blockchain (accesses the blockchain, finds the specified smart contract, and executes the specified ABI method with the provided parameters). However, because this API can be run against any smart contract on the blockchain, Tatum cannot in any way guarantee that the method itself will be executed successfully. If you have issues with invoking the method, refer to the user documentation for this method, or contact the author of the smart contract. For more information about invoking methods in smart contracts, see this article on our Support Portal. Signing a transaction When invoking a method in a smart contract, you are charged a fee for the transaction, and you must sign the transaction with the private key of the blockchain address from which the fee will be deducted. Providing the private key in the API is not a secure way of signing transactions, because the private key can be stolen or exposed. Your private keys should never leave your security perimeter. You should use the private keys only for testing a solution you are building on the testnet of a blockchain. For signing transactions on the mainnet, we strongly recommend that you use the Tatum Key Management System (KMS) and provide the signature ID instead of the private key in the API. Alternatively, you can use the Tatum JavaScript client.
        /// </remarks>
        /// <exception cref="Tatum.CSharp.Ethereum.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="callSmartContractMethod"></param>
        /// <param name="xTestnetType">Type of Ethereum testnet. Defaults to ethereum-sepolia. (optional, default to ethereum-sepolia)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (TransactionHash)</returns>
        System.Threading.Tasks.Task<ApiResponse<TransactionHash>> EthBlockchainSmartContractInvocationWithHttpInfoAsync(CallSmartContractMethod callSmartContractMethod, string xTestnetType = default(string), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        /// <summary>
        /// Invoke a method in a smart contract on Ethereum
        /// </summary>
        /// <remarks>
        /// 2 credits per API call Invoke a method in an existing smart contract on Ethereum. You can call a read-only or write method. For read-only methods, the output of the invoked method is returned. For write methods, the ID of the associated transaction is returned. Troubleshooting a failed transaction Tatum ensures that this API works against the blockchain (accesses the blockchain, finds the specified smart contract, and executes the specified ABI method with the provided parameters). However, because this API can be run against any smart contract on the blockchain, Tatum cannot in any way guarantee that the method itself will be executed successfully. If you have issues with invoking the method, refer to the user documentation for this method, or contact the author of the smart contract. For more information about invoking methods in smart contracts, see this article on our Support Portal. Signing a transaction When invoking a method in a smart contract, you are charged a fee for the transaction, and you must sign the transaction with the private key of the blockchain address from which the fee will be deducted. Providing the private key in the API is not a secure way of signing transactions, because the private key can be stolen or exposed. Your private keys should never leave your security perimeter. You should use the private keys only for testing a solution you are building on the testnet of a blockchain. For signing transactions on the mainnet, we strongly recommend that you use the Tatum Key Management System (KMS) and provide the signature ID instead of the private key in the API. Alternatively, you can use the Tatum JavaScript client.
        /// </remarks>
        /// <exception cref="Tatum.CSharp.Ethereum.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="callReadSmartContractMethod"></param>
        /// <param name="xTestnetType">Type of Ethereum testnet. Defaults to ethereum-sepolia. (optional, default to ethereum-sepolia)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (Data)</returns>
        System.Threading.Tasks.Task<ApiResponse<Data>> EthBlockchainSmartContractInvocationWithHttpInfoAsync(CallReadSmartContractMethod callReadSmartContractMethod, string xTestnetType = default(string), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        /// <summary>
        /// Invoke a method in a smart contract on Ethereum
        /// </summary>
        /// <remarks>
        /// 2 credits per API call Invoke a method in an existing smart contract on Ethereum. You can call a read-only or write method. For read-only methods, the output of the invoked method is returned. For write methods, the ID of the associated transaction is returned. Troubleshooting a failed transaction Tatum ensures that this API works against the blockchain (accesses the blockchain, finds the specified smart contract, and executes the specified ABI method with the provided parameters). However, because this API can be run against any smart contract on the blockchain, Tatum cannot in any way guarantee that the method itself will be executed successfully. If you have issues with invoking the method, refer to the user documentation for this method, or contact the author of the smart contract. For more information about invoking methods in smart contracts, see this article on our Support Portal. Signing a transaction When invoking a method in a smart contract, you are charged a fee for the transaction, and you must sign the transaction with the private key of the blockchain address from which the fee will be deducted. Providing the private key in the API is not a secure way of signing transactions, because the private key can be stolen or exposed. Your private keys should never leave your security perimeter. You should use the private keys only for testing a solution you are building on the testnet of a blockchain. For signing transactions on the mainnet, we strongly recommend that you use the Tatum Key Management System (KMS) and provide the signature ID instead of the private key in the API. Alternatively, you can use the Tatum JavaScript client.
        /// </remarks>
        /// <exception cref="Tatum.CSharp.Ethereum.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="callSmartContractMethodKMS"></param>
        /// <param name="xTestnetType">Type of Ethereum testnet. Defaults to ethereum-sepolia. (optional, default to ethereum-sepolia)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (SignatureId)</returns>
        System.Threading.Tasks.Task<ApiResponse<SignatureId>> EthBlockchainSmartContractInvocationWithHttpInfoAsync(CallSmartContractMethodKMS callSmartContractMethodKMS, string xTestnetType = default(string), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        /// <summary>
        /// Send Ethereum / ERC20 from account to account
        /// </summary>
        /// <remarks>
        /// 2 credits per API call Send Ethereum or Tatum supported ERC20 token from account to account. Signing a transaction When sending ETH, you are charged a fee for the transaction, and you must sign the transaction with the private key of the blockchain address from which the fee will be deducted. Providing the private key in the API is not a secure way of signing transactions, because the private key can be stolen or exposed. Your private keys should never leave your security perimeter. You should use the private keys only for testing a solution you are building on the testnet of a blockchain. For signing transactions on the mainnet, we strongly recommend that you use the Tatum Key Management System (KMS) and provide the signature ID instead of the private key in the API. Alternatively, you can use the Tatum JavaScript client.
        /// </remarks>
        /// <exception cref="Tatum.CSharp.Ethereum.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="transferEthBlockchain"></param>
        /// <param name="xTestnetType">Type of Ethereum testnet. Defaults to ethereum-sepolia. (optional, default to ethereum-sepolia)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (TransactionHash)</returns>
        System.Threading.Tasks.Task<ApiResponse<TransactionHash>> EthBlockchainTransferWithHttpInfoAsync(TransferEthBlockchain transferEthBlockchain, string xTestnetType = default(string), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        /// <summary>
        /// Send Ethereum / ERC20 from account to account
        /// </summary>
        /// <remarks>
        /// 2 credits per API call Send Ethereum or Tatum supported ERC20 token from account to account. Signing a transaction When sending ETH, you are charged a fee for the transaction, and you must sign the transaction with the private key of the blockchain address from which the fee will be deducted. Providing the private key in the API is not a secure way of signing transactions, because the private key can be stolen or exposed. Your private keys should never leave your security perimeter. You should use the private keys only for testing a solution you are building on the testnet of a blockchain. For signing transactions on the mainnet, we strongly recommend that you use the Tatum Key Management System (KMS) and provide the signature ID instead of the private key in the API. Alternatively, you can use the Tatum JavaScript client.
        /// </remarks>
        /// <exception cref="Tatum.CSharp.Ethereum.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="transferEthBlockchainKMS"></param>
        /// <param name="xTestnetType">Type of Ethereum testnet. Defaults to ethereum-sepolia. (optional, default to ethereum-sepolia)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (SignatureId)</returns>
        System.Threading.Tasks.Task<ApiResponse<SignatureId>> EthBlockchainTransferWithHttpInfoAsync(TransferEthBlockchainKMS transferEthBlockchainKMS, string xTestnetType = default(string), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        /// <summary>
        /// Broadcast signed Ethereum transaction
        /// </summary>
        /// <remarks>
        /// 2 credits per API call Broadcast signed transaction to Ethereum blockchain. This method is used internally from Tatum KMS or Tatum client libraries. It is possible to create custom signing mechanism and use this method only for broadcasting data to the blockchain.
        /// </remarks>
        /// <exception cref="Tatum.CSharp.Ethereum.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="broadcastKMS"></param>
        /// <param name="xTestnetType">Type of Ethereum testnet. Defaults to ethereum-sepolia. (optional, default to ethereum-sepolia)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (TransactionHash)</returns>
        System.Threading.Tasks.Task<ApiResponse<TransactionHash>> EthBroadcastWithHttpInfoAsync(BroadcastKMS broadcastKMS, string xTestnetType = default(string), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        /// <summary>
        /// Generate Ethereum account address from Extended public key
        /// </summary>
        /// <remarks>
        /// 1 credit per API call. Generates an Ethereum account deposit address from an Extended public key. The deposit address is generated for the specific index - each extended public key can generate up to 2^31 addresses starting from index 0 until 2^31 - 1.
        /// </remarks>
        /// <exception cref="Tatum.CSharp.Ethereum.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="xpub">Extended public key of wallet.</param>
        /// <param name="index">Derivation index of the address to be generated.</param>
        /// <param name="xTestnetType">Type of Ethereum testnet. Defaults to ethereum-sepolia. (optional, default to ethereum-sepolia)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (GeneratedAddressEth)</returns>
        System.Threading.Tasks.Task<ApiResponse<GeneratedAddressEth>> EthGenerateAddressWithHttpInfoAsync(string xpub, decimal index, string xTestnetType = default(string), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        /// <summary>
        /// Generate Ethereum private key
        /// </summary>
        /// <remarks>
        /// 1 credit per API call. Generates the private key of an address from a mnemonic for a given derivation path index. The private key is generated for the specific index - each mnemonic can generate up to 2^32 private keys starting from index 0 until 2^31 - 1.
        /// </remarks>
        /// <exception cref="Tatum.CSharp.Ethereum.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="privKeyRequest"></param>
        /// <param name="xTestnetType">Type of Ethereum testnet. Defaults to ethereum-sepolia. (optional, default to ethereum-sepolia)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (PrivKey)</returns>
        System.Threading.Tasks.Task<ApiResponse<PrivKey>> EthGenerateAddressPrivateKeyWithHttpInfoAsync(PrivKeyRequest privKeyRequest, string xTestnetType = default(string), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        /// <summary>
        /// Generate Ethereum wallet
        /// </summary>
        /// <remarks>
        /// 1 credit per API call. Tatum supports BIP44 HD wallets. Because they can generate 2^31 addresses from 1 mnemonic phrase, they are very convenient and secure. A mnemonic phrase consists of 24 special words in a defined order and can restore access to all generated addresses and private keys. Each address is identified by 3 main values: Private Key - your secret value which should never be revealed Public Key - a public address to be published Derivation index - an index of generated address Tatum follows the BIP44 specification and generates for Ethereum wallets with the derivation path m/44&#39;/60&#39;/0&#39;/0. More about BIP44 HD wallets can be found here - https://github.com/bitcoin/bips/blob/master/bip-0044.mediawiki. Generates a BIP44 compatible Ethereum wallet.
        /// </remarks>
        /// <exception cref="Tatum.CSharp.Ethereum.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="mnemonic">Mnemonic to use for generating extended public and private keys. (optional)</param>
        /// <param name="xTestnetType">Type of Ethereum testnet. Defaults to ethereum-sepolia. (optional, default to ethereum-sepolia)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (Wallet)</returns>
        System.Threading.Tasks.Task<ApiResponse<Wallet>> EthGenerateWalletWithHttpInfoAsync(string mnemonic = default(string), string xTestnetType = default(string), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        /// <summary>
        /// Get the ETH balance of an Ethereum account
        /// </summary>
        /// <remarks>
        /// 1 credit per API call Get the balance of ETH of an Ethereum account. To get the balance of tokens, use the APIs for getting the balance of fungible tokens (ERC-20) and NFTs (ERC-721).
        /// </remarks>
        /// <exception cref="Tatum.CSharp.Ethereum.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="address">Account address you want to get balance of</param>
        /// <param name="xTestnetType">Type of Ethereum testnet. Defaults to ethereum-sepolia. (optional, default to ethereum-sepolia)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (EthBalance)</returns>
        System.Threading.Tasks.Task<ApiResponse<EthBalance>> EthGetBalanceWithHttpInfoAsync(string address, string xTestnetType = default(string), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        /// <summary>
        /// Get Ethereum block by hash
        /// </summary>
        /// <remarks>
        /// 1 credit per API call. Gets an Ethereum block-by-block hash or block number.
        /// </remarks>
        /// <exception cref="Tatum.CSharp.Ethereum.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="hash">Block hash or block number</param>
        /// <param name="xTestnetType">Type of Ethereum testnet. Defaults to ethereum-sepolia. (optional, default to ethereum-sepolia)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (EthBlock)</returns>
        System.Threading.Tasks.Task<ApiResponse<EthBlock>> EthGetBlockWithHttpInfoAsync(string hash, string xTestnetType = default(string), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        /// <summary>
        /// Get current block number
        /// </summary>
        /// <remarks>
        /// 1 credit per API call. Gets the current Ethereum block number. This is the number of the latest block in the blockchain.
        /// </remarks>
        /// <exception cref="Tatum.CSharp.Ethereum.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="xTestnetType">Type of Ethereum testnet. Defaults to ethereum-sepolia. (optional, default to ethereum-sepolia)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (decimal)</returns>
        System.Threading.Tasks.Task<ApiResponse<decimal>> EthGetCurrentBlockWithHttpInfoAsync(string xTestnetType = default(string), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        /// <summary>
        /// Get Ethereum internal transactions by address
        /// </summary>
        /// <remarks>
        /// 1 credit per API call. Get Ethereum internal transactions by address.
        /// </remarks>
        /// <exception cref="Tatum.CSharp.Ethereum.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="address">Account address you want to get balance of</param>
        /// <param name="pageSize">Max number of items per page is 50.</param>
        /// <param name="offset">Offset to obtain next page of the data. (optional)</param>
        /// <param name="xTestnetType">Type of Ethereum testnet. Defaults to ethereum-sepolia. (optional, default to ethereum-sepolia)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (List&lt;EthTxInternal&gt;)</returns>
        System.Threading.Tasks.Task<ApiResponse<List<EthTxInternal>>> EthGetInternalTransactionByAddressWithHttpInfoAsync(string address, decimal pageSize, decimal? offset = default(decimal?), string xTestnetType = default(string), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        /// <summary>
        /// Get Ethereum Transaction
        /// </summary>
        /// <remarks>
        /// 1 credit per API call. Get Ethereum transaction by transaction hash.
        /// </remarks>
        /// <exception cref="Tatum.CSharp.Ethereum.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="hash">Transaction hash</param>
        /// <param name="xTestnetType">Type of Ethereum testnet. Defaults to ethereum-sepolia. (optional, default to ethereum-sepolia)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (EthTx)</returns>
        System.Threading.Tasks.Task<ApiResponse<EthTx>> EthGetTransactionWithHttpInfoAsync(string hash, string xTestnetType = default(string), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        /// <summary>
        /// Get Ethereum transactions by address
        /// </summary>
        /// <remarks>
        /// 1 credit per API call. Get Ethereum transactions by address. This includes incoming and outgoing transactions for the address.
        /// </remarks>
        /// <exception cref="Tatum.CSharp.Ethereum.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="address">Account address you want to get balance of</param>
        /// <param name="pageSize">Max number of items per page is 50.</param>
        /// <param name="offset">Offset to obtain next page of the data. (optional)</param>
        /// <param name="from">Transactions from this block onwards will be included. (optional)</param>
        /// <param name="to">Transactions up to this block will be included. (optional)</param>
        /// <param name="sort">Sorting of the data. ASC - oldest first, DESC - newest first. (optional, default to DESC)</param>
        /// <param name="xTestnetType">Type of Ethereum testnet. Defaults to ethereum-sepolia. (optional, default to ethereum-sepolia)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (List&lt;EthTx&gt;)</returns>
        System.Threading.Tasks.Task<ApiResponse<List<EthTx>>> EthGetTransactionByAddressWithHttpInfoAsync(string address, decimal pageSize, decimal? offset = default(decimal?), decimal? from = default(decimal?), decimal? to = default(decimal?), string sort = default(string), string xTestnetType = default(string), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        /// <summary>
        /// Get count of outgoing Ethereum transactions
        /// </summary>
        /// <remarks>
        /// 1 credit per API call. Get a number of outgoing Ethereum transactions for the address. When a transaction is sent, there can be multiple outgoing transactions, which are not yet processed by the blockchain. To distinguish between them, there is a counter called a nonce, which represents the order of the transaction in the list of outgoing transactions.
        /// </remarks>
        /// <exception cref="Tatum.CSharp.Ethereum.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="address">address</param>
        /// <param name="xTestnetType">Type of Ethereum testnet. Defaults to ethereum-sepolia. (optional, default to ethereum-sepolia)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (decimal)</returns>
        System.Threading.Tasks.Task<ApiResponse<decimal>> EthGetTransactionCountWithHttpInfoAsync(string address, string xTestnetType = default(string), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        #endregion Asynchronous Operations With Http Info
    }


    /// <summary>
    /// Represents a collection of functions to interact with the API endpoints
    /// </summary>
    public interface IEthereumApi : IEthereumApiSync, IEthereumApiWithHttpInfoSync, IEthereumApiAsync, IEthereumApiWithHttpInfoAsync
    {

    }

    /// <summary>
    /// Represents a collection of functions to interact with the API endpoints
    /// </summary>
    public partial class EthereumApi : IEthereumApi
    {
        private ExceptionFactory _exceptionFactory = (name, response) => null;

        /// <summary>
        /// Initializes a new instance of the <see cref="EthereumApi"/> class.
        /// </summary>
        /// <param name="client">An instance of HttpClient.</param>
        /// <param name="handler">An optional instance of HttpClientHandler that is used by HttpClient.</param>
        /// <exception cref="ArgumentNullException"></exception>
        /// <returns></returns>
        /// <remarks>
        /// Some configuration settings will not be applied without passing an HttpClientHandler.
        /// The features affected are: Setting and Retrieving Cookies, Client Certificates, Proxy settings.
        /// </remarks>
        public EthereumApi(HttpClient client, HttpClientHandler handler = null) : this(client, (string)null, handler)
        {
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="EthereumApi"/> class.
        /// </summary>
        /// <param name="client">An instance of HttpClient.</param>
        /// <param name="basePath">The target service's base path in URL format.</param>
        /// <param name="handler">An optional instance of HttpClientHandler that is used by HttpClient.</param>
        /// <exception cref="ArgumentNullException"></exception>
        /// <exception cref="ArgumentException"></exception>
        /// <returns></returns>
        /// <remarks>
        /// Some configuration settings will not be applied without passing an HttpClientHandler.
        /// The features affected are: Setting and Retrieving Cookies, Client Certificates, Proxy settings.
        /// </remarks>
        public EthereumApi(HttpClient client, string basePath, HttpClientHandler handler = null)
        {
            if (client == null) throw new ArgumentNullException(nameof(client));

            Configuration = Tatum.CSharp.Ethereum.Core.Client.Configuration.MergeConfigurations(
                GlobalConfiguration.Instance,
                new Configuration { BasePath = basePath }
            );
            ApiClient = new ApiClient(client, Configuration.BasePath, handler);
            Client =  ApiClient;
            AsynchronousClient = ApiClient;
            ExceptionFactory = Tatum.CSharp.Ethereum.Core.Client.Configuration.DefaultExceptionFactory;
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="EthereumApi"/> class using Configuration object.
        /// </summary>
        /// <param name="client">An instance of HttpClient.</param>
        /// <param name="configuration">An instance of Configuration.</param>
        /// <param name="handler">An optional instance of HttpClientHandler that is used by HttpClient.</param>
        /// <exception cref="ArgumentNullException"></exception>
        /// <returns></returns>
        /// <remarks>
        /// Some configuration settings will not be applied without passing an HttpClientHandler.
        /// The features affected are: Setting and Retrieving Cookies, Client Certificates, Proxy settings.
        /// </remarks>
        public EthereumApi(HttpClient client, Configuration configuration, HttpClientHandler handler = null)
        {
            if (configuration == null) throw new ArgumentNullException(nameof(configuration));
            if (client == null) throw new ArgumentNullException(nameof(client));

            Configuration = Tatum.CSharp.Ethereum.Core.Client.Configuration.MergeConfigurations(
                GlobalConfiguration.Instance,
                configuration
            );
            ApiClient = new ApiClient(client, Configuration.BasePath, handler);
            Client = ApiClient;
            AsynchronousClient = ApiClient;
            ExceptionFactory = Tatum.CSharp.Ethereum.Core.Client.Configuration.DefaultExceptionFactory;
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="EthereumApi"/> class
        /// using a Configuration object and client instance.
        /// </summary>
        /// <param name="client">The client interface for synchronous API access.</param>
        /// <param name="asyncClient">The client interface for asynchronous API access.</param>
        /// <param name="configuration">The configuration object.</param>
        /// <exception cref="ArgumentNullException"></exception>
        public EthereumApi(ISynchronousClient client, IAsynchronousClient asyncClient, IReadableConfiguration configuration)
        {
            Client = client ?? throw new ArgumentNullException(nameof(client));
            AsynchronousClient = asyncClient ?? throw new ArgumentNullException(nameof(asyncClient));
            Configuration = configuration ?? throw new ArgumentNullException(nameof(configuration));
            ExceptionFactory = Tatum.CSharp.Ethereum.Core.Client.Configuration.DefaultExceptionFactory;
        }

        /// <summary>
        /// Holds the ApiClient if created
        /// </summary>
        public ApiClient ApiClient { get; set; }

        /// <summary>
        /// The client for accessing this underlying API asynchronously.
        /// </summary>
        public IAsynchronousClient AsynchronousClient { get; set; }

        /// <summary>
        /// The client for accessing this underlying API synchronously.
        /// </summary>
        public ISynchronousClient Client { get; set; }

        /// <summary>
        /// Gets the base path of the API client.
        /// </summary>
        /// <value>The base path</value>
        public string GetBasePath()
        {
            return Configuration.BasePath;
        }

        /// <summary>
        /// Gets or sets the configuration object
        /// </summary>
        /// <value>An instance of the Configuration</value>
        public IReadableConfiguration Configuration { get; set; }

        /// <summary>
        /// Provides a factory method hook for the creation of exceptions.
        /// </summary>
        public ExceptionFactory ExceptionFactory
        {
            get
            {
                if (_exceptionFactory != null && _exceptionFactory.GetInvocationList().Length > 1)
                {
                    throw new InvalidOperationException("Multicast delegate for ExceptionFactory is unsupported.");
                }
                return _exceptionFactory;
            }
            set => _exceptionFactory = value;
        }

        /// <summary>
        /// Invoke a method in a smart contract on Ethereum 2 credits per API call Invoke a method in an existing smart contract on Ethereum. You can call a read-only or write method. For read-only methods, the output of the invoked method is returned. For write methods, the ID of the associated transaction is returned. Troubleshooting a failed transaction Tatum ensures that this API works against the blockchain (accesses the blockchain, finds the specified smart contract, and executes the specified ABI method with the provided parameters). However, because this API can be run against any smart contract on the blockchain, Tatum cannot in any way guarantee that the method itself will be executed successfully. If you have issues with invoking the method, refer to the user documentation for this method, or contact the author of the smart contract. For more information about invoking methods in smart contracts, see this article on our Support Portal. Signing a transaction When invoking a method in a smart contract, you are charged a fee for the transaction, and you must sign the transaction with the private key of the blockchain address from which the fee will be deducted. Providing the private key in the API is not a secure way of signing transactions, because the private key can be stolen or exposed. Your private keys should never leave your security perimeter. You should use the private keys only for testing a solution you are building on the testnet of a blockchain. For signing transactions on the mainnet, we strongly recommend that you use the Tatum Key Management System (KMS) and provide the signature ID instead of the private key in the API. Alternatively, you can use the Tatum JavaScript client.
        /// </summary>
        /// <exception cref="Tatum.CSharp.Ethereum.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="callSmartContractMethod"></param>
        /// <param name="xTestnetType">Type of Ethereum testnet. Defaults to ethereum-sepolia. (optional, default to ethereum-sepolia)</param>
        /// <returns>TransactionHash</returns>
        public TransactionHash EthBlockchainSmartContractInvocation(CallSmartContractMethod callSmartContractMethod, string xTestnetType = default(string))
        {
            var localVarResponse = EthBlockchainSmartContractInvocationWithHttpInfo(callSmartContractMethod, xTestnetType);

            var exception = ExceptionFactory?.Invoke("EthBlockchainSmartContractInvocation", localVarResponse);
            if (exception != null) throw exception;

            return localVarResponse.Data;
        }

        /// <summary>
        /// Invoke a method in a smart contract on Ethereum 2 credits per API call Invoke a method in an existing smart contract on Ethereum. You can call a read-only or write method. For read-only methods, the output of the invoked method is returned. For write methods, the ID of the associated transaction is returned. Troubleshooting a failed transaction Tatum ensures that this API works against the blockchain (accesses the blockchain, finds the specified smart contract, and executes the specified ABI method with the provided parameters). However, because this API can be run against any smart contract on the blockchain, Tatum cannot in any way guarantee that the method itself will be executed successfully. If you have issues with invoking the method, refer to the user documentation for this method, or contact the author of the smart contract. For more information about invoking methods in smart contracts, see this article on our Support Portal. Signing a transaction When invoking a method in a smart contract, you are charged a fee for the transaction, and you must sign the transaction with the private key of the blockchain address from which the fee will be deducted. Providing the private key in the API is not a secure way of signing transactions, because the private key can be stolen or exposed. Your private keys should never leave your security perimeter. You should use the private keys only for testing a solution you are building on the testnet of a blockchain. For signing transactions on the mainnet, we strongly recommend that you use the Tatum Key Management System (KMS) and provide the signature ID instead of the private key in the API. Alternatively, you can use the Tatum JavaScript client.
        /// </summary>
        /// <exception cref="Tatum.CSharp.Ethereum.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="callSmartContractMethod"></param>
        /// <param name="xTestnetType">Type of Ethereum testnet. Defaults to ethereum-sepolia. (optional, default to ethereum-sepolia)</param>
        /// <returns>ApiResponse of TransactionHash</returns>
        public ApiResponse<TransactionHash> EthBlockchainSmartContractInvocationWithHttpInfo(CallSmartContractMethod callSmartContractMethod, string xTestnetType = default(string))
        {
            // verify the required parameter 'callSmartContractMethod' is set
            if (callSmartContractMethod == null)
                throw new ApiException(400, "Missing required parameter 'callSmartContractMethod' when calling EthereumApi->EthBlockchainSmartContractInvocation");

            var localVarRequestOptions = new RequestOptions();

            var contentTypes = new string[]{
                "application/json"
            };

            // to determine the Accept header
            var accepts = new string[]{
                "application/json"
            };

            var localVarContentType = ClientUtils.SelectHeaderContentType(contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = ClientUtils.SelectHeaderAccept(accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            if (xTestnetType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("x-testnet-type", ClientUtils.ParameterToString(xTestnetType)); // header parameter
            }
            localVarRequestOptions.Data = callSmartContractMethod;

            // authentication (X-API-Key) required
            if (!string.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("x-api-key")))
            {
                localVarRequestOptions.HeaderParameters.Add("x-api-key", Configuration.GetApiKeyWithPrefix("x-api-key"));
            }

            // make the HTTP request
            var localVarResponse = Client.Post<TransactionHash>("/v3/ethereum/smartcontract", localVarRequestOptions, Configuration);

            return localVarResponse;
        }

        /// <summary>
        /// Invoke a method in a smart contract on Ethereum 2 credits per API call Invoke a method in an existing smart contract on Ethereum. You can call a read-only or write method. For read-only methods, the output of the invoked method is returned. For write methods, the ID of the associated transaction is returned. Troubleshooting a failed transaction Tatum ensures that this API works against the blockchain (accesses the blockchain, finds the specified smart contract, and executes the specified ABI method with the provided parameters). However, because this API can be run against any smart contract on the blockchain, Tatum cannot in any way guarantee that the method itself will be executed successfully. If you have issues with invoking the method, refer to the user documentation for this method, or contact the author of the smart contract. For more information about invoking methods in smart contracts, see this article on our Support Portal. Signing a transaction When invoking a method in a smart contract, you are charged a fee for the transaction, and you must sign the transaction with the private key of the blockchain address from which the fee will be deducted. Providing the private key in the API is not a secure way of signing transactions, because the private key can be stolen or exposed. Your private keys should never leave your security perimeter. You should use the private keys only for testing a solution you are building on the testnet of a blockchain. For signing transactions on the mainnet, we strongly recommend that you use the Tatum Key Management System (KMS) and provide the signature ID instead of the private key in the API. Alternatively, you can use the Tatum JavaScript client.
        /// </summary>
        /// <exception cref="Tatum.CSharp.Ethereum.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="callSmartContractMethod"></param>
        /// <param name="xTestnetType">Type of Ethereum testnet. Defaults to ethereum-sepolia. (optional, default to ethereum-sepolia)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of TransactionHash</returns>
        public async System.Threading.Tasks.Task<TransactionHash> EthBlockchainSmartContractInvocationAsync(CallSmartContractMethod callSmartContractMethod, string xTestnetType = default(string), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            var localVarResponse = await EthBlockchainSmartContractInvocationWithHttpInfoAsync(callSmartContractMethod, xTestnetType, cancellationToken).ConfigureAwait(false);
            
            var exception = ExceptionFactory?.Invoke("EthBlockchainSmartContractInvocation", localVarResponse);
            if (exception != null) throw exception;

            return localVarResponse.Data;
        }

        /// <summary>
        /// Invoke a method in a smart contract on Ethereum 2 credits per API call Invoke a method in an existing smart contract on Ethereum. You can call a read-only or write method. For read-only methods, the output of the invoked method is returned. For write methods, the ID of the associated transaction is returned. Troubleshooting a failed transaction Tatum ensures that this API works against the blockchain (accesses the blockchain, finds the specified smart contract, and executes the specified ABI method with the provided parameters). However, because this API can be run against any smart contract on the blockchain, Tatum cannot in any way guarantee that the method itself will be executed successfully. If you have issues with invoking the method, refer to the user documentation for this method, or contact the author of the smart contract. For more information about invoking methods in smart contracts, see this article on our Support Portal. Signing a transaction When invoking a method in a smart contract, you are charged a fee for the transaction, and you must sign the transaction with the private key of the blockchain address from which the fee will be deducted. Providing the private key in the API is not a secure way of signing transactions, because the private key can be stolen or exposed. Your private keys should never leave your security perimeter. You should use the private keys only for testing a solution you are building on the testnet of a blockchain. For signing transactions on the mainnet, we strongly recommend that you use the Tatum Key Management System (KMS) and provide the signature ID instead of the private key in the API. Alternatively, you can use the Tatum JavaScript client.
        /// </summary>
        /// <exception cref="Tatum.CSharp.Ethereum.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="callSmartContractMethod"></param>
        /// <param name="xTestnetType">Type of Ethereum testnet. Defaults to ethereum-sepolia. (optional, default to ethereum-sepolia)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (TransactionHash)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<TransactionHash>> EthBlockchainSmartContractInvocationWithHttpInfoAsync(CallSmartContractMethod callSmartContractMethod, string xTestnetType = default(string), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            // verify the required parameter 'callSmartContractMethod' is set
            if (callSmartContractMethod == null)
                throw new ApiException(400, "Missing required parameter 'callSmartContractMethod' when calling EthereumApi->EthBlockchainSmartContractInvocation");

            var localVarRequestOptions = new RequestOptions();

            var contentTypes = new string[]{
                "application/json"
            };

            // to determine the Accept header
            var accepts = new string[]{
                "application/json"
            };


            var localVarContentType = ClientUtils.SelectHeaderContentType(contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = ClientUtils.SelectHeaderAccept(accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            if (xTestnetType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("x-testnet-type", ClientUtils.ParameterToString(xTestnetType)); // header parameter
            }
            localVarRequestOptions.Data = callSmartContractMethod;

            // authentication (X-API-Key) required
            if (!string.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("x-api-key")))
            {
                localVarRequestOptions.HeaderParameters.Add("x-api-key", Configuration.GetApiKeyWithPrefix("x-api-key"));
            }

            // make the HTTP request

            var localVarResponse = await AsynchronousClient.PostAsync<TransactionHash>("/v3/ethereum/smartcontract", localVarRequestOptions, Configuration, cancellationToken).ConfigureAwait(false);

            return localVarResponse;
        }

        /// <summary>
        /// Invoke a method in a smart contract on Ethereum 2 credits per API call Invoke a method in an existing smart contract on Ethereum. You can call a read-only or write method. For read-only methods, the output of the invoked method is returned. For write methods, the ID of the associated transaction is returned. Troubleshooting a failed transaction Tatum ensures that this API works against the blockchain (accesses the blockchain, finds the specified smart contract, and executes the specified ABI method with the provided parameters). However, because this API can be run against any smart contract on the blockchain, Tatum cannot in any way guarantee that the method itself will be executed successfully. If you have issues with invoking the method, refer to the user documentation for this method, or contact the author of the smart contract. For more information about invoking methods in smart contracts, see this article on our Support Portal. Signing a transaction When invoking a method in a smart contract, you are charged a fee for the transaction, and you must sign the transaction with the private key of the blockchain address from which the fee will be deducted. Providing the private key in the API is not a secure way of signing transactions, because the private key can be stolen or exposed. Your private keys should never leave your security perimeter. You should use the private keys only for testing a solution you are building on the testnet of a blockchain. For signing transactions on the mainnet, we strongly recommend that you use the Tatum Key Management System (KMS) and provide the signature ID instead of the private key in the API. Alternatively, you can use the Tatum JavaScript client.
        /// </summary>
        /// <exception cref="Tatum.CSharp.Ethereum.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="callReadSmartContractMethod"></param>
        /// <param name="xTestnetType">Type of Ethereum testnet. Defaults to ethereum-sepolia. (optional, default to ethereum-sepolia)</param>
        /// <returns>Data</returns>
        public Data EthBlockchainSmartContractInvocation(CallReadSmartContractMethod callReadSmartContractMethod, string xTestnetType = default(string))
        {
            var localVarResponse = EthBlockchainSmartContractInvocationWithHttpInfo(callReadSmartContractMethod, xTestnetType);

            var exception = ExceptionFactory?.Invoke("EthBlockchainSmartContractInvocation_0", localVarResponse);
            if (exception != null) throw exception;

            return localVarResponse.Data;
        }

        /// <summary>
        /// Invoke a method in a smart contract on Ethereum 2 credits per API call Invoke a method in an existing smart contract on Ethereum. You can call a read-only or write method. For read-only methods, the output of the invoked method is returned. For write methods, the ID of the associated transaction is returned. Troubleshooting a failed transaction Tatum ensures that this API works against the blockchain (accesses the blockchain, finds the specified smart contract, and executes the specified ABI method with the provided parameters). However, because this API can be run against any smart contract on the blockchain, Tatum cannot in any way guarantee that the method itself will be executed successfully. If you have issues with invoking the method, refer to the user documentation for this method, or contact the author of the smart contract. For more information about invoking methods in smart contracts, see this article on our Support Portal. Signing a transaction When invoking a method in a smart contract, you are charged a fee for the transaction, and you must sign the transaction with the private key of the blockchain address from which the fee will be deducted. Providing the private key in the API is not a secure way of signing transactions, because the private key can be stolen or exposed. Your private keys should never leave your security perimeter. You should use the private keys only for testing a solution you are building on the testnet of a blockchain. For signing transactions on the mainnet, we strongly recommend that you use the Tatum Key Management System (KMS) and provide the signature ID instead of the private key in the API. Alternatively, you can use the Tatum JavaScript client.
        /// </summary>
        /// <exception cref="Tatum.CSharp.Ethereum.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="callReadSmartContractMethod"></param>
        /// <param name="xTestnetType">Type of Ethereum testnet. Defaults to ethereum-sepolia. (optional, default to ethereum-sepolia)</param>
        /// <returns>ApiResponse of Data</returns>
        public ApiResponse<Data> EthBlockchainSmartContractInvocationWithHttpInfo(CallReadSmartContractMethod callReadSmartContractMethod, string xTestnetType = default(string))
        {
            // verify the required parameter 'callReadSmartContractMethod' is set
            if (callReadSmartContractMethod == null)
                throw new ApiException(400, "Missing required parameter 'callReadSmartContractMethod' when calling EthereumApi->EthBlockchainSmartContractInvocation_0");

            var localVarRequestOptions = new RequestOptions();

            var contentTypes = new string[]{
                "application/json"
            };

            // to determine the Accept header
            var accepts = new string[]{
                "application/json"
            };

            var localVarContentType = ClientUtils.SelectHeaderContentType(contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = ClientUtils.SelectHeaderAccept(accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            if (xTestnetType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("x-testnet-type", ClientUtils.ParameterToString(xTestnetType)); // header parameter
            }
            localVarRequestOptions.Data = callReadSmartContractMethod;

            // authentication (X-API-Key) required
            if (!string.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("x-api-key")))
            {
                localVarRequestOptions.HeaderParameters.Add("x-api-key", Configuration.GetApiKeyWithPrefix("x-api-key"));
            }

            // make the HTTP request
            var localVarResponse = Client.Post<Data>("/v3/ethereum/smartcontract", localVarRequestOptions, Configuration);

            return localVarResponse;
        }

        /// <summary>
        /// Invoke a method in a smart contract on Ethereum 2 credits per API call Invoke a method in an existing smart contract on Ethereum. You can call a read-only or write method. For read-only methods, the output of the invoked method is returned. For write methods, the ID of the associated transaction is returned. Troubleshooting a failed transaction Tatum ensures that this API works against the blockchain (accesses the blockchain, finds the specified smart contract, and executes the specified ABI method with the provided parameters). However, because this API can be run against any smart contract on the blockchain, Tatum cannot in any way guarantee that the method itself will be executed successfully. If you have issues with invoking the method, refer to the user documentation for this method, or contact the author of the smart contract. For more information about invoking methods in smart contracts, see this article on our Support Portal. Signing a transaction When invoking a method in a smart contract, you are charged a fee for the transaction, and you must sign the transaction with the private key of the blockchain address from which the fee will be deducted. Providing the private key in the API is not a secure way of signing transactions, because the private key can be stolen or exposed. Your private keys should never leave your security perimeter. You should use the private keys only for testing a solution you are building on the testnet of a blockchain. For signing transactions on the mainnet, we strongly recommend that you use the Tatum Key Management System (KMS) and provide the signature ID instead of the private key in the API. Alternatively, you can use the Tatum JavaScript client.
        /// </summary>
        /// <exception cref="Tatum.CSharp.Ethereum.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="callReadSmartContractMethod"></param>
        /// <param name="xTestnetType">Type of Ethereum testnet. Defaults to ethereum-sepolia. (optional, default to ethereum-sepolia)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of Data</returns>
        public async System.Threading.Tasks.Task<Data> EthBlockchainSmartContractInvocationAsync(CallReadSmartContractMethod callReadSmartContractMethod, string xTestnetType = default(string), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            var localVarResponse = await EthBlockchainSmartContractInvocationWithHttpInfoAsync(callReadSmartContractMethod, xTestnetType, cancellationToken).ConfigureAwait(false);
            
            var exception = ExceptionFactory?.Invoke("EthBlockchainSmartContractInvocation_0", localVarResponse);
            if (exception != null) throw exception;

            return localVarResponse.Data;
        }

        /// <summary>
        /// Invoke a method in a smart contract on Ethereum 2 credits per API call Invoke a method in an existing smart contract on Ethereum. You can call a read-only or write method. For read-only methods, the output of the invoked method is returned. For write methods, the ID of the associated transaction is returned. Troubleshooting a failed transaction Tatum ensures that this API works against the blockchain (accesses the blockchain, finds the specified smart contract, and executes the specified ABI method with the provided parameters). However, because this API can be run against any smart contract on the blockchain, Tatum cannot in any way guarantee that the method itself will be executed successfully. If you have issues with invoking the method, refer to the user documentation for this method, or contact the author of the smart contract. For more information about invoking methods in smart contracts, see this article on our Support Portal. Signing a transaction When invoking a method in a smart contract, you are charged a fee for the transaction, and you must sign the transaction with the private key of the blockchain address from which the fee will be deducted. Providing the private key in the API is not a secure way of signing transactions, because the private key can be stolen or exposed. Your private keys should never leave your security perimeter. You should use the private keys only for testing a solution you are building on the testnet of a blockchain. For signing transactions on the mainnet, we strongly recommend that you use the Tatum Key Management System (KMS) and provide the signature ID instead of the private key in the API. Alternatively, you can use the Tatum JavaScript client.
        /// </summary>
        /// <exception cref="Tatum.CSharp.Ethereum.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="callReadSmartContractMethod"></param>
        /// <param name="xTestnetType">Type of Ethereum testnet. Defaults to ethereum-sepolia. (optional, default to ethereum-sepolia)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (Data)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<Data>> EthBlockchainSmartContractInvocationWithHttpInfoAsync(CallReadSmartContractMethod callReadSmartContractMethod, string xTestnetType = default(string), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            // verify the required parameter 'callReadSmartContractMethod' is set
            if (callReadSmartContractMethod == null)
                throw new ApiException(400, "Missing required parameter 'callReadSmartContractMethod' when calling EthereumApi->EthBlockchainSmartContractInvocation_0");

            var localVarRequestOptions = new RequestOptions();

            var contentTypes = new string[]{
                "application/json"
            };

            // to determine the Accept header
            var accepts = new string[]{
                "application/json"
            };


            var localVarContentType = ClientUtils.SelectHeaderContentType(contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = ClientUtils.SelectHeaderAccept(accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            if (xTestnetType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("x-testnet-type", ClientUtils.ParameterToString(xTestnetType)); // header parameter
            }
            localVarRequestOptions.Data = callReadSmartContractMethod;

            // authentication (X-API-Key) required
            if (!string.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("x-api-key")))
            {
                localVarRequestOptions.HeaderParameters.Add("x-api-key", Configuration.GetApiKeyWithPrefix("x-api-key"));
            }

            // make the HTTP request

            var localVarResponse = await AsynchronousClient.PostAsync<Data>("/v3/ethereum/smartcontract", localVarRequestOptions, Configuration, cancellationToken).ConfigureAwait(false);

            return localVarResponse;
        }

        /// <summary>
        /// Invoke a method in a smart contract on Ethereum 2 credits per API call Invoke a method in an existing smart contract on Ethereum. You can call a read-only or write method. For read-only methods, the output of the invoked method is returned. For write methods, the ID of the associated transaction is returned. Troubleshooting a failed transaction Tatum ensures that this API works against the blockchain (accesses the blockchain, finds the specified smart contract, and executes the specified ABI method with the provided parameters). However, because this API can be run against any smart contract on the blockchain, Tatum cannot in any way guarantee that the method itself will be executed successfully. If you have issues with invoking the method, refer to the user documentation for this method, or contact the author of the smart contract. For more information about invoking methods in smart contracts, see this article on our Support Portal. Signing a transaction When invoking a method in a smart contract, you are charged a fee for the transaction, and you must sign the transaction with the private key of the blockchain address from which the fee will be deducted. Providing the private key in the API is not a secure way of signing transactions, because the private key can be stolen or exposed. Your private keys should never leave your security perimeter. You should use the private keys only for testing a solution you are building on the testnet of a blockchain. For signing transactions on the mainnet, we strongly recommend that you use the Tatum Key Management System (KMS) and provide the signature ID instead of the private key in the API. Alternatively, you can use the Tatum JavaScript client.
        /// </summary>
        /// <exception cref="Tatum.CSharp.Ethereum.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="callSmartContractMethodKMS"></param>
        /// <param name="xTestnetType">Type of Ethereum testnet. Defaults to ethereum-sepolia. (optional, default to ethereum-sepolia)</param>
        /// <returns>SignatureId</returns>
        public SignatureId EthBlockchainSmartContractInvocation(CallSmartContractMethodKMS callSmartContractMethodKMS, string xTestnetType = default(string))
        {
            var localVarResponse = EthBlockchainSmartContractInvocationWithHttpInfo(callSmartContractMethodKMS, xTestnetType);

            var exception = ExceptionFactory?.Invoke("EthBlockchainSmartContractInvocation_1", localVarResponse);
            if (exception != null) throw exception;

            return localVarResponse.Data;
        }

        /// <summary>
        /// Invoke a method in a smart contract on Ethereum 2 credits per API call Invoke a method in an existing smart contract on Ethereum. You can call a read-only or write method. For read-only methods, the output of the invoked method is returned. For write methods, the ID of the associated transaction is returned. Troubleshooting a failed transaction Tatum ensures that this API works against the blockchain (accesses the blockchain, finds the specified smart contract, and executes the specified ABI method with the provided parameters). However, because this API can be run against any smart contract on the blockchain, Tatum cannot in any way guarantee that the method itself will be executed successfully. If you have issues with invoking the method, refer to the user documentation for this method, or contact the author of the smart contract. For more information about invoking methods in smart contracts, see this article on our Support Portal. Signing a transaction When invoking a method in a smart contract, you are charged a fee for the transaction, and you must sign the transaction with the private key of the blockchain address from which the fee will be deducted. Providing the private key in the API is not a secure way of signing transactions, because the private key can be stolen or exposed. Your private keys should never leave your security perimeter. You should use the private keys only for testing a solution you are building on the testnet of a blockchain. For signing transactions on the mainnet, we strongly recommend that you use the Tatum Key Management System (KMS) and provide the signature ID instead of the private key in the API. Alternatively, you can use the Tatum JavaScript client.
        /// </summary>
        /// <exception cref="Tatum.CSharp.Ethereum.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="callSmartContractMethodKMS"></param>
        /// <param name="xTestnetType">Type of Ethereum testnet. Defaults to ethereum-sepolia. (optional, default to ethereum-sepolia)</param>
        /// <returns>ApiResponse of SignatureId</returns>
        public ApiResponse<SignatureId> EthBlockchainSmartContractInvocationWithHttpInfo(CallSmartContractMethodKMS callSmartContractMethodKMS, string xTestnetType = default(string))
        {
            // verify the required parameter 'callSmartContractMethodKMS' is set
            if (callSmartContractMethodKMS == null)
                throw new ApiException(400, "Missing required parameter 'callSmartContractMethodKMS' when calling EthereumApi->EthBlockchainSmartContractInvocation_1");

            var localVarRequestOptions = new RequestOptions();

            var contentTypes = new string[]{
                "application/json"
            };

            // to determine the Accept header
            var accepts = new string[]{
                "application/json"
            };

            var localVarContentType = ClientUtils.SelectHeaderContentType(contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = ClientUtils.SelectHeaderAccept(accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            if (xTestnetType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("x-testnet-type", ClientUtils.ParameterToString(xTestnetType)); // header parameter
            }
            localVarRequestOptions.Data = callSmartContractMethodKMS;

            // authentication (X-API-Key) required
            if (!string.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("x-api-key")))
            {
                localVarRequestOptions.HeaderParameters.Add("x-api-key", Configuration.GetApiKeyWithPrefix("x-api-key"));
            }

            // make the HTTP request
            var localVarResponse = Client.Post<SignatureId>("/v3/ethereum/smartcontract", localVarRequestOptions, Configuration);

            return localVarResponse;
        }

        /// <summary>
        /// Invoke a method in a smart contract on Ethereum 2 credits per API call Invoke a method in an existing smart contract on Ethereum. You can call a read-only or write method. For read-only methods, the output of the invoked method is returned. For write methods, the ID of the associated transaction is returned. Troubleshooting a failed transaction Tatum ensures that this API works against the blockchain (accesses the blockchain, finds the specified smart contract, and executes the specified ABI method with the provided parameters). However, because this API can be run against any smart contract on the blockchain, Tatum cannot in any way guarantee that the method itself will be executed successfully. If you have issues with invoking the method, refer to the user documentation for this method, or contact the author of the smart contract. For more information about invoking methods in smart contracts, see this article on our Support Portal. Signing a transaction When invoking a method in a smart contract, you are charged a fee for the transaction, and you must sign the transaction with the private key of the blockchain address from which the fee will be deducted. Providing the private key in the API is not a secure way of signing transactions, because the private key can be stolen or exposed. Your private keys should never leave your security perimeter. You should use the private keys only for testing a solution you are building on the testnet of a blockchain. For signing transactions on the mainnet, we strongly recommend that you use the Tatum Key Management System (KMS) and provide the signature ID instead of the private key in the API. Alternatively, you can use the Tatum JavaScript client.
        /// </summary>
        /// <exception cref="Tatum.CSharp.Ethereum.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="callSmartContractMethodKMS"></param>
        /// <param name="xTestnetType">Type of Ethereum testnet. Defaults to ethereum-sepolia. (optional, default to ethereum-sepolia)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of SignatureId</returns>
        public async System.Threading.Tasks.Task<SignatureId> EthBlockchainSmartContractInvocationAsync(CallSmartContractMethodKMS callSmartContractMethodKMS, string xTestnetType = default(string), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            var localVarResponse = await EthBlockchainSmartContractInvocationWithHttpInfoAsync(callSmartContractMethodKMS, xTestnetType, cancellationToken).ConfigureAwait(false);
            
            var exception = ExceptionFactory?.Invoke("EthBlockchainSmartContractInvocation_1", localVarResponse);
            if (exception != null) throw exception;

            return localVarResponse.Data;
        }

        /// <summary>
        /// Invoke a method in a smart contract on Ethereum 2 credits per API call Invoke a method in an existing smart contract on Ethereum. You can call a read-only or write method. For read-only methods, the output of the invoked method is returned. For write methods, the ID of the associated transaction is returned. Troubleshooting a failed transaction Tatum ensures that this API works against the blockchain (accesses the blockchain, finds the specified smart contract, and executes the specified ABI method with the provided parameters). However, because this API can be run against any smart contract on the blockchain, Tatum cannot in any way guarantee that the method itself will be executed successfully. If you have issues with invoking the method, refer to the user documentation for this method, or contact the author of the smart contract. For more information about invoking methods in smart contracts, see this article on our Support Portal. Signing a transaction When invoking a method in a smart contract, you are charged a fee for the transaction, and you must sign the transaction with the private key of the blockchain address from which the fee will be deducted. Providing the private key in the API is not a secure way of signing transactions, because the private key can be stolen or exposed. Your private keys should never leave your security perimeter. You should use the private keys only for testing a solution you are building on the testnet of a blockchain. For signing transactions on the mainnet, we strongly recommend that you use the Tatum Key Management System (KMS) and provide the signature ID instead of the private key in the API. Alternatively, you can use the Tatum JavaScript client.
        /// </summary>
        /// <exception cref="Tatum.CSharp.Ethereum.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="callSmartContractMethodKMS"></param>
        /// <param name="xTestnetType">Type of Ethereum testnet. Defaults to ethereum-sepolia. (optional, default to ethereum-sepolia)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (SignatureId)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<SignatureId>> EthBlockchainSmartContractInvocationWithHttpInfoAsync(CallSmartContractMethodKMS callSmartContractMethodKMS, string xTestnetType = default(string), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            // verify the required parameter 'callSmartContractMethodKMS' is set
            if (callSmartContractMethodKMS == null)
                throw new ApiException(400, "Missing required parameter 'callSmartContractMethodKMS' when calling EthereumApi->EthBlockchainSmartContractInvocation_1");

            var localVarRequestOptions = new RequestOptions();

            var contentTypes = new string[]{
                "application/json"
            };

            // to determine the Accept header
            var accepts = new string[]{
                "application/json"
            };


            var localVarContentType = ClientUtils.SelectHeaderContentType(contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = ClientUtils.SelectHeaderAccept(accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            if (xTestnetType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("x-testnet-type", ClientUtils.ParameterToString(xTestnetType)); // header parameter
            }
            localVarRequestOptions.Data = callSmartContractMethodKMS;

            // authentication (X-API-Key) required
            if (!string.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("x-api-key")))
            {
                localVarRequestOptions.HeaderParameters.Add("x-api-key", Configuration.GetApiKeyWithPrefix("x-api-key"));
            }

            // make the HTTP request

            var localVarResponse = await AsynchronousClient.PostAsync<SignatureId>("/v3/ethereum/smartcontract", localVarRequestOptions, Configuration, cancellationToken).ConfigureAwait(false);

            return localVarResponse;
        }

        /// <summary>
        /// Send Ethereum / ERC20 from account to account 2 credits per API call Send Ethereum or Tatum supported ERC20 token from account to account. Signing a transaction When sending ETH, you are charged a fee for the transaction, and you must sign the transaction with the private key of the blockchain address from which the fee will be deducted. Providing the private key in the API is not a secure way of signing transactions, because the private key can be stolen or exposed. Your private keys should never leave your security perimeter. You should use the private keys only for testing a solution you are building on the testnet of a blockchain. For signing transactions on the mainnet, we strongly recommend that you use the Tatum Key Management System (KMS) and provide the signature ID instead of the private key in the API. Alternatively, you can use the Tatum JavaScript client.
        /// </summary>
        /// <exception cref="Tatum.CSharp.Ethereum.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="transferEthBlockchain"></param>
        /// <param name="xTestnetType">Type of Ethereum testnet. Defaults to ethereum-sepolia. (optional, default to ethereum-sepolia)</param>
        /// <returns>TransactionHash</returns>
        public TransactionHash EthBlockchainTransfer(TransferEthBlockchain transferEthBlockchain, string xTestnetType = default(string))
        {
            var localVarResponse = EthBlockchainTransferWithHttpInfo(transferEthBlockchain, xTestnetType);

            var exception = ExceptionFactory?.Invoke("EthBlockchainTransfer", localVarResponse);
            if (exception != null) throw exception;

            return localVarResponse.Data;
        }

        /// <summary>
        /// Send Ethereum / ERC20 from account to account 2 credits per API call Send Ethereum or Tatum supported ERC20 token from account to account. Signing a transaction When sending ETH, you are charged a fee for the transaction, and you must sign the transaction with the private key of the blockchain address from which the fee will be deducted. Providing the private key in the API is not a secure way of signing transactions, because the private key can be stolen or exposed. Your private keys should never leave your security perimeter. You should use the private keys only for testing a solution you are building on the testnet of a blockchain. For signing transactions on the mainnet, we strongly recommend that you use the Tatum Key Management System (KMS) and provide the signature ID instead of the private key in the API. Alternatively, you can use the Tatum JavaScript client.
        /// </summary>
        /// <exception cref="Tatum.CSharp.Ethereum.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="transferEthBlockchain"></param>
        /// <param name="xTestnetType">Type of Ethereum testnet. Defaults to ethereum-sepolia. (optional, default to ethereum-sepolia)</param>
        /// <returns>ApiResponse of TransactionHash</returns>
        public ApiResponse<TransactionHash> EthBlockchainTransferWithHttpInfo(TransferEthBlockchain transferEthBlockchain, string xTestnetType = default(string))
        {
            // verify the required parameter 'transferEthBlockchain' is set
            if (transferEthBlockchain == null)
                throw new ApiException(400, "Missing required parameter 'transferEthBlockchain' when calling EthereumApi->EthBlockchainTransfer");

            var localVarRequestOptions = new RequestOptions();

            var contentTypes = new string[]{
                "application/json"
            };

            // to determine the Accept header
            var accepts = new string[]{
                "application/json"
            };

            var localVarContentType = ClientUtils.SelectHeaderContentType(contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = ClientUtils.SelectHeaderAccept(accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            if (xTestnetType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("x-testnet-type", ClientUtils.ParameterToString(xTestnetType)); // header parameter
            }
            localVarRequestOptions.Data = transferEthBlockchain;

            // authentication (X-API-Key) required
            if (!string.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("x-api-key")))
            {
                localVarRequestOptions.HeaderParameters.Add("x-api-key", Configuration.GetApiKeyWithPrefix("x-api-key"));
            }

            // make the HTTP request
            var localVarResponse = Client.Post<TransactionHash>("/v3/ethereum/transaction", localVarRequestOptions, Configuration);

            return localVarResponse;
        }

        /// <summary>
        /// Send Ethereum / ERC20 from account to account 2 credits per API call Send Ethereum or Tatum supported ERC20 token from account to account. Signing a transaction When sending ETH, you are charged a fee for the transaction, and you must sign the transaction with the private key of the blockchain address from which the fee will be deducted. Providing the private key in the API is not a secure way of signing transactions, because the private key can be stolen or exposed. Your private keys should never leave your security perimeter. You should use the private keys only for testing a solution you are building on the testnet of a blockchain. For signing transactions on the mainnet, we strongly recommend that you use the Tatum Key Management System (KMS) and provide the signature ID instead of the private key in the API. Alternatively, you can use the Tatum JavaScript client.
        /// </summary>
        /// <exception cref="Tatum.CSharp.Ethereum.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="transferEthBlockchain"></param>
        /// <param name="xTestnetType">Type of Ethereum testnet. Defaults to ethereum-sepolia. (optional, default to ethereum-sepolia)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of TransactionHash</returns>
        public async System.Threading.Tasks.Task<TransactionHash> EthBlockchainTransferAsync(TransferEthBlockchain transferEthBlockchain, string xTestnetType = default(string), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            var localVarResponse = await EthBlockchainTransferWithHttpInfoAsync(transferEthBlockchain, xTestnetType, cancellationToken).ConfigureAwait(false);
            
            var exception = ExceptionFactory?.Invoke("EthBlockchainTransfer", localVarResponse);
            if (exception != null) throw exception;

            return localVarResponse.Data;
        }

        /// <summary>
        /// Send Ethereum / ERC20 from account to account 2 credits per API call Send Ethereum or Tatum supported ERC20 token from account to account. Signing a transaction When sending ETH, you are charged a fee for the transaction, and you must sign the transaction with the private key of the blockchain address from which the fee will be deducted. Providing the private key in the API is not a secure way of signing transactions, because the private key can be stolen or exposed. Your private keys should never leave your security perimeter. You should use the private keys only for testing a solution you are building on the testnet of a blockchain. For signing transactions on the mainnet, we strongly recommend that you use the Tatum Key Management System (KMS) and provide the signature ID instead of the private key in the API. Alternatively, you can use the Tatum JavaScript client.
        /// </summary>
        /// <exception cref="Tatum.CSharp.Ethereum.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="transferEthBlockchain"></param>
        /// <param name="xTestnetType">Type of Ethereum testnet. Defaults to ethereum-sepolia. (optional, default to ethereum-sepolia)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (TransactionHash)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<TransactionHash>> EthBlockchainTransferWithHttpInfoAsync(TransferEthBlockchain transferEthBlockchain, string xTestnetType = default(string), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            // verify the required parameter 'transferEthBlockchain' is set
            if (transferEthBlockchain == null)
                throw new ApiException(400, "Missing required parameter 'transferEthBlockchain' when calling EthereumApi->EthBlockchainTransfer");

            var localVarRequestOptions = new RequestOptions();

            var contentTypes = new string[]{
                "application/json"
            };

            // to determine the Accept header
            var accepts = new string[]{
                "application/json"
            };


            var localVarContentType = ClientUtils.SelectHeaderContentType(contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = ClientUtils.SelectHeaderAccept(accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            if (xTestnetType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("x-testnet-type", ClientUtils.ParameterToString(xTestnetType)); // header parameter
            }
            localVarRequestOptions.Data = transferEthBlockchain;

            // authentication (X-API-Key) required
            if (!string.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("x-api-key")))
            {
                localVarRequestOptions.HeaderParameters.Add("x-api-key", Configuration.GetApiKeyWithPrefix("x-api-key"));
            }

            // make the HTTP request

            var localVarResponse = await AsynchronousClient.PostAsync<TransactionHash>("/v3/ethereum/transaction", localVarRequestOptions, Configuration, cancellationToken).ConfigureAwait(false);

            return localVarResponse;
        }

        /// <summary>
        /// Send Ethereum / ERC20 from account to account 2 credits per API call Send Ethereum or Tatum supported ERC20 token from account to account. Signing a transaction When sending ETH, you are charged a fee for the transaction, and you must sign the transaction with the private key of the blockchain address from which the fee will be deducted. Providing the private key in the API is not a secure way of signing transactions, because the private key can be stolen or exposed. Your private keys should never leave your security perimeter. You should use the private keys only for testing a solution you are building on the testnet of a blockchain. For signing transactions on the mainnet, we strongly recommend that you use the Tatum Key Management System (KMS) and provide the signature ID instead of the private key in the API. Alternatively, you can use the Tatum JavaScript client.
        /// </summary>
        /// <exception cref="Tatum.CSharp.Ethereum.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="transferEthBlockchainKMS"></param>
        /// <param name="xTestnetType">Type of Ethereum testnet. Defaults to ethereum-sepolia. (optional, default to ethereum-sepolia)</param>
        /// <returns>SignatureId</returns>
        public SignatureId EthBlockchainTransfer(TransferEthBlockchainKMS transferEthBlockchainKMS, string xTestnetType = default(string))
        {
            var localVarResponse = EthBlockchainTransferWithHttpInfo(transferEthBlockchainKMS, xTestnetType);

            var exception = ExceptionFactory?.Invoke("EthBlockchainTransfer_0", localVarResponse);
            if (exception != null) throw exception;

            return localVarResponse.Data;
        }

        /// <summary>
        /// Send Ethereum / ERC20 from account to account 2 credits per API call Send Ethereum or Tatum supported ERC20 token from account to account. Signing a transaction When sending ETH, you are charged a fee for the transaction, and you must sign the transaction with the private key of the blockchain address from which the fee will be deducted. Providing the private key in the API is not a secure way of signing transactions, because the private key can be stolen or exposed. Your private keys should never leave your security perimeter. You should use the private keys only for testing a solution you are building on the testnet of a blockchain. For signing transactions on the mainnet, we strongly recommend that you use the Tatum Key Management System (KMS) and provide the signature ID instead of the private key in the API. Alternatively, you can use the Tatum JavaScript client.
        /// </summary>
        /// <exception cref="Tatum.CSharp.Ethereum.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="transferEthBlockchainKMS"></param>
        /// <param name="xTestnetType">Type of Ethereum testnet. Defaults to ethereum-sepolia. (optional, default to ethereum-sepolia)</param>
        /// <returns>ApiResponse of SignatureId</returns>
        public ApiResponse<SignatureId> EthBlockchainTransferWithHttpInfo(TransferEthBlockchainKMS transferEthBlockchainKMS, string xTestnetType = default(string))
        {
            // verify the required parameter 'transferEthBlockchainKMS' is set
            if (transferEthBlockchainKMS == null)
                throw new ApiException(400, "Missing required parameter 'transferEthBlockchainKMS' when calling EthereumApi->EthBlockchainTransfer_0");

            var localVarRequestOptions = new RequestOptions();

            var contentTypes = new string[]{
                "application/json"
            };

            // to determine the Accept header
            var accepts = new string[]{
                "application/json"
            };

            var localVarContentType = ClientUtils.SelectHeaderContentType(contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = ClientUtils.SelectHeaderAccept(accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            if (xTestnetType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("x-testnet-type", ClientUtils.ParameterToString(xTestnetType)); // header parameter
            }
            localVarRequestOptions.Data = transferEthBlockchainKMS;

            // authentication (X-API-Key) required
            if (!string.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("x-api-key")))
            {
                localVarRequestOptions.HeaderParameters.Add("x-api-key", Configuration.GetApiKeyWithPrefix("x-api-key"));
            }

            // make the HTTP request
            var localVarResponse = Client.Post<SignatureId>("/v3/ethereum/transaction", localVarRequestOptions, Configuration);

            return localVarResponse;
        }

        /// <summary>
        /// Send Ethereum / ERC20 from account to account 2 credits per API call Send Ethereum or Tatum supported ERC20 token from account to account. Signing a transaction When sending ETH, you are charged a fee for the transaction, and you must sign the transaction with the private key of the blockchain address from which the fee will be deducted. Providing the private key in the API is not a secure way of signing transactions, because the private key can be stolen or exposed. Your private keys should never leave your security perimeter. You should use the private keys only for testing a solution you are building on the testnet of a blockchain. For signing transactions on the mainnet, we strongly recommend that you use the Tatum Key Management System (KMS) and provide the signature ID instead of the private key in the API. Alternatively, you can use the Tatum JavaScript client.
        /// </summary>
        /// <exception cref="Tatum.CSharp.Ethereum.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="transferEthBlockchainKMS"></param>
        /// <param name="xTestnetType">Type of Ethereum testnet. Defaults to ethereum-sepolia. (optional, default to ethereum-sepolia)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of SignatureId</returns>
        public async System.Threading.Tasks.Task<SignatureId> EthBlockchainTransferAsync(TransferEthBlockchainKMS transferEthBlockchainKMS, string xTestnetType = default(string), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            var localVarResponse = await EthBlockchainTransferWithHttpInfoAsync(transferEthBlockchainKMS, xTestnetType, cancellationToken).ConfigureAwait(false);
            
            var exception = ExceptionFactory?.Invoke("EthBlockchainTransfer_0", localVarResponse);
            if (exception != null) throw exception;

            return localVarResponse.Data;
        }

        /// <summary>
        /// Send Ethereum / ERC20 from account to account 2 credits per API call Send Ethereum or Tatum supported ERC20 token from account to account. Signing a transaction When sending ETH, you are charged a fee for the transaction, and you must sign the transaction with the private key of the blockchain address from which the fee will be deducted. Providing the private key in the API is not a secure way of signing transactions, because the private key can be stolen or exposed. Your private keys should never leave your security perimeter. You should use the private keys only for testing a solution you are building on the testnet of a blockchain. For signing transactions on the mainnet, we strongly recommend that you use the Tatum Key Management System (KMS) and provide the signature ID instead of the private key in the API. Alternatively, you can use the Tatum JavaScript client.
        /// </summary>
        /// <exception cref="Tatum.CSharp.Ethereum.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="transferEthBlockchainKMS"></param>
        /// <param name="xTestnetType">Type of Ethereum testnet. Defaults to ethereum-sepolia. (optional, default to ethereum-sepolia)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (SignatureId)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<SignatureId>> EthBlockchainTransferWithHttpInfoAsync(TransferEthBlockchainKMS transferEthBlockchainKMS, string xTestnetType = default(string), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            // verify the required parameter 'transferEthBlockchainKMS' is set
            if (transferEthBlockchainKMS == null)
                throw new ApiException(400, "Missing required parameter 'transferEthBlockchainKMS' when calling EthereumApi->EthBlockchainTransfer_0");

            var localVarRequestOptions = new RequestOptions();

            var contentTypes = new string[]{
                "application/json"
            };

            // to determine the Accept header
            var accepts = new string[]{
                "application/json"
            };


            var localVarContentType = ClientUtils.SelectHeaderContentType(contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = ClientUtils.SelectHeaderAccept(accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            if (xTestnetType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("x-testnet-type", ClientUtils.ParameterToString(xTestnetType)); // header parameter
            }
            localVarRequestOptions.Data = transferEthBlockchainKMS;

            // authentication (X-API-Key) required
            if (!string.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("x-api-key")))
            {
                localVarRequestOptions.HeaderParameters.Add("x-api-key", Configuration.GetApiKeyWithPrefix("x-api-key"));
            }

            // make the HTTP request

            var localVarResponse = await AsynchronousClient.PostAsync<SignatureId>("/v3/ethereum/transaction", localVarRequestOptions, Configuration, cancellationToken).ConfigureAwait(false);

            return localVarResponse;
        }

        /// <summary>
        /// Broadcast signed Ethereum transaction 2 credits per API call Broadcast signed transaction to Ethereum blockchain. This method is used internally from Tatum KMS or Tatum client libraries. It is possible to create custom signing mechanism and use this method only for broadcasting data to the blockchain.
        /// </summary>
        /// <exception cref="Tatum.CSharp.Ethereum.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="broadcastKMS"></param>
        /// <param name="xTestnetType">Type of Ethereum testnet. Defaults to ethereum-sepolia. (optional, default to ethereum-sepolia)</param>
        /// <returns>TransactionHash</returns>
        public TransactionHash EthBroadcast(BroadcastKMS broadcastKMS, string xTestnetType = default(string))
        {
            var localVarResponse = EthBroadcastWithHttpInfo(broadcastKMS, xTestnetType);

            var exception = ExceptionFactory?.Invoke("EthBroadcast", localVarResponse);
            if (exception != null) throw exception;

            return localVarResponse.Data;
        }

        /// <summary>
        /// Broadcast signed Ethereum transaction 2 credits per API call Broadcast signed transaction to Ethereum blockchain. This method is used internally from Tatum KMS or Tatum client libraries. It is possible to create custom signing mechanism and use this method only for broadcasting data to the blockchain.
        /// </summary>
        /// <exception cref="Tatum.CSharp.Ethereum.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="broadcastKMS"></param>
        /// <param name="xTestnetType">Type of Ethereum testnet. Defaults to ethereum-sepolia. (optional, default to ethereum-sepolia)</param>
        /// <returns>ApiResponse of TransactionHash</returns>
        public ApiResponse<TransactionHash> EthBroadcastWithHttpInfo(BroadcastKMS broadcastKMS, string xTestnetType = default(string))
        {
            // verify the required parameter 'broadcastKMS' is set
            if (broadcastKMS == null)
                throw new ApiException(400, "Missing required parameter 'broadcastKMS' when calling EthereumApi->EthBroadcast");

            var localVarRequestOptions = new RequestOptions();

            var contentTypes = new string[]{
                "application/json"
            };

            // to determine the Accept header
            var accepts = new string[]{
                "application/json"
            };

            var localVarContentType = ClientUtils.SelectHeaderContentType(contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = ClientUtils.SelectHeaderAccept(accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            if (xTestnetType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("x-testnet-type", ClientUtils.ParameterToString(xTestnetType)); // header parameter
            }
            localVarRequestOptions.Data = broadcastKMS;

            // authentication (X-API-Key) required
            if (!string.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("x-api-key")))
            {
                localVarRequestOptions.HeaderParameters.Add("x-api-key", Configuration.GetApiKeyWithPrefix("x-api-key"));
            }

            // make the HTTP request
            var localVarResponse = Client.Post<TransactionHash>("/v3/ethereum/broadcast", localVarRequestOptions, Configuration);

            return localVarResponse;
        }

        /// <summary>
        /// Broadcast signed Ethereum transaction 2 credits per API call Broadcast signed transaction to Ethereum blockchain. This method is used internally from Tatum KMS or Tatum client libraries. It is possible to create custom signing mechanism and use this method only for broadcasting data to the blockchain.
        /// </summary>
        /// <exception cref="Tatum.CSharp.Ethereum.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="broadcastKMS"></param>
        /// <param name="xTestnetType">Type of Ethereum testnet. Defaults to ethereum-sepolia. (optional, default to ethereum-sepolia)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of TransactionHash</returns>
        public async System.Threading.Tasks.Task<TransactionHash> EthBroadcastAsync(BroadcastKMS broadcastKMS, string xTestnetType = default(string), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            var localVarResponse = await EthBroadcastWithHttpInfoAsync(broadcastKMS, xTestnetType, cancellationToken).ConfigureAwait(false);
            
            var exception = ExceptionFactory?.Invoke("EthBroadcast", localVarResponse);
            if (exception != null) throw exception;

            return localVarResponse.Data;
        }

        /// <summary>
        /// Broadcast signed Ethereum transaction 2 credits per API call Broadcast signed transaction to Ethereum blockchain. This method is used internally from Tatum KMS or Tatum client libraries. It is possible to create custom signing mechanism and use this method only for broadcasting data to the blockchain.
        /// </summary>
        /// <exception cref="Tatum.CSharp.Ethereum.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="broadcastKMS"></param>
        /// <param name="xTestnetType">Type of Ethereum testnet. Defaults to ethereum-sepolia. (optional, default to ethereum-sepolia)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (TransactionHash)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<TransactionHash>> EthBroadcastWithHttpInfoAsync(BroadcastKMS broadcastKMS, string xTestnetType = default(string), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            // verify the required parameter 'broadcastKMS' is set
            if (broadcastKMS == null)
                throw new ApiException(400, "Missing required parameter 'broadcastKMS' when calling EthereumApi->EthBroadcast");

            var localVarRequestOptions = new RequestOptions();

            var contentTypes = new string[]{
                "application/json"
            };

            // to determine the Accept header
            var accepts = new string[]{
                "application/json"
            };


            var localVarContentType = ClientUtils.SelectHeaderContentType(contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = ClientUtils.SelectHeaderAccept(accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            if (xTestnetType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("x-testnet-type", ClientUtils.ParameterToString(xTestnetType)); // header parameter
            }
            localVarRequestOptions.Data = broadcastKMS;

            // authentication (X-API-Key) required
            if (!string.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("x-api-key")))
            {
                localVarRequestOptions.HeaderParameters.Add("x-api-key", Configuration.GetApiKeyWithPrefix("x-api-key"));
            }

            // make the HTTP request

            var localVarResponse = await AsynchronousClient.PostAsync<TransactionHash>("/v3/ethereum/broadcast", localVarRequestOptions, Configuration, cancellationToken).ConfigureAwait(false);

            return localVarResponse;
        }

        /// <summary>
        /// Generate Ethereum account address from Extended public key 1 credit per API call. Generates an Ethereum account deposit address from an Extended public key. The deposit address is generated for the specific index - each extended public key can generate up to 2^31 addresses starting from index 0 until 2^31 - 1.
        /// </summary>
        /// <exception cref="Tatum.CSharp.Ethereum.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="xpub">Extended public key of wallet.</param>
        /// <param name="index">Derivation index of the address to be generated.</param>
        /// <param name="xTestnetType">Type of Ethereum testnet. Defaults to ethereum-sepolia. (optional, default to ethereum-sepolia)</param>
        /// <returns>GeneratedAddressEth</returns>
        public GeneratedAddressEth EthGenerateAddress(string xpub, decimal index, string xTestnetType = default(string))
        {
            var localVarResponse = EthGenerateAddressWithHttpInfo(xpub, index, xTestnetType);

            var exception = ExceptionFactory?.Invoke("EthGenerateAddress", localVarResponse);
            if (exception != null) throw exception;

            return localVarResponse.Data;
        }

        /// <summary>
        /// Generate Ethereum account address from Extended public key 1 credit per API call. Generates an Ethereum account deposit address from an Extended public key. The deposit address is generated for the specific index - each extended public key can generate up to 2^31 addresses starting from index 0 until 2^31 - 1.
        /// </summary>
        /// <exception cref="Tatum.CSharp.Ethereum.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="xpub">Extended public key of wallet.</param>
        /// <param name="index">Derivation index of the address to be generated.</param>
        /// <param name="xTestnetType">Type of Ethereum testnet. Defaults to ethereum-sepolia. (optional, default to ethereum-sepolia)</param>
        /// <returns>ApiResponse of GeneratedAddressEth</returns>
        public ApiResponse<GeneratedAddressEth> EthGenerateAddressWithHttpInfo(string xpub, decimal index, string xTestnetType = default(string))
        {
            // verify the required parameter 'xpub' is set
            if (xpub == null)
                throw new ApiException(400, "Missing required parameter 'xpub' when calling EthereumApi->EthGenerateAddress");

            var localVarRequestOptions = new RequestOptions();

            var contentTypes = new string[]{
            };

            // to determine the Accept header
            var accepts = new string[]{
                "application/json"
            };

            var localVarContentType = ClientUtils.SelectHeaderContentType(contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = ClientUtils.SelectHeaderAccept(accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.PathParameters.Add("xpub", ClientUtils.ParameterToString(xpub)); // path parameter
            localVarRequestOptions.PathParameters.Add("index", ClientUtils.ParameterToString(index)); // path parameter
            if (xTestnetType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("x-testnet-type", ClientUtils.ParameterToString(xTestnetType)); // header parameter
            }

            // authentication (X-API-Key) required
            if (!string.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("x-api-key")))
            {
                localVarRequestOptions.HeaderParameters.Add("x-api-key", Configuration.GetApiKeyWithPrefix("x-api-key"));
            }

            // make the HTTP request
            var localVarResponse = Client.Get<GeneratedAddressEth>("/v3/ethereum/address/{xpub}/{index}", localVarRequestOptions, Configuration);

            return localVarResponse;
        }

        /// <summary>
        /// Generate Ethereum account address from Extended public key 1 credit per API call. Generates an Ethereum account deposit address from an Extended public key. The deposit address is generated for the specific index - each extended public key can generate up to 2^31 addresses starting from index 0 until 2^31 - 1.
        /// </summary>
        /// <exception cref="Tatum.CSharp.Ethereum.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="xpub">Extended public key of wallet.</param>
        /// <param name="index">Derivation index of the address to be generated.</param>
        /// <param name="xTestnetType">Type of Ethereum testnet. Defaults to ethereum-sepolia. (optional, default to ethereum-sepolia)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of GeneratedAddressEth</returns>
        public async System.Threading.Tasks.Task<GeneratedAddressEth> EthGenerateAddressAsync(string xpub, decimal index, string xTestnetType = default(string), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            var localVarResponse = await EthGenerateAddressWithHttpInfoAsync(xpub, index, xTestnetType, cancellationToken).ConfigureAwait(false);
            
            var exception = ExceptionFactory?.Invoke("EthGenerateAddress", localVarResponse);
            if (exception != null) throw exception;

            return localVarResponse.Data;
        }

        /// <summary>
        /// Generate Ethereum account address from Extended public key 1 credit per API call. Generates an Ethereum account deposit address from an Extended public key. The deposit address is generated for the specific index - each extended public key can generate up to 2^31 addresses starting from index 0 until 2^31 - 1.
        /// </summary>
        /// <exception cref="Tatum.CSharp.Ethereum.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="xpub">Extended public key of wallet.</param>
        /// <param name="index">Derivation index of the address to be generated.</param>
        /// <param name="xTestnetType">Type of Ethereum testnet. Defaults to ethereum-sepolia. (optional, default to ethereum-sepolia)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (GeneratedAddressEth)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<GeneratedAddressEth>> EthGenerateAddressWithHttpInfoAsync(string xpub, decimal index, string xTestnetType = default(string), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            // verify the required parameter 'xpub' is set
            if (xpub == null)
                throw new ApiException(400, "Missing required parameter 'xpub' when calling EthereumApi->EthGenerateAddress");

            var localVarRequestOptions = new RequestOptions();

            var contentTypes = new string[]{
            };

            // to determine the Accept header
            var accepts = new string[]{
                "application/json"
            };


            var localVarContentType = ClientUtils.SelectHeaderContentType(contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = ClientUtils.SelectHeaderAccept(accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.PathParameters.Add("xpub", ClientUtils.ParameterToString(xpub)); // path parameter
            localVarRequestOptions.PathParameters.Add("index", ClientUtils.ParameterToString(index)); // path parameter
            if (xTestnetType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("x-testnet-type", ClientUtils.ParameterToString(xTestnetType)); // header parameter
            }

            // authentication (X-API-Key) required
            if (!string.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("x-api-key")))
            {
                localVarRequestOptions.HeaderParameters.Add("x-api-key", Configuration.GetApiKeyWithPrefix("x-api-key"));
            }

            // make the HTTP request

            var localVarResponse = await AsynchronousClient.GetAsync<GeneratedAddressEth>("/v3/ethereum/address/{xpub}/{index}", localVarRequestOptions, Configuration, cancellationToken).ConfigureAwait(false);

            return localVarResponse;
        }

        /// <summary>
        /// Generate Ethereum private key 1 credit per API call. Generates the private key of an address from a mnemonic for a given derivation path index. The private key is generated for the specific index - each mnemonic can generate up to 2^32 private keys starting from index 0 until 2^31 - 1.
        /// </summary>
        /// <exception cref="Tatum.CSharp.Ethereum.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="privKeyRequest"></param>
        /// <param name="xTestnetType">Type of Ethereum testnet. Defaults to ethereum-sepolia. (optional, default to ethereum-sepolia)</param>
        /// <returns>PrivKey</returns>
        public PrivKey EthGenerateAddressPrivateKey(PrivKeyRequest privKeyRequest, string xTestnetType = default(string))
        {
            var localVarResponse = EthGenerateAddressPrivateKeyWithHttpInfo(privKeyRequest, xTestnetType);

            var exception = ExceptionFactory?.Invoke("EthGenerateAddressPrivateKey", localVarResponse);
            if (exception != null) throw exception;

            return localVarResponse.Data;
        }

        /// <summary>
        /// Generate Ethereum private key 1 credit per API call. Generates the private key of an address from a mnemonic for a given derivation path index. The private key is generated for the specific index - each mnemonic can generate up to 2^32 private keys starting from index 0 until 2^31 - 1.
        /// </summary>
        /// <exception cref="Tatum.CSharp.Ethereum.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="privKeyRequest"></param>
        /// <param name="xTestnetType">Type of Ethereum testnet. Defaults to ethereum-sepolia. (optional, default to ethereum-sepolia)</param>
        /// <returns>ApiResponse of PrivKey</returns>
        public ApiResponse<PrivKey> EthGenerateAddressPrivateKeyWithHttpInfo(PrivKeyRequest privKeyRequest, string xTestnetType = default(string))
        {
            // verify the required parameter 'privKeyRequest' is set
            if (privKeyRequest == null)
                throw new ApiException(400, "Missing required parameter 'privKeyRequest' when calling EthereumApi->EthGenerateAddressPrivateKey");

            var localVarRequestOptions = new RequestOptions();

            var contentTypes = new string[]{
                "application/json"
            };

            // to determine the Accept header
            var accepts = new string[]{
                "application/json"
            };

            var localVarContentType = ClientUtils.SelectHeaderContentType(contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = ClientUtils.SelectHeaderAccept(accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            if (xTestnetType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("x-testnet-type", ClientUtils.ParameterToString(xTestnetType)); // header parameter
            }
            localVarRequestOptions.Data = privKeyRequest;

            // authentication (X-API-Key) required
            if (!string.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("x-api-key")))
            {
                localVarRequestOptions.HeaderParameters.Add("x-api-key", Configuration.GetApiKeyWithPrefix("x-api-key"));
            }

            // make the HTTP request
            var localVarResponse = Client.Post<PrivKey>("/v3/ethereum/wallet/priv", localVarRequestOptions, Configuration);

            return localVarResponse;
        }

        /// <summary>
        /// Generate Ethereum private key 1 credit per API call. Generates the private key of an address from a mnemonic for a given derivation path index. The private key is generated for the specific index - each mnemonic can generate up to 2^32 private keys starting from index 0 until 2^31 - 1.
        /// </summary>
        /// <exception cref="Tatum.CSharp.Ethereum.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="privKeyRequest"></param>
        /// <param name="xTestnetType">Type of Ethereum testnet. Defaults to ethereum-sepolia. (optional, default to ethereum-sepolia)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of PrivKey</returns>
        public async System.Threading.Tasks.Task<PrivKey> EthGenerateAddressPrivateKeyAsync(PrivKeyRequest privKeyRequest, string xTestnetType = default(string), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            var localVarResponse = await EthGenerateAddressPrivateKeyWithHttpInfoAsync(privKeyRequest, xTestnetType, cancellationToken).ConfigureAwait(false);
            
            var exception = ExceptionFactory?.Invoke("EthGenerateAddressPrivateKey", localVarResponse);
            if (exception != null) throw exception;

            return localVarResponse.Data;
        }

        /// <summary>
        /// Generate Ethereum private key 1 credit per API call. Generates the private key of an address from a mnemonic for a given derivation path index. The private key is generated for the specific index - each mnemonic can generate up to 2^32 private keys starting from index 0 until 2^31 - 1.
        /// </summary>
        /// <exception cref="Tatum.CSharp.Ethereum.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="privKeyRequest"></param>
        /// <param name="xTestnetType">Type of Ethereum testnet. Defaults to ethereum-sepolia. (optional, default to ethereum-sepolia)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (PrivKey)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<PrivKey>> EthGenerateAddressPrivateKeyWithHttpInfoAsync(PrivKeyRequest privKeyRequest, string xTestnetType = default(string), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            // verify the required parameter 'privKeyRequest' is set
            if (privKeyRequest == null)
                throw new ApiException(400, "Missing required parameter 'privKeyRequest' when calling EthereumApi->EthGenerateAddressPrivateKey");

            var localVarRequestOptions = new RequestOptions();

            var contentTypes = new string[]{
                "application/json"
            };

            // to determine the Accept header
            var accepts = new string[]{
                "application/json"
            };


            var localVarContentType = ClientUtils.SelectHeaderContentType(contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = ClientUtils.SelectHeaderAccept(accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            if (xTestnetType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("x-testnet-type", ClientUtils.ParameterToString(xTestnetType)); // header parameter
            }
            localVarRequestOptions.Data = privKeyRequest;

            // authentication (X-API-Key) required
            if (!string.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("x-api-key")))
            {
                localVarRequestOptions.HeaderParameters.Add("x-api-key", Configuration.GetApiKeyWithPrefix("x-api-key"));
            }

            // make the HTTP request

            var localVarResponse = await AsynchronousClient.PostAsync<PrivKey>("/v3/ethereum/wallet/priv", localVarRequestOptions, Configuration, cancellationToken).ConfigureAwait(false);

            return localVarResponse;
        }

        /// <summary>
        /// Generate Ethereum wallet 1 credit per API call. Tatum supports BIP44 HD wallets. Because they can generate 2^31 addresses from 1 mnemonic phrase, they are very convenient and secure. A mnemonic phrase consists of 24 special words in a defined order and can restore access to all generated addresses and private keys. Each address is identified by 3 main values: Private Key - your secret value which should never be revealed Public Key - a public address to be published Derivation index - an index of generated address Tatum follows the BIP44 specification and generates for Ethereum wallets with the derivation path m/44&#39;/60&#39;/0&#39;/0. More about BIP44 HD wallets can be found here - https://github.com/bitcoin/bips/blob/master/bip-0044.mediawiki. Generates a BIP44 compatible Ethereum wallet.
        /// </summary>
        /// <exception cref="Tatum.CSharp.Ethereum.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="mnemonic">Mnemonic to use for generating extended public and private keys. (optional)</param>
        /// <param name="xTestnetType">Type of Ethereum testnet. Defaults to ethereum-sepolia. (optional, default to ethereum-sepolia)</param>
        /// <returns>Wallet</returns>
        public Wallet EthGenerateWallet(string mnemonic = default(string), string xTestnetType = default(string))
        {
            var localVarResponse = EthGenerateWalletWithHttpInfo(mnemonic, xTestnetType);

            var exception = ExceptionFactory?.Invoke("EthGenerateWallet", localVarResponse);
            if (exception != null) throw exception;

            return localVarResponse.Data;
        }

        /// <summary>
        /// Generate Ethereum wallet 1 credit per API call. Tatum supports BIP44 HD wallets. Because they can generate 2^31 addresses from 1 mnemonic phrase, they are very convenient and secure. A mnemonic phrase consists of 24 special words in a defined order and can restore access to all generated addresses and private keys. Each address is identified by 3 main values: Private Key - your secret value which should never be revealed Public Key - a public address to be published Derivation index - an index of generated address Tatum follows the BIP44 specification and generates for Ethereum wallets with the derivation path m/44&#39;/60&#39;/0&#39;/0. More about BIP44 HD wallets can be found here - https://github.com/bitcoin/bips/blob/master/bip-0044.mediawiki. Generates a BIP44 compatible Ethereum wallet.
        /// </summary>
        /// <exception cref="Tatum.CSharp.Ethereum.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="mnemonic">Mnemonic to use for generating extended public and private keys. (optional)</param>
        /// <param name="xTestnetType">Type of Ethereum testnet. Defaults to ethereum-sepolia. (optional, default to ethereum-sepolia)</param>
        /// <returns>ApiResponse of Wallet</returns>
        public ApiResponse<Wallet> EthGenerateWalletWithHttpInfo(string mnemonic = default(string), string xTestnetType = default(string))
        {
            var localVarRequestOptions = new RequestOptions();

            var contentTypes = new string[]{
            };

            // to determine the Accept header
            var accepts = new string[]{
                "application/json"
            };

            var localVarContentType = ClientUtils.SelectHeaderContentType(contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = ClientUtils.SelectHeaderAccept(accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            if (mnemonic != null)
            {
                localVarRequestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "mnemonic", mnemonic));
            }
            if (xTestnetType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("x-testnet-type", ClientUtils.ParameterToString(xTestnetType)); // header parameter
            }

            // authentication (X-API-Key) required
            if (!string.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("x-api-key")))
            {
                localVarRequestOptions.HeaderParameters.Add("x-api-key", Configuration.GetApiKeyWithPrefix("x-api-key"));
            }

            // make the HTTP request
            var localVarResponse = Client.Get<Wallet>("/v3/ethereum/wallet", localVarRequestOptions, Configuration);

            return localVarResponse;
        }

        /// <summary>
        /// Generate Ethereum wallet 1 credit per API call. Tatum supports BIP44 HD wallets. Because they can generate 2^31 addresses from 1 mnemonic phrase, they are very convenient and secure. A mnemonic phrase consists of 24 special words in a defined order and can restore access to all generated addresses and private keys. Each address is identified by 3 main values: Private Key - your secret value which should never be revealed Public Key - a public address to be published Derivation index - an index of generated address Tatum follows the BIP44 specification and generates for Ethereum wallets with the derivation path m/44&#39;/60&#39;/0&#39;/0. More about BIP44 HD wallets can be found here - https://github.com/bitcoin/bips/blob/master/bip-0044.mediawiki. Generates a BIP44 compatible Ethereum wallet.
        /// </summary>
        /// <exception cref="Tatum.CSharp.Ethereum.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="mnemonic">Mnemonic to use for generating extended public and private keys. (optional)</param>
        /// <param name="xTestnetType">Type of Ethereum testnet. Defaults to ethereum-sepolia. (optional, default to ethereum-sepolia)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of Wallet</returns>
        public async System.Threading.Tasks.Task<Wallet> EthGenerateWalletAsync(string mnemonic = default(string), string xTestnetType = default(string), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            var localVarResponse = await EthGenerateWalletWithHttpInfoAsync(mnemonic, xTestnetType, cancellationToken).ConfigureAwait(false);
            
            var exception = ExceptionFactory?.Invoke("EthGenerateWallet", localVarResponse);
            if (exception != null) throw exception;

            return localVarResponse.Data;
        }

        /// <summary>
        /// Generate Ethereum wallet 1 credit per API call. Tatum supports BIP44 HD wallets. Because they can generate 2^31 addresses from 1 mnemonic phrase, they are very convenient and secure. A mnemonic phrase consists of 24 special words in a defined order and can restore access to all generated addresses and private keys. Each address is identified by 3 main values: Private Key - your secret value which should never be revealed Public Key - a public address to be published Derivation index - an index of generated address Tatum follows the BIP44 specification and generates for Ethereum wallets with the derivation path m/44&#39;/60&#39;/0&#39;/0. More about BIP44 HD wallets can be found here - https://github.com/bitcoin/bips/blob/master/bip-0044.mediawiki. Generates a BIP44 compatible Ethereum wallet.
        /// </summary>
        /// <exception cref="Tatum.CSharp.Ethereum.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="mnemonic">Mnemonic to use for generating extended public and private keys. (optional)</param>
        /// <param name="xTestnetType">Type of Ethereum testnet. Defaults to ethereum-sepolia. (optional, default to ethereum-sepolia)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (Wallet)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<Wallet>> EthGenerateWalletWithHttpInfoAsync(string mnemonic = default(string), string xTestnetType = default(string), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            var localVarRequestOptions = new RequestOptions();

            var contentTypes = new string[]{
            };

            // to determine the Accept header
            var accepts = new string[]{
                "application/json"
            };


            var localVarContentType = ClientUtils.SelectHeaderContentType(contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = ClientUtils.SelectHeaderAccept(accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            if (mnemonic != null)
            {
                localVarRequestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "mnemonic", mnemonic));
            }
            if (xTestnetType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("x-testnet-type", ClientUtils.ParameterToString(xTestnetType)); // header parameter
            }

            // authentication (X-API-Key) required
            if (!string.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("x-api-key")))
            {
                localVarRequestOptions.HeaderParameters.Add("x-api-key", Configuration.GetApiKeyWithPrefix("x-api-key"));
            }

            // make the HTTP request

            var localVarResponse = await AsynchronousClient.GetAsync<Wallet>("/v3/ethereum/wallet", localVarRequestOptions, Configuration, cancellationToken).ConfigureAwait(false);

            return localVarResponse;
        }

        /// <summary>
        /// Get the ETH balance of an Ethereum account 1 credit per API call Get the balance of ETH of an Ethereum account. To get the balance of tokens, use the APIs for getting the balance of fungible tokens (ERC-20) and NFTs (ERC-721).
        /// </summary>
        /// <exception cref="Tatum.CSharp.Ethereum.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="address">Account address you want to get balance of</param>
        /// <param name="xTestnetType">Type of Ethereum testnet. Defaults to ethereum-sepolia. (optional, default to ethereum-sepolia)</param>
        /// <returns>EthBalance</returns>
        public EthBalance EthGetBalance(string address, string xTestnetType = default(string))
        {
            var localVarResponse = EthGetBalanceWithHttpInfo(address, xTestnetType);

            var exception = ExceptionFactory?.Invoke("EthGetBalance", localVarResponse);
            if (exception != null) throw exception;

            return localVarResponse.Data;
        }

        /// <summary>
        /// Get the ETH balance of an Ethereum account 1 credit per API call Get the balance of ETH of an Ethereum account. To get the balance of tokens, use the APIs for getting the balance of fungible tokens (ERC-20) and NFTs (ERC-721).
        /// </summary>
        /// <exception cref="Tatum.CSharp.Ethereum.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="address">Account address you want to get balance of</param>
        /// <param name="xTestnetType">Type of Ethereum testnet. Defaults to ethereum-sepolia. (optional, default to ethereum-sepolia)</param>
        /// <returns>ApiResponse of EthBalance</returns>
        public ApiResponse<EthBalance> EthGetBalanceWithHttpInfo(string address, string xTestnetType = default(string))
        {
            // verify the required parameter 'address' is set
            if (address == null)
                throw new ApiException(400, "Missing required parameter 'address' when calling EthereumApi->EthGetBalance");

            var localVarRequestOptions = new RequestOptions();

            var contentTypes = new string[]{
            };

            // to determine the Accept header
            var accepts = new string[]{
                "application/json"
            };

            var localVarContentType = ClientUtils.SelectHeaderContentType(contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = ClientUtils.SelectHeaderAccept(accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.PathParameters.Add("address", ClientUtils.ParameterToString(address)); // path parameter
            if (xTestnetType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("x-testnet-type", ClientUtils.ParameterToString(xTestnetType)); // header parameter
            }

            // authentication (X-API-Key) required
            if (!string.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("x-api-key")))
            {
                localVarRequestOptions.HeaderParameters.Add("x-api-key", Configuration.GetApiKeyWithPrefix("x-api-key"));
            }

            // make the HTTP request
            var localVarResponse = Client.Get<EthBalance>("/v3/ethereum/account/balance/{address}", localVarRequestOptions, Configuration);

            return localVarResponse;
        }

        /// <summary>
        /// Get the ETH balance of an Ethereum account 1 credit per API call Get the balance of ETH of an Ethereum account. To get the balance of tokens, use the APIs for getting the balance of fungible tokens (ERC-20) and NFTs (ERC-721).
        /// </summary>
        /// <exception cref="Tatum.CSharp.Ethereum.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="address">Account address you want to get balance of</param>
        /// <param name="xTestnetType">Type of Ethereum testnet. Defaults to ethereum-sepolia. (optional, default to ethereum-sepolia)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of EthBalance</returns>
        public async System.Threading.Tasks.Task<EthBalance> EthGetBalanceAsync(string address, string xTestnetType = default(string), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            var localVarResponse = await EthGetBalanceWithHttpInfoAsync(address, xTestnetType, cancellationToken).ConfigureAwait(false);
            
            var exception = ExceptionFactory?.Invoke("EthGetBalance", localVarResponse);
            if (exception != null) throw exception;

            return localVarResponse.Data;
        }

        /// <summary>
        /// Get the ETH balance of an Ethereum account 1 credit per API call Get the balance of ETH of an Ethereum account. To get the balance of tokens, use the APIs for getting the balance of fungible tokens (ERC-20) and NFTs (ERC-721).
        /// </summary>
        /// <exception cref="Tatum.CSharp.Ethereum.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="address">Account address you want to get balance of</param>
        /// <param name="xTestnetType">Type of Ethereum testnet. Defaults to ethereum-sepolia. (optional, default to ethereum-sepolia)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (EthBalance)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<EthBalance>> EthGetBalanceWithHttpInfoAsync(string address, string xTestnetType = default(string), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            // verify the required parameter 'address' is set
            if (address == null)
                throw new ApiException(400, "Missing required parameter 'address' when calling EthereumApi->EthGetBalance");

            var localVarRequestOptions = new RequestOptions();

            var contentTypes = new string[]{
            };

            // to determine the Accept header
            var accepts = new string[]{
                "application/json"
            };


            var localVarContentType = ClientUtils.SelectHeaderContentType(contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = ClientUtils.SelectHeaderAccept(accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.PathParameters.Add("address", ClientUtils.ParameterToString(address)); // path parameter
            if (xTestnetType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("x-testnet-type", ClientUtils.ParameterToString(xTestnetType)); // header parameter
            }

            // authentication (X-API-Key) required
            if (!string.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("x-api-key")))
            {
                localVarRequestOptions.HeaderParameters.Add("x-api-key", Configuration.GetApiKeyWithPrefix("x-api-key"));
            }

            // make the HTTP request

            var localVarResponse = await AsynchronousClient.GetAsync<EthBalance>("/v3/ethereum/account/balance/{address}", localVarRequestOptions, Configuration, cancellationToken).ConfigureAwait(false);

            return localVarResponse;
        }

        /// <summary>
        /// Get Ethereum block by hash 1 credit per API call. Gets an Ethereum block-by-block hash or block number.
        /// </summary>
        /// <exception cref="Tatum.CSharp.Ethereum.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="hash">Block hash or block number</param>
        /// <param name="xTestnetType">Type of Ethereum testnet. Defaults to ethereum-sepolia. (optional, default to ethereum-sepolia)</param>
        /// <returns>EthBlock</returns>
        public EthBlock EthGetBlock(string hash, string xTestnetType = default(string))
        {
            var localVarResponse = EthGetBlockWithHttpInfo(hash, xTestnetType);

            var exception = ExceptionFactory?.Invoke("EthGetBlock", localVarResponse);
            if (exception != null) throw exception;

            return localVarResponse.Data;
        }

        /// <summary>
        /// Get Ethereum block by hash 1 credit per API call. Gets an Ethereum block-by-block hash or block number.
        /// </summary>
        /// <exception cref="Tatum.CSharp.Ethereum.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="hash">Block hash or block number</param>
        /// <param name="xTestnetType">Type of Ethereum testnet. Defaults to ethereum-sepolia. (optional, default to ethereum-sepolia)</param>
        /// <returns>ApiResponse of EthBlock</returns>
        public ApiResponse<EthBlock> EthGetBlockWithHttpInfo(string hash, string xTestnetType = default(string))
        {
            // verify the required parameter 'hash' is set
            if (hash == null)
                throw new ApiException(400, "Missing required parameter 'hash' when calling EthereumApi->EthGetBlock");

            var localVarRequestOptions = new RequestOptions();

            var contentTypes = new string[]{
            };

            // to determine the Accept header
            var accepts = new string[]{
                "application/json"
            };

            var localVarContentType = ClientUtils.SelectHeaderContentType(contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = ClientUtils.SelectHeaderAccept(accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.PathParameters.Add("hash", ClientUtils.ParameterToString(hash)); // path parameter
            if (xTestnetType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("x-testnet-type", ClientUtils.ParameterToString(xTestnetType)); // header parameter
            }

            // authentication (X-API-Key) required
            if (!string.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("x-api-key")))
            {
                localVarRequestOptions.HeaderParameters.Add("x-api-key", Configuration.GetApiKeyWithPrefix("x-api-key"));
            }

            // make the HTTP request
            var localVarResponse = Client.Get<EthBlock>("/v3/ethereum/block/{hash}", localVarRequestOptions, Configuration);

            return localVarResponse;
        }

        /// <summary>
        /// Get Ethereum block by hash 1 credit per API call. Gets an Ethereum block-by-block hash or block number.
        /// </summary>
        /// <exception cref="Tatum.CSharp.Ethereum.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="hash">Block hash or block number</param>
        /// <param name="xTestnetType">Type of Ethereum testnet. Defaults to ethereum-sepolia. (optional, default to ethereum-sepolia)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of EthBlock</returns>
        public async System.Threading.Tasks.Task<EthBlock> EthGetBlockAsync(string hash, string xTestnetType = default(string), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            var localVarResponse = await EthGetBlockWithHttpInfoAsync(hash, xTestnetType, cancellationToken).ConfigureAwait(false);
            
            var exception = ExceptionFactory?.Invoke("EthGetBlock", localVarResponse);
            if (exception != null) throw exception;

            return localVarResponse.Data;
        }

        /// <summary>
        /// Get Ethereum block by hash 1 credit per API call. Gets an Ethereum block-by-block hash or block number.
        /// </summary>
        /// <exception cref="Tatum.CSharp.Ethereum.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="hash">Block hash or block number</param>
        /// <param name="xTestnetType">Type of Ethereum testnet. Defaults to ethereum-sepolia. (optional, default to ethereum-sepolia)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (EthBlock)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<EthBlock>> EthGetBlockWithHttpInfoAsync(string hash, string xTestnetType = default(string), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            // verify the required parameter 'hash' is set
            if (hash == null)
                throw new ApiException(400, "Missing required parameter 'hash' when calling EthereumApi->EthGetBlock");

            var localVarRequestOptions = new RequestOptions();

            var contentTypes = new string[]{
            };

            // to determine the Accept header
            var accepts = new string[]{
                "application/json"
            };


            var localVarContentType = ClientUtils.SelectHeaderContentType(contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = ClientUtils.SelectHeaderAccept(accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.PathParameters.Add("hash", ClientUtils.ParameterToString(hash)); // path parameter
            if (xTestnetType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("x-testnet-type", ClientUtils.ParameterToString(xTestnetType)); // header parameter
            }

            // authentication (X-API-Key) required
            if (!string.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("x-api-key")))
            {
                localVarRequestOptions.HeaderParameters.Add("x-api-key", Configuration.GetApiKeyWithPrefix("x-api-key"));
            }

            // make the HTTP request

            var localVarResponse = await AsynchronousClient.GetAsync<EthBlock>("/v3/ethereum/block/{hash}", localVarRequestOptions, Configuration, cancellationToken).ConfigureAwait(false);

            return localVarResponse;
        }

        /// <summary>
        /// Get current block number 1 credit per API call. Gets the current Ethereum block number. This is the number of the latest block in the blockchain.
        /// </summary>
        /// <exception cref="Tatum.CSharp.Ethereum.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="xTestnetType">Type of Ethereum testnet. Defaults to ethereum-sepolia. (optional, default to ethereum-sepolia)</param>
        /// <returns>decimal</returns>
        public decimal EthGetCurrentBlock(string xTestnetType = default(string))
        {
            var localVarResponse = EthGetCurrentBlockWithHttpInfo(xTestnetType);

            var exception = ExceptionFactory?.Invoke("EthGetCurrentBlock", localVarResponse);
            if (exception != null) throw exception;

            return localVarResponse.Data;
        }

        /// <summary>
        /// Get current block number 1 credit per API call. Gets the current Ethereum block number. This is the number of the latest block in the blockchain.
        /// </summary>
        /// <exception cref="Tatum.CSharp.Ethereum.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="xTestnetType">Type of Ethereum testnet. Defaults to ethereum-sepolia. (optional, default to ethereum-sepolia)</param>
        /// <returns>ApiResponse of decimal</returns>
        public ApiResponse<decimal> EthGetCurrentBlockWithHttpInfo(string xTestnetType = default(string))
        {
            var localVarRequestOptions = new RequestOptions();

            var contentTypes = new string[]{
            };

            // to determine the Accept header
            var accepts = new string[]{
                "application/json"
            };

            var localVarContentType = ClientUtils.SelectHeaderContentType(contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = ClientUtils.SelectHeaderAccept(accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            if (xTestnetType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("x-testnet-type", ClientUtils.ParameterToString(xTestnetType)); // header parameter
            }

            // authentication (X-API-Key) required
            if (!string.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("x-api-key")))
            {
                localVarRequestOptions.HeaderParameters.Add("x-api-key", Configuration.GetApiKeyWithPrefix("x-api-key"));
            }

            // make the HTTP request
            var localVarResponse = Client.Get<decimal>("/v3/ethereum/block/current", localVarRequestOptions, Configuration);

            return localVarResponse;
        }

        /// <summary>
        /// Get current block number 1 credit per API call. Gets the current Ethereum block number. This is the number of the latest block in the blockchain.
        /// </summary>
        /// <exception cref="Tatum.CSharp.Ethereum.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="xTestnetType">Type of Ethereum testnet. Defaults to ethereum-sepolia. (optional, default to ethereum-sepolia)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of decimal</returns>
        public async System.Threading.Tasks.Task<decimal> EthGetCurrentBlockAsync(string xTestnetType = default(string), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            var localVarResponse = await EthGetCurrentBlockWithHttpInfoAsync(xTestnetType, cancellationToken).ConfigureAwait(false);
            
            var exception = ExceptionFactory?.Invoke("EthGetCurrentBlock", localVarResponse);
            if (exception != null) throw exception;

            return localVarResponse.Data;
        }

        /// <summary>
        /// Get current block number 1 credit per API call. Gets the current Ethereum block number. This is the number of the latest block in the blockchain.
        /// </summary>
        /// <exception cref="Tatum.CSharp.Ethereum.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="xTestnetType">Type of Ethereum testnet. Defaults to ethereum-sepolia. (optional, default to ethereum-sepolia)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (decimal)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<decimal>> EthGetCurrentBlockWithHttpInfoAsync(string xTestnetType = default(string), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            var localVarRequestOptions = new RequestOptions();

            var contentTypes = new string[]{
            };

            // to determine the Accept header
            var accepts = new string[]{
                "application/json"
            };


            var localVarContentType = ClientUtils.SelectHeaderContentType(contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = ClientUtils.SelectHeaderAccept(accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            if (xTestnetType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("x-testnet-type", ClientUtils.ParameterToString(xTestnetType)); // header parameter
            }

            // authentication (X-API-Key) required
            if (!string.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("x-api-key")))
            {
                localVarRequestOptions.HeaderParameters.Add("x-api-key", Configuration.GetApiKeyWithPrefix("x-api-key"));
            }

            // make the HTTP request

            var localVarResponse = await AsynchronousClient.GetAsync<decimal>("/v3/ethereum/block/current", localVarRequestOptions, Configuration, cancellationToken).ConfigureAwait(false);

            return localVarResponse;
        }

        /// <summary>
        /// Get Ethereum internal transactions by address 1 credit per API call. Get Ethereum internal transactions by address.
        /// </summary>
        /// <exception cref="Tatum.CSharp.Ethereum.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="address">Account address you want to get balance of</param>
        /// <param name="pageSize">Max number of items per page is 50.</param>
        /// <param name="offset">Offset to obtain next page of the data. (optional)</param>
        /// <param name="xTestnetType">Type of Ethereum testnet. Defaults to ethereum-sepolia. (optional, default to ethereum-sepolia)</param>
        /// <returns>List&lt;EthTxInternal&gt;</returns>
        public List<EthTxInternal> EthGetInternalTransactionByAddress(string address, decimal pageSize, decimal? offset = default(decimal?), string xTestnetType = default(string))
        {
            var localVarResponse = EthGetInternalTransactionByAddressWithHttpInfo(address, pageSize, offset, xTestnetType);

            var exception = ExceptionFactory?.Invoke("EthGetInternalTransactionByAddress", localVarResponse);
            if (exception != null) throw exception;

            return localVarResponse.Data;
        }

        /// <summary>
        /// Get Ethereum internal transactions by address 1 credit per API call. Get Ethereum internal transactions by address.
        /// </summary>
        /// <exception cref="Tatum.CSharp.Ethereum.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="address">Account address you want to get balance of</param>
        /// <param name="pageSize">Max number of items per page is 50.</param>
        /// <param name="offset">Offset to obtain next page of the data. (optional)</param>
        /// <param name="xTestnetType">Type of Ethereum testnet. Defaults to ethereum-sepolia. (optional, default to ethereum-sepolia)</param>
        /// <returns>ApiResponse of List&lt;EthTxInternal&gt;</returns>
        public ApiResponse<List<EthTxInternal>> EthGetInternalTransactionByAddressWithHttpInfo(string address, decimal pageSize, decimal? offset = default(decimal?), string xTestnetType = default(string))
        {
            // verify the required parameter 'address' is set
            if (address == null)
                throw new ApiException(400, "Missing required parameter 'address' when calling EthereumApi->EthGetInternalTransactionByAddress");

            var localVarRequestOptions = new RequestOptions();

            var contentTypes = new string[]{
            };

            // to determine the Accept header
            var accepts = new string[]{
                "application/json"
            };

            var localVarContentType = ClientUtils.SelectHeaderContentType(contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = ClientUtils.SelectHeaderAccept(accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.PathParameters.Add("address", ClientUtils.ParameterToString(address)); // path parameter
            localVarRequestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "pageSize", pageSize));
            if (offset != null)
            {
                localVarRequestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "offset", offset));
            }
            if (xTestnetType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("x-testnet-type", ClientUtils.ParameterToString(xTestnetType)); // header parameter
            }

            // authentication (X-API-Key) required
            if (!string.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("x-api-key")))
            {
                localVarRequestOptions.HeaderParameters.Add("x-api-key", Configuration.GetApiKeyWithPrefix("x-api-key"));
            }

            // make the HTTP request
            var localVarResponse = Client.Get<List<EthTxInternal>>("/v3/ethereum/account/transaction/erc20/internal/{address}", localVarRequestOptions, Configuration);

            return localVarResponse;
        }

        /// <summary>
        /// Get Ethereum internal transactions by address 1 credit per API call. Get Ethereum internal transactions by address.
        /// </summary>
        /// <exception cref="Tatum.CSharp.Ethereum.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="address">Account address you want to get balance of</param>
        /// <param name="pageSize">Max number of items per page is 50.</param>
        /// <param name="offset">Offset to obtain next page of the data. (optional)</param>
        /// <param name="xTestnetType">Type of Ethereum testnet. Defaults to ethereum-sepolia. (optional, default to ethereum-sepolia)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of List&lt;EthTxInternal&gt;</returns>
        public async System.Threading.Tasks.Task<List<EthTxInternal>> EthGetInternalTransactionByAddressAsync(string address, decimal pageSize, decimal? offset = default(decimal?), string xTestnetType = default(string), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            var localVarResponse = await EthGetInternalTransactionByAddressWithHttpInfoAsync(address, pageSize, offset, xTestnetType, cancellationToken).ConfigureAwait(false);
            
            var exception = ExceptionFactory?.Invoke("EthGetInternalTransactionByAddress", localVarResponse);
            if (exception != null) throw exception;

            return localVarResponse.Data;
        }

        /// <summary>
        /// Get Ethereum internal transactions by address 1 credit per API call. Get Ethereum internal transactions by address.
        /// </summary>
        /// <exception cref="Tatum.CSharp.Ethereum.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="address">Account address you want to get balance of</param>
        /// <param name="pageSize">Max number of items per page is 50.</param>
        /// <param name="offset">Offset to obtain next page of the data. (optional)</param>
        /// <param name="xTestnetType">Type of Ethereum testnet. Defaults to ethereum-sepolia. (optional, default to ethereum-sepolia)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (List&lt;EthTxInternal&gt;)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<List<EthTxInternal>>> EthGetInternalTransactionByAddressWithHttpInfoAsync(string address, decimal pageSize, decimal? offset = default(decimal?), string xTestnetType = default(string), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            // verify the required parameter 'address' is set
            if (address == null)
                throw new ApiException(400, "Missing required parameter 'address' when calling EthereumApi->EthGetInternalTransactionByAddress");

            var localVarRequestOptions = new RequestOptions();

            var contentTypes = new string[]{
            };

            // to determine the Accept header
            var accepts = new string[]{
                "application/json"
            };


            var localVarContentType = ClientUtils.SelectHeaderContentType(contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = ClientUtils.SelectHeaderAccept(accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.PathParameters.Add("address", ClientUtils.ParameterToString(address)); // path parameter
            localVarRequestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "pageSize", pageSize));
            if (offset != null)
            {
                localVarRequestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "offset", offset));
            }
            if (xTestnetType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("x-testnet-type", ClientUtils.ParameterToString(xTestnetType)); // header parameter
            }

            // authentication (X-API-Key) required
            if (!string.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("x-api-key")))
            {
                localVarRequestOptions.HeaderParameters.Add("x-api-key", Configuration.GetApiKeyWithPrefix("x-api-key"));
            }

            // make the HTTP request

            var localVarResponse = await AsynchronousClient.GetAsync<List<EthTxInternal>>("/v3/ethereum/account/transaction/erc20/internal/{address}", localVarRequestOptions, Configuration, cancellationToken).ConfigureAwait(false);

            return localVarResponse;
        }

        /// <summary>
        /// Get Ethereum Transaction 1 credit per API call. Get Ethereum transaction by transaction hash.
        /// </summary>
        /// <exception cref="Tatum.CSharp.Ethereum.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="hash">Transaction hash</param>
        /// <param name="xTestnetType">Type of Ethereum testnet. Defaults to ethereum-sepolia. (optional, default to ethereum-sepolia)</param>
        /// <returns>EthTx</returns>
        public EthTx EthGetTransaction(string hash, string xTestnetType = default(string))
        {
            var localVarResponse = EthGetTransactionWithHttpInfo(hash, xTestnetType);

            var exception = ExceptionFactory?.Invoke("EthGetTransaction", localVarResponse);
            if (exception != null) throw exception;

            return localVarResponse.Data;
        }

        /// <summary>
        /// Get Ethereum Transaction 1 credit per API call. Get Ethereum transaction by transaction hash.
        /// </summary>
        /// <exception cref="Tatum.CSharp.Ethereum.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="hash">Transaction hash</param>
        /// <param name="xTestnetType">Type of Ethereum testnet. Defaults to ethereum-sepolia. (optional, default to ethereum-sepolia)</param>
        /// <returns>ApiResponse of EthTx</returns>
        public ApiResponse<EthTx> EthGetTransactionWithHttpInfo(string hash, string xTestnetType = default(string))
        {
            // verify the required parameter 'hash' is set
            if (hash == null)
                throw new ApiException(400, "Missing required parameter 'hash' when calling EthereumApi->EthGetTransaction");

            var localVarRequestOptions = new RequestOptions();

            var contentTypes = new string[]{
            };

            // to determine the Accept header
            var accepts = new string[]{
                "application/json"
            };

            var localVarContentType = ClientUtils.SelectHeaderContentType(contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = ClientUtils.SelectHeaderAccept(accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.PathParameters.Add("hash", ClientUtils.ParameterToString(hash)); // path parameter
            if (xTestnetType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("x-testnet-type", ClientUtils.ParameterToString(xTestnetType)); // header parameter
            }

            // authentication (X-API-Key) required
            if (!string.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("x-api-key")))
            {
                localVarRequestOptions.HeaderParameters.Add("x-api-key", Configuration.GetApiKeyWithPrefix("x-api-key"));
            }

            // make the HTTP request
            var localVarResponse = Client.Get<EthTx>("/v3/ethereum/transaction/{hash}", localVarRequestOptions, Configuration);

            return localVarResponse;
        }

        /// <summary>
        /// Get Ethereum Transaction 1 credit per API call. Get Ethereum transaction by transaction hash.
        /// </summary>
        /// <exception cref="Tatum.CSharp.Ethereum.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="hash">Transaction hash</param>
        /// <param name="xTestnetType">Type of Ethereum testnet. Defaults to ethereum-sepolia. (optional, default to ethereum-sepolia)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of EthTx</returns>
        public async System.Threading.Tasks.Task<EthTx> EthGetTransactionAsync(string hash, string xTestnetType = default(string), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            var localVarResponse = await EthGetTransactionWithHttpInfoAsync(hash, xTestnetType, cancellationToken).ConfigureAwait(false);
            
            var exception = ExceptionFactory?.Invoke("EthGetTransaction", localVarResponse);
            if (exception != null) throw exception;

            return localVarResponse.Data;
        }

        /// <summary>
        /// Get Ethereum Transaction 1 credit per API call. Get Ethereum transaction by transaction hash.
        /// </summary>
        /// <exception cref="Tatum.CSharp.Ethereum.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="hash">Transaction hash</param>
        /// <param name="xTestnetType">Type of Ethereum testnet. Defaults to ethereum-sepolia. (optional, default to ethereum-sepolia)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (EthTx)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<EthTx>> EthGetTransactionWithHttpInfoAsync(string hash, string xTestnetType = default(string), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            // verify the required parameter 'hash' is set
            if (hash == null)
                throw new ApiException(400, "Missing required parameter 'hash' when calling EthereumApi->EthGetTransaction");

            var localVarRequestOptions = new RequestOptions();

            var contentTypes = new string[]{
            };

            // to determine the Accept header
            var accepts = new string[]{
                "application/json"
            };


            var localVarContentType = ClientUtils.SelectHeaderContentType(contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = ClientUtils.SelectHeaderAccept(accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.PathParameters.Add("hash", ClientUtils.ParameterToString(hash)); // path parameter
            if (xTestnetType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("x-testnet-type", ClientUtils.ParameterToString(xTestnetType)); // header parameter
            }

            // authentication (X-API-Key) required
            if (!string.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("x-api-key")))
            {
                localVarRequestOptions.HeaderParameters.Add("x-api-key", Configuration.GetApiKeyWithPrefix("x-api-key"));
            }

            // make the HTTP request

            var localVarResponse = await AsynchronousClient.GetAsync<EthTx>("/v3/ethereum/transaction/{hash}", localVarRequestOptions, Configuration, cancellationToken).ConfigureAwait(false);

            return localVarResponse;
        }

        /// <summary>
        /// Get Ethereum transactions by address 1 credit per API call. Get Ethereum transactions by address. This includes incoming and outgoing transactions for the address.
        /// </summary>
        /// <exception cref="Tatum.CSharp.Ethereum.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="address">Account address you want to get balance of</param>
        /// <param name="pageSize">Max number of items per page is 50.</param>
        /// <param name="offset">Offset to obtain next page of the data. (optional)</param>
        /// <param name="from">Transactions from this block onwards will be included. (optional)</param>
        /// <param name="to">Transactions up to this block will be included. (optional)</param>
        /// <param name="sort">Sorting of the data. ASC - oldest first, DESC - newest first. (optional, default to DESC)</param>
        /// <param name="xTestnetType">Type of Ethereum testnet. Defaults to ethereum-sepolia. (optional, default to ethereum-sepolia)</param>
        /// <returns>List&lt;EthTx&gt;</returns>
        public List<EthTx> EthGetTransactionByAddress(string address, decimal pageSize, decimal? offset = default(decimal?), decimal? from = default(decimal?), decimal? to = default(decimal?), string sort = default(string), string xTestnetType = default(string))
        {
            var localVarResponse = EthGetTransactionByAddressWithHttpInfo(address, pageSize, offset, from, to, sort, xTestnetType);

            var exception = ExceptionFactory?.Invoke("EthGetTransactionByAddress", localVarResponse);
            if (exception != null) throw exception;

            return localVarResponse.Data;
        }

        /// <summary>
        /// Get Ethereum transactions by address 1 credit per API call. Get Ethereum transactions by address. This includes incoming and outgoing transactions for the address.
        /// </summary>
        /// <exception cref="Tatum.CSharp.Ethereum.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="address">Account address you want to get balance of</param>
        /// <param name="pageSize">Max number of items per page is 50.</param>
        /// <param name="offset">Offset to obtain next page of the data. (optional)</param>
        /// <param name="from">Transactions from this block onwards will be included. (optional)</param>
        /// <param name="to">Transactions up to this block will be included. (optional)</param>
        /// <param name="sort">Sorting of the data. ASC - oldest first, DESC - newest first. (optional, default to DESC)</param>
        /// <param name="xTestnetType">Type of Ethereum testnet. Defaults to ethereum-sepolia. (optional, default to ethereum-sepolia)</param>
        /// <returns>ApiResponse of List&lt;EthTx&gt;</returns>
        public ApiResponse<List<EthTx>> EthGetTransactionByAddressWithHttpInfo(string address, decimal pageSize, decimal? offset = default(decimal?), decimal? from = default(decimal?), decimal? to = default(decimal?), string sort = default(string), string xTestnetType = default(string))
        {
            // verify the required parameter 'address' is set
            if (address == null)
                throw new ApiException(400, "Missing required parameter 'address' when calling EthereumApi->EthGetTransactionByAddress");

            var localVarRequestOptions = new RequestOptions();

            var contentTypes = new string[]{
            };

            // to determine the Accept header
            var accepts = new string[]{
                "application/json"
            };

            var localVarContentType = ClientUtils.SelectHeaderContentType(contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = ClientUtils.SelectHeaderAccept(accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.PathParameters.Add("address", ClientUtils.ParameterToString(address)); // path parameter
            localVarRequestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "pageSize", pageSize));
            if (offset != null)
            {
                localVarRequestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "offset", offset));
            }
            if (from != null)
            {
                localVarRequestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "from", from));
            }
            if (to != null)
            {
                localVarRequestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "to", to));
            }
            if (sort != null)
            {
                localVarRequestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "sort", sort));
            }
            if (xTestnetType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("x-testnet-type", ClientUtils.ParameterToString(xTestnetType)); // header parameter
            }

            // authentication (X-API-Key) required
            if (!string.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("x-api-key")))
            {
                localVarRequestOptions.HeaderParameters.Add("x-api-key", Configuration.GetApiKeyWithPrefix("x-api-key"));
            }

            // make the HTTP request
            var localVarResponse = Client.Get<List<EthTx>>("/v3/ethereum/account/transaction/{address}", localVarRequestOptions, Configuration);

            return localVarResponse;
        }

        /// <summary>
        /// Get Ethereum transactions by address 1 credit per API call. Get Ethereum transactions by address. This includes incoming and outgoing transactions for the address.
        /// </summary>
        /// <exception cref="Tatum.CSharp.Ethereum.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="address">Account address you want to get balance of</param>
        /// <param name="pageSize">Max number of items per page is 50.</param>
        /// <param name="offset">Offset to obtain next page of the data. (optional)</param>
        /// <param name="from">Transactions from this block onwards will be included. (optional)</param>
        /// <param name="to">Transactions up to this block will be included. (optional)</param>
        /// <param name="sort">Sorting of the data. ASC - oldest first, DESC - newest first. (optional, default to DESC)</param>
        /// <param name="xTestnetType">Type of Ethereum testnet. Defaults to ethereum-sepolia. (optional, default to ethereum-sepolia)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of List&lt;EthTx&gt;</returns>
        public async System.Threading.Tasks.Task<List<EthTx>> EthGetTransactionByAddressAsync(string address, decimal pageSize, decimal? offset = default(decimal?), decimal? from = default(decimal?), decimal? to = default(decimal?), string sort = default(string), string xTestnetType = default(string), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            var localVarResponse = await EthGetTransactionByAddressWithHttpInfoAsync(address, pageSize, offset, from, to, sort, xTestnetType, cancellationToken).ConfigureAwait(false);
            
            var exception = ExceptionFactory?.Invoke("EthGetTransactionByAddress", localVarResponse);
            if (exception != null) throw exception;

            return localVarResponse.Data;
        }

        /// <summary>
        /// Get Ethereum transactions by address 1 credit per API call. Get Ethereum transactions by address. This includes incoming and outgoing transactions for the address.
        /// </summary>
        /// <exception cref="Tatum.CSharp.Ethereum.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="address">Account address you want to get balance of</param>
        /// <param name="pageSize">Max number of items per page is 50.</param>
        /// <param name="offset">Offset to obtain next page of the data. (optional)</param>
        /// <param name="from">Transactions from this block onwards will be included. (optional)</param>
        /// <param name="to">Transactions up to this block will be included. (optional)</param>
        /// <param name="sort">Sorting of the data. ASC - oldest first, DESC - newest first. (optional, default to DESC)</param>
        /// <param name="xTestnetType">Type of Ethereum testnet. Defaults to ethereum-sepolia. (optional, default to ethereum-sepolia)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (List&lt;EthTx&gt;)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<List<EthTx>>> EthGetTransactionByAddressWithHttpInfoAsync(string address, decimal pageSize, decimal? offset = default(decimal?), decimal? from = default(decimal?), decimal? to = default(decimal?), string sort = default(string), string xTestnetType = default(string), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            // verify the required parameter 'address' is set
            if (address == null)
                throw new ApiException(400, "Missing required parameter 'address' when calling EthereumApi->EthGetTransactionByAddress");

            var localVarRequestOptions = new RequestOptions();

            var contentTypes = new string[]{
            };

            // to determine the Accept header
            var accepts = new string[]{
                "application/json"
            };


            var localVarContentType = ClientUtils.SelectHeaderContentType(contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = ClientUtils.SelectHeaderAccept(accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.PathParameters.Add("address", ClientUtils.ParameterToString(address)); // path parameter
            localVarRequestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "pageSize", pageSize));
            if (offset != null)
            {
                localVarRequestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "offset", offset));
            }
            if (from != null)
            {
                localVarRequestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "from", from));
            }
            if (to != null)
            {
                localVarRequestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "to", to));
            }
            if (sort != null)
            {
                localVarRequestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "sort", sort));
            }
            if (xTestnetType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("x-testnet-type", ClientUtils.ParameterToString(xTestnetType)); // header parameter
            }

            // authentication (X-API-Key) required
            if (!string.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("x-api-key")))
            {
                localVarRequestOptions.HeaderParameters.Add("x-api-key", Configuration.GetApiKeyWithPrefix("x-api-key"));
            }

            // make the HTTP request

            var localVarResponse = await AsynchronousClient.GetAsync<List<EthTx>>("/v3/ethereum/account/transaction/{address}", localVarRequestOptions, Configuration, cancellationToken).ConfigureAwait(false);

            return localVarResponse;
        }

        /// <summary>
        /// Get count of outgoing Ethereum transactions 1 credit per API call. Get a number of outgoing Ethereum transactions for the address. When a transaction is sent, there can be multiple outgoing transactions, which are not yet processed by the blockchain. To distinguish between them, there is a counter called a nonce, which represents the order of the transaction in the list of outgoing transactions.
        /// </summary>
        /// <exception cref="Tatum.CSharp.Ethereum.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="address">address</param>
        /// <param name="xTestnetType">Type of Ethereum testnet. Defaults to ethereum-sepolia. (optional, default to ethereum-sepolia)</param>
        /// <returns>decimal</returns>
        public decimal EthGetTransactionCount(string address, string xTestnetType = default(string))
        {
            var localVarResponse = EthGetTransactionCountWithHttpInfo(address, xTestnetType);

            var exception = ExceptionFactory?.Invoke("EthGetTransactionCount", localVarResponse);
            if (exception != null) throw exception;

            return localVarResponse.Data;
        }

        /// <summary>
        /// Get count of outgoing Ethereum transactions 1 credit per API call. Get a number of outgoing Ethereum transactions for the address. When a transaction is sent, there can be multiple outgoing transactions, which are not yet processed by the blockchain. To distinguish between them, there is a counter called a nonce, which represents the order of the transaction in the list of outgoing transactions.
        /// </summary>
        /// <exception cref="Tatum.CSharp.Ethereum.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="address">address</param>
        /// <param name="xTestnetType">Type of Ethereum testnet. Defaults to ethereum-sepolia. (optional, default to ethereum-sepolia)</param>
        /// <returns>ApiResponse of decimal</returns>
        public ApiResponse<decimal> EthGetTransactionCountWithHttpInfo(string address, string xTestnetType = default(string))
        {
            // verify the required parameter 'address' is set
            if (address == null)
                throw new ApiException(400, "Missing required parameter 'address' when calling EthereumApi->EthGetTransactionCount");

            var localVarRequestOptions = new RequestOptions();

            var contentTypes = new string[]{
            };

            // to determine the Accept header
            var accepts = new string[]{
                "application/json"
            };

            var localVarContentType = ClientUtils.SelectHeaderContentType(contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = ClientUtils.SelectHeaderAccept(accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.PathParameters.Add("address", ClientUtils.ParameterToString(address)); // path parameter
            if (xTestnetType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("x-testnet-type", ClientUtils.ParameterToString(xTestnetType)); // header parameter
            }

            // authentication (X-API-Key) required
            if (!string.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("x-api-key")))
            {
                localVarRequestOptions.HeaderParameters.Add("x-api-key", Configuration.GetApiKeyWithPrefix("x-api-key"));
            }

            // make the HTTP request
            var localVarResponse = Client.Get<decimal>("/v3/ethereum/transaction/count/{address}", localVarRequestOptions, Configuration);

            return localVarResponse;
        }

        /// <summary>
        /// Get count of outgoing Ethereum transactions 1 credit per API call. Get a number of outgoing Ethereum transactions for the address. When a transaction is sent, there can be multiple outgoing transactions, which are not yet processed by the blockchain. To distinguish between them, there is a counter called a nonce, which represents the order of the transaction in the list of outgoing transactions.
        /// </summary>
        /// <exception cref="Tatum.CSharp.Ethereum.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="address">address</param>
        /// <param name="xTestnetType">Type of Ethereum testnet. Defaults to ethereum-sepolia. (optional, default to ethereum-sepolia)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of decimal</returns>
        public async System.Threading.Tasks.Task<decimal> EthGetTransactionCountAsync(string address, string xTestnetType = default(string), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            var localVarResponse = await EthGetTransactionCountWithHttpInfoAsync(address, xTestnetType, cancellationToken).ConfigureAwait(false);
            
            var exception = ExceptionFactory?.Invoke("EthGetTransactionCount", localVarResponse);
            if (exception != null) throw exception;

            return localVarResponse.Data;
        }

        /// <summary>
        /// Get count of outgoing Ethereum transactions 1 credit per API call. Get a number of outgoing Ethereum transactions for the address. When a transaction is sent, there can be multiple outgoing transactions, which are not yet processed by the blockchain. To distinguish between them, there is a counter called a nonce, which represents the order of the transaction in the list of outgoing transactions.
        /// </summary>
        /// <exception cref="Tatum.CSharp.Ethereum.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="address">address</param>
        /// <param name="xTestnetType">Type of Ethereum testnet. Defaults to ethereum-sepolia. (optional, default to ethereum-sepolia)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (decimal)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<decimal>> EthGetTransactionCountWithHttpInfoAsync(string address, string xTestnetType = default(string), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            // verify the required parameter 'address' is set
            if (address == null)
                throw new ApiException(400, "Missing required parameter 'address' when calling EthereumApi->EthGetTransactionCount");

            var localVarRequestOptions = new RequestOptions();

            var contentTypes = new string[]{
            };

            // to determine the Accept header
            var accepts = new string[]{
                "application/json"
            };


            var localVarContentType = ClientUtils.SelectHeaderContentType(contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = ClientUtils.SelectHeaderAccept(accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.PathParameters.Add("address", ClientUtils.ParameterToString(address)); // path parameter
            if (xTestnetType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("x-testnet-type", ClientUtils.ParameterToString(xTestnetType)); // header parameter
            }

            // authentication (X-API-Key) required
            if (!string.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("x-api-key")))
            {
                localVarRequestOptions.HeaderParameters.Add("x-api-key", Configuration.GetApiKeyWithPrefix("x-api-key"));
            }

            // make the HTTP request

            var localVarResponse = await AsynchronousClient.GetAsync<decimal>("/v3/ethereum/transaction/count/{address}", localVarRequestOptions, Configuration, cancellationToken).ConfigureAwait(false);

            return localVarResponse;
        }

    }
}
