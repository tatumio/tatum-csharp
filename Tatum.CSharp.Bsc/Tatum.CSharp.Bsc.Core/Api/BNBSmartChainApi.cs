/*
 * Tatum API Reference
 *
 * # Welcome to the Tatum API Reference!  ## What is Tatum?  Tatum offers a flexible framework to build, run, and scale blockchain apps fast. To learn more about the Tatum blockchain development framework, visit [our website](https://tatum.io/framework).  The Tatum API features powerful endpoints that simplify a complex blockchain into single API requests. Code for all supported blockchains using unified API calls.  ## Need help?  To chat with other developers, get help from the Support team, and engage with the thriving Tatum community, join  our [Discord server](https://discord.com/invite/tatum). For more information about how to work with Tatum, review the [online documentation](https://docs.tatum.io/).  ## About this API Reference  The Tatum API Reference is based on OpenAPI Specification v3.1.0 with a few [vendor extensions](https://github.com/Redocly/redoc/blob/master/docs/redoc-vendor-extensions.md) applied.  # Authentication  When using the Tatum API, you authenticate yourself with an **API key**. <SecurityDefinitions /> 
 *
 * The version of the OpenAPI document: 3.17.0
 * Generated by: https://github.com/openapitools/openapi-generator.git
 */


using System;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.Linq;
using System.Net;
using System.Net.Http;
using System.Net.Mime;
using Tatum.CSharp.Bsc.Core.Client;
using Tatum.CSharp.Bsc.Core.Model;

namespace Tatum.CSharp.Bsc.Core.Api
{

    /// <summary>
    /// Represents a collection of functions to interact with the API endpoints
    /// </summary>
    public interface IBNBSmartChainApiSync : IApiAccessor
    {
        #region Synchronous Operations
        /// <summary>
        /// Invoke a method in a smart contract on BNB Smart Chain
        /// </summary>
        /// <remarks>
        /// 2 credits per API call Invoke a method in an existing smart contract on BNB Smart Chain. You can call a read-only or write method. For read-only methods, the output of the invoked method is returned. For write methods, the ID of the associated transaction is returned. Signing a transaction When invoking a method in a smart contract, you are charged a fee for the transaction, and you must sign the transaction with the private key of the blockchain address from which the fee will be deducted. Providing the private key in the API is not a secure way of signing transactions, because the private key can be stolen or exposed. Your private keys should never leave your security perimeter. You should use the private keys only for testing a solution you are building on the testnet of a blockchain. For signing transactions on the mainnet, we strongly recommend that you use the Tatum Key Management System (KMS) and provide the signature ID instead of the private key in the API. Alternatively, you can use the Tatum JavaScript client.
        /// </remarks>
        /// <exception cref="Tatum.CSharp.Bsc.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="callBscSmartContractReadMethod"></param>
        /// <returns>Data</returns>
        Data BscBlockchainSmartContractInvocation(CallBscSmartContractReadMethod callBscSmartContractReadMethod);
        /// <summary>
        /// Invoke a method in a smart contract on BNB Smart Chain
        /// </summary>
        /// <remarks>
        /// 2 credits per API call Invoke a method in an existing smart contract on BNB Smart Chain. You can call a read-only or write method. For read-only methods, the output of the invoked method is returned. For write methods, the ID of the associated transaction is returned. Signing a transaction When invoking a method in a smart contract, you are charged a fee for the transaction, and you must sign the transaction with the private key of the blockchain address from which the fee will be deducted. Providing the private key in the API is not a secure way of signing transactions, because the private key can be stolen or exposed. Your private keys should never leave your security perimeter. You should use the private keys only for testing a solution you are building on the testnet of a blockchain. For signing transactions on the mainnet, we strongly recommend that you use the Tatum Key Management System (KMS) and provide the signature ID instead of the private key in the API. Alternatively, you can use the Tatum JavaScript client.
        /// </remarks>
        /// <exception cref="Tatum.CSharp.Bsc.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="callBscSmartContractMethod"></param>
        /// <returns>TransactionHash</returns>
        TransactionHash BscBlockchainSmartContractInvocation(CallBscSmartContractMethod callBscSmartContractMethod);
        /// <summary>
        /// Invoke a method in a smart contract on BNB Smart Chain
        /// </summary>
        /// <remarks>
        /// 2 credits per API call Invoke a method in an existing smart contract on BNB Smart Chain. You can call a read-only or write method. For read-only methods, the output of the invoked method is returned. For write methods, the ID of the associated transaction is returned. Signing a transaction When invoking a method in a smart contract, you are charged a fee for the transaction, and you must sign the transaction with the private key of the blockchain address from which the fee will be deducted. Providing the private key in the API is not a secure way of signing transactions, because the private key can be stolen or exposed. Your private keys should never leave your security perimeter. You should use the private keys only for testing a solution you are building on the testnet of a blockchain. For signing transactions on the mainnet, we strongly recommend that you use the Tatum Key Management System (KMS) and provide the signature ID instead of the private key in the API. Alternatively, you can use the Tatum JavaScript client.
        /// </remarks>
        /// <exception cref="Tatum.CSharp.Bsc.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="callBscSmartContractMethodKMS"></param>
        /// <returns>SignatureId</returns>
        SignatureId BscBlockchainSmartContractInvocation(CallBscSmartContractMethodKMS callBscSmartContractMethodKMS);
        /// <summary>
        /// Send BSC / BEP20 from account to account
        /// </summary>
        /// <remarks>
        /// 2 credits per API call Send BNB or Tatum supported BEP20 token from account to account. Signing a transaction When sending BNB, you are charged a fee for the transaction, and you must sign the transaction with the private key of the blockchain address from which the fee will be deducted. Providing the private key in the API is not a secure way of signing transactions, because the private key can be stolen or exposed. Your private keys should never leave your security perimeter. You should use the private keys only for testing a solution you are building on the testnet of a blockchain. For signing transactions on the mainnet, we strongly recommend that you use the Tatum Key Management System (KMS) and provide the signature ID instead of the private key in the API. Alternatively, you can use the Tatum JavaScript client.
        /// </remarks>
        /// <exception cref="Tatum.CSharp.Bsc.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="transferBscBlockchain"></param>
        /// <returns>TransactionHash</returns>
        TransactionHash BscBlockchainTransfer(TransferBscBlockchain transferBscBlockchain);
        /// <summary>
        /// Send BSC / BEP20 from account to account
        /// </summary>
        /// <remarks>
        /// 2 credits per API call Send BNB or Tatum supported BEP20 token from account to account. Signing a transaction When sending BNB, you are charged a fee for the transaction, and you must sign the transaction with the private key of the blockchain address from which the fee will be deducted. Providing the private key in the API is not a secure way of signing transactions, because the private key can be stolen or exposed. Your private keys should never leave your security perimeter. You should use the private keys only for testing a solution you are building on the testnet of a blockchain. For signing transactions on the mainnet, we strongly recommend that you use the Tatum Key Management System (KMS) and provide the signature ID instead of the private key in the API. Alternatively, you can use the Tatum JavaScript client.
        /// </remarks>
        /// <exception cref="Tatum.CSharp.Bsc.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="transferBscBlockchainKMS"></param>
        /// <returns>SignatureId</returns>
        SignatureId BscBlockchainTransfer(TransferBscBlockchainKMS transferBscBlockchainKMS);
        /// <summary>
        /// Broadcast signed BSC transaction
        /// </summary>
        /// <remarks>
        /// 2 credits per API call Broadcast signed transaction to BSC blockchain. This method is used internally from Tatum KMS or Tatum client libraries. It is possible to create custom signing mechanism and use this method only for broadcasting data to the blockchain.
        /// </remarks>
        /// <exception cref="Tatum.CSharp.Bsc.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="broadcastKMS"></param>
        /// <returns>TransactionHash</returns>
        TransactionHash BscBroadcast(BroadcastKMS broadcastKMS);
        /// <summary>
        /// Generate BSC account address from Extended public key
        /// </summary>
        /// <remarks>
        /// 1 credit per API call Generate BSC account deposit address from Extended public key. Deposit address is generated for the specific index - each extended public key can generate up to 2^31 addresses starting from index 0 until 2^31.
        /// </remarks>
        /// <exception cref="Tatum.CSharp.Bsc.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="xpub">Extended public key of wallet.</param>
        /// <param name="index">Derivation index of desired address to be generated.</param>
        /// <returns>GeneratedAddressBsc</returns>
        GeneratedAddressBsc BscGenerateAddress(string xpub, decimal index);
        /// <summary>
        /// Generate BSC private key
        /// </summary>
        /// <remarks>
        /// 1 credit per API call Generate private key of address from mnemonic for given derivation path index. Private key is generated for the specific index - each mnemonic can generate up to 2^31 private keys starting from index 0 until 2^31.
        /// </remarks>
        /// <exception cref="Tatum.CSharp.Bsc.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="privKeyRequest"></param>
        /// <returns>PrivKey</returns>
        PrivKey BscGenerateAddressPrivateKey(PrivKeyRequest privKeyRequest);
        /// <summary>
        /// Generate BSC wallet
        /// </summary>
        /// <remarks>
        /// 1 credit per API call Tatum supports BIP44 HD wallets. It is very convenient and secure, since it can generate 2^31 addresses from 1 mnemonic phrase. Mnemonic phrase consists of 24 special words in defined order and can restore access to all generated addresses and private keys. Each address is identified by 3 main values: Private Key - your secret value, which should never be revealed Public Key - public address to be published Derivation index - index of generated address Tatum follows BIP44 specification and generates for BSC wallet with derivation path m&#39;/44&#39;/60&#39;/0&#39;/0. More about BIP44 HD wallets can be found here - https://github.com/bitcoin/bips/blob/master/bip-0044.mediawiki. Generate BIP44 compatible BSC wallet.
        /// </remarks>
        /// <exception cref="Tatum.CSharp.Bsc.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="mnemonic">Mnemonic to use for generation of extended public and private keys. (optional)</param>
        /// <returns>Wallet</returns>
        Wallet BscGenerateWallet(string mnemonic = default(string));
        /// <summary>
        /// Get BSC Account balance
        /// </summary>
        /// <remarks>
        /// 1 credit per API call Get BSC account balance in BNB. This method does not prints any balance of the BEP20 or BEP721 tokens on the account.
        /// </remarks>
        /// <exception cref="Tatum.CSharp.Bsc.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="address">Account address you want to get balance of</param>
        /// <returns>BscBalance</returns>
        BscBalance BscGetBalance(string address);
        /// <summary>
        /// Get BSC block by hash
        /// </summary>
        /// <remarks>
        /// 1 credit per API call Get BSC block by block hash or block number.
        /// </remarks>
        /// <exception cref="Tatum.CSharp.Bsc.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="hash">Block hash or block number</param>
        /// <returns>EthBlock</returns>
        EthBlock BscGetBlock(string hash);
        /// <summary>
        /// Get current block number
        /// </summary>
        /// <remarks>
        /// 1 credit per API call Get BSC current block number. This is the number of the latest block in the blockchain.
        /// </remarks>
        /// <exception cref="Tatum.CSharp.Bsc.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <returns>decimal</returns>
        decimal BscGetCurrentBlock();
        /// <summary>
        /// Get BSC Transaction
        /// </summary>
        /// <remarks>
        /// 2 credits per API call Get BSC transaction by transaction hash.
        /// </remarks>
        /// <exception cref="Tatum.CSharp.Bsc.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="hash">Transaction hash</param>
        /// <returns>BscTx</returns>
        BscTx BscGetTransaction(string hash);
        /// <summary>
        /// Get count of outgoing BSC transactions
        /// </summary>
        /// <remarks>
        /// 1 credit per API call Get a number of outgoing BSC transactions for the address. When a transaction is sent, there can be multiple outgoing transactions, which are not yet processed by the blockchain. To distinguish between them, there is a counter called a nonce, which represents the order of the transaction in the list of outgoing transactions.
        /// </remarks>
        /// <exception cref="Tatum.CSharp.Bsc.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="address">address</param>
        /// <returns>decimal</returns>
        decimal BscGetTransactionCount(string address);
        #endregion Synchronous Operations
    }

    /// <summary>
    /// Represents a collection of functions to interact with the API endpoints
    /// </summary>
    public interface IBNBSmartChainApiWithHttpInfoSync : IApiAccessor
    {
        #region Synchronous Operations With Http Info
        /// <summary>
        /// Invoke a method in a smart contract on BNB Smart Chain
        /// </summary>
        /// <remarks>
        /// 2 credits per API call Invoke a method in an existing smart contract on BNB Smart Chain. You can call a read-only or write method. For read-only methods, the output of the invoked method is returned. For write methods, the ID of the associated transaction is returned. Signing a transaction When invoking a method in a smart contract, you are charged a fee for the transaction, and you must sign the transaction with the private key of the blockchain address from which the fee will be deducted. Providing the private key in the API is not a secure way of signing transactions, because the private key can be stolen or exposed. Your private keys should never leave your security perimeter. You should use the private keys only for testing a solution you are building on the testnet of a blockchain. For signing transactions on the mainnet, we strongly recommend that you use the Tatum Key Management System (KMS) and provide the signature ID instead of the private key in the API. Alternatively, you can use the Tatum JavaScript client.
        /// </remarks>
        /// <exception cref="Tatum.CSharp.Bsc.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="callBscSmartContractReadMethod"></param>
        /// <returns>ApiResponse of Data</returns>
        ApiResponse<Data> BscBlockchainSmartContractInvocationWithHttpInfo(CallBscSmartContractReadMethod callBscSmartContractReadMethod);
        /// <summary>
        /// Invoke a method in a smart contract on BNB Smart Chain
        /// </summary>
        /// <remarks>
        /// 2 credits per API call Invoke a method in an existing smart contract on BNB Smart Chain. You can call a read-only or write method. For read-only methods, the output of the invoked method is returned. For write methods, the ID of the associated transaction is returned. Signing a transaction When invoking a method in a smart contract, you are charged a fee for the transaction, and you must sign the transaction with the private key of the blockchain address from which the fee will be deducted. Providing the private key in the API is not a secure way of signing transactions, because the private key can be stolen or exposed. Your private keys should never leave your security perimeter. You should use the private keys only for testing a solution you are building on the testnet of a blockchain. For signing transactions on the mainnet, we strongly recommend that you use the Tatum Key Management System (KMS) and provide the signature ID instead of the private key in the API. Alternatively, you can use the Tatum JavaScript client.
        /// </remarks>
        /// <exception cref="Tatum.CSharp.Bsc.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="callBscSmartContractMethod"></param>
        /// <returns>ApiResponse of TransactionHash</returns>
        ApiResponse<TransactionHash> BscBlockchainSmartContractInvocationWithHttpInfo(CallBscSmartContractMethod callBscSmartContractMethod);
        /// <summary>
        /// Invoke a method in a smart contract on BNB Smart Chain
        /// </summary>
        /// <remarks>
        /// 2 credits per API call Invoke a method in an existing smart contract on BNB Smart Chain. You can call a read-only or write method. For read-only methods, the output of the invoked method is returned. For write methods, the ID of the associated transaction is returned. Signing a transaction When invoking a method in a smart contract, you are charged a fee for the transaction, and you must sign the transaction with the private key of the blockchain address from which the fee will be deducted. Providing the private key in the API is not a secure way of signing transactions, because the private key can be stolen or exposed. Your private keys should never leave your security perimeter. You should use the private keys only for testing a solution you are building on the testnet of a blockchain. For signing transactions on the mainnet, we strongly recommend that you use the Tatum Key Management System (KMS) and provide the signature ID instead of the private key in the API. Alternatively, you can use the Tatum JavaScript client.
        /// </remarks>
        /// <exception cref="Tatum.CSharp.Bsc.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="callBscSmartContractMethodKMS"></param>
        /// <returns>ApiResponse of SignatureId</returns>
        ApiResponse<SignatureId> BscBlockchainSmartContractInvocationWithHttpInfo(CallBscSmartContractMethodKMS callBscSmartContractMethodKMS);
        /// <summary>
        /// Send BSC / BEP20 from account to account
        /// </summary>
        /// <remarks>
        /// 2 credits per API call Send BNB or Tatum supported BEP20 token from account to account. Signing a transaction When sending BNB, you are charged a fee for the transaction, and you must sign the transaction with the private key of the blockchain address from which the fee will be deducted. Providing the private key in the API is not a secure way of signing transactions, because the private key can be stolen or exposed. Your private keys should never leave your security perimeter. You should use the private keys only for testing a solution you are building on the testnet of a blockchain. For signing transactions on the mainnet, we strongly recommend that you use the Tatum Key Management System (KMS) and provide the signature ID instead of the private key in the API. Alternatively, you can use the Tatum JavaScript client.
        /// </remarks>
        /// <exception cref="Tatum.CSharp.Bsc.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="transferBscBlockchain"></param>
        /// <returns>ApiResponse of TransactionHash</returns>
        ApiResponse<TransactionHash> BscBlockchainTransferWithHttpInfo(TransferBscBlockchain transferBscBlockchain);
        /// <summary>
        /// Send BSC / BEP20 from account to account
        /// </summary>
        /// <remarks>
        /// 2 credits per API call Send BNB or Tatum supported BEP20 token from account to account. Signing a transaction When sending BNB, you are charged a fee for the transaction, and you must sign the transaction with the private key of the blockchain address from which the fee will be deducted. Providing the private key in the API is not a secure way of signing transactions, because the private key can be stolen or exposed. Your private keys should never leave your security perimeter. You should use the private keys only for testing a solution you are building on the testnet of a blockchain. For signing transactions on the mainnet, we strongly recommend that you use the Tatum Key Management System (KMS) and provide the signature ID instead of the private key in the API. Alternatively, you can use the Tatum JavaScript client.
        /// </remarks>
        /// <exception cref="Tatum.CSharp.Bsc.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="transferBscBlockchainKMS"></param>
        /// <returns>ApiResponse of SignatureId</returns>
        ApiResponse<SignatureId> BscBlockchainTransferWithHttpInfo(TransferBscBlockchainKMS transferBscBlockchainKMS);
        /// <summary>
        /// Broadcast signed BSC transaction
        /// </summary>
        /// <remarks>
        /// 2 credits per API call Broadcast signed transaction to BSC blockchain. This method is used internally from Tatum KMS or Tatum client libraries. It is possible to create custom signing mechanism and use this method only for broadcasting data to the blockchain.
        /// </remarks>
        /// <exception cref="Tatum.CSharp.Bsc.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="broadcastKMS"></param>
        /// <returns>ApiResponse of TransactionHash</returns>
        ApiResponse<TransactionHash> BscBroadcastWithHttpInfo(BroadcastKMS broadcastKMS);
        /// <summary>
        /// Generate BSC account address from Extended public key
        /// </summary>
        /// <remarks>
        /// 1 credit per API call Generate BSC account deposit address from Extended public key. Deposit address is generated for the specific index - each extended public key can generate up to 2^31 addresses starting from index 0 until 2^31.
        /// </remarks>
        /// <exception cref="Tatum.CSharp.Bsc.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="xpub">Extended public key of wallet.</param>
        /// <param name="index">Derivation index of desired address to be generated.</param>
        /// <returns>ApiResponse of GeneratedAddressBsc</returns>
        ApiResponse<GeneratedAddressBsc> BscGenerateAddressWithHttpInfo(string xpub, decimal index);
        /// <summary>
        /// Generate BSC private key
        /// </summary>
        /// <remarks>
        /// 1 credit per API call Generate private key of address from mnemonic for given derivation path index. Private key is generated for the specific index - each mnemonic can generate up to 2^31 private keys starting from index 0 until 2^31.
        /// </remarks>
        /// <exception cref="Tatum.CSharp.Bsc.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="privKeyRequest"></param>
        /// <returns>ApiResponse of PrivKey</returns>
        ApiResponse<PrivKey> BscGenerateAddressPrivateKeyWithHttpInfo(PrivKeyRequest privKeyRequest);
        /// <summary>
        /// Generate BSC wallet
        /// </summary>
        /// <remarks>
        /// 1 credit per API call Tatum supports BIP44 HD wallets. It is very convenient and secure, since it can generate 2^31 addresses from 1 mnemonic phrase. Mnemonic phrase consists of 24 special words in defined order and can restore access to all generated addresses and private keys. Each address is identified by 3 main values: Private Key - your secret value, which should never be revealed Public Key - public address to be published Derivation index - index of generated address Tatum follows BIP44 specification and generates for BSC wallet with derivation path m&#39;/44&#39;/60&#39;/0&#39;/0. More about BIP44 HD wallets can be found here - https://github.com/bitcoin/bips/blob/master/bip-0044.mediawiki. Generate BIP44 compatible BSC wallet.
        /// </remarks>
        /// <exception cref="Tatum.CSharp.Bsc.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="mnemonic">Mnemonic to use for generation of extended public and private keys. (optional)</param>
        /// <returns>ApiResponse of Wallet</returns>
        ApiResponse<Wallet> BscGenerateWalletWithHttpInfo(string mnemonic = default(string));
        /// <summary>
        /// Get BSC Account balance
        /// </summary>
        /// <remarks>
        /// 1 credit per API call Get BSC account balance in BNB. This method does not prints any balance of the BEP20 or BEP721 tokens on the account.
        /// </remarks>
        /// <exception cref="Tatum.CSharp.Bsc.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="address">Account address you want to get balance of</param>
        /// <returns>ApiResponse of BscBalance</returns>
        ApiResponse<BscBalance> BscGetBalanceWithHttpInfo(string address);
        /// <summary>
        /// Get BSC block by hash
        /// </summary>
        /// <remarks>
        /// 1 credit per API call Get BSC block by block hash or block number.
        /// </remarks>
        /// <exception cref="Tatum.CSharp.Bsc.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="hash">Block hash or block number</param>
        /// <returns>ApiResponse of EthBlock</returns>
        ApiResponse<EthBlock> BscGetBlockWithHttpInfo(string hash);
        /// <summary>
        /// Get current block number
        /// </summary>
        /// <remarks>
        /// 1 credit per API call Get BSC current block number. This is the number of the latest block in the blockchain.
        /// </remarks>
        /// <exception cref="Tatum.CSharp.Bsc.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <returns>ApiResponse of decimal</returns>
        ApiResponse<decimal> BscGetCurrentBlockWithHttpInfo();
        /// <summary>
        /// Get BSC Transaction
        /// </summary>
        /// <remarks>
        /// 2 credits per API call Get BSC transaction by transaction hash.
        /// </remarks>
        /// <exception cref="Tatum.CSharp.Bsc.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="hash">Transaction hash</param>
        /// <returns>ApiResponse of BscTx</returns>
        ApiResponse<BscTx> BscGetTransactionWithHttpInfo(string hash);
        /// <summary>
        /// Get count of outgoing BSC transactions
        /// </summary>
        /// <remarks>
        /// 1 credit per API call Get a number of outgoing BSC transactions for the address. When a transaction is sent, there can be multiple outgoing transactions, which are not yet processed by the blockchain. To distinguish between them, there is a counter called a nonce, which represents the order of the transaction in the list of outgoing transactions.
        /// </remarks>
        /// <exception cref="Tatum.CSharp.Bsc.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="address">address</param>
        /// <returns>ApiResponse of decimal</returns>
        ApiResponse<decimal> BscGetTransactionCountWithHttpInfo(string address);
        #endregion Synchronous Operations With Http Info
    }

    /// <summary>
    /// Represents a collection of functions to interact with the API endpoints
    /// </summary>
    public interface IBNBSmartChainApiAsync : IApiAccessor
    {
        #region Asynchronous Operations
        /// <summary>
        /// Invoke a method in a smart contract on BNB Smart Chain
        /// </summary>
        /// <remarks>
        /// 2 credits per API call Invoke a method in an existing smart contract on BNB Smart Chain. You can call a read-only or write method. For read-only methods, the output of the invoked method is returned. For write methods, the ID of the associated transaction is returned. Signing a transaction When invoking a method in a smart contract, you are charged a fee for the transaction, and you must sign the transaction with the private key of the blockchain address from which the fee will be deducted. Providing the private key in the API is not a secure way of signing transactions, because the private key can be stolen or exposed. Your private keys should never leave your security perimeter. You should use the private keys only for testing a solution you are building on the testnet of a blockchain. For signing transactions on the mainnet, we strongly recommend that you use the Tatum Key Management System (KMS) and provide the signature ID instead of the private key in the API. Alternatively, you can use the Tatum JavaScript client.
        /// </remarks>
        /// <exception cref="Tatum.CSharp.Bsc.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="callBscSmartContractReadMethod"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of Data</returns>
        System.Threading.Tasks.Task<Data> BscBlockchainSmartContractInvocationAsync(CallBscSmartContractReadMethod callBscSmartContractReadMethod, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        /// <summary>
        /// Invoke a method in a smart contract on BNB Smart Chain
        /// </summary>
        /// <remarks>
        /// 2 credits per API call Invoke a method in an existing smart contract on BNB Smart Chain. You can call a read-only or write method. For read-only methods, the output of the invoked method is returned. For write methods, the ID of the associated transaction is returned. Signing a transaction When invoking a method in a smart contract, you are charged a fee for the transaction, and you must sign the transaction with the private key of the blockchain address from which the fee will be deducted. Providing the private key in the API is not a secure way of signing transactions, because the private key can be stolen or exposed. Your private keys should never leave your security perimeter. You should use the private keys only for testing a solution you are building on the testnet of a blockchain. For signing transactions on the mainnet, we strongly recommend that you use the Tatum Key Management System (KMS) and provide the signature ID instead of the private key in the API. Alternatively, you can use the Tatum JavaScript client.
        /// </remarks>
        /// <exception cref="Tatum.CSharp.Bsc.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="callBscSmartContractMethod"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of TransactionHash</returns>
        System.Threading.Tasks.Task<TransactionHash> BscBlockchainSmartContractInvocationAsync(CallBscSmartContractMethod callBscSmartContractMethod, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        /// <summary>
        /// Invoke a method in a smart contract on BNB Smart Chain
        /// </summary>
        /// <remarks>
        /// 2 credits per API call Invoke a method in an existing smart contract on BNB Smart Chain. You can call a read-only or write method. For read-only methods, the output of the invoked method is returned. For write methods, the ID of the associated transaction is returned. Signing a transaction When invoking a method in a smart contract, you are charged a fee for the transaction, and you must sign the transaction with the private key of the blockchain address from which the fee will be deducted. Providing the private key in the API is not a secure way of signing transactions, because the private key can be stolen or exposed. Your private keys should never leave your security perimeter. You should use the private keys only for testing a solution you are building on the testnet of a blockchain. For signing transactions on the mainnet, we strongly recommend that you use the Tatum Key Management System (KMS) and provide the signature ID instead of the private key in the API. Alternatively, you can use the Tatum JavaScript client.
        /// </remarks>
        /// <exception cref="Tatum.CSharp.Bsc.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="callBscSmartContractMethodKMS"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of SignatureId</returns>
        System.Threading.Tasks.Task<SignatureId> BscBlockchainSmartContractInvocationAsync(CallBscSmartContractMethodKMS callBscSmartContractMethodKMS, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        /// <summary>
        /// Send BSC / BEP20 from account to account
        /// </summary>
        /// <remarks>
        /// 2 credits per API call Send BNB or Tatum supported BEP20 token from account to account. Signing a transaction When sending BNB, you are charged a fee for the transaction, and you must sign the transaction with the private key of the blockchain address from which the fee will be deducted. Providing the private key in the API is not a secure way of signing transactions, because the private key can be stolen or exposed. Your private keys should never leave your security perimeter. You should use the private keys only for testing a solution you are building on the testnet of a blockchain. For signing transactions on the mainnet, we strongly recommend that you use the Tatum Key Management System (KMS) and provide the signature ID instead of the private key in the API. Alternatively, you can use the Tatum JavaScript client.
        /// </remarks>
        /// <exception cref="Tatum.CSharp.Bsc.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="transferBscBlockchain"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of TransactionHash</returns>
        System.Threading.Tasks.Task<TransactionHash> BscBlockchainTransferAsync(TransferBscBlockchain transferBscBlockchain, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        /// <summary>
        /// Send BSC / BEP20 from account to account
        /// </summary>
        /// <remarks>
        /// 2 credits per API call Send BNB or Tatum supported BEP20 token from account to account. Signing a transaction When sending BNB, you are charged a fee for the transaction, and you must sign the transaction with the private key of the blockchain address from which the fee will be deducted. Providing the private key in the API is not a secure way of signing transactions, because the private key can be stolen or exposed. Your private keys should never leave your security perimeter. You should use the private keys only for testing a solution you are building on the testnet of a blockchain. For signing transactions on the mainnet, we strongly recommend that you use the Tatum Key Management System (KMS) and provide the signature ID instead of the private key in the API. Alternatively, you can use the Tatum JavaScript client.
        /// </remarks>
        /// <exception cref="Tatum.CSharp.Bsc.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="transferBscBlockchainKMS"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of SignatureId</returns>
        System.Threading.Tasks.Task<SignatureId> BscBlockchainTransferAsync(TransferBscBlockchainKMS transferBscBlockchainKMS, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        /// <summary>
        /// Broadcast signed BSC transaction
        /// </summary>
        /// <remarks>
        /// 2 credits per API call Broadcast signed transaction to BSC blockchain. This method is used internally from Tatum KMS or Tatum client libraries. It is possible to create custom signing mechanism and use this method only for broadcasting data to the blockchain.
        /// </remarks>
        /// <exception cref="Tatum.CSharp.Bsc.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="broadcastKMS"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of TransactionHash</returns>
        System.Threading.Tasks.Task<TransactionHash> BscBroadcastAsync(BroadcastKMS broadcastKMS, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        /// <summary>
        /// Generate BSC account address from Extended public key
        /// </summary>
        /// <remarks>
        /// 1 credit per API call Generate BSC account deposit address from Extended public key. Deposit address is generated for the specific index - each extended public key can generate up to 2^31 addresses starting from index 0 until 2^31.
        /// </remarks>
        /// <exception cref="Tatum.CSharp.Bsc.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="xpub">Extended public key of wallet.</param>
        /// <param name="index">Derivation index of desired address to be generated.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of GeneratedAddressBsc</returns>
        System.Threading.Tasks.Task<GeneratedAddressBsc> BscGenerateAddressAsync(string xpub, decimal index, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        /// <summary>
        /// Generate BSC private key
        /// </summary>
        /// <remarks>
        /// 1 credit per API call Generate private key of address from mnemonic for given derivation path index. Private key is generated for the specific index - each mnemonic can generate up to 2^31 private keys starting from index 0 until 2^31.
        /// </remarks>
        /// <exception cref="Tatum.CSharp.Bsc.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="privKeyRequest"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of PrivKey</returns>
        System.Threading.Tasks.Task<PrivKey> BscGenerateAddressPrivateKeyAsync(PrivKeyRequest privKeyRequest, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        /// <summary>
        /// Generate BSC wallet
        /// </summary>
        /// <remarks>
        /// 1 credit per API call Tatum supports BIP44 HD wallets. It is very convenient and secure, since it can generate 2^31 addresses from 1 mnemonic phrase. Mnemonic phrase consists of 24 special words in defined order and can restore access to all generated addresses and private keys. Each address is identified by 3 main values: Private Key - your secret value, which should never be revealed Public Key - public address to be published Derivation index - index of generated address Tatum follows BIP44 specification and generates for BSC wallet with derivation path m&#39;/44&#39;/60&#39;/0&#39;/0. More about BIP44 HD wallets can be found here - https://github.com/bitcoin/bips/blob/master/bip-0044.mediawiki. Generate BIP44 compatible BSC wallet.
        /// </remarks>
        /// <exception cref="Tatum.CSharp.Bsc.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="mnemonic">Mnemonic to use for generation of extended public and private keys. (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of Wallet</returns>
        System.Threading.Tasks.Task<Wallet> BscGenerateWalletAsync(string mnemonic = default(string), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        /// <summary>
        /// Get BSC Account balance
        /// </summary>
        /// <remarks>
        /// 1 credit per API call Get BSC account balance in BNB. This method does not prints any balance of the BEP20 or BEP721 tokens on the account.
        /// </remarks>
        /// <exception cref="Tatum.CSharp.Bsc.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="address">Account address you want to get balance of</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of BscBalance</returns>
        System.Threading.Tasks.Task<BscBalance> BscGetBalanceAsync(string address, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        /// <summary>
        /// Get BSC block by hash
        /// </summary>
        /// <remarks>
        /// 1 credit per API call Get BSC block by block hash or block number.
        /// </remarks>
        /// <exception cref="Tatum.CSharp.Bsc.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="hash">Block hash or block number</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of EthBlock</returns>
        System.Threading.Tasks.Task<EthBlock> BscGetBlockAsync(string hash, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        /// <summary>
        /// Get current block number
        /// </summary>
        /// <remarks>
        /// 1 credit per API call Get BSC current block number. This is the number of the latest block in the blockchain.
        /// </remarks>
        /// <exception cref="Tatum.CSharp.Bsc.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of decimal</returns>
        System.Threading.Tasks.Task<decimal> BscGetCurrentBlockAsync(System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        /// <summary>
        /// Get BSC Transaction
        /// </summary>
        /// <remarks>
        /// 2 credits per API call Get BSC transaction by transaction hash.
        /// </remarks>
        /// <exception cref="Tatum.CSharp.Bsc.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="hash">Transaction hash</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of BscTx</returns>
        System.Threading.Tasks.Task<BscTx> BscGetTransactionAsync(string hash, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        /// <summary>
        /// Get count of outgoing BSC transactions
        /// </summary>
        /// <remarks>
        /// 1 credit per API call Get a number of outgoing BSC transactions for the address. When a transaction is sent, there can be multiple outgoing transactions, which are not yet processed by the blockchain. To distinguish between them, there is a counter called a nonce, which represents the order of the transaction in the list of outgoing transactions.
        /// </remarks>
        /// <exception cref="Tatum.CSharp.Bsc.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="address">address</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of decimal</returns>
        System.Threading.Tasks.Task<decimal> BscGetTransactionCountAsync(string address, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        #endregion Asynchronous Operations
    }

    /// <summary>
    /// Represents a collection of functions to interact with the API endpoints
    /// </summary>
    public interface IBNBSmartChainApiWithHttpInfoAsync : IApiAccessor
    {
        #region Asynchronous Operations With Http Info
        /// <summary>
        /// Invoke a method in a smart contract on BNB Smart Chain
        /// </summary>
        /// <remarks>
        /// 2 credits per API call Invoke a method in an existing smart contract on BNB Smart Chain. You can call a read-only or write method. For read-only methods, the output of the invoked method is returned. For write methods, the ID of the associated transaction is returned. Signing a transaction When invoking a method in a smart contract, you are charged a fee for the transaction, and you must sign the transaction with the private key of the blockchain address from which the fee will be deducted. Providing the private key in the API is not a secure way of signing transactions, because the private key can be stolen or exposed. Your private keys should never leave your security perimeter. You should use the private keys only for testing a solution you are building on the testnet of a blockchain. For signing transactions on the mainnet, we strongly recommend that you use the Tatum Key Management System (KMS) and provide the signature ID instead of the private key in the API. Alternatively, you can use the Tatum JavaScript client.
        /// </remarks>
        /// <exception cref="Tatum.CSharp.Bsc.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="callBscSmartContractReadMethod"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (Data)</returns>
        System.Threading.Tasks.Task<ApiResponse<Data>> BscBlockchainSmartContractInvocationWithHttpInfoAsync(CallBscSmartContractReadMethod callBscSmartContractReadMethod, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        /// <summary>
        /// Invoke a method in a smart contract on BNB Smart Chain
        /// </summary>
        /// <remarks>
        /// 2 credits per API call Invoke a method in an existing smart contract on BNB Smart Chain. You can call a read-only or write method. For read-only methods, the output of the invoked method is returned. For write methods, the ID of the associated transaction is returned. Signing a transaction When invoking a method in a smart contract, you are charged a fee for the transaction, and you must sign the transaction with the private key of the blockchain address from which the fee will be deducted. Providing the private key in the API is not a secure way of signing transactions, because the private key can be stolen or exposed. Your private keys should never leave your security perimeter. You should use the private keys only for testing a solution you are building on the testnet of a blockchain. For signing transactions on the mainnet, we strongly recommend that you use the Tatum Key Management System (KMS) and provide the signature ID instead of the private key in the API. Alternatively, you can use the Tatum JavaScript client.
        /// </remarks>
        /// <exception cref="Tatum.CSharp.Bsc.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="callBscSmartContractMethod"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (TransactionHash)</returns>
        System.Threading.Tasks.Task<ApiResponse<TransactionHash>> BscBlockchainSmartContractInvocationWithHttpInfoAsync(CallBscSmartContractMethod callBscSmartContractMethod, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        /// <summary>
        /// Invoke a method in a smart contract on BNB Smart Chain
        /// </summary>
        /// <remarks>
        /// 2 credits per API call Invoke a method in an existing smart contract on BNB Smart Chain. You can call a read-only or write method. For read-only methods, the output of the invoked method is returned. For write methods, the ID of the associated transaction is returned. Signing a transaction When invoking a method in a smart contract, you are charged a fee for the transaction, and you must sign the transaction with the private key of the blockchain address from which the fee will be deducted. Providing the private key in the API is not a secure way of signing transactions, because the private key can be stolen or exposed. Your private keys should never leave your security perimeter. You should use the private keys only for testing a solution you are building on the testnet of a blockchain. For signing transactions on the mainnet, we strongly recommend that you use the Tatum Key Management System (KMS) and provide the signature ID instead of the private key in the API. Alternatively, you can use the Tatum JavaScript client.
        /// </remarks>
        /// <exception cref="Tatum.CSharp.Bsc.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="callBscSmartContractMethodKMS"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (SignatureId)</returns>
        System.Threading.Tasks.Task<ApiResponse<SignatureId>> BscBlockchainSmartContractInvocationWithHttpInfoAsync(CallBscSmartContractMethodKMS callBscSmartContractMethodKMS, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        /// <summary>
        /// Send BSC / BEP20 from account to account
        /// </summary>
        /// <remarks>
        /// 2 credits per API call Send BNB or Tatum supported BEP20 token from account to account. Signing a transaction When sending BNB, you are charged a fee for the transaction, and you must sign the transaction with the private key of the blockchain address from which the fee will be deducted. Providing the private key in the API is not a secure way of signing transactions, because the private key can be stolen or exposed. Your private keys should never leave your security perimeter. You should use the private keys only for testing a solution you are building on the testnet of a blockchain. For signing transactions on the mainnet, we strongly recommend that you use the Tatum Key Management System (KMS) and provide the signature ID instead of the private key in the API. Alternatively, you can use the Tatum JavaScript client.
        /// </remarks>
        /// <exception cref="Tatum.CSharp.Bsc.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="transferBscBlockchain"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (TransactionHash)</returns>
        System.Threading.Tasks.Task<ApiResponse<TransactionHash>> BscBlockchainTransferWithHttpInfoAsync(TransferBscBlockchain transferBscBlockchain, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        /// <summary>
        /// Send BSC / BEP20 from account to account
        /// </summary>
        /// <remarks>
        /// 2 credits per API call Send BNB or Tatum supported BEP20 token from account to account. Signing a transaction When sending BNB, you are charged a fee for the transaction, and you must sign the transaction with the private key of the blockchain address from which the fee will be deducted. Providing the private key in the API is not a secure way of signing transactions, because the private key can be stolen or exposed. Your private keys should never leave your security perimeter. You should use the private keys only for testing a solution you are building on the testnet of a blockchain. For signing transactions on the mainnet, we strongly recommend that you use the Tatum Key Management System (KMS) and provide the signature ID instead of the private key in the API. Alternatively, you can use the Tatum JavaScript client.
        /// </remarks>
        /// <exception cref="Tatum.CSharp.Bsc.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="transferBscBlockchainKMS"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (SignatureId)</returns>
        System.Threading.Tasks.Task<ApiResponse<SignatureId>> BscBlockchainTransferWithHttpInfoAsync(TransferBscBlockchainKMS transferBscBlockchainKMS, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        /// <summary>
        /// Broadcast signed BSC transaction
        /// </summary>
        /// <remarks>
        /// 2 credits per API call Broadcast signed transaction to BSC blockchain. This method is used internally from Tatum KMS or Tatum client libraries. It is possible to create custom signing mechanism and use this method only for broadcasting data to the blockchain.
        /// </remarks>
        /// <exception cref="Tatum.CSharp.Bsc.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="broadcastKMS"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (TransactionHash)</returns>
        System.Threading.Tasks.Task<ApiResponse<TransactionHash>> BscBroadcastWithHttpInfoAsync(BroadcastKMS broadcastKMS, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        /// <summary>
        /// Generate BSC account address from Extended public key
        /// </summary>
        /// <remarks>
        /// 1 credit per API call Generate BSC account deposit address from Extended public key. Deposit address is generated for the specific index - each extended public key can generate up to 2^31 addresses starting from index 0 until 2^31.
        /// </remarks>
        /// <exception cref="Tatum.CSharp.Bsc.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="xpub">Extended public key of wallet.</param>
        /// <param name="index">Derivation index of desired address to be generated.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (GeneratedAddressBsc)</returns>
        System.Threading.Tasks.Task<ApiResponse<GeneratedAddressBsc>> BscGenerateAddressWithHttpInfoAsync(string xpub, decimal index, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        /// <summary>
        /// Generate BSC private key
        /// </summary>
        /// <remarks>
        /// 1 credit per API call Generate private key of address from mnemonic for given derivation path index. Private key is generated for the specific index - each mnemonic can generate up to 2^31 private keys starting from index 0 until 2^31.
        /// </remarks>
        /// <exception cref="Tatum.CSharp.Bsc.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="privKeyRequest"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (PrivKey)</returns>
        System.Threading.Tasks.Task<ApiResponse<PrivKey>> BscGenerateAddressPrivateKeyWithHttpInfoAsync(PrivKeyRequest privKeyRequest, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        /// <summary>
        /// Generate BSC wallet
        /// </summary>
        /// <remarks>
        /// 1 credit per API call Tatum supports BIP44 HD wallets. It is very convenient and secure, since it can generate 2^31 addresses from 1 mnemonic phrase. Mnemonic phrase consists of 24 special words in defined order and can restore access to all generated addresses and private keys. Each address is identified by 3 main values: Private Key - your secret value, which should never be revealed Public Key - public address to be published Derivation index - index of generated address Tatum follows BIP44 specification and generates for BSC wallet with derivation path m&#39;/44&#39;/60&#39;/0&#39;/0. More about BIP44 HD wallets can be found here - https://github.com/bitcoin/bips/blob/master/bip-0044.mediawiki. Generate BIP44 compatible BSC wallet.
        /// </remarks>
        /// <exception cref="Tatum.CSharp.Bsc.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="mnemonic">Mnemonic to use for generation of extended public and private keys. (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (Wallet)</returns>
        System.Threading.Tasks.Task<ApiResponse<Wallet>> BscGenerateWalletWithHttpInfoAsync(string mnemonic = default(string), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        /// <summary>
        /// Get BSC Account balance
        /// </summary>
        /// <remarks>
        /// 1 credit per API call Get BSC account balance in BNB. This method does not prints any balance of the BEP20 or BEP721 tokens on the account.
        /// </remarks>
        /// <exception cref="Tatum.CSharp.Bsc.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="address">Account address you want to get balance of</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (BscBalance)</returns>
        System.Threading.Tasks.Task<ApiResponse<BscBalance>> BscGetBalanceWithHttpInfoAsync(string address, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        /// <summary>
        /// Get BSC block by hash
        /// </summary>
        /// <remarks>
        /// 1 credit per API call Get BSC block by block hash or block number.
        /// </remarks>
        /// <exception cref="Tatum.CSharp.Bsc.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="hash">Block hash or block number</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (EthBlock)</returns>
        System.Threading.Tasks.Task<ApiResponse<EthBlock>> BscGetBlockWithHttpInfoAsync(string hash, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        /// <summary>
        /// Get current block number
        /// </summary>
        /// <remarks>
        /// 1 credit per API call Get BSC current block number. This is the number of the latest block in the blockchain.
        /// </remarks>
        /// <exception cref="Tatum.CSharp.Bsc.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (decimal)</returns>
        System.Threading.Tasks.Task<ApiResponse<decimal>> BscGetCurrentBlockWithHttpInfoAsync(System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        /// <summary>
        /// Get BSC Transaction
        /// </summary>
        /// <remarks>
        /// 2 credits per API call Get BSC transaction by transaction hash.
        /// </remarks>
        /// <exception cref="Tatum.CSharp.Bsc.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="hash">Transaction hash</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (BscTx)</returns>
        System.Threading.Tasks.Task<ApiResponse<BscTx>> BscGetTransactionWithHttpInfoAsync(string hash, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        /// <summary>
        /// Get count of outgoing BSC transactions
        /// </summary>
        /// <remarks>
        /// 1 credit per API call Get a number of outgoing BSC transactions for the address. When a transaction is sent, there can be multiple outgoing transactions, which are not yet processed by the blockchain. To distinguish between them, there is a counter called a nonce, which represents the order of the transaction in the list of outgoing transactions.
        /// </remarks>
        /// <exception cref="Tatum.CSharp.Bsc.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="address">address</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (decimal)</returns>
        System.Threading.Tasks.Task<ApiResponse<decimal>> BscGetTransactionCountWithHttpInfoAsync(string address, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        #endregion Asynchronous Operations With Http Info
    }


    /// <summary>
    /// Represents a collection of functions to interact with the API endpoints
    /// </summary>
    public interface IBNBSmartChainApi : IBNBSmartChainApiSync, IBNBSmartChainApiWithHttpInfoSync, IBNBSmartChainApiAsync, IBNBSmartChainApiWithHttpInfoAsync
    {

    }

    /// <summary>
    /// Represents a collection of functions to interact with the API endpoints
    /// </summary>
    public partial class BNBSmartChainApi : IBNBSmartChainApi
    {
        private ExceptionFactory _exceptionFactory = (name, response) => null;

        /// <summary>
        /// Initializes a new instance of the <see cref="BNBSmartChainApi"/> class.
        /// </summary>
        /// <param name="client">An instance of HttpClient.</param>
        /// <param name="handler">An optional instance of HttpClientHandler that is used by HttpClient.</param>
        /// <exception cref="ArgumentNullException"></exception>
        /// <returns></returns>
        /// <remarks>
        /// Some configuration settings will not be applied without passing an HttpClientHandler.
        /// The features affected are: Setting and Retrieving Cookies, Client Certificates, Proxy settings.
        /// </remarks>
        public BNBSmartChainApi(HttpClient client, HttpClientHandler handler = null) : this(client, (string)null, handler)
        {
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="BNBSmartChainApi"/> class.
        /// </summary>
        /// <param name="client">An instance of HttpClient.</param>
        /// <param name="basePath">The target service's base path in URL format.</param>
        /// <param name="handler">An optional instance of HttpClientHandler that is used by HttpClient.</param>
        /// <exception cref="ArgumentNullException"></exception>
        /// <exception cref="ArgumentException"></exception>
        /// <returns></returns>
        /// <remarks>
        /// Some configuration settings will not be applied without passing an HttpClientHandler.
        /// The features affected are: Setting and Retrieving Cookies, Client Certificates, Proxy settings.
        /// </remarks>
        public BNBSmartChainApi(HttpClient client, string basePath, HttpClientHandler handler = null)
        {
            if (client == null) throw new ArgumentNullException(nameof(client));

            Configuration = Tatum.CSharp.Bsc.Core.Client.Configuration.MergeConfigurations(
                GlobalConfiguration.Instance,
                new Configuration { BasePath = basePath }
            );
            ApiClient = new ApiClient(client, Configuration.BasePath, handler);
            Client =  ApiClient;
            AsynchronousClient = ApiClient;
            ExceptionFactory = Tatum.CSharp.Bsc.Core.Client.Configuration.DefaultExceptionFactory;
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="BNBSmartChainApi"/> class using Configuration object.
        /// </summary>
        /// <param name="client">An instance of HttpClient.</param>
        /// <param name="configuration">An instance of Configuration.</param>
        /// <param name="handler">An optional instance of HttpClientHandler that is used by HttpClient.</param>
        /// <exception cref="ArgumentNullException"></exception>
        /// <returns></returns>
        /// <remarks>
        /// Some configuration settings will not be applied without passing an HttpClientHandler.
        /// The features affected are: Setting and Retrieving Cookies, Client Certificates, Proxy settings.
        /// </remarks>
        public BNBSmartChainApi(HttpClient client, Configuration configuration, HttpClientHandler handler = null)
        {
            if (configuration == null) throw new ArgumentNullException(nameof(configuration));
            if (client == null) throw new ArgumentNullException(nameof(client));

            Configuration = Tatum.CSharp.Bsc.Core.Client.Configuration.MergeConfigurations(
                GlobalConfiguration.Instance,
                configuration
            );
            ApiClient = new ApiClient(client, Configuration.BasePath, handler);
            Client = ApiClient;
            AsynchronousClient = ApiClient;
            ExceptionFactory = Tatum.CSharp.Bsc.Core.Client.Configuration.DefaultExceptionFactory;
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="BNBSmartChainApi"/> class
        /// using a Configuration object and client instance.
        /// </summary>
        /// <param name="client">The client interface for synchronous API access.</param>
        /// <param name="asyncClient">The client interface for asynchronous API access.</param>
        /// <param name="configuration">The configuration object.</param>
        /// <exception cref="ArgumentNullException"></exception>
        public BNBSmartChainApi(ISynchronousClient client, IAsynchronousClient asyncClient, IReadableConfiguration configuration)
        {
            Client = client ?? throw new ArgumentNullException(nameof(client));
            AsynchronousClient = asyncClient ?? throw new ArgumentNullException(nameof(asyncClient));
            Configuration = configuration ?? throw new ArgumentNullException(nameof(configuration));
            ExceptionFactory = Tatum.CSharp.Bsc.Core.Client.Configuration.DefaultExceptionFactory;
        }

        /// <summary>
        /// Holds the ApiClient if created
        /// </summary>
        public ApiClient ApiClient { get; set; }

        /// <summary>
        /// The client for accessing this underlying API asynchronously.
        /// </summary>
        public IAsynchronousClient AsynchronousClient { get; set; }

        /// <summary>
        /// The client for accessing this underlying API synchronously.
        /// </summary>
        public ISynchronousClient Client { get; set; }

        /// <summary>
        /// Gets the base path of the API client.
        /// </summary>
        /// <value>The base path</value>
        public string GetBasePath()
        {
            return Configuration.BasePath;
        }

        /// <summary>
        /// Gets or sets the configuration object
        /// </summary>
        /// <value>An instance of the Configuration</value>
        public IReadableConfiguration Configuration { get; set; }

        /// <summary>
        /// Provides a factory method hook for the creation of exceptions.
        /// </summary>
        public ExceptionFactory ExceptionFactory
        {
            get
            {
                if (_exceptionFactory != null && _exceptionFactory.GetInvocationList().Length > 1)
                {
                    throw new InvalidOperationException("Multicast delegate for ExceptionFactory is unsupported.");
                }
                return _exceptionFactory;
            }
            set => _exceptionFactory = value;
        }

        /// <summary>
        /// Invoke a method in a smart contract on BNB Smart Chain 2 credits per API call Invoke a method in an existing smart contract on BNB Smart Chain. You can call a read-only or write method. For read-only methods, the output of the invoked method is returned. For write methods, the ID of the associated transaction is returned. Signing a transaction When invoking a method in a smart contract, you are charged a fee for the transaction, and you must sign the transaction with the private key of the blockchain address from which the fee will be deducted. Providing the private key in the API is not a secure way of signing transactions, because the private key can be stolen or exposed. Your private keys should never leave your security perimeter. You should use the private keys only for testing a solution you are building on the testnet of a blockchain. For signing transactions on the mainnet, we strongly recommend that you use the Tatum Key Management System (KMS) and provide the signature ID instead of the private key in the API. Alternatively, you can use the Tatum JavaScript client.
        /// </summary>
        /// <exception cref="Tatum.CSharp.Bsc.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="callBscSmartContractReadMethod"></param>
        /// <returns>Data</returns>
        public Data BscBlockchainSmartContractInvocation(CallBscSmartContractReadMethod callBscSmartContractReadMethod)
        {
            var localVarResponse = BscBlockchainSmartContractInvocationWithHttpInfo(callBscSmartContractReadMethod);

            var exception = ExceptionFactory?.Invoke("BscBlockchainSmartContractInvocation", localVarResponse);
            if (exception != null) throw exception;

            return localVarResponse.Data;
        }

        /// <summary>
        /// Invoke a method in a smart contract on BNB Smart Chain 2 credits per API call Invoke a method in an existing smart contract on BNB Smart Chain. You can call a read-only or write method. For read-only methods, the output of the invoked method is returned. For write methods, the ID of the associated transaction is returned. Signing a transaction When invoking a method in a smart contract, you are charged a fee for the transaction, and you must sign the transaction with the private key of the blockchain address from which the fee will be deducted. Providing the private key in the API is not a secure way of signing transactions, because the private key can be stolen or exposed. Your private keys should never leave your security perimeter. You should use the private keys only for testing a solution you are building on the testnet of a blockchain. For signing transactions on the mainnet, we strongly recommend that you use the Tatum Key Management System (KMS) and provide the signature ID instead of the private key in the API. Alternatively, you can use the Tatum JavaScript client.
        /// </summary>
        /// <exception cref="Tatum.CSharp.Bsc.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="callBscSmartContractReadMethod"></param>
        /// <returns>ApiResponse of Data</returns>
        public ApiResponse<Data> BscBlockchainSmartContractInvocationWithHttpInfo(CallBscSmartContractReadMethod callBscSmartContractReadMethod)
        {
            // verify the required parameter 'callBscSmartContractReadMethod' is set
            if (callBscSmartContractReadMethod == null)
                throw new ApiException(400, "Missing required parameter 'callBscSmartContractReadMethod' when calling BNBSmartChainApi->BscBlockchainSmartContractInvocation");

            var localVarRequestOptions = new RequestOptions();

            var contentTypes = new string[]{
                "application/json"
            };

            // to determine the Accept header
            var accepts = new string[]{
                "application/json"
            };

            var localVarContentType = ClientUtils.SelectHeaderContentType(contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = ClientUtils.SelectHeaderAccept(accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.Data = callBscSmartContractReadMethod;

            // authentication (X-API-Key) required
            if (!string.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("x-api-key")))
            {
                localVarRequestOptions.HeaderParameters.Add("x-api-key", Configuration.GetApiKeyWithPrefix("x-api-key"));
            }

            // make the HTTP request
            var localVarResponse = Client.Post<Data>("/v3/bsc/smartcontract", localVarRequestOptions, Configuration);

            return localVarResponse;
        }

        /// <summary>
        /// Invoke a method in a smart contract on BNB Smart Chain 2 credits per API call Invoke a method in an existing smart contract on BNB Smart Chain. You can call a read-only or write method. For read-only methods, the output of the invoked method is returned. For write methods, the ID of the associated transaction is returned. Signing a transaction When invoking a method in a smart contract, you are charged a fee for the transaction, and you must sign the transaction with the private key of the blockchain address from which the fee will be deducted. Providing the private key in the API is not a secure way of signing transactions, because the private key can be stolen or exposed. Your private keys should never leave your security perimeter. You should use the private keys only for testing a solution you are building on the testnet of a blockchain. For signing transactions on the mainnet, we strongly recommend that you use the Tatum Key Management System (KMS) and provide the signature ID instead of the private key in the API. Alternatively, you can use the Tatum JavaScript client.
        /// </summary>
        /// <exception cref="Tatum.CSharp.Bsc.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="callBscSmartContractReadMethod"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of Data</returns>
        public async System.Threading.Tasks.Task<Data> BscBlockchainSmartContractInvocationAsync(CallBscSmartContractReadMethod callBscSmartContractReadMethod, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            var localVarResponse = await BscBlockchainSmartContractInvocationWithHttpInfoAsync(callBscSmartContractReadMethod, cancellationToken).ConfigureAwait(false);
            
            var exception = ExceptionFactory?.Invoke("BscBlockchainSmartContractInvocation", localVarResponse);
            if (exception != null) throw exception;

            return localVarResponse.Data;
        }

        /// <summary>
        /// Invoke a method in a smart contract on BNB Smart Chain 2 credits per API call Invoke a method in an existing smart contract on BNB Smart Chain. You can call a read-only or write method. For read-only methods, the output of the invoked method is returned. For write methods, the ID of the associated transaction is returned. Signing a transaction When invoking a method in a smart contract, you are charged a fee for the transaction, and you must sign the transaction with the private key of the blockchain address from which the fee will be deducted. Providing the private key in the API is not a secure way of signing transactions, because the private key can be stolen or exposed. Your private keys should never leave your security perimeter. You should use the private keys only for testing a solution you are building on the testnet of a blockchain. For signing transactions on the mainnet, we strongly recommend that you use the Tatum Key Management System (KMS) and provide the signature ID instead of the private key in the API. Alternatively, you can use the Tatum JavaScript client.
        /// </summary>
        /// <exception cref="Tatum.CSharp.Bsc.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="callBscSmartContractReadMethod"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (Data)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<Data>> BscBlockchainSmartContractInvocationWithHttpInfoAsync(CallBscSmartContractReadMethod callBscSmartContractReadMethod, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            // verify the required parameter 'callBscSmartContractReadMethod' is set
            if (callBscSmartContractReadMethod == null)
                throw new ApiException(400, "Missing required parameter 'callBscSmartContractReadMethod' when calling BNBSmartChainApi->BscBlockchainSmartContractInvocation");

            var localVarRequestOptions = new RequestOptions();

            var contentTypes = new string[]{
                "application/json"
            };

            // to determine the Accept header
            var accepts = new string[]{
                "application/json"
            };


            var localVarContentType = ClientUtils.SelectHeaderContentType(contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = ClientUtils.SelectHeaderAccept(accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.Data = callBscSmartContractReadMethod;

            // authentication (X-API-Key) required
            if (!string.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("x-api-key")))
            {
                localVarRequestOptions.HeaderParameters.Add("x-api-key", Configuration.GetApiKeyWithPrefix("x-api-key"));
            }

            // make the HTTP request

            var localVarResponse = await AsynchronousClient.PostAsync<Data>("/v3/bsc/smartcontract", localVarRequestOptions, Configuration, cancellationToken).ConfigureAwait(false);

            return localVarResponse;
        }

        /// <summary>
        /// Invoke a method in a smart contract on BNB Smart Chain 2 credits per API call Invoke a method in an existing smart contract on BNB Smart Chain. You can call a read-only or write method. For read-only methods, the output of the invoked method is returned. For write methods, the ID of the associated transaction is returned. Signing a transaction When invoking a method in a smart contract, you are charged a fee for the transaction, and you must sign the transaction with the private key of the blockchain address from which the fee will be deducted. Providing the private key in the API is not a secure way of signing transactions, because the private key can be stolen or exposed. Your private keys should never leave your security perimeter. You should use the private keys only for testing a solution you are building on the testnet of a blockchain. For signing transactions on the mainnet, we strongly recommend that you use the Tatum Key Management System (KMS) and provide the signature ID instead of the private key in the API. Alternatively, you can use the Tatum JavaScript client.
        /// </summary>
        /// <exception cref="Tatum.CSharp.Bsc.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="callBscSmartContractMethod"></param>
        /// <returns>TransactionHash</returns>
        public TransactionHash BscBlockchainSmartContractInvocation(CallBscSmartContractMethod callBscSmartContractMethod)
        {
            var localVarResponse = BscBlockchainSmartContractInvocationWithHttpInfo(callBscSmartContractMethod);

            var exception = ExceptionFactory?.Invoke("BscBlockchainSmartContractInvocation_0", localVarResponse);
            if (exception != null) throw exception;

            return localVarResponse.Data;
        }

        /// <summary>
        /// Invoke a method in a smart contract on BNB Smart Chain 2 credits per API call Invoke a method in an existing smart contract on BNB Smart Chain. You can call a read-only or write method. For read-only methods, the output of the invoked method is returned. For write methods, the ID of the associated transaction is returned. Signing a transaction When invoking a method in a smart contract, you are charged a fee for the transaction, and you must sign the transaction with the private key of the blockchain address from which the fee will be deducted. Providing the private key in the API is not a secure way of signing transactions, because the private key can be stolen or exposed. Your private keys should never leave your security perimeter. You should use the private keys only for testing a solution you are building on the testnet of a blockchain. For signing transactions on the mainnet, we strongly recommend that you use the Tatum Key Management System (KMS) and provide the signature ID instead of the private key in the API. Alternatively, you can use the Tatum JavaScript client.
        /// </summary>
        /// <exception cref="Tatum.CSharp.Bsc.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="callBscSmartContractMethod"></param>
        /// <returns>ApiResponse of TransactionHash</returns>
        public ApiResponse<TransactionHash> BscBlockchainSmartContractInvocationWithHttpInfo(CallBscSmartContractMethod callBscSmartContractMethod)
        {
            // verify the required parameter 'callBscSmartContractMethod' is set
            if (callBscSmartContractMethod == null)
                throw new ApiException(400, "Missing required parameter 'callBscSmartContractMethod' when calling BNBSmartChainApi->BscBlockchainSmartContractInvocation_0");

            var localVarRequestOptions = new RequestOptions();

            var contentTypes = new string[]{
                "application/json"
            };

            // to determine the Accept header
            var accepts = new string[]{
                "application/json"
            };

            var localVarContentType = ClientUtils.SelectHeaderContentType(contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = ClientUtils.SelectHeaderAccept(accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.Data = callBscSmartContractMethod;

            // authentication (X-API-Key) required
            if (!string.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("x-api-key")))
            {
                localVarRequestOptions.HeaderParameters.Add("x-api-key", Configuration.GetApiKeyWithPrefix("x-api-key"));
            }

            // make the HTTP request
            var localVarResponse = Client.Post<TransactionHash>("/v3/bsc/smartcontract", localVarRequestOptions, Configuration);

            return localVarResponse;
        }

        /// <summary>
        /// Invoke a method in a smart contract on BNB Smart Chain 2 credits per API call Invoke a method in an existing smart contract on BNB Smart Chain. You can call a read-only or write method. For read-only methods, the output of the invoked method is returned. For write methods, the ID of the associated transaction is returned. Signing a transaction When invoking a method in a smart contract, you are charged a fee for the transaction, and you must sign the transaction with the private key of the blockchain address from which the fee will be deducted. Providing the private key in the API is not a secure way of signing transactions, because the private key can be stolen or exposed. Your private keys should never leave your security perimeter. You should use the private keys only for testing a solution you are building on the testnet of a blockchain. For signing transactions on the mainnet, we strongly recommend that you use the Tatum Key Management System (KMS) and provide the signature ID instead of the private key in the API. Alternatively, you can use the Tatum JavaScript client.
        /// </summary>
        /// <exception cref="Tatum.CSharp.Bsc.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="callBscSmartContractMethod"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of TransactionHash</returns>
        public async System.Threading.Tasks.Task<TransactionHash> BscBlockchainSmartContractInvocationAsync(CallBscSmartContractMethod callBscSmartContractMethod, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            var localVarResponse = await BscBlockchainSmartContractInvocationWithHttpInfoAsync(callBscSmartContractMethod, cancellationToken).ConfigureAwait(false);
            
            var exception = ExceptionFactory?.Invoke("BscBlockchainSmartContractInvocation_0", localVarResponse);
            if (exception != null) throw exception;

            return localVarResponse.Data;
        }

        /// <summary>
        /// Invoke a method in a smart contract on BNB Smart Chain 2 credits per API call Invoke a method in an existing smart contract on BNB Smart Chain. You can call a read-only or write method. For read-only methods, the output of the invoked method is returned. For write methods, the ID of the associated transaction is returned. Signing a transaction When invoking a method in a smart contract, you are charged a fee for the transaction, and you must sign the transaction with the private key of the blockchain address from which the fee will be deducted. Providing the private key in the API is not a secure way of signing transactions, because the private key can be stolen or exposed. Your private keys should never leave your security perimeter. You should use the private keys only for testing a solution you are building on the testnet of a blockchain. For signing transactions on the mainnet, we strongly recommend that you use the Tatum Key Management System (KMS) and provide the signature ID instead of the private key in the API. Alternatively, you can use the Tatum JavaScript client.
        /// </summary>
        /// <exception cref="Tatum.CSharp.Bsc.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="callBscSmartContractMethod"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (TransactionHash)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<TransactionHash>> BscBlockchainSmartContractInvocationWithHttpInfoAsync(CallBscSmartContractMethod callBscSmartContractMethod, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            // verify the required parameter 'callBscSmartContractMethod' is set
            if (callBscSmartContractMethod == null)
                throw new ApiException(400, "Missing required parameter 'callBscSmartContractMethod' when calling BNBSmartChainApi->BscBlockchainSmartContractInvocation_0");

            var localVarRequestOptions = new RequestOptions();

            var contentTypes = new string[]{
                "application/json"
            };

            // to determine the Accept header
            var accepts = new string[]{
                "application/json"
            };


            var localVarContentType = ClientUtils.SelectHeaderContentType(contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = ClientUtils.SelectHeaderAccept(accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.Data = callBscSmartContractMethod;

            // authentication (X-API-Key) required
            if (!string.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("x-api-key")))
            {
                localVarRequestOptions.HeaderParameters.Add("x-api-key", Configuration.GetApiKeyWithPrefix("x-api-key"));
            }

            // make the HTTP request

            var localVarResponse = await AsynchronousClient.PostAsync<TransactionHash>("/v3/bsc/smartcontract", localVarRequestOptions, Configuration, cancellationToken).ConfigureAwait(false);

            return localVarResponse;
        }

        /// <summary>
        /// Invoke a method in a smart contract on BNB Smart Chain 2 credits per API call Invoke a method in an existing smart contract on BNB Smart Chain. You can call a read-only or write method. For read-only methods, the output of the invoked method is returned. For write methods, the ID of the associated transaction is returned. Signing a transaction When invoking a method in a smart contract, you are charged a fee for the transaction, and you must sign the transaction with the private key of the blockchain address from which the fee will be deducted. Providing the private key in the API is not a secure way of signing transactions, because the private key can be stolen or exposed. Your private keys should never leave your security perimeter. You should use the private keys only for testing a solution you are building on the testnet of a blockchain. For signing transactions on the mainnet, we strongly recommend that you use the Tatum Key Management System (KMS) and provide the signature ID instead of the private key in the API. Alternatively, you can use the Tatum JavaScript client.
        /// </summary>
        /// <exception cref="Tatum.CSharp.Bsc.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="callBscSmartContractMethodKMS"></param>
        /// <returns>SignatureId</returns>
        public SignatureId BscBlockchainSmartContractInvocation(CallBscSmartContractMethodKMS callBscSmartContractMethodKMS)
        {
            var localVarResponse = BscBlockchainSmartContractInvocationWithHttpInfo(callBscSmartContractMethodKMS);

            var exception = ExceptionFactory?.Invoke("BscBlockchainSmartContractInvocation_1", localVarResponse);
            if (exception != null) throw exception;

            return localVarResponse.Data;
        }

        /// <summary>
        /// Invoke a method in a smart contract on BNB Smart Chain 2 credits per API call Invoke a method in an existing smart contract on BNB Smart Chain. You can call a read-only or write method. For read-only methods, the output of the invoked method is returned. For write methods, the ID of the associated transaction is returned. Signing a transaction When invoking a method in a smart contract, you are charged a fee for the transaction, and you must sign the transaction with the private key of the blockchain address from which the fee will be deducted. Providing the private key in the API is not a secure way of signing transactions, because the private key can be stolen or exposed. Your private keys should never leave your security perimeter. You should use the private keys only for testing a solution you are building on the testnet of a blockchain. For signing transactions on the mainnet, we strongly recommend that you use the Tatum Key Management System (KMS) and provide the signature ID instead of the private key in the API. Alternatively, you can use the Tatum JavaScript client.
        /// </summary>
        /// <exception cref="Tatum.CSharp.Bsc.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="callBscSmartContractMethodKMS"></param>
        /// <returns>ApiResponse of SignatureId</returns>
        public ApiResponse<SignatureId> BscBlockchainSmartContractInvocationWithHttpInfo(CallBscSmartContractMethodKMS callBscSmartContractMethodKMS)
        {
            // verify the required parameter 'callBscSmartContractMethodKMS' is set
            if (callBscSmartContractMethodKMS == null)
                throw new ApiException(400, "Missing required parameter 'callBscSmartContractMethodKMS' when calling BNBSmartChainApi->BscBlockchainSmartContractInvocation_1");

            var localVarRequestOptions = new RequestOptions();

            var contentTypes = new string[]{
                "application/json"
            };

            // to determine the Accept header
            var accepts = new string[]{
                "application/json"
            };

            var localVarContentType = ClientUtils.SelectHeaderContentType(contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = ClientUtils.SelectHeaderAccept(accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.Data = callBscSmartContractMethodKMS;

            // authentication (X-API-Key) required
            if (!string.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("x-api-key")))
            {
                localVarRequestOptions.HeaderParameters.Add("x-api-key", Configuration.GetApiKeyWithPrefix("x-api-key"));
            }

            // make the HTTP request
            var localVarResponse = Client.Post<SignatureId>("/v3/bsc/smartcontract", localVarRequestOptions, Configuration);

            return localVarResponse;
        }

        /// <summary>
        /// Invoke a method in a smart contract on BNB Smart Chain 2 credits per API call Invoke a method in an existing smart contract on BNB Smart Chain. You can call a read-only or write method. For read-only methods, the output of the invoked method is returned. For write methods, the ID of the associated transaction is returned. Signing a transaction When invoking a method in a smart contract, you are charged a fee for the transaction, and you must sign the transaction with the private key of the blockchain address from which the fee will be deducted. Providing the private key in the API is not a secure way of signing transactions, because the private key can be stolen or exposed. Your private keys should never leave your security perimeter. You should use the private keys only for testing a solution you are building on the testnet of a blockchain. For signing transactions on the mainnet, we strongly recommend that you use the Tatum Key Management System (KMS) and provide the signature ID instead of the private key in the API. Alternatively, you can use the Tatum JavaScript client.
        /// </summary>
        /// <exception cref="Tatum.CSharp.Bsc.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="callBscSmartContractMethodKMS"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of SignatureId</returns>
        public async System.Threading.Tasks.Task<SignatureId> BscBlockchainSmartContractInvocationAsync(CallBscSmartContractMethodKMS callBscSmartContractMethodKMS, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            var localVarResponse = await BscBlockchainSmartContractInvocationWithHttpInfoAsync(callBscSmartContractMethodKMS, cancellationToken).ConfigureAwait(false);
            
            var exception = ExceptionFactory?.Invoke("BscBlockchainSmartContractInvocation_1", localVarResponse);
            if (exception != null) throw exception;

            return localVarResponse.Data;
        }

        /// <summary>
        /// Invoke a method in a smart contract on BNB Smart Chain 2 credits per API call Invoke a method in an existing smart contract on BNB Smart Chain. You can call a read-only or write method. For read-only methods, the output of the invoked method is returned. For write methods, the ID of the associated transaction is returned. Signing a transaction When invoking a method in a smart contract, you are charged a fee for the transaction, and you must sign the transaction with the private key of the blockchain address from which the fee will be deducted. Providing the private key in the API is not a secure way of signing transactions, because the private key can be stolen or exposed. Your private keys should never leave your security perimeter. You should use the private keys only for testing a solution you are building on the testnet of a blockchain. For signing transactions on the mainnet, we strongly recommend that you use the Tatum Key Management System (KMS) and provide the signature ID instead of the private key in the API. Alternatively, you can use the Tatum JavaScript client.
        /// </summary>
        /// <exception cref="Tatum.CSharp.Bsc.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="callBscSmartContractMethodKMS"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (SignatureId)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<SignatureId>> BscBlockchainSmartContractInvocationWithHttpInfoAsync(CallBscSmartContractMethodKMS callBscSmartContractMethodKMS, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            // verify the required parameter 'callBscSmartContractMethodKMS' is set
            if (callBscSmartContractMethodKMS == null)
                throw new ApiException(400, "Missing required parameter 'callBscSmartContractMethodKMS' when calling BNBSmartChainApi->BscBlockchainSmartContractInvocation_1");

            var localVarRequestOptions = new RequestOptions();

            var contentTypes = new string[]{
                "application/json"
            };

            // to determine the Accept header
            var accepts = new string[]{
                "application/json"
            };


            var localVarContentType = ClientUtils.SelectHeaderContentType(contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = ClientUtils.SelectHeaderAccept(accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.Data = callBscSmartContractMethodKMS;

            // authentication (X-API-Key) required
            if (!string.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("x-api-key")))
            {
                localVarRequestOptions.HeaderParameters.Add("x-api-key", Configuration.GetApiKeyWithPrefix("x-api-key"));
            }

            // make the HTTP request

            var localVarResponse = await AsynchronousClient.PostAsync<SignatureId>("/v3/bsc/smartcontract", localVarRequestOptions, Configuration, cancellationToken).ConfigureAwait(false);

            return localVarResponse;
        }

        /// <summary>
        /// Send BSC / BEP20 from account to account 2 credits per API call Send BNB or Tatum supported BEP20 token from account to account. Signing a transaction When sending BNB, you are charged a fee for the transaction, and you must sign the transaction with the private key of the blockchain address from which the fee will be deducted. Providing the private key in the API is not a secure way of signing transactions, because the private key can be stolen or exposed. Your private keys should never leave your security perimeter. You should use the private keys only for testing a solution you are building on the testnet of a blockchain. For signing transactions on the mainnet, we strongly recommend that you use the Tatum Key Management System (KMS) and provide the signature ID instead of the private key in the API. Alternatively, you can use the Tatum JavaScript client.
        /// </summary>
        /// <exception cref="Tatum.CSharp.Bsc.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="transferBscBlockchain"></param>
        /// <returns>TransactionHash</returns>
        public TransactionHash BscBlockchainTransfer(TransferBscBlockchain transferBscBlockchain)
        {
            var localVarResponse = BscBlockchainTransferWithHttpInfo(transferBscBlockchain);

            var exception = ExceptionFactory?.Invoke("BscBlockchainTransfer", localVarResponse);
            if (exception != null) throw exception;

            return localVarResponse.Data;
        }

        /// <summary>
        /// Send BSC / BEP20 from account to account 2 credits per API call Send BNB or Tatum supported BEP20 token from account to account. Signing a transaction When sending BNB, you are charged a fee for the transaction, and you must sign the transaction with the private key of the blockchain address from which the fee will be deducted. Providing the private key in the API is not a secure way of signing transactions, because the private key can be stolen or exposed. Your private keys should never leave your security perimeter. You should use the private keys only for testing a solution you are building on the testnet of a blockchain. For signing transactions on the mainnet, we strongly recommend that you use the Tatum Key Management System (KMS) and provide the signature ID instead of the private key in the API. Alternatively, you can use the Tatum JavaScript client.
        /// </summary>
        /// <exception cref="Tatum.CSharp.Bsc.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="transferBscBlockchain"></param>
        /// <returns>ApiResponse of TransactionHash</returns>
        public ApiResponse<TransactionHash> BscBlockchainTransferWithHttpInfo(TransferBscBlockchain transferBscBlockchain)
        {
            // verify the required parameter 'transferBscBlockchain' is set
            if (transferBscBlockchain == null)
                throw new ApiException(400, "Missing required parameter 'transferBscBlockchain' when calling BNBSmartChainApi->BscBlockchainTransfer");

            var localVarRequestOptions = new RequestOptions();

            var contentTypes = new string[]{
                "application/json"
            };

            // to determine the Accept header
            var accepts = new string[]{
                "application/json"
            };

            var localVarContentType = ClientUtils.SelectHeaderContentType(contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = ClientUtils.SelectHeaderAccept(accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.Data = transferBscBlockchain;

            // authentication (X-API-Key) required
            if (!string.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("x-api-key")))
            {
                localVarRequestOptions.HeaderParameters.Add("x-api-key", Configuration.GetApiKeyWithPrefix("x-api-key"));
            }

            // make the HTTP request
            var localVarResponse = Client.Post<TransactionHash>("/v3/bsc/transaction", localVarRequestOptions, Configuration);

            return localVarResponse;
        }

        /// <summary>
        /// Send BSC / BEP20 from account to account 2 credits per API call Send BNB or Tatum supported BEP20 token from account to account. Signing a transaction When sending BNB, you are charged a fee for the transaction, and you must sign the transaction with the private key of the blockchain address from which the fee will be deducted. Providing the private key in the API is not a secure way of signing transactions, because the private key can be stolen or exposed. Your private keys should never leave your security perimeter. You should use the private keys only for testing a solution you are building on the testnet of a blockchain. For signing transactions on the mainnet, we strongly recommend that you use the Tatum Key Management System (KMS) and provide the signature ID instead of the private key in the API. Alternatively, you can use the Tatum JavaScript client.
        /// </summary>
        /// <exception cref="Tatum.CSharp.Bsc.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="transferBscBlockchain"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of TransactionHash</returns>
        public async System.Threading.Tasks.Task<TransactionHash> BscBlockchainTransferAsync(TransferBscBlockchain transferBscBlockchain, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            var localVarResponse = await BscBlockchainTransferWithHttpInfoAsync(transferBscBlockchain, cancellationToken).ConfigureAwait(false);
            
            var exception = ExceptionFactory?.Invoke("BscBlockchainTransfer", localVarResponse);
            if (exception != null) throw exception;

            return localVarResponse.Data;
        }

        /// <summary>
        /// Send BSC / BEP20 from account to account 2 credits per API call Send BNB or Tatum supported BEP20 token from account to account. Signing a transaction When sending BNB, you are charged a fee for the transaction, and you must sign the transaction with the private key of the blockchain address from which the fee will be deducted. Providing the private key in the API is not a secure way of signing transactions, because the private key can be stolen or exposed. Your private keys should never leave your security perimeter. You should use the private keys only for testing a solution you are building on the testnet of a blockchain. For signing transactions on the mainnet, we strongly recommend that you use the Tatum Key Management System (KMS) and provide the signature ID instead of the private key in the API. Alternatively, you can use the Tatum JavaScript client.
        /// </summary>
        /// <exception cref="Tatum.CSharp.Bsc.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="transferBscBlockchain"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (TransactionHash)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<TransactionHash>> BscBlockchainTransferWithHttpInfoAsync(TransferBscBlockchain transferBscBlockchain, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            // verify the required parameter 'transferBscBlockchain' is set
            if (transferBscBlockchain == null)
                throw new ApiException(400, "Missing required parameter 'transferBscBlockchain' when calling BNBSmartChainApi->BscBlockchainTransfer");

            var localVarRequestOptions = new RequestOptions();

            var contentTypes = new string[]{
                "application/json"
            };

            // to determine the Accept header
            var accepts = new string[]{
                "application/json"
            };


            var localVarContentType = ClientUtils.SelectHeaderContentType(contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = ClientUtils.SelectHeaderAccept(accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.Data = transferBscBlockchain;

            // authentication (X-API-Key) required
            if (!string.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("x-api-key")))
            {
                localVarRequestOptions.HeaderParameters.Add("x-api-key", Configuration.GetApiKeyWithPrefix("x-api-key"));
            }

            // make the HTTP request

            var localVarResponse = await AsynchronousClient.PostAsync<TransactionHash>("/v3/bsc/transaction", localVarRequestOptions, Configuration, cancellationToken).ConfigureAwait(false);

            return localVarResponse;
        }

        /// <summary>
        /// Send BSC / BEP20 from account to account 2 credits per API call Send BNB or Tatum supported BEP20 token from account to account. Signing a transaction When sending BNB, you are charged a fee for the transaction, and you must sign the transaction with the private key of the blockchain address from which the fee will be deducted. Providing the private key in the API is not a secure way of signing transactions, because the private key can be stolen or exposed. Your private keys should never leave your security perimeter. You should use the private keys only for testing a solution you are building on the testnet of a blockchain. For signing transactions on the mainnet, we strongly recommend that you use the Tatum Key Management System (KMS) and provide the signature ID instead of the private key in the API. Alternatively, you can use the Tatum JavaScript client.
        /// </summary>
        /// <exception cref="Tatum.CSharp.Bsc.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="transferBscBlockchainKMS"></param>
        /// <returns>SignatureId</returns>
        public SignatureId BscBlockchainTransfer(TransferBscBlockchainKMS transferBscBlockchainKMS)
        {
            var localVarResponse = BscBlockchainTransferWithHttpInfo(transferBscBlockchainKMS);

            var exception = ExceptionFactory?.Invoke("BscBlockchainTransfer_0", localVarResponse);
            if (exception != null) throw exception;

            return localVarResponse.Data;
        }

        /// <summary>
        /// Send BSC / BEP20 from account to account 2 credits per API call Send BNB or Tatum supported BEP20 token from account to account. Signing a transaction When sending BNB, you are charged a fee for the transaction, and you must sign the transaction with the private key of the blockchain address from which the fee will be deducted. Providing the private key in the API is not a secure way of signing transactions, because the private key can be stolen or exposed. Your private keys should never leave your security perimeter. You should use the private keys only for testing a solution you are building on the testnet of a blockchain. For signing transactions on the mainnet, we strongly recommend that you use the Tatum Key Management System (KMS) and provide the signature ID instead of the private key in the API. Alternatively, you can use the Tatum JavaScript client.
        /// </summary>
        /// <exception cref="Tatum.CSharp.Bsc.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="transferBscBlockchainKMS"></param>
        /// <returns>ApiResponse of SignatureId</returns>
        public ApiResponse<SignatureId> BscBlockchainTransferWithHttpInfo(TransferBscBlockchainKMS transferBscBlockchainKMS)
        {
            // verify the required parameter 'transferBscBlockchainKMS' is set
            if (transferBscBlockchainKMS == null)
                throw new ApiException(400, "Missing required parameter 'transferBscBlockchainKMS' when calling BNBSmartChainApi->BscBlockchainTransfer_0");

            var localVarRequestOptions = new RequestOptions();

            var contentTypes = new string[]{
                "application/json"
            };

            // to determine the Accept header
            var accepts = new string[]{
                "application/json"
            };

            var localVarContentType = ClientUtils.SelectHeaderContentType(contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = ClientUtils.SelectHeaderAccept(accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.Data = transferBscBlockchainKMS;

            // authentication (X-API-Key) required
            if (!string.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("x-api-key")))
            {
                localVarRequestOptions.HeaderParameters.Add("x-api-key", Configuration.GetApiKeyWithPrefix("x-api-key"));
            }

            // make the HTTP request
            var localVarResponse = Client.Post<SignatureId>("/v3/bsc/transaction", localVarRequestOptions, Configuration);

            return localVarResponse;
        }

        /// <summary>
        /// Send BSC / BEP20 from account to account 2 credits per API call Send BNB or Tatum supported BEP20 token from account to account. Signing a transaction When sending BNB, you are charged a fee for the transaction, and you must sign the transaction with the private key of the blockchain address from which the fee will be deducted. Providing the private key in the API is not a secure way of signing transactions, because the private key can be stolen or exposed. Your private keys should never leave your security perimeter. You should use the private keys only for testing a solution you are building on the testnet of a blockchain. For signing transactions on the mainnet, we strongly recommend that you use the Tatum Key Management System (KMS) and provide the signature ID instead of the private key in the API. Alternatively, you can use the Tatum JavaScript client.
        /// </summary>
        /// <exception cref="Tatum.CSharp.Bsc.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="transferBscBlockchainKMS"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of SignatureId</returns>
        public async System.Threading.Tasks.Task<SignatureId> BscBlockchainTransferAsync(TransferBscBlockchainKMS transferBscBlockchainKMS, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            var localVarResponse = await BscBlockchainTransferWithHttpInfoAsync(transferBscBlockchainKMS, cancellationToken).ConfigureAwait(false);
            
            var exception = ExceptionFactory?.Invoke("BscBlockchainTransfer_0", localVarResponse);
            if (exception != null) throw exception;

            return localVarResponse.Data;
        }

        /// <summary>
        /// Send BSC / BEP20 from account to account 2 credits per API call Send BNB or Tatum supported BEP20 token from account to account. Signing a transaction When sending BNB, you are charged a fee for the transaction, and you must sign the transaction with the private key of the blockchain address from which the fee will be deducted. Providing the private key in the API is not a secure way of signing transactions, because the private key can be stolen or exposed. Your private keys should never leave your security perimeter. You should use the private keys only for testing a solution you are building on the testnet of a blockchain. For signing transactions on the mainnet, we strongly recommend that you use the Tatum Key Management System (KMS) and provide the signature ID instead of the private key in the API. Alternatively, you can use the Tatum JavaScript client.
        /// </summary>
        /// <exception cref="Tatum.CSharp.Bsc.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="transferBscBlockchainKMS"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (SignatureId)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<SignatureId>> BscBlockchainTransferWithHttpInfoAsync(TransferBscBlockchainKMS transferBscBlockchainKMS, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            // verify the required parameter 'transferBscBlockchainKMS' is set
            if (transferBscBlockchainKMS == null)
                throw new ApiException(400, "Missing required parameter 'transferBscBlockchainKMS' when calling BNBSmartChainApi->BscBlockchainTransfer_0");

            var localVarRequestOptions = new RequestOptions();

            var contentTypes = new string[]{
                "application/json"
            };

            // to determine the Accept header
            var accepts = new string[]{
                "application/json"
            };


            var localVarContentType = ClientUtils.SelectHeaderContentType(contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = ClientUtils.SelectHeaderAccept(accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.Data = transferBscBlockchainKMS;

            // authentication (X-API-Key) required
            if (!string.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("x-api-key")))
            {
                localVarRequestOptions.HeaderParameters.Add("x-api-key", Configuration.GetApiKeyWithPrefix("x-api-key"));
            }

            // make the HTTP request

            var localVarResponse = await AsynchronousClient.PostAsync<SignatureId>("/v3/bsc/transaction", localVarRequestOptions, Configuration, cancellationToken).ConfigureAwait(false);

            return localVarResponse;
        }

        /// <summary>
        /// Broadcast signed BSC transaction 2 credits per API call Broadcast signed transaction to BSC blockchain. This method is used internally from Tatum KMS or Tatum client libraries. It is possible to create custom signing mechanism and use this method only for broadcasting data to the blockchain.
        /// </summary>
        /// <exception cref="Tatum.CSharp.Bsc.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="broadcastKMS"></param>
        /// <returns>TransactionHash</returns>
        public TransactionHash BscBroadcast(BroadcastKMS broadcastKMS)
        {
            var localVarResponse = BscBroadcastWithHttpInfo(broadcastKMS);

            var exception = ExceptionFactory?.Invoke("BscBroadcast", localVarResponse);
            if (exception != null) throw exception;

            return localVarResponse.Data;
        }

        /// <summary>
        /// Broadcast signed BSC transaction 2 credits per API call Broadcast signed transaction to BSC blockchain. This method is used internally from Tatum KMS or Tatum client libraries. It is possible to create custom signing mechanism and use this method only for broadcasting data to the blockchain.
        /// </summary>
        /// <exception cref="Tatum.CSharp.Bsc.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="broadcastKMS"></param>
        /// <returns>ApiResponse of TransactionHash</returns>
        public ApiResponse<TransactionHash> BscBroadcastWithHttpInfo(BroadcastKMS broadcastKMS)
        {
            // verify the required parameter 'broadcastKMS' is set
            if (broadcastKMS == null)
                throw new ApiException(400, "Missing required parameter 'broadcastKMS' when calling BNBSmartChainApi->BscBroadcast");

            var localVarRequestOptions = new RequestOptions();

            var contentTypes = new string[]{
                "application/json"
            };

            // to determine the Accept header
            var accepts = new string[]{
                "application/json"
            };

            var localVarContentType = ClientUtils.SelectHeaderContentType(contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = ClientUtils.SelectHeaderAccept(accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.Data = broadcastKMS;

            // authentication (X-API-Key) required
            if (!string.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("x-api-key")))
            {
                localVarRequestOptions.HeaderParameters.Add("x-api-key", Configuration.GetApiKeyWithPrefix("x-api-key"));
            }

            // make the HTTP request
            var localVarResponse = Client.Post<TransactionHash>("/v3/bsc/broadcast", localVarRequestOptions, Configuration);

            return localVarResponse;
        }

        /// <summary>
        /// Broadcast signed BSC transaction 2 credits per API call Broadcast signed transaction to BSC blockchain. This method is used internally from Tatum KMS or Tatum client libraries. It is possible to create custom signing mechanism and use this method only for broadcasting data to the blockchain.
        /// </summary>
        /// <exception cref="Tatum.CSharp.Bsc.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="broadcastKMS"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of TransactionHash</returns>
        public async System.Threading.Tasks.Task<TransactionHash> BscBroadcastAsync(BroadcastKMS broadcastKMS, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            var localVarResponse = await BscBroadcastWithHttpInfoAsync(broadcastKMS, cancellationToken).ConfigureAwait(false);
            
            var exception = ExceptionFactory?.Invoke("BscBroadcast", localVarResponse);
            if (exception != null) throw exception;

            return localVarResponse.Data;
        }

        /// <summary>
        /// Broadcast signed BSC transaction 2 credits per API call Broadcast signed transaction to BSC blockchain. This method is used internally from Tatum KMS or Tatum client libraries. It is possible to create custom signing mechanism and use this method only for broadcasting data to the blockchain.
        /// </summary>
        /// <exception cref="Tatum.CSharp.Bsc.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="broadcastKMS"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (TransactionHash)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<TransactionHash>> BscBroadcastWithHttpInfoAsync(BroadcastKMS broadcastKMS, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            // verify the required parameter 'broadcastKMS' is set
            if (broadcastKMS == null)
                throw new ApiException(400, "Missing required parameter 'broadcastKMS' when calling BNBSmartChainApi->BscBroadcast");

            var localVarRequestOptions = new RequestOptions();

            var contentTypes = new string[]{
                "application/json"
            };

            // to determine the Accept header
            var accepts = new string[]{
                "application/json"
            };


            var localVarContentType = ClientUtils.SelectHeaderContentType(contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = ClientUtils.SelectHeaderAccept(accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.Data = broadcastKMS;

            // authentication (X-API-Key) required
            if (!string.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("x-api-key")))
            {
                localVarRequestOptions.HeaderParameters.Add("x-api-key", Configuration.GetApiKeyWithPrefix("x-api-key"));
            }

            // make the HTTP request

            var localVarResponse = await AsynchronousClient.PostAsync<TransactionHash>("/v3/bsc/broadcast", localVarRequestOptions, Configuration, cancellationToken).ConfigureAwait(false);

            return localVarResponse;
        }

        /// <summary>
        /// Generate BSC account address from Extended public key 1 credit per API call Generate BSC account deposit address from Extended public key. Deposit address is generated for the specific index - each extended public key can generate up to 2^31 addresses starting from index 0 until 2^31.
        /// </summary>
        /// <exception cref="Tatum.CSharp.Bsc.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="xpub">Extended public key of wallet.</param>
        /// <param name="index">Derivation index of desired address to be generated.</param>
        /// <returns>GeneratedAddressBsc</returns>
        public GeneratedAddressBsc BscGenerateAddress(string xpub, decimal index)
        {
            var localVarResponse = BscGenerateAddressWithHttpInfo(xpub, index);

            var exception = ExceptionFactory?.Invoke("BscGenerateAddress", localVarResponse);
            if (exception != null) throw exception;

            return localVarResponse.Data;
        }

        /// <summary>
        /// Generate BSC account address from Extended public key 1 credit per API call Generate BSC account deposit address from Extended public key. Deposit address is generated for the specific index - each extended public key can generate up to 2^31 addresses starting from index 0 until 2^31.
        /// </summary>
        /// <exception cref="Tatum.CSharp.Bsc.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="xpub">Extended public key of wallet.</param>
        /// <param name="index">Derivation index of desired address to be generated.</param>
        /// <returns>ApiResponse of GeneratedAddressBsc</returns>
        public ApiResponse<GeneratedAddressBsc> BscGenerateAddressWithHttpInfo(string xpub, decimal index)
        {
            // verify the required parameter 'xpub' is set
            if (xpub == null)
                throw new ApiException(400, "Missing required parameter 'xpub' when calling BNBSmartChainApi->BscGenerateAddress");

            var localVarRequestOptions = new RequestOptions();

            var contentTypes = new string[]{
            };

            // to determine the Accept header
            var accepts = new string[]{
                "application/json"
            };

            var localVarContentType = ClientUtils.SelectHeaderContentType(contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = ClientUtils.SelectHeaderAccept(accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.PathParameters.Add("xpub", ClientUtils.ParameterToString(xpub)); // path parameter
            localVarRequestOptions.PathParameters.Add("index", ClientUtils.ParameterToString(index)); // path parameter

            // authentication (X-API-Key) required
            if (!string.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("x-api-key")))
            {
                localVarRequestOptions.HeaderParameters.Add("x-api-key", Configuration.GetApiKeyWithPrefix("x-api-key"));
            }

            // make the HTTP request
            var localVarResponse = Client.Get<GeneratedAddressBsc>("/v3/bsc/address/{xpub}/{index}", localVarRequestOptions, Configuration);

            return localVarResponse;
        }

        /// <summary>
        /// Generate BSC account address from Extended public key 1 credit per API call Generate BSC account deposit address from Extended public key. Deposit address is generated for the specific index - each extended public key can generate up to 2^31 addresses starting from index 0 until 2^31.
        /// </summary>
        /// <exception cref="Tatum.CSharp.Bsc.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="xpub">Extended public key of wallet.</param>
        /// <param name="index">Derivation index of desired address to be generated.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of GeneratedAddressBsc</returns>
        public async System.Threading.Tasks.Task<GeneratedAddressBsc> BscGenerateAddressAsync(string xpub, decimal index, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            var localVarResponse = await BscGenerateAddressWithHttpInfoAsync(xpub, index, cancellationToken).ConfigureAwait(false);
            
            var exception = ExceptionFactory?.Invoke("BscGenerateAddress", localVarResponse);
            if (exception != null) throw exception;

            return localVarResponse.Data;
        }

        /// <summary>
        /// Generate BSC account address from Extended public key 1 credit per API call Generate BSC account deposit address from Extended public key. Deposit address is generated for the specific index - each extended public key can generate up to 2^31 addresses starting from index 0 until 2^31.
        /// </summary>
        /// <exception cref="Tatum.CSharp.Bsc.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="xpub">Extended public key of wallet.</param>
        /// <param name="index">Derivation index of desired address to be generated.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (GeneratedAddressBsc)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<GeneratedAddressBsc>> BscGenerateAddressWithHttpInfoAsync(string xpub, decimal index, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            // verify the required parameter 'xpub' is set
            if (xpub == null)
                throw new ApiException(400, "Missing required parameter 'xpub' when calling BNBSmartChainApi->BscGenerateAddress");

            var localVarRequestOptions = new RequestOptions();

            var contentTypes = new string[]{
            };

            // to determine the Accept header
            var accepts = new string[]{
                "application/json"
            };


            var localVarContentType = ClientUtils.SelectHeaderContentType(contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = ClientUtils.SelectHeaderAccept(accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.PathParameters.Add("xpub", ClientUtils.ParameterToString(xpub)); // path parameter
            localVarRequestOptions.PathParameters.Add("index", ClientUtils.ParameterToString(index)); // path parameter

            // authentication (X-API-Key) required
            if (!string.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("x-api-key")))
            {
                localVarRequestOptions.HeaderParameters.Add("x-api-key", Configuration.GetApiKeyWithPrefix("x-api-key"));
            }

            // make the HTTP request

            var localVarResponse = await AsynchronousClient.GetAsync<GeneratedAddressBsc>("/v3/bsc/address/{xpub}/{index}", localVarRequestOptions, Configuration, cancellationToken).ConfigureAwait(false);

            return localVarResponse;
        }

        /// <summary>
        /// Generate BSC private key 1 credit per API call Generate private key of address from mnemonic for given derivation path index. Private key is generated for the specific index - each mnemonic can generate up to 2^31 private keys starting from index 0 until 2^31.
        /// </summary>
        /// <exception cref="Tatum.CSharp.Bsc.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="privKeyRequest"></param>
        /// <returns>PrivKey</returns>
        public PrivKey BscGenerateAddressPrivateKey(PrivKeyRequest privKeyRequest)
        {
            var localVarResponse = BscGenerateAddressPrivateKeyWithHttpInfo(privKeyRequest);

            var exception = ExceptionFactory?.Invoke("BscGenerateAddressPrivateKey", localVarResponse);
            if (exception != null) throw exception;

            return localVarResponse.Data;
        }

        /// <summary>
        /// Generate BSC private key 1 credit per API call Generate private key of address from mnemonic for given derivation path index. Private key is generated for the specific index - each mnemonic can generate up to 2^31 private keys starting from index 0 until 2^31.
        /// </summary>
        /// <exception cref="Tatum.CSharp.Bsc.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="privKeyRequest"></param>
        /// <returns>ApiResponse of PrivKey</returns>
        public ApiResponse<PrivKey> BscGenerateAddressPrivateKeyWithHttpInfo(PrivKeyRequest privKeyRequest)
        {
            // verify the required parameter 'privKeyRequest' is set
            if (privKeyRequest == null)
                throw new ApiException(400, "Missing required parameter 'privKeyRequest' when calling BNBSmartChainApi->BscGenerateAddressPrivateKey");

            var localVarRequestOptions = new RequestOptions();

            var contentTypes = new string[]{
                "application/json"
            };

            // to determine the Accept header
            var accepts = new string[]{
                "application/json"
            };

            var localVarContentType = ClientUtils.SelectHeaderContentType(contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = ClientUtils.SelectHeaderAccept(accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.Data = privKeyRequest;

            // authentication (X-API-Key) required
            if (!string.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("x-api-key")))
            {
                localVarRequestOptions.HeaderParameters.Add("x-api-key", Configuration.GetApiKeyWithPrefix("x-api-key"));
            }

            // make the HTTP request
            var localVarResponse = Client.Post<PrivKey>("/v3/bsc/wallet/priv", localVarRequestOptions, Configuration);

            return localVarResponse;
        }

        /// <summary>
        /// Generate BSC private key 1 credit per API call Generate private key of address from mnemonic for given derivation path index. Private key is generated for the specific index - each mnemonic can generate up to 2^31 private keys starting from index 0 until 2^31.
        /// </summary>
        /// <exception cref="Tatum.CSharp.Bsc.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="privKeyRequest"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of PrivKey</returns>
        public async System.Threading.Tasks.Task<PrivKey> BscGenerateAddressPrivateKeyAsync(PrivKeyRequest privKeyRequest, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            var localVarResponse = await BscGenerateAddressPrivateKeyWithHttpInfoAsync(privKeyRequest, cancellationToken).ConfigureAwait(false);
            
            var exception = ExceptionFactory?.Invoke("BscGenerateAddressPrivateKey", localVarResponse);
            if (exception != null) throw exception;

            return localVarResponse.Data;
        }

        /// <summary>
        /// Generate BSC private key 1 credit per API call Generate private key of address from mnemonic for given derivation path index. Private key is generated for the specific index - each mnemonic can generate up to 2^31 private keys starting from index 0 until 2^31.
        /// </summary>
        /// <exception cref="Tatum.CSharp.Bsc.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="privKeyRequest"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (PrivKey)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<PrivKey>> BscGenerateAddressPrivateKeyWithHttpInfoAsync(PrivKeyRequest privKeyRequest, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            // verify the required parameter 'privKeyRequest' is set
            if (privKeyRequest == null)
                throw new ApiException(400, "Missing required parameter 'privKeyRequest' when calling BNBSmartChainApi->BscGenerateAddressPrivateKey");

            var localVarRequestOptions = new RequestOptions();

            var contentTypes = new string[]{
                "application/json"
            };

            // to determine the Accept header
            var accepts = new string[]{
                "application/json"
            };


            var localVarContentType = ClientUtils.SelectHeaderContentType(contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = ClientUtils.SelectHeaderAccept(accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.Data = privKeyRequest;

            // authentication (X-API-Key) required
            if (!string.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("x-api-key")))
            {
                localVarRequestOptions.HeaderParameters.Add("x-api-key", Configuration.GetApiKeyWithPrefix("x-api-key"));
            }

            // make the HTTP request

            var localVarResponse = await AsynchronousClient.PostAsync<PrivKey>("/v3/bsc/wallet/priv", localVarRequestOptions, Configuration, cancellationToken).ConfigureAwait(false);

            return localVarResponse;
        }

        /// <summary>
        /// Generate BSC wallet 1 credit per API call Tatum supports BIP44 HD wallets. It is very convenient and secure, since it can generate 2^31 addresses from 1 mnemonic phrase. Mnemonic phrase consists of 24 special words in defined order and can restore access to all generated addresses and private keys. Each address is identified by 3 main values: Private Key - your secret value, which should never be revealed Public Key - public address to be published Derivation index - index of generated address Tatum follows BIP44 specification and generates for BSC wallet with derivation path m&#39;/44&#39;/60&#39;/0&#39;/0. More about BIP44 HD wallets can be found here - https://github.com/bitcoin/bips/blob/master/bip-0044.mediawiki. Generate BIP44 compatible BSC wallet.
        /// </summary>
        /// <exception cref="Tatum.CSharp.Bsc.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="mnemonic">Mnemonic to use for generation of extended public and private keys. (optional)</param>
        /// <returns>Wallet</returns>
        public Wallet BscGenerateWallet(string mnemonic = default(string))
        {
            var localVarResponse = BscGenerateWalletWithHttpInfo(mnemonic);

            var exception = ExceptionFactory?.Invoke("BscGenerateWallet", localVarResponse);
            if (exception != null) throw exception;

            return localVarResponse.Data;
        }

        /// <summary>
        /// Generate BSC wallet 1 credit per API call Tatum supports BIP44 HD wallets. It is very convenient and secure, since it can generate 2^31 addresses from 1 mnemonic phrase. Mnemonic phrase consists of 24 special words in defined order and can restore access to all generated addresses and private keys. Each address is identified by 3 main values: Private Key - your secret value, which should never be revealed Public Key - public address to be published Derivation index - index of generated address Tatum follows BIP44 specification and generates for BSC wallet with derivation path m&#39;/44&#39;/60&#39;/0&#39;/0. More about BIP44 HD wallets can be found here - https://github.com/bitcoin/bips/blob/master/bip-0044.mediawiki. Generate BIP44 compatible BSC wallet.
        /// </summary>
        /// <exception cref="Tatum.CSharp.Bsc.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="mnemonic">Mnemonic to use for generation of extended public and private keys. (optional)</param>
        /// <returns>ApiResponse of Wallet</returns>
        public ApiResponse<Wallet> BscGenerateWalletWithHttpInfo(string mnemonic = default(string))
        {
            var localVarRequestOptions = new RequestOptions();

            var contentTypes = new string[]{
            };

            // to determine the Accept header
            var accepts = new string[]{
                "application/json"
            };

            var localVarContentType = ClientUtils.SelectHeaderContentType(contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = ClientUtils.SelectHeaderAccept(accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            if (mnemonic != null)
            {
                localVarRequestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "mnemonic", mnemonic));
            }

            // authentication (X-API-Key) required
            if (!string.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("x-api-key")))
            {
                localVarRequestOptions.HeaderParameters.Add("x-api-key", Configuration.GetApiKeyWithPrefix("x-api-key"));
            }

            // make the HTTP request
            var localVarResponse = Client.Get<Wallet>("/v3/bsc/wallet", localVarRequestOptions, Configuration);

            return localVarResponse;
        }

        /// <summary>
        /// Generate BSC wallet 1 credit per API call Tatum supports BIP44 HD wallets. It is very convenient and secure, since it can generate 2^31 addresses from 1 mnemonic phrase. Mnemonic phrase consists of 24 special words in defined order and can restore access to all generated addresses and private keys. Each address is identified by 3 main values: Private Key - your secret value, which should never be revealed Public Key - public address to be published Derivation index - index of generated address Tatum follows BIP44 specification and generates for BSC wallet with derivation path m&#39;/44&#39;/60&#39;/0&#39;/0. More about BIP44 HD wallets can be found here - https://github.com/bitcoin/bips/blob/master/bip-0044.mediawiki. Generate BIP44 compatible BSC wallet.
        /// </summary>
        /// <exception cref="Tatum.CSharp.Bsc.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="mnemonic">Mnemonic to use for generation of extended public and private keys. (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of Wallet</returns>
        public async System.Threading.Tasks.Task<Wallet> BscGenerateWalletAsync(string mnemonic = default(string), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            var localVarResponse = await BscGenerateWalletWithHttpInfoAsync(mnemonic, cancellationToken).ConfigureAwait(false);
            
            var exception = ExceptionFactory?.Invoke("BscGenerateWallet", localVarResponse);
            if (exception != null) throw exception;

            return localVarResponse.Data;
        }

        /// <summary>
        /// Generate BSC wallet 1 credit per API call Tatum supports BIP44 HD wallets. It is very convenient and secure, since it can generate 2^31 addresses from 1 mnemonic phrase. Mnemonic phrase consists of 24 special words in defined order and can restore access to all generated addresses and private keys. Each address is identified by 3 main values: Private Key - your secret value, which should never be revealed Public Key - public address to be published Derivation index - index of generated address Tatum follows BIP44 specification and generates for BSC wallet with derivation path m&#39;/44&#39;/60&#39;/0&#39;/0. More about BIP44 HD wallets can be found here - https://github.com/bitcoin/bips/blob/master/bip-0044.mediawiki. Generate BIP44 compatible BSC wallet.
        /// </summary>
        /// <exception cref="Tatum.CSharp.Bsc.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="mnemonic">Mnemonic to use for generation of extended public and private keys. (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (Wallet)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<Wallet>> BscGenerateWalletWithHttpInfoAsync(string mnemonic = default(string), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            var localVarRequestOptions = new RequestOptions();

            var contentTypes = new string[]{
            };

            // to determine the Accept header
            var accepts = new string[]{
                "application/json"
            };


            var localVarContentType = ClientUtils.SelectHeaderContentType(contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = ClientUtils.SelectHeaderAccept(accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            if (mnemonic != null)
            {
                localVarRequestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "mnemonic", mnemonic));
            }

            // authentication (X-API-Key) required
            if (!string.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("x-api-key")))
            {
                localVarRequestOptions.HeaderParameters.Add("x-api-key", Configuration.GetApiKeyWithPrefix("x-api-key"));
            }

            // make the HTTP request

            var localVarResponse = await AsynchronousClient.GetAsync<Wallet>("/v3/bsc/wallet", localVarRequestOptions, Configuration, cancellationToken).ConfigureAwait(false);

            return localVarResponse;
        }

        /// <summary>
        /// Get BSC Account balance 1 credit per API call Get BSC account balance in BNB. This method does not prints any balance of the BEP20 or BEP721 tokens on the account.
        /// </summary>
        /// <exception cref="Tatum.CSharp.Bsc.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="address">Account address you want to get balance of</param>
        /// <returns>BscBalance</returns>
        public BscBalance BscGetBalance(string address)
        {
            var localVarResponse = BscGetBalanceWithHttpInfo(address);

            var exception = ExceptionFactory?.Invoke("BscGetBalance", localVarResponse);
            if (exception != null) throw exception;

            return localVarResponse.Data;
        }

        /// <summary>
        /// Get BSC Account balance 1 credit per API call Get BSC account balance in BNB. This method does not prints any balance of the BEP20 or BEP721 tokens on the account.
        /// </summary>
        /// <exception cref="Tatum.CSharp.Bsc.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="address">Account address you want to get balance of</param>
        /// <returns>ApiResponse of BscBalance</returns>
        public ApiResponse<BscBalance> BscGetBalanceWithHttpInfo(string address)
        {
            // verify the required parameter 'address' is set
            if (address == null)
                throw new ApiException(400, "Missing required parameter 'address' when calling BNBSmartChainApi->BscGetBalance");

            var localVarRequestOptions = new RequestOptions();

            var contentTypes = new string[]{
            };

            // to determine the Accept header
            var accepts = new string[]{
                "application/json"
            };

            var localVarContentType = ClientUtils.SelectHeaderContentType(contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = ClientUtils.SelectHeaderAccept(accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.PathParameters.Add("address", ClientUtils.ParameterToString(address)); // path parameter

            // authentication (X-API-Key) required
            if (!string.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("x-api-key")))
            {
                localVarRequestOptions.HeaderParameters.Add("x-api-key", Configuration.GetApiKeyWithPrefix("x-api-key"));
            }

            // make the HTTP request
            var localVarResponse = Client.Get<BscBalance>("/v3/bsc/account/balance/{address}", localVarRequestOptions, Configuration);

            return localVarResponse;
        }

        /// <summary>
        /// Get BSC Account balance 1 credit per API call Get BSC account balance in BNB. This method does not prints any balance of the BEP20 or BEP721 tokens on the account.
        /// </summary>
        /// <exception cref="Tatum.CSharp.Bsc.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="address">Account address you want to get balance of</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of BscBalance</returns>
        public async System.Threading.Tasks.Task<BscBalance> BscGetBalanceAsync(string address, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            var localVarResponse = await BscGetBalanceWithHttpInfoAsync(address, cancellationToken).ConfigureAwait(false);
            
            var exception = ExceptionFactory?.Invoke("BscGetBalance", localVarResponse);
            if (exception != null) throw exception;

            return localVarResponse.Data;
        }

        /// <summary>
        /// Get BSC Account balance 1 credit per API call Get BSC account balance in BNB. This method does not prints any balance of the BEP20 or BEP721 tokens on the account.
        /// </summary>
        /// <exception cref="Tatum.CSharp.Bsc.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="address">Account address you want to get balance of</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (BscBalance)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<BscBalance>> BscGetBalanceWithHttpInfoAsync(string address, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            // verify the required parameter 'address' is set
            if (address == null)
                throw new ApiException(400, "Missing required parameter 'address' when calling BNBSmartChainApi->BscGetBalance");

            var localVarRequestOptions = new RequestOptions();

            var contentTypes = new string[]{
            };

            // to determine the Accept header
            var accepts = new string[]{
                "application/json"
            };


            var localVarContentType = ClientUtils.SelectHeaderContentType(contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = ClientUtils.SelectHeaderAccept(accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.PathParameters.Add("address", ClientUtils.ParameterToString(address)); // path parameter

            // authentication (X-API-Key) required
            if (!string.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("x-api-key")))
            {
                localVarRequestOptions.HeaderParameters.Add("x-api-key", Configuration.GetApiKeyWithPrefix("x-api-key"));
            }

            // make the HTTP request

            var localVarResponse = await AsynchronousClient.GetAsync<BscBalance>("/v3/bsc/account/balance/{address}", localVarRequestOptions, Configuration, cancellationToken).ConfigureAwait(false);

            return localVarResponse;
        }

        /// <summary>
        /// Get BSC block by hash 1 credit per API call Get BSC block by block hash or block number.
        /// </summary>
        /// <exception cref="Tatum.CSharp.Bsc.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="hash">Block hash or block number</param>
        /// <returns>EthBlock</returns>
        public EthBlock BscGetBlock(string hash)
        {
            var localVarResponse = BscGetBlockWithHttpInfo(hash);

            var exception = ExceptionFactory?.Invoke("BscGetBlock", localVarResponse);
            if (exception != null) throw exception;

            return localVarResponse.Data;
        }

        /// <summary>
        /// Get BSC block by hash 1 credit per API call Get BSC block by block hash or block number.
        /// </summary>
        /// <exception cref="Tatum.CSharp.Bsc.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="hash">Block hash or block number</param>
        /// <returns>ApiResponse of EthBlock</returns>
        public ApiResponse<EthBlock> BscGetBlockWithHttpInfo(string hash)
        {
            // verify the required parameter 'hash' is set
            if (hash == null)
                throw new ApiException(400, "Missing required parameter 'hash' when calling BNBSmartChainApi->BscGetBlock");

            var localVarRequestOptions = new RequestOptions();

            var contentTypes = new string[]{
            };

            // to determine the Accept header
            var accepts = new string[]{
                "application/json"
            };

            var localVarContentType = ClientUtils.SelectHeaderContentType(contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = ClientUtils.SelectHeaderAccept(accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.PathParameters.Add("hash", ClientUtils.ParameterToString(hash)); // path parameter

            // authentication (X-API-Key) required
            if (!string.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("x-api-key")))
            {
                localVarRequestOptions.HeaderParameters.Add("x-api-key", Configuration.GetApiKeyWithPrefix("x-api-key"));
            }

            // make the HTTP request
            var localVarResponse = Client.Get<EthBlock>("/v3/bsc/block/{hash}", localVarRequestOptions, Configuration);

            return localVarResponse;
        }

        /// <summary>
        /// Get BSC block by hash 1 credit per API call Get BSC block by block hash or block number.
        /// </summary>
        /// <exception cref="Tatum.CSharp.Bsc.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="hash">Block hash or block number</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of EthBlock</returns>
        public async System.Threading.Tasks.Task<EthBlock> BscGetBlockAsync(string hash, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            var localVarResponse = await BscGetBlockWithHttpInfoAsync(hash, cancellationToken).ConfigureAwait(false);
            
            var exception = ExceptionFactory?.Invoke("BscGetBlock", localVarResponse);
            if (exception != null) throw exception;

            return localVarResponse.Data;
        }

        /// <summary>
        /// Get BSC block by hash 1 credit per API call Get BSC block by block hash or block number.
        /// </summary>
        /// <exception cref="Tatum.CSharp.Bsc.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="hash">Block hash or block number</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (EthBlock)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<EthBlock>> BscGetBlockWithHttpInfoAsync(string hash, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            // verify the required parameter 'hash' is set
            if (hash == null)
                throw new ApiException(400, "Missing required parameter 'hash' when calling BNBSmartChainApi->BscGetBlock");

            var localVarRequestOptions = new RequestOptions();

            var contentTypes = new string[]{
            };

            // to determine the Accept header
            var accepts = new string[]{
                "application/json"
            };


            var localVarContentType = ClientUtils.SelectHeaderContentType(contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = ClientUtils.SelectHeaderAccept(accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.PathParameters.Add("hash", ClientUtils.ParameterToString(hash)); // path parameter

            // authentication (X-API-Key) required
            if (!string.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("x-api-key")))
            {
                localVarRequestOptions.HeaderParameters.Add("x-api-key", Configuration.GetApiKeyWithPrefix("x-api-key"));
            }

            // make the HTTP request

            var localVarResponse = await AsynchronousClient.GetAsync<EthBlock>("/v3/bsc/block/{hash}", localVarRequestOptions, Configuration, cancellationToken).ConfigureAwait(false);

            return localVarResponse;
        }

        /// <summary>
        /// Get current block number 1 credit per API call Get BSC current block number. This is the number of the latest block in the blockchain.
        /// </summary>
        /// <exception cref="Tatum.CSharp.Bsc.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <returns>decimal</returns>
        public decimal BscGetCurrentBlock()
        {
            var localVarResponse = BscGetCurrentBlockWithHttpInfo();

            var exception = ExceptionFactory?.Invoke("BscGetCurrentBlock", localVarResponse);
            if (exception != null) throw exception;

            return localVarResponse.Data;
        }

        /// <summary>
        /// Get current block number 1 credit per API call Get BSC current block number. This is the number of the latest block in the blockchain.
        /// </summary>
        /// <exception cref="Tatum.CSharp.Bsc.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <returns>ApiResponse of decimal</returns>
        public ApiResponse<decimal> BscGetCurrentBlockWithHttpInfo()
        {
            var localVarRequestOptions = new RequestOptions();

            var contentTypes = new string[]{
            };

            // to determine the Accept header
            var accepts = new string[]{
                "application/json"
            };

            var localVarContentType = ClientUtils.SelectHeaderContentType(contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = ClientUtils.SelectHeaderAccept(accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);


            // authentication (X-API-Key) required
            if (!string.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("x-api-key")))
            {
                localVarRequestOptions.HeaderParameters.Add("x-api-key", Configuration.GetApiKeyWithPrefix("x-api-key"));
            }

            // make the HTTP request
            var localVarResponse = Client.Get<decimal>("/v3/bsc/block/current", localVarRequestOptions, Configuration);

            return localVarResponse;
        }

        /// <summary>
        /// Get current block number 1 credit per API call Get BSC current block number. This is the number of the latest block in the blockchain.
        /// </summary>
        /// <exception cref="Tatum.CSharp.Bsc.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of decimal</returns>
        public async System.Threading.Tasks.Task<decimal> BscGetCurrentBlockAsync(System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            var localVarResponse = await BscGetCurrentBlockWithHttpInfoAsync(cancellationToken).ConfigureAwait(false);
            
            var exception = ExceptionFactory?.Invoke("BscGetCurrentBlock", localVarResponse);
            if (exception != null) throw exception;

            return localVarResponse.Data;
        }

        /// <summary>
        /// Get current block number 1 credit per API call Get BSC current block number. This is the number of the latest block in the blockchain.
        /// </summary>
        /// <exception cref="Tatum.CSharp.Bsc.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (decimal)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<decimal>> BscGetCurrentBlockWithHttpInfoAsync(System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            var localVarRequestOptions = new RequestOptions();

            var contentTypes = new string[]{
            };

            // to determine the Accept header
            var accepts = new string[]{
                "application/json"
            };


            var localVarContentType = ClientUtils.SelectHeaderContentType(contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = ClientUtils.SelectHeaderAccept(accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);


            // authentication (X-API-Key) required
            if (!string.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("x-api-key")))
            {
                localVarRequestOptions.HeaderParameters.Add("x-api-key", Configuration.GetApiKeyWithPrefix("x-api-key"));
            }

            // make the HTTP request

            var localVarResponse = await AsynchronousClient.GetAsync<decimal>("/v3/bsc/block/current", localVarRequestOptions, Configuration, cancellationToken).ConfigureAwait(false);

            return localVarResponse;
        }

        /// <summary>
        /// Get BSC Transaction 2 credits per API call Get BSC transaction by transaction hash.
        /// </summary>
        /// <exception cref="Tatum.CSharp.Bsc.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="hash">Transaction hash</param>
        /// <returns>BscTx</returns>
        public BscTx BscGetTransaction(string hash)
        {
            var localVarResponse = BscGetTransactionWithHttpInfo(hash);

            var exception = ExceptionFactory?.Invoke("BscGetTransaction", localVarResponse);
            if (exception != null) throw exception;

            return localVarResponse.Data;
        }

        /// <summary>
        /// Get BSC Transaction 2 credits per API call Get BSC transaction by transaction hash.
        /// </summary>
        /// <exception cref="Tatum.CSharp.Bsc.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="hash">Transaction hash</param>
        /// <returns>ApiResponse of BscTx</returns>
        public ApiResponse<BscTx> BscGetTransactionWithHttpInfo(string hash)
        {
            // verify the required parameter 'hash' is set
            if (hash == null)
                throw new ApiException(400, "Missing required parameter 'hash' when calling BNBSmartChainApi->BscGetTransaction");

            var localVarRequestOptions = new RequestOptions();

            var contentTypes = new string[]{
            };

            // to determine the Accept header
            var accepts = new string[]{
                "application/json"
            };

            var localVarContentType = ClientUtils.SelectHeaderContentType(contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = ClientUtils.SelectHeaderAccept(accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.PathParameters.Add("hash", ClientUtils.ParameterToString(hash)); // path parameter

            // authentication (X-API-Key) required
            if (!string.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("x-api-key")))
            {
                localVarRequestOptions.HeaderParameters.Add("x-api-key", Configuration.GetApiKeyWithPrefix("x-api-key"));
            }

            // make the HTTP request
            var localVarResponse = Client.Get<BscTx>("/v3/bsc/transaction/{hash}", localVarRequestOptions, Configuration);

            return localVarResponse;
        }

        /// <summary>
        /// Get BSC Transaction 2 credits per API call Get BSC transaction by transaction hash.
        /// </summary>
        /// <exception cref="Tatum.CSharp.Bsc.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="hash">Transaction hash</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of BscTx</returns>
        public async System.Threading.Tasks.Task<BscTx> BscGetTransactionAsync(string hash, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            var localVarResponse = await BscGetTransactionWithHttpInfoAsync(hash, cancellationToken).ConfigureAwait(false);
            
            var exception = ExceptionFactory?.Invoke("BscGetTransaction", localVarResponse);
            if (exception != null) throw exception;

            return localVarResponse.Data;
        }

        /// <summary>
        /// Get BSC Transaction 2 credits per API call Get BSC transaction by transaction hash.
        /// </summary>
        /// <exception cref="Tatum.CSharp.Bsc.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="hash">Transaction hash</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (BscTx)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<BscTx>> BscGetTransactionWithHttpInfoAsync(string hash, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            // verify the required parameter 'hash' is set
            if (hash == null)
                throw new ApiException(400, "Missing required parameter 'hash' when calling BNBSmartChainApi->BscGetTransaction");

            var localVarRequestOptions = new RequestOptions();

            var contentTypes = new string[]{
            };

            // to determine the Accept header
            var accepts = new string[]{
                "application/json"
            };


            var localVarContentType = ClientUtils.SelectHeaderContentType(contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = ClientUtils.SelectHeaderAccept(accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.PathParameters.Add("hash", ClientUtils.ParameterToString(hash)); // path parameter

            // authentication (X-API-Key) required
            if (!string.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("x-api-key")))
            {
                localVarRequestOptions.HeaderParameters.Add("x-api-key", Configuration.GetApiKeyWithPrefix("x-api-key"));
            }

            // make the HTTP request

            var localVarResponse = await AsynchronousClient.GetAsync<BscTx>("/v3/bsc/transaction/{hash}", localVarRequestOptions, Configuration, cancellationToken).ConfigureAwait(false);

            return localVarResponse;
        }

        /// <summary>
        /// Get count of outgoing BSC transactions 1 credit per API call Get a number of outgoing BSC transactions for the address. When a transaction is sent, there can be multiple outgoing transactions, which are not yet processed by the blockchain. To distinguish between them, there is a counter called a nonce, which represents the order of the transaction in the list of outgoing transactions.
        /// </summary>
        /// <exception cref="Tatum.CSharp.Bsc.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="address">address</param>
        /// <returns>decimal</returns>
        public decimal BscGetTransactionCount(string address)
        {
            var localVarResponse = BscGetTransactionCountWithHttpInfo(address);

            var exception = ExceptionFactory?.Invoke("BscGetTransactionCount", localVarResponse);
            if (exception != null) throw exception;

            return localVarResponse.Data;
        }

        /// <summary>
        /// Get count of outgoing BSC transactions 1 credit per API call Get a number of outgoing BSC transactions for the address. When a transaction is sent, there can be multiple outgoing transactions, which are not yet processed by the blockchain. To distinguish between them, there is a counter called a nonce, which represents the order of the transaction in the list of outgoing transactions.
        /// </summary>
        /// <exception cref="Tatum.CSharp.Bsc.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="address">address</param>
        /// <returns>ApiResponse of decimal</returns>
        public ApiResponse<decimal> BscGetTransactionCountWithHttpInfo(string address)
        {
            // verify the required parameter 'address' is set
            if (address == null)
                throw new ApiException(400, "Missing required parameter 'address' when calling BNBSmartChainApi->BscGetTransactionCount");

            var localVarRequestOptions = new RequestOptions();

            var contentTypes = new string[]{
            };

            // to determine the Accept header
            var accepts = new string[]{
                "application/json"
            };

            var localVarContentType = ClientUtils.SelectHeaderContentType(contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = ClientUtils.SelectHeaderAccept(accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.PathParameters.Add("address", ClientUtils.ParameterToString(address)); // path parameter

            // authentication (X-API-Key) required
            if (!string.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("x-api-key")))
            {
                localVarRequestOptions.HeaderParameters.Add("x-api-key", Configuration.GetApiKeyWithPrefix("x-api-key"));
            }

            // make the HTTP request
            var localVarResponse = Client.Get<decimal>("/v3/bsc/transaction/count/{address}", localVarRequestOptions, Configuration);

            return localVarResponse;
        }

        /// <summary>
        /// Get count of outgoing BSC transactions 1 credit per API call Get a number of outgoing BSC transactions for the address. When a transaction is sent, there can be multiple outgoing transactions, which are not yet processed by the blockchain. To distinguish between them, there is a counter called a nonce, which represents the order of the transaction in the list of outgoing transactions.
        /// </summary>
        /// <exception cref="Tatum.CSharp.Bsc.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="address">address</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of decimal</returns>
        public async System.Threading.Tasks.Task<decimal> BscGetTransactionCountAsync(string address, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            var localVarResponse = await BscGetTransactionCountWithHttpInfoAsync(address, cancellationToken).ConfigureAwait(false);
            
            var exception = ExceptionFactory?.Invoke("BscGetTransactionCount", localVarResponse);
            if (exception != null) throw exception;

            return localVarResponse.Data;
        }

        /// <summary>
        /// Get count of outgoing BSC transactions 1 credit per API call Get a number of outgoing BSC transactions for the address. When a transaction is sent, there can be multiple outgoing transactions, which are not yet processed by the blockchain. To distinguish between them, there is a counter called a nonce, which represents the order of the transaction in the list of outgoing transactions.
        /// </summary>
        /// <exception cref="Tatum.CSharp.Bsc.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="address">address</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (decimal)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<decimal>> BscGetTransactionCountWithHttpInfoAsync(string address, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            // verify the required parameter 'address' is set
            if (address == null)
                throw new ApiException(400, "Missing required parameter 'address' when calling BNBSmartChainApi->BscGetTransactionCount");

            var localVarRequestOptions = new RequestOptions();

            var contentTypes = new string[]{
            };

            // to determine the Accept header
            var accepts = new string[]{
                "application/json"
            };


            var localVarContentType = ClientUtils.SelectHeaderContentType(contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = ClientUtils.SelectHeaderAccept(accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.PathParameters.Add("address", ClientUtils.ParameterToString(address)); // path parameter

            // authentication (X-API-Key) required
            if (!string.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("x-api-key")))
            {
                localVarRequestOptions.HeaderParameters.Add("x-api-key", Configuration.GetApiKeyWithPrefix("x-api-key"));
            }

            // make the HTTP request

            var localVarResponse = await AsynchronousClient.GetAsync<decimal>("/v3/bsc/transaction/count/{address}", localVarRequestOptions, Configuration, cancellationToken).ConfigureAwait(false);

            return localVarResponse;
        }

    }
}
