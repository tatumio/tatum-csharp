/*
 * Tatum API Reference
 *
 * # Welcome to the Tatum API Reference!  ## What is Tatum?  Tatum offers a flexible framework to build, run, and scale blockchain apps fast. To learn more about the Tatum blockchain development framework, visit [our website](https://tatum.io/framework).  The Tatum API features powerful endpoints that simplify a complex blockchain into single API requests. Code for all supported blockchains using unified API calls.  ## Need help?  To chat with other developers, get help from the Support team, and engage with the thriving Tatum community, join  our [Discord server](https://discord.com/invite/tatum). For more information about how to work with Tatum, review the [online documentation](https://docs.tatum.io/).  ## About this API Reference  The Tatum API Reference is based on OpenAPI Specification v3.1.0 with a few [vendor extensions](https://github.com/Redocly/redoc/blob/master/docs/redoc-vendor-extensions.md) applied.  # Authentication  When using the Tatum API, you authenticate yourself with an **API key**. <SecurityDefinitions /> 
 *
 * The version of the OpenAPI document: 3.17.0
 * Generated by: https://github.com/openapitools/openapi-generator.git
 */


using System;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.Linq;
using System.Net;
using System.Net.Http;
using System.Net.Mime;
using Tatum.CSharp.Bsc.Core.Client;
using Tatum.CSharp.Bsc.Core.Model;

namespace Tatum.CSharp.Bsc.Core.Api
{

    /// <summary>
    /// Represents a collection of functions to interact with the API endpoints
    /// </summary>
    public interface INFTBscApiSync : IApiAccessor
    {
        #region Synchronous Operations
        /// <summary>
        /// Add an NFT minter to an NFT smart contract
        /// </summary>
        /// <remarks>
        /// 2 credits per API call Allow a blockchain address (the minter parameter in the request body) to mint NFTs on the NFT smart contract (the contractAddress parameter in the request body). Use this API when you are using NFT Express with your own smart contract to mint NFTs and need to add the Tatum NFT minter&#39;s address as an NFT minter to your smart contract. For more information about the Tatum NFT minter, see \&quot;Use your own smart contract to mint NFTs\&quot; in Mint an NFT. This API is supported for the following blockchains: BNB Smart Chain Celo Ethereum Harmony Klaytn KuCoin Community Chain Polygon Signing a transaction When adding an NFT minter, you are charged a fee for the transaction, and you must sign the transaction with the private key of the blockchain address from which the fee will be deducted. Providing the private key in the API is not a secure way of signing transactions, because the private key can be stolen or exposed. Your private keys should never leave your security perimeter. You should use the private keys only for testing a solution you are building on the testnet of a blockchain. For signing transactions on the mainnet, we strongly recommend that you use the Tatum Key Management System (KMS) and provide the signature ID instead of the private key in the API. Alternatively, you can use the Tatum JavaScript client.
        /// </remarks>
        /// <exception cref="Tatum.CSharp.Bsc.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="addNftMinter"></param>
        /// <param name="xTestnetType">Type of Ethereum testnet. Defaults to Sepolia. Valid only for ETH invocations for testnet API Key. For mainnet API Key, this value is ignored. (optional, default to ethereum-sepolia)</param>
        /// <returns>TransactionHash</returns>
        TransactionHash NftAddMinter(AddNftMinter addNftMinter, string xTestnetType = default(string));
        /// <summary>
        /// Add an NFT minter to an NFT smart contract
        /// </summary>
        /// <remarks>
        /// 2 credits per API call Allow a blockchain address (the minter parameter in the request body) to mint NFTs on the NFT smart contract (the contractAddress parameter in the request body). Use this API when you are using NFT Express with your own smart contract to mint NFTs and need to add the Tatum NFT minter&#39;s address as an NFT minter to your smart contract. For more information about the Tatum NFT minter, see \&quot;Use your own smart contract to mint NFTs\&quot; in Mint an NFT. This API is supported for the following blockchains: BNB Smart Chain Celo Ethereum Harmony Klaytn KuCoin Community Chain Polygon Signing a transaction When adding an NFT minter, you are charged a fee for the transaction, and you must sign the transaction with the private key of the blockchain address from which the fee will be deducted. Providing the private key in the API is not a secure way of signing transactions, because the private key can be stolen or exposed. Your private keys should never leave your security perimeter. You should use the private keys only for testing a solution you are building on the testnet of a blockchain. For signing transactions on the mainnet, we strongly recommend that you use the Tatum Key Management System (KMS) and provide the signature ID instead of the private key in the API. Alternatively, you can use the Tatum JavaScript client.
        /// </remarks>
        /// <exception cref="Tatum.CSharp.Bsc.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="addNftMinterKMS"></param>
        /// <param name="xTestnetType">Type of Ethereum testnet. Defaults to Sepolia. Valid only for ETH invocations for testnet API Key. For mainnet API Key, this value is ignored. (optional, default to ethereum-sepolia)</param>
        /// <returns>SignatureId</returns>
        SignatureId NftAddMinter(AddNftMinterKMS addNftMinterKMS, string xTestnetType = default(string));
        /// <summary>
        /// Burn an NFT
        /// </summary>
        /// <remarks>
        /// 100 credits per API call on Flow 2 credits per API call on the other blockchains Destroy an NFT. Burning the NFT transfers it to an un-spendable blockchain address that no one can access. This API is supported for the following blockchains: Algorand BNB Smart Chain Celo Ethereum Flow Harmony Klaytn KuCoin Community Chain Polygon TRON Burning NFTs on Algorand You can burn only the NFTs that were minted with the address of the manager account specified in the manager parameter in the minting call (see the MintNftExpressAlgorand, MintNftAlgorand, and MintNftAlgorandKMS schemas of the request body). Signing a transaction When burning an NFT, you are charged a fee for the transaction, and you must sign the transaction with the private key of the blockchain address from which the fee will be deducted. Providing the private key in the API is not a secure way of signing transactions, because the private key can be stolen or exposed. Your private keys should never leave your security perimeter. You should use the private keys only for testing a solution you are building on the testnet of a blockchain. For signing transactions on the mainnet, we strongly recommend that you use the Tatum Key Management System (KMS) and provide the signature ID instead of the private key in the API. Alternatively, you can use the Tatum JavaScript client.
        /// </remarks>
        /// <exception cref="Tatum.CSharp.Bsc.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="burnNft"></param>
        /// <param name="xTestnetType">Type of Ethereum testnet. Defaults to Sepolia. Valid only for ETH invocations for testnet API Key. For mainnet API Key, this value is ignored. (optional, default to ethereum-sepolia)</param>
        /// <returns>TransactionHash</returns>
        TransactionHash NftBurnErc721(BurnNft burnNft, string xTestnetType = default(string));
        /// <summary>
        /// Burn an NFT
        /// </summary>
        /// <remarks>
        /// 100 credits per API call on Flow 2 credits per API call on the other blockchains Destroy an NFT. Burning the NFT transfers it to an un-spendable blockchain address that no one can access. This API is supported for the following blockchains: Algorand BNB Smart Chain Celo Ethereum Flow Harmony Klaytn KuCoin Community Chain Polygon TRON Burning NFTs on Algorand You can burn only the NFTs that were minted with the address of the manager account specified in the manager parameter in the minting call (see the MintNftExpressAlgorand, MintNftAlgorand, and MintNftAlgorandKMS schemas of the request body). Signing a transaction When burning an NFT, you are charged a fee for the transaction, and you must sign the transaction with the private key of the blockchain address from which the fee will be deducted. Providing the private key in the API is not a secure way of signing transactions, because the private key can be stolen or exposed. Your private keys should never leave your security perimeter. You should use the private keys only for testing a solution you are building on the testnet of a blockchain. For signing transactions on the mainnet, we strongly recommend that you use the Tatum Key Management System (KMS) and provide the signature ID instead of the private key in the API. Alternatively, you can use the Tatum JavaScript client.
        /// </remarks>
        /// <exception cref="Tatum.CSharp.Bsc.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="burnNftKMS"></param>
        /// <param name="xTestnetType">Type of Ethereum testnet. Defaults to Sepolia. Valid only for ETH invocations for testnet API Key. For mainnet API Key, this value is ignored. (optional, default to ethereum-sepolia)</param>
        /// <returns>SignatureId</returns>
        SignatureId NftBurnErc721(BurnNftKMS burnNftKMS, string xTestnetType = default(string));
        /// <summary>
        /// Deploy an NFT smart contract
        /// </summary>
        /// <remarks>
        /// 100 credits per API call on Flow 2 credits per API call on the other blockchains Deploy an NFT smart contract on the blockchain. In a deployed NFT smart contract, you can mint NFTs (one NFT at a time or multiple NFTs at once), burn, and transfer NFTs. Smart contracts are standardized and audited. You can review the code of a deployed NFT smart contract here (if the contract is deployed on Flow) or here (if the contract is deployed on any other supported blockchain). This API is supported for the following blockchains: BNB Smart Chain Celo Ethereum Flow Harmony Klaytn KuCoin Community Chain Polygon TRON General NFT smart contracts By default, an NFT smart contract is deployed as a general NFT smart contract compatible with OpenSea royalties. This is a standard NFT contract with AccessControl and Ownable, enhanced with NFT batch minting. NFTs minted on this smart contract are compatible with OpenSea and its royalty structure. Cashback and provenance NFT smart contracts In addition to the general NFT contract, you can deploy the following types of NFT smart contracts for the supported blockchains except for Flow and TRON: Cashback NFT smart contract is an NFT smart contract that forces on-chain royalties to be paid every time an NFT is transferred, and the royalties are defined as a fixed value. The royalties are not OpenSea-compatible. To deploy an NFT smart contract as a cashback contract, deploy the contract with the cashback parameter set to true in the request body. Provenance NFT smart contract is an NFT smart contract that forces on-chain royalties to be paid every time an NFT is transferred, and the royalties are defined as a percentage of the NFT price. The royalties are not OpenSea-compatible. To deploy an NFT smart contract as a provenance contract, deploy the contract with the provenance parameter set to true in the request body. You can enable public minting for cashback and provenance smart contracts. By default, public minting is disabled, which means that only the blockchain address whose private key was used to create the smart contract or the blockchain addresses added to the smart contract as NFT minters will be able to mint NFTs for the contract. To enable public minting and allow anyone to mint NFTs on top of the smart contract, deploy the contract with the publicMint parameter set to true in the request body. NFT smart contracts and NFT Express If you want to use NFT Express to mint NFTs on the deployed smart contract, deploy the smart contract as a general NFT smart contract (that is, deploy the contract with the cashback, provenance, and publicMint parameters either set to false or not set at all in the request body). After you have deployed the NFT smart contract, add the Tatum minter address as an NFT minter to your smart contract. For the complete information about using NFT Express on your smart contract, see \&quot;Use your own smart contract to mint NFTs\&quot; in Mint an NFT. Signing a transaction When deploying an NFT smart contract, you are charged a fee for the transaction, and you must sign the transaction with the private key of the blockchain address from which the fee will be deducted. Providing the private key in the API is not a secure way of signing transactions, because the private key can be stolen or exposed. Your private keys should never leave your security perimeter. You should use the private keys only for testing a solution you are building on the testnet of a blockchain. For signing transactions on the mainnet, we strongly recommend that you use the Tatum Key Management System (KMS) and provide the signature ID instead of the private key in the API. Alternatively, you can use the Tatum JavaScript client.
        /// </remarks>
        /// <exception cref="Tatum.CSharp.Bsc.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="deployNft"></param>
        /// <param name="xTestnetType">Type of Ethereum testnet. Defaults to Sepolia. Valid only for ETH invocations for testnet API Key. For mainnet API Key, this value is ignored. (optional, default to ethereum-sepolia)</param>
        /// <returns>TransactionHash</returns>
        TransactionHash NftDeployErc721(DeployNft deployNft, string xTestnetType = default(string));
        /// <summary>
        /// Deploy an NFT smart contract
        /// </summary>
        /// <remarks>
        /// 100 credits per API call on Flow 2 credits per API call on the other blockchains Deploy an NFT smart contract on the blockchain. In a deployed NFT smart contract, you can mint NFTs (one NFT at a time or multiple NFTs at once), burn, and transfer NFTs. Smart contracts are standardized and audited. You can review the code of a deployed NFT smart contract here (if the contract is deployed on Flow) or here (if the contract is deployed on any other supported blockchain). This API is supported for the following blockchains: BNB Smart Chain Celo Ethereum Flow Harmony Klaytn KuCoin Community Chain Polygon TRON General NFT smart contracts By default, an NFT smart contract is deployed as a general NFT smart contract compatible with OpenSea royalties. This is a standard NFT contract with AccessControl and Ownable, enhanced with NFT batch minting. NFTs minted on this smart contract are compatible with OpenSea and its royalty structure. Cashback and provenance NFT smart contracts In addition to the general NFT contract, you can deploy the following types of NFT smart contracts for the supported blockchains except for Flow and TRON: Cashback NFT smart contract is an NFT smart contract that forces on-chain royalties to be paid every time an NFT is transferred, and the royalties are defined as a fixed value. The royalties are not OpenSea-compatible. To deploy an NFT smart contract as a cashback contract, deploy the contract with the cashback parameter set to true in the request body. Provenance NFT smart contract is an NFT smart contract that forces on-chain royalties to be paid every time an NFT is transferred, and the royalties are defined as a percentage of the NFT price. The royalties are not OpenSea-compatible. To deploy an NFT smart contract as a provenance contract, deploy the contract with the provenance parameter set to true in the request body. You can enable public minting for cashback and provenance smart contracts. By default, public minting is disabled, which means that only the blockchain address whose private key was used to create the smart contract or the blockchain addresses added to the smart contract as NFT minters will be able to mint NFTs for the contract. To enable public minting and allow anyone to mint NFTs on top of the smart contract, deploy the contract with the publicMint parameter set to true in the request body. NFT smart contracts and NFT Express If you want to use NFT Express to mint NFTs on the deployed smart contract, deploy the smart contract as a general NFT smart contract (that is, deploy the contract with the cashback, provenance, and publicMint parameters either set to false or not set at all in the request body). After you have deployed the NFT smart contract, add the Tatum minter address as an NFT minter to your smart contract. For the complete information about using NFT Express on your smart contract, see \&quot;Use your own smart contract to mint NFTs\&quot; in Mint an NFT. Signing a transaction When deploying an NFT smart contract, you are charged a fee for the transaction, and you must sign the transaction with the private key of the blockchain address from which the fee will be deducted. Providing the private key in the API is not a secure way of signing transactions, because the private key can be stolen or exposed. Your private keys should never leave your security perimeter. You should use the private keys only for testing a solution you are building on the testnet of a blockchain. For signing transactions on the mainnet, we strongly recommend that you use the Tatum Key Management System (KMS) and provide the signature ID instead of the private key in the API. Alternatively, you can use the Tatum JavaScript client.
        /// </remarks>
        /// <exception cref="Tatum.CSharp.Bsc.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="deployNftKMS"></param>
        /// <param name="xTestnetType">Type of Ethereum testnet. Defaults to Sepolia. Valid only for ETH invocations for testnet API Key. For mainnet API Key, this value is ignored. (optional, default to ethereum-sepolia)</param>
        /// <returns>SignatureId</returns>
        SignatureId NftDeployErc721(DeployNftKMS deployNftKMS, string xTestnetType = default(string));
        /// <summary>
        /// Get the NFTs from a specific smart contract that a blockchain address holds
        /// </summary>
        /// <remarks>
        /// 1 credit per API call Get the NFTs minted on a specific smart contract (the contractAddress path parameter in the request endpoint URL) that a blockchain address holds. NOTE: This API works only for the NFT smart contracts deployed using the Tatum smart contract API. This API is supported for the following blockchains: Algorand BNB Smart Chain Celo Elrond Ethereum Flow Harmony Klaytn KuCoin Community Chain Polygon Solana TRON
        /// </remarks>
        /// <exception cref="Tatum.CSharp.Bsc.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="address">The blockchain address that you want to get the token balance of</param>
        /// <param name="contractAddress">The address of the NFT smart contract</param>
        /// <param name="xTestnetType">Type of Ethereum testnet. Defaults to Sepolia. Valid only for ETH invocations for testnet API Key. For mainnet API Key, this value is ignored. (optional, default to ethereum-sepolia)</param>
        /// <returns>NftGetBalanceSc</returns>
        NftGetBalanceSc NftGetBalanceErc721(string address, string contractAddress, string xTestnetType = default(string));
        /// <summary>
        /// Get NFT metadata
        /// </summary>
        /// <remarks>
        /// 1 credit per API call Get metadata of an NFT. This API is supported for the following blockchains: BNB Smart Chain Celo Ethereum Flow Harmony Klaytn KuCoin Community Chain Polygon Solana TRON
        /// </remarks>
        /// <exception cref="Tatum.CSharp.Bsc.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="contractAddress">The blockchain address of the NFT to get metadata for</param>
        /// <param name="tokenId">The ID of the NFT to get metadata for&lt;br/&gt;Do &lt;b&gt;not&lt;/b&gt; use this parameter if you are getting metadata for an NFT on Solana, this parameter is irrelevant on Solana.</param>
        /// <param name="account">(Flow only) The account that holds the NFT (optional)</param>
        /// <param name="xTestnetType">Type of Ethereum testnet. Defaults to Sepolia. Valid only for ETH invocations for testnet API Key. For mainnet API Key, this value is ignored. (optional, default to ethereum-sepolia)</param>
        /// <returns>NftMetadataErc721</returns>
        NftMetadataErc721 NftGetMetadataErc721(string contractAddress, string tokenId, string account = default(string), string xTestnetType = default(string));
        /// <summary>
        /// Get NFT provenance information
        /// </summary>
        /// <remarks>
        /// 1 credit per API call Get provenance information for an NFT. NOTE: This API works only for provenance NFT smart contracts. This API is supported for the following blockchains: BNB Smart Chain Celo Ethereum Harmony Klaytn KuCoin Community Chain Polygon
        /// </remarks>
        /// <exception cref="Tatum.CSharp.Bsc.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="contractAddress">The blockchain address of the NFT to get provenance information for</param>
        /// <param name="tokenId">The ID of the NFT to get provenance information for.</param>
        /// <param name="xTestnetType">Type of Ethereum testnet. Defaults to Sepolia. Valid only for ETH invocations for testnet API Key. For mainnet API Key, this value is ignored. (optional, default to ethereum-sepolia)</param>
        /// <returns>List&lt;NftProvenanceDataErc721&gt;</returns>
        List<NftProvenanceDataErc721> NftGetProvenanceDataErc721(string contractAddress, string tokenId, string xTestnetType = default(string));
        /// <summary>
        /// Get NFT royalty information
        /// </summary>
        /// <remarks>
        /// 1 credit per API call Get information about royalties for an NFT. This API is supported for the following blockchains: BNB Smart Chain Celo Ethereum Harmony Klaytn KuCoin Community Chain Polygon Solana TRON
        /// </remarks>
        /// <exception cref="Tatum.CSharp.Bsc.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="contractAddress">The blockchain address of the NFT to get royalty information for</param>
        /// <param name="tokenId">The ID of the NFT to get royalty information for&lt;br/&gt;Do &lt;b&gt;not&lt;/b&gt; use this parameter if you are getting metadata for an NFT on Solana, this parameter is irrelevant on Solana.</param>
        /// <param name="xTestnetType">Type of Ethereum testnet. Defaults to Sepolia. Valid only for ETH invocations for testnet API Key. For mainnet API Key, this value is ignored. (optional, default to ethereum-sepolia)</param>
        /// <returns>NftRoyaltyErc721</returns>
        NftRoyaltyErc721 NftGetRoyaltyErc721(string contractAddress, string tokenId, string xTestnetType = default(string));
        /// <summary>
        /// Get all NFTs that a blockchain address holds
        /// </summary>
        /// <remarks>
        /// 1 credit per API call + 5 credits for each owned NFT Get all NFTs that a blockchain address holds. The NFTs are returned grouped by the smart contracts they were minted on. This API is supported for the following blockchains: Algorand BNB Smart Chain - mainnet only Celo Ethereum Polygon Solana On Solana and Algorand, if a blockchain address holds fewer than 50 NFTs, the API also returns each NFT&#39;s metadata. If the metadata is not returned, you can obtain it using the API for getting NFT metadata.
        /// </remarks>
        /// <exception cref="Tatum.CSharp.Bsc.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="address">The blockchain address that you want to get the token balance of</param>
        /// <returns>List&lt;NftTokenByAddressErc721&gt;</returns>
        List<NftTokenByAddressErc721> NftGetTokensByAddressErc721(string address);
        /// <summary>
        /// Get an NFT transaction by its hash
        /// </summary>
        /// <remarks>
        /// 1 credit per API call Get an NFT transaction by its hash. This API is supported for the following blockchains: BNB Smart Chain Celo Ethereum Flow Harmony Klaytn KuCoin Community Chain Polygon TRON
        /// </remarks>
        /// <exception cref="Tatum.CSharp.Bsc.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="hash">The hash (ID) of the NFT transaction</param>
        /// <param name="xTestnetType">Type of Ethereum testnet. Defaults to Sepolia. Valid only for ETH invocations for testnet API Key. For mainnet API Key, this value is ignored. (optional, default to ethereum-sepolia)</param>
        /// <returns>EthTx</returns>
        EthTx NftGetTransactErc721(string hash, string xTestnetType = default(string));
        /// <summary>
        /// Mint an NFT
        /// </summary>
        /// <remarks>
        /// 100 credits per API call on Flow 2 credits per API call on the other blockchains You can mint NFTs using either of the following methods: Using NFT Express Natively on a blockchain Minting NFTs using NFT Express NFT Express is Tatum&#39;s feature that helps you mint NFTs easier than minting natively on a blockchain. You do not need to enter your private key or signature ID. NFT Express uses the private key provided by Tatum. You do not need to hold crypto or keep addresses topped up with crypto to pay for minting transactions. To use NFT Express on the mainnet, you have to have a paid pricing plan. Tatum covers your transaction fees for NFT minting and pays for them from its own blockchain address. Then, the fee amount paid by Tatum is converted to the number of credits, and these credits are deducted from the monthly credit allowance of your paid pricing plan. The transaction fees and the corresponding numbers of credits deducted from your allowance vary depending on what blockchain you mint NFTs on. On the testnet, no credits are deducted from the monthly credit allowance. You can mint NFTs with NFT Express regardless of your pricing plan. With NFT Express, you can choose whether to mint NFTs on the pre-built NFT smart contract provided by Tatum or on your own smart contract. Use the pre-built smart contract provided by Tatum to mint NFTs If you want to mint NFTs using the pre-built smart contract, you do not need to deploy your own NFT smart contract. You do not need to provide the address of the NFT smart contract and the token ID in the request body either. The address of the smart contract and the token ID are provided automatically by Tatum. The token ID is autogenerated. It starts with 0 and is increased by 1 for each new NFT. The token ID is calculated separately for each supported blockchain and its mainnet and testnet. For more information, see our user documentation. You can mint NFTs on the pre-built smart contract provided by Tatum on the following blockchains: Algorand BNB Smart Chain Celo Ethereum Harmony Klaytn Polygon Solana Depending on what blockchain you use, choose the request body schema to use in the API call. To mint NFTs on BNB Smart Chain, Celo, Ethereum, Harmony, Klaytn, or Polygon, use this API with the MintNftExpress schema of the request body. To mint NFTs on Algorand, use this API with the MintNftExpressAlgorand schema of the request body. To be able to burn the minted NFTs any time later, specify the address of the manager account in the manager parameter. An NFT minted on Algorand is automatically transferred to your blockchain address. After the NFT is minted, you have to transfer it to the recipient&#39;s address. The recipient has to agree in advance to receive your NFT because Algorand charges users for storing NFTs on their addresses, and an Algorand blockchain address by default does not receive NFTs unless explicitly agreed. This how it works: The recipient agrees to receive the NFT to their address. You transfer the NFT to the recipient&#39;s address (use the transferNftAlgoExpress schema of the request body). NOTE: On the mainnet, Tatum covers your transaction fees for the NFT transfer and pays for them from its own blockchain address. Then, the fee amount paid by Tatum is converted to the number of credits, and these credits are deducted from the monthly credit allowance of your paid pricing plan. On the testnet, no credits are deducted from the monthly credit allowance. To mint NFTs on Solana, use this API with the MintNftExpressSolana schema of the request body. Solana uses the Metaplex Protocol, a smart contract and metadata standard for creating and working with NFTs. When you mint an NFT on Solana with NFT Express, the pre-built smart contract based on the Metaplex Protocol is used. When an NFT is minted on Solana, a new blockchain address is created to receive the NFT under the recipient&#39;s account address (the one in the to parameter of the request body). This address is returned in the nftAccountAddress parameter in the response body, is owned by the recipient&#39;s address, and has the same private key. The response body also returns the address of the minted NFT itself, which is held in the nftAddress parameter. After the NFT is minted, you have to transfer it to the recipient&#39;s address (use the transferNftSolana or transferNftSolanaKMS schema of the request body). In the request body of the transfer call: Set the from parameter to the address that you used in the to parameter in the request body of the minting call. Set the to parameter to the recipient&#39;s address. Set the contractAddress parameter to the address from the nftAddress parameter returned in the response body of the minting call. Set the fromPrivateKey/signatureId parameter to the private key/signature ID of the blockchain address that you specified in the from parameter. Use your own smart contract to mint NFTs If you want to mint NFTs using your own smart contract, you are going to use an NTF minter, a special blockchain address provided by Tatum that will cover the minting fees. The number of credits equivalent to the fees will be then deducted from the monthly credit allowance of your paid pricing plan. IMPORTANT! Your smart contract must be deployed as a general NFT smart contract. You cannot use cashback and provenance smart contracts with NFT Express. For more information, see our user documentation and the article in the Tatum blog. You can mint NFTs on your own smart contract on the following blockchains: BNB Smart Chain Celo Ethereum Harmony Klaytn Polygon To mint NFTs using your own smart contract, do the following: In the table located under this section, find the blockchain address of the Tatum NFT minter for your blockchain and network (mainnet or testnet). Add the minter address as an NFT minter to your smart contract. Use this API with the MintNftMinter schema of the request body. In the request body, enter the following information: chain is the blockchain that you use. to is the blockchain address where to send the minted NFT to. url is the URL of the NFT metadata. minter is the address of the NFT minter that you found in Step 1. contractAddress is the address of your NFT smart contract. tokenId is the the token ID of the NFT. For example:  {   \&quot;chain\&quot;: \&quot;CELO\&quot;,   \&quot;to\&quot;: \&quot;0x8ce4e40889a13971681391aad29e88efaf91f784\&quot;,   \&quot;url\&quot;: \&quot;ipfs://QmXJJ6UF5WkF4WTJvsdhiA1etGwBLfpva7Vr9AudGMe3pj\&quot;,   \&quot;contractAddress\&quot;: \&quot;0x687422eEA2cB73B5d3e242bA5456b782919AFc85\&quot;,   \&quot;tokenId\&quot;: \&quot;0123\&quot;,   \&quot;minter\&quot;: \&quot;0xBC2eBA680EE50d685cc4Fe65f102AA70AfB27D3F\&quot; } When you make an API call with this request body, the private key of the NFT minter will be added to the request body automatically:  {   \&quot;chain\&quot;: \&quot;CELO\&quot;,   \&quot;to\&quot;: \&quot;0x8ce4e40889a13971681391aad29e88efaf91f784\&quot;,   \&quot;url\&quot;: \&quot;ipfs://QmXJJ6UF5WkF4WTJvsdhiA1etGwBLfpva7Vr9AudGMe3pj\&quot;,   \&quot;contractAddress\&quot;: \&quot;0x687422eEA2cB73B5d3e242bA5456b782919AFc85\&quot;,   \&quot;tokenId\&quot;: \&quot;0123\&quot;,   \&quot;minter\&quot;: \&quot;0xBC2eBA680EE50d685cc4Fe65f102AA70AfB27D3F\&quot;,   \&quot;fromPrivateKey\&quot;: \&quot;0x05e150c73f1920ec14caa1e0b6aa09940899678051a78542840c2668ce5080c2\&quot; } The following table lists the blockchain addresses of the Tatum NFT minters for the testnet and mainnet of the supported blockchains: Blockchain Minter address - testnet* Minter address - mainnet BNB Smart Chain 0xc16ae5e8c985b906935a0cadf4e24f0400531883 0x49678AAB11E001eb3cB2cBD9aA96b36DC2461A94 Celo 0xBC2eBA680EE50d685cc4Fe65f102AA70AfB27D3F 0x49678AAB11E001eb3cB2cBD9aA96b36DC2461A94 Ethereum 0x53e8577C4347C365E4e0DA5B57A589cB6f2AB848 0x49678AAB11E001eb3cB2cBD9aA96b36DC2461A94 Harmony 0x8906f62d40293ddca77fdf6714c3f63265deddf0 0x49678AAB11E001eb3cB2cBD9aA96b36DC2461A94 Klaytn 0x80d8bac9a6901698b3749fe336bbd1385c1f98f2 0x49678AAB11E001eb3cB2cBD9aA96b36DC2461A94 Polygon 0x542b9ac4945a3836fd12ad98acbc76a0c8b743f5 0x49678AAB11E001eb3cB2cBD9aA96b36DC2461A94 *If a minter blockchain address on the testnet does not have sufficient funds to cover the transaction fee, add some amount to it using a crypto faucet of the blockchain. Minting NFTs natively on a blockchain When minting an NFT natively on a blockchain, you are charged a fee for the transaction, and you must sign the transaction with the private key of the blockchain address from which the fee will be deducted. Providing the private key in the API is not a secure way of signing transactions, because the private key can be stolen or exposed. Your private keys should never leave your security perimeter. You should use the private keys only for testing a solution you are building on the testnet of a blockchain. For signing transactions on the mainnet, we strongly recommend that you use the Tatum Key Management System (KMS) and provide the signature ID instead of the private key in the API. Alternatively, you can use the Tatum JavaScript client. You can mint NFTs natively on the following blockchains: Algorand BNB Smart Chain Celo Ethereum Flow Harmony Klaytn KuCoin Community Chain Polygon Solana TRON Depending on what blockchain you use, choose the request body schema to use in the API call. To mint NFTs natively on Algorand and: To sign the transaction with your private key, use this API with the MintNftAlgorand schema of the request body. To sign the transaction with your signature ID, use this API the MintNftAlgorandKMS schema of the request body. NOTE: To be able to burn the minted NFTs any time later, specify the address of the manager account in the manager parameter. An NFT minted on Algorand is automatically transferred to your blockchain address. After the NFT is minted, you have to transfer it to the recipient&#39;s address. The recipient has to agree in advance to receive your NFT because Algorand charges users for storing NFTs on their addresses, and an Algorand blockchain address by default does not receive NFTs unless explicitly agreed. For more information about how it works, see the section about minting NFTs on Algorand using the pre-built NFT smart contract provided by Tatum. To mint NFTs natively on BNB Smart Chain, Ethereum, Harmony, Klaytn, KuCoin Community Chain, or Polygon, and: To sign the transaction with your private key, use this API with the MintNft schema of the request body. To sign the transaction with your signature ID, use this API the MintNftKMS schema of the request body. To mint NFTs natively on Celo and: To sign the transaction with your private key, use this API with the MintNftCelo schema of the request body. To sign the transaction with your signature ID, use this API the MintNftKMSCelo schema of the request body. To mint NFTs natively on Flow and: To sign the transaction with your private key, use this API with the MintNftFlowPK schema of the request body. To sign the transaction with your signature ID, use this API the MintNftFlowMnemonic schema of the request body. To sign the transaction with your wallet mnemonic, use this API the MintNftFlowKMS schema of the request body. To mint NFTs natively on Solana and: To sign the transaction with your private key, use this API with the MintNftSolana schema of the request body. To sign the transaction with your signature ID, use this API the MintNftSolanaKMS schema of the request body. NOTE: When an NFT is minted on Solana, a new blockchain address is created to receive the NFT under the recipient&#39;s account address. After the NFT is minted, you have to transfer it to the recipient&#39;s address. For more information about how it works, see the section about minting NFTs on Solana using the pre-built NFT smart contract provided by Tatum. To mint NFTs natively on TRON and: To sign the transaction with your private key, use this API with the MintNftTron schema of the request body. To sign the transaction with your signature ID, use this API the MintNftKMSTron schema of the request body.
        /// </remarks>
        /// <exception cref="Tatum.CSharp.Bsc.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="mintNftExpress"></param>
        /// <param name="xTestnetType">Type of Ethereum testnet. Defaults to Sepolia. Valid only for ETH invocations for testnet API Key. For mainnet API Key, this value is ignored. (optional, default to ethereum-sepolia)</param>
        /// <returns>TransactionHash</returns>
        TransactionHash NftMintErc721(MintNftExpress mintNftExpress, string xTestnetType = default(string));
        /// <summary>
        /// Mint an NFT
        /// </summary>
        /// <remarks>
        /// 100 credits per API call on Flow 2 credits per API call on the other blockchains You can mint NFTs using either of the following methods: Using NFT Express Natively on a blockchain Minting NFTs using NFT Express NFT Express is Tatum&#39;s feature that helps you mint NFTs easier than minting natively on a blockchain. You do not need to enter your private key or signature ID. NFT Express uses the private key provided by Tatum. You do not need to hold crypto or keep addresses topped up with crypto to pay for minting transactions. To use NFT Express on the mainnet, you have to have a paid pricing plan. Tatum covers your transaction fees for NFT minting and pays for them from its own blockchain address. Then, the fee amount paid by Tatum is converted to the number of credits, and these credits are deducted from the monthly credit allowance of your paid pricing plan. The transaction fees and the corresponding numbers of credits deducted from your allowance vary depending on what blockchain you mint NFTs on. On the testnet, no credits are deducted from the monthly credit allowance. You can mint NFTs with NFT Express regardless of your pricing plan. With NFT Express, you can choose whether to mint NFTs on the pre-built NFT smart contract provided by Tatum or on your own smart contract. Use the pre-built smart contract provided by Tatum to mint NFTs If you want to mint NFTs using the pre-built smart contract, you do not need to deploy your own NFT smart contract. You do not need to provide the address of the NFT smart contract and the token ID in the request body either. The address of the smart contract and the token ID are provided automatically by Tatum. The token ID is autogenerated. It starts with 0 and is increased by 1 for each new NFT. The token ID is calculated separately for each supported blockchain and its mainnet and testnet. For more information, see our user documentation. You can mint NFTs on the pre-built smart contract provided by Tatum on the following blockchains: Algorand BNB Smart Chain Celo Ethereum Harmony Klaytn Polygon Solana Depending on what blockchain you use, choose the request body schema to use in the API call. To mint NFTs on BNB Smart Chain, Celo, Ethereum, Harmony, Klaytn, or Polygon, use this API with the MintNftExpress schema of the request body. To mint NFTs on Algorand, use this API with the MintNftExpressAlgorand schema of the request body. To be able to burn the minted NFTs any time later, specify the address of the manager account in the manager parameter. An NFT minted on Algorand is automatically transferred to your blockchain address. After the NFT is minted, you have to transfer it to the recipient&#39;s address. The recipient has to agree in advance to receive your NFT because Algorand charges users for storing NFTs on their addresses, and an Algorand blockchain address by default does not receive NFTs unless explicitly agreed. This how it works: The recipient agrees to receive the NFT to their address. You transfer the NFT to the recipient&#39;s address (use the transferNftAlgoExpress schema of the request body). NOTE: On the mainnet, Tatum covers your transaction fees for the NFT transfer and pays for them from its own blockchain address. Then, the fee amount paid by Tatum is converted to the number of credits, and these credits are deducted from the monthly credit allowance of your paid pricing plan. On the testnet, no credits are deducted from the monthly credit allowance. To mint NFTs on Solana, use this API with the MintNftExpressSolana schema of the request body. Solana uses the Metaplex Protocol, a smart contract and metadata standard for creating and working with NFTs. When you mint an NFT on Solana with NFT Express, the pre-built smart contract based on the Metaplex Protocol is used. When an NFT is minted on Solana, a new blockchain address is created to receive the NFT under the recipient&#39;s account address (the one in the to parameter of the request body). This address is returned in the nftAccountAddress parameter in the response body, is owned by the recipient&#39;s address, and has the same private key. The response body also returns the address of the minted NFT itself, which is held in the nftAddress parameter. After the NFT is minted, you have to transfer it to the recipient&#39;s address (use the transferNftSolana or transferNftSolanaKMS schema of the request body). In the request body of the transfer call: Set the from parameter to the address that you used in the to parameter in the request body of the minting call. Set the to parameter to the recipient&#39;s address. Set the contractAddress parameter to the address from the nftAddress parameter returned in the response body of the minting call. Set the fromPrivateKey/signatureId parameter to the private key/signature ID of the blockchain address that you specified in the from parameter. Use your own smart contract to mint NFTs If you want to mint NFTs using your own smart contract, you are going to use an NTF minter, a special blockchain address provided by Tatum that will cover the minting fees. The number of credits equivalent to the fees will be then deducted from the monthly credit allowance of your paid pricing plan. IMPORTANT! Your smart contract must be deployed as a general NFT smart contract. You cannot use cashback and provenance smart contracts with NFT Express. For more information, see our user documentation and the article in the Tatum blog. You can mint NFTs on your own smart contract on the following blockchains: BNB Smart Chain Celo Ethereum Harmony Klaytn Polygon To mint NFTs using your own smart contract, do the following: In the table located under this section, find the blockchain address of the Tatum NFT minter for your blockchain and network (mainnet or testnet). Add the minter address as an NFT minter to your smart contract. Use this API with the MintNftMinter schema of the request body. In the request body, enter the following information: chain is the blockchain that you use. to is the blockchain address where to send the minted NFT to. url is the URL of the NFT metadata. minter is the address of the NFT minter that you found in Step 1. contractAddress is the address of your NFT smart contract. tokenId is the the token ID of the NFT. For example:  {   \&quot;chain\&quot;: \&quot;CELO\&quot;,   \&quot;to\&quot;: \&quot;0x8ce4e40889a13971681391aad29e88efaf91f784\&quot;,   \&quot;url\&quot;: \&quot;ipfs://QmXJJ6UF5WkF4WTJvsdhiA1etGwBLfpva7Vr9AudGMe3pj\&quot;,   \&quot;contractAddress\&quot;: \&quot;0x687422eEA2cB73B5d3e242bA5456b782919AFc85\&quot;,   \&quot;tokenId\&quot;: \&quot;0123\&quot;,   \&quot;minter\&quot;: \&quot;0xBC2eBA680EE50d685cc4Fe65f102AA70AfB27D3F\&quot; } When you make an API call with this request body, the private key of the NFT minter will be added to the request body automatically:  {   \&quot;chain\&quot;: \&quot;CELO\&quot;,   \&quot;to\&quot;: \&quot;0x8ce4e40889a13971681391aad29e88efaf91f784\&quot;,   \&quot;url\&quot;: \&quot;ipfs://QmXJJ6UF5WkF4WTJvsdhiA1etGwBLfpva7Vr9AudGMe3pj\&quot;,   \&quot;contractAddress\&quot;: \&quot;0x687422eEA2cB73B5d3e242bA5456b782919AFc85\&quot;,   \&quot;tokenId\&quot;: \&quot;0123\&quot;,   \&quot;minter\&quot;: \&quot;0xBC2eBA680EE50d685cc4Fe65f102AA70AfB27D3F\&quot;,   \&quot;fromPrivateKey\&quot;: \&quot;0x05e150c73f1920ec14caa1e0b6aa09940899678051a78542840c2668ce5080c2\&quot; } The following table lists the blockchain addresses of the Tatum NFT minters for the testnet and mainnet of the supported blockchains: Blockchain Minter address - testnet* Minter address - mainnet BNB Smart Chain 0xc16ae5e8c985b906935a0cadf4e24f0400531883 0x49678AAB11E001eb3cB2cBD9aA96b36DC2461A94 Celo 0xBC2eBA680EE50d685cc4Fe65f102AA70AfB27D3F 0x49678AAB11E001eb3cB2cBD9aA96b36DC2461A94 Ethereum 0x53e8577C4347C365E4e0DA5B57A589cB6f2AB848 0x49678AAB11E001eb3cB2cBD9aA96b36DC2461A94 Harmony 0x8906f62d40293ddca77fdf6714c3f63265deddf0 0x49678AAB11E001eb3cB2cBD9aA96b36DC2461A94 Klaytn 0x80d8bac9a6901698b3749fe336bbd1385c1f98f2 0x49678AAB11E001eb3cB2cBD9aA96b36DC2461A94 Polygon 0x542b9ac4945a3836fd12ad98acbc76a0c8b743f5 0x49678AAB11E001eb3cB2cBD9aA96b36DC2461A94 *If a minter blockchain address on the testnet does not have sufficient funds to cover the transaction fee, add some amount to it using a crypto faucet of the blockchain. Minting NFTs natively on a blockchain When minting an NFT natively on a blockchain, you are charged a fee for the transaction, and you must sign the transaction with the private key of the blockchain address from which the fee will be deducted. Providing the private key in the API is not a secure way of signing transactions, because the private key can be stolen or exposed. Your private keys should never leave your security perimeter. You should use the private keys only for testing a solution you are building on the testnet of a blockchain. For signing transactions on the mainnet, we strongly recommend that you use the Tatum Key Management System (KMS) and provide the signature ID instead of the private key in the API. Alternatively, you can use the Tatum JavaScript client. You can mint NFTs natively on the following blockchains: Algorand BNB Smart Chain Celo Ethereum Flow Harmony Klaytn KuCoin Community Chain Polygon Solana TRON Depending on what blockchain you use, choose the request body schema to use in the API call. To mint NFTs natively on Algorand and: To sign the transaction with your private key, use this API with the MintNftAlgorand schema of the request body. To sign the transaction with your signature ID, use this API the MintNftAlgorandKMS schema of the request body. NOTE: To be able to burn the minted NFTs any time later, specify the address of the manager account in the manager parameter. An NFT minted on Algorand is automatically transferred to your blockchain address. After the NFT is minted, you have to transfer it to the recipient&#39;s address. The recipient has to agree in advance to receive your NFT because Algorand charges users for storing NFTs on their addresses, and an Algorand blockchain address by default does not receive NFTs unless explicitly agreed. For more information about how it works, see the section about minting NFTs on Algorand using the pre-built NFT smart contract provided by Tatum. To mint NFTs natively on BNB Smart Chain, Ethereum, Harmony, Klaytn, KuCoin Community Chain, or Polygon, and: To sign the transaction with your private key, use this API with the MintNft schema of the request body. To sign the transaction with your signature ID, use this API the MintNftKMS schema of the request body. To mint NFTs natively on Celo and: To sign the transaction with your private key, use this API with the MintNftCelo schema of the request body. To sign the transaction with your signature ID, use this API the MintNftKMSCelo schema of the request body. To mint NFTs natively on Flow and: To sign the transaction with your private key, use this API with the MintNftFlowPK schema of the request body. To sign the transaction with your signature ID, use this API the MintNftFlowMnemonic schema of the request body. To sign the transaction with your wallet mnemonic, use this API the MintNftFlowKMS schema of the request body. To mint NFTs natively on Solana and: To sign the transaction with your private key, use this API with the MintNftSolana schema of the request body. To sign the transaction with your signature ID, use this API the MintNftSolanaKMS schema of the request body. NOTE: When an NFT is minted on Solana, a new blockchain address is created to receive the NFT under the recipient&#39;s account address. After the NFT is minted, you have to transfer it to the recipient&#39;s address. For more information about how it works, see the section about minting NFTs on Solana using the pre-built NFT smart contract provided by Tatum. To mint NFTs natively on TRON and: To sign the transaction with your private key, use this API with the MintNftTron schema of the request body. To sign the transaction with your signature ID, use this API the MintNftKMSTron schema of the request body.
        /// </remarks>
        /// <exception cref="Tatum.CSharp.Bsc.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="mintNftMinter"></param>
        /// <param name="xTestnetType">Type of Ethereum testnet. Defaults to Sepolia. Valid only for ETH invocations for testnet API Key. For mainnet API Key, this value is ignored. (optional, default to ethereum-sepolia)</param>
        /// <returns>TransactionHash</returns>
        TransactionHash NftMintErc721(MintNftMinter mintNftMinter, string xTestnetType = default(string));
        /// <summary>
        /// Mint an NFT
        /// </summary>
        /// <remarks>
        /// 100 credits per API call on Flow 2 credits per API call on the other blockchains You can mint NFTs using either of the following methods: Using NFT Express Natively on a blockchain Minting NFTs using NFT Express NFT Express is Tatum&#39;s feature that helps you mint NFTs easier than minting natively on a blockchain. You do not need to enter your private key or signature ID. NFT Express uses the private key provided by Tatum. You do not need to hold crypto or keep addresses topped up with crypto to pay for minting transactions. To use NFT Express on the mainnet, you have to have a paid pricing plan. Tatum covers your transaction fees for NFT minting and pays for them from its own blockchain address. Then, the fee amount paid by Tatum is converted to the number of credits, and these credits are deducted from the monthly credit allowance of your paid pricing plan. The transaction fees and the corresponding numbers of credits deducted from your allowance vary depending on what blockchain you mint NFTs on. On the testnet, no credits are deducted from the monthly credit allowance. You can mint NFTs with NFT Express regardless of your pricing plan. With NFT Express, you can choose whether to mint NFTs on the pre-built NFT smart contract provided by Tatum or on your own smart contract. Use the pre-built smart contract provided by Tatum to mint NFTs If you want to mint NFTs using the pre-built smart contract, you do not need to deploy your own NFT smart contract. You do not need to provide the address of the NFT smart contract and the token ID in the request body either. The address of the smart contract and the token ID are provided automatically by Tatum. The token ID is autogenerated. It starts with 0 and is increased by 1 for each new NFT. The token ID is calculated separately for each supported blockchain and its mainnet and testnet. For more information, see our user documentation. You can mint NFTs on the pre-built smart contract provided by Tatum on the following blockchains: Algorand BNB Smart Chain Celo Ethereum Harmony Klaytn Polygon Solana Depending on what blockchain you use, choose the request body schema to use in the API call. To mint NFTs on BNB Smart Chain, Celo, Ethereum, Harmony, Klaytn, or Polygon, use this API with the MintNftExpress schema of the request body. To mint NFTs on Algorand, use this API with the MintNftExpressAlgorand schema of the request body. To be able to burn the minted NFTs any time later, specify the address of the manager account in the manager parameter. An NFT minted on Algorand is automatically transferred to your blockchain address. After the NFT is minted, you have to transfer it to the recipient&#39;s address. The recipient has to agree in advance to receive your NFT because Algorand charges users for storing NFTs on their addresses, and an Algorand blockchain address by default does not receive NFTs unless explicitly agreed. This how it works: The recipient agrees to receive the NFT to their address. You transfer the NFT to the recipient&#39;s address (use the transferNftAlgoExpress schema of the request body). NOTE: On the mainnet, Tatum covers your transaction fees for the NFT transfer and pays for them from its own blockchain address. Then, the fee amount paid by Tatum is converted to the number of credits, and these credits are deducted from the monthly credit allowance of your paid pricing plan. On the testnet, no credits are deducted from the monthly credit allowance. To mint NFTs on Solana, use this API with the MintNftExpressSolana schema of the request body. Solana uses the Metaplex Protocol, a smart contract and metadata standard for creating and working with NFTs. When you mint an NFT on Solana with NFT Express, the pre-built smart contract based on the Metaplex Protocol is used. When an NFT is minted on Solana, a new blockchain address is created to receive the NFT under the recipient&#39;s account address (the one in the to parameter of the request body). This address is returned in the nftAccountAddress parameter in the response body, is owned by the recipient&#39;s address, and has the same private key. The response body also returns the address of the minted NFT itself, which is held in the nftAddress parameter. After the NFT is minted, you have to transfer it to the recipient&#39;s address (use the transferNftSolana or transferNftSolanaKMS schema of the request body). In the request body of the transfer call: Set the from parameter to the address that you used in the to parameter in the request body of the minting call. Set the to parameter to the recipient&#39;s address. Set the contractAddress parameter to the address from the nftAddress parameter returned in the response body of the minting call. Set the fromPrivateKey/signatureId parameter to the private key/signature ID of the blockchain address that you specified in the from parameter. Use your own smart contract to mint NFTs If you want to mint NFTs using your own smart contract, you are going to use an NTF minter, a special blockchain address provided by Tatum that will cover the minting fees. The number of credits equivalent to the fees will be then deducted from the monthly credit allowance of your paid pricing plan. IMPORTANT! Your smart contract must be deployed as a general NFT smart contract. You cannot use cashback and provenance smart contracts with NFT Express. For more information, see our user documentation and the article in the Tatum blog. You can mint NFTs on your own smart contract on the following blockchains: BNB Smart Chain Celo Ethereum Harmony Klaytn Polygon To mint NFTs using your own smart contract, do the following: In the table located under this section, find the blockchain address of the Tatum NFT minter for your blockchain and network (mainnet or testnet). Add the minter address as an NFT minter to your smart contract. Use this API with the MintNftMinter schema of the request body. In the request body, enter the following information: chain is the blockchain that you use. to is the blockchain address where to send the minted NFT to. url is the URL of the NFT metadata. minter is the address of the NFT minter that you found in Step 1. contractAddress is the address of your NFT smart contract. tokenId is the the token ID of the NFT. For example:  {   \&quot;chain\&quot;: \&quot;CELO\&quot;,   \&quot;to\&quot;: \&quot;0x8ce4e40889a13971681391aad29e88efaf91f784\&quot;,   \&quot;url\&quot;: \&quot;ipfs://QmXJJ6UF5WkF4WTJvsdhiA1etGwBLfpva7Vr9AudGMe3pj\&quot;,   \&quot;contractAddress\&quot;: \&quot;0x687422eEA2cB73B5d3e242bA5456b782919AFc85\&quot;,   \&quot;tokenId\&quot;: \&quot;0123\&quot;,   \&quot;minter\&quot;: \&quot;0xBC2eBA680EE50d685cc4Fe65f102AA70AfB27D3F\&quot; } When you make an API call with this request body, the private key of the NFT minter will be added to the request body automatically:  {   \&quot;chain\&quot;: \&quot;CELO\&quot;,   \&quot;to\&quot;: \&quot;0x8ce4e40889a13971681391aad29e88efaf91f784\&quot;,   \&quot;url\&quot;: \&quot;ipfs://QmXJJ6UF5WkF4WTJvsdhiA1etGwBLfpva7Vr9AudGMe3pj\&quot;,   \&quot;contractAddress\&quot;: \&quot;0x687422eEA2cB73B5d3e242bA5456b782919AFc85\&quot;,   \&quot;tokenId\&quot;: \&quot;0123\&quot;,   \&quot;minter\&quot;: \&quot;0xBC2eBA680EE50d685cc4Fe65f102AA70AfB27D3F\&quot;,   \&quot;fromPrivateKey\&quot;: \&quot;0x05e150c73f1920ec14caa1e0b6aa09940899678051a78542840c2668ce5080c2\&quot; } The following table lists the blockchain addresses of the Tatum NFT minters for the testnet and mainnet of the supported blockchains: Blockchain Minter address - testnet* Minter address - mainnet BNB Smart Chain 0xc16ae5e8c985b906935a0cadf4e24f0400531883 0x49678AAB11E001eb3cB2cBD9aA96b36DC2461A94 Celo 0xBC2eBA680EE50d685cc4Fe65f102AA70AfB27D3F 0x49678AAB11E001eb3cB2cBD9aA96b36DC2461A94 Ethereum 0x53e8577C4347C365E4e0DA5B57A589cB6f2AB848 0x49678AAB11E001eb3cB2cBD9aA96b36DC2461A94 Harmony 0x8906f62d40293ddca77fdf6714c3f63265deddf0 0x49678AAB11E001eb3cB2cBD9aA96b36DC2461A94 Klaytn 0x80d8bac9a6901698b3749fe336bbd1385c1f98f2 0x49678AAB11E001eb3cB2cBD9aA96b36DC2461A94 Polygon 0x542b9ac4945a3836fd12ad98acbc76a0c8b743f5 0x49678AAB11E001eb3cB2cBD9aA96b36DC2461A94 *If a minter blockchain address on the testnet does not have sufficient funds to cover the transaction fee, add some amount to it using a crypto faucet of the blockchain. Minting NFTs natively on a blockchain When minting an NFT natively on a blockchain, you are charged a fee for the transaction, and you must sign the transaction with the private key of the blockchain address from which the fee will be deducted. Providing the private key in the API is not a secure way of signing transactions, because the private key can be stolen or exposed. Your private keys should never leave your security perimeter. You should use the private keys only for testing a solution you are building on the testnet of a blockchain. For signing transactions on the mainnet, we strongly recommend that you use the Tatum Key Management System (KMS) and provide the signature ID instead of the private key in the API. Alternatively, you can use the Tatum JavaScript client. You can mint NFTs natively on the following blockchains: Algorand BNB Smart Chain Celo Ethereum Flow Harmony Klaytn KuCoin Community Chain Polygon Solana TRON Depending on what blockchain you use, choose the request body schema to use in the API call. To mint NFTs natively on Algorand and: To sign the transaction with your private key, use this API with the MintNftAlgorand schema of the request body. To sign the transaction with your signature ID, use this API the MintNftAlgorandKMS schema of the request body. NOTE: To be able to burn the minted NFTs any time later, specify the address of the manager account in the manager parameter. An NFT minted on Algorand is automatically transferred to your blockchain address. After the NFT is minted, you have to transfer it to the recipient&#39;s address. The recipient has to agree in advance to receive your NFT because Algorand charges users for storing NFTs on their addresses, and an Algorand blockchain address by default does not receive NFTs unless explicitly agreed. For more information about how it works, see the section about minting NFTs on Algorand using the pre-built NFT smart contract provided by Tatum. To mint NFTs natively on BNB Smart Chain, Ethereum, Harmony, Klaytn, KuCoin Community Chain, or Polygon, and: To sign the transaction with your private key, use this API with the MintNft schema of the request body. To sign the transaction with your signature ID, use this API the MintNftKMS schema of the request body. To mint NFTs natively on Celo and: To sign the transaction with your private key, use this API with the MintNftCelo schema of the request body. To sign the transaction with your signature ID, use this API the MintNftKMSCelo schema of the request body. To mint NFTs natively on Flow and: To sign the transaction with your private key, use this API with the MintNftFlowPK schema of the request body. To sign the transaction with your signature ID, use this API the MintNftFlowMnemonic schema of the request body. To sign the transaction with your wallet mnemonic, use this API the MintNftFlowKMS schema of the request body. To mint NFTs natively on Solana and: To sign the transaction with your private key, use this API with the MintNftSolana schema of the request body. To sign the transaction with your signature ID, use this API the MintNftSolanaKMS schema of the request body. NOTE: When an NFT is minted on Solana, a new blockchain address is created to receive the NFT under the recipient&#39;s account address. After the NFT is minted, you have to transfer it to the recipient&#39;s address. For more information about how it works, see the section about minting NFTs on Solana using the pre-built NFT smart contract provided by Tatum. To mint NFTs natively on TRON and: To sign the transaction with your private key, use this API with the MintNftTron schema of the request body. To sign the transaction with your signature ID, use this API the MintNftKMSTron schema of the request body.
        /// </remarks>
        /// <exception cref="Tatum.CSharp.Bsc.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="mintNft"></param>
        /// <param name="xTestnetType">Type of Ethereum testnet. Defaults to Sepolia. Valid only for ETH invocations for testnet API Key. For mainnet API Key, this value is ignored. (optional, default to ethereum-sepolia)</param>
        /// <returns>TransactionHash</returns>
        TransactionHash NftMintErc721(MintNft mintNft, string xTestnetType = default(string));
        /// <summary>
        /// Mint an NFT
        /// </summary>
        /// <remarks>
        /// 100 credits per API call on Flow 2 credits per API call on the other blockchains You can mint NFTs using either of the following methods: Using NFT Express Natively on a blockchain Minting NFTs using NFT Express NFT Express is Tatum&#39;s feature that helps you mint NFTs easier than minting natively on a blockchain. You do not need to enter your private key or signature ID. NFT Express uses the private key provided by Tatum. You do not need to hold crypto or keep addresses topped up with crypto to pay for minting transactions. To use NFT Express on the mainnet, you have to have a paid pricing plan. Tatum covers your transaction fees for NFT minting and pays for them from its own blockchain address. Then, the fee amount paid by Tatum is converted to the number of credits, and these credits are deducted from the monthly credit allowance of your paid pricing plan. The transaction fees and the corresponding numbers of credits deducted from your allowance vary depending on what blockchain you mint NFTs on. On the testnet, no credits are deducted from the monthly credit allowance. You can mint NFTs with NFT Express regardless of your pricing plan. With NFT Express, you can choose whether to mint NFTs on the pre-built NFT smart contract provided by Tatum or on your own smart contract. Use the pre-built smart contract provided by Tatum to mint NFTs If you want to mint NFTs using the pre-built smart contract, you do not need to deploy your own NFT smart contract. You do not need to provide the address of the NFT smart contract and the token ID in the request body either. The address of the smart contract and the token ID are provided automatically by Tatum. The token ID is autogenerated. It starts with 0 and is increased by 1 for each new NFT. The token ID is calculated separately for each supported blockchain and its mainnet and testnet. For more information, see our user documentation. You can mint NFTs on the pre-built smart contract provided by Tatum on the following blockchains: Algorand BNB Smart Chain Celo Ethereum Harmony Klaytn Polygon Solana Depending on what blockchain you use, choose the request body schema to use in the API call. To mint NFTs on BNB Smart Chain, Celo, Ethereum, Harmony, Klaytn, or Polygon, use this API with the MintNftExpress schema of the request body. To mint NFTs on Algorand, use this API with the MintNftExpressAlgorand schema of the request body. To be able to burn the minted NFTs any time later, specify the address of the manager account in the manager parameter. An NFT minted on Algorand is automatically transferred to your blockchain address. After the NFT is minted, you have to transfer it to the recipient&#39;s address. The recipient has to agree in advance to receive your NFT because Algorand charges users for storing NFTs on their addresses, and an Algorand blockchain address by default does not receive NFTs unless explicitly agreed. This how it works: The recipient agrees to receive the NFT to their address. You transfer the NFT to the recipient&#39;s address (use the transferNftAlgoExpress schema of the request body). NOTE: On the mainnet, Tatum covers your transaction fees for the NFT transfer and pays for them from its own blockchain address. Then, the fee amount paid by Tatum is converted to the number of credits, and these credits are deducted from the monthly credit allowance of your paid pricing plan. On the testnet, no credits are deducted from the monthly credit allowance. To mint NFTs on Solana, use this API with the MintNftExpressSolana schema of the request body. Solana uses the Metaplex Protocol, a smart contract and metadata standard for creating and working with NFTs. When you mint an NFT on Solana with NFT Express, the pre-built smart contract based on the Metaplex Protocol is used. When an NFT is minted on Solana, a new blockchain address is created to receive the NFT under the recipient&#39;s account address (the one in the to parameter of the request body). This address is returned in the nftAccountAddress parameter in the response body, is owned by the recipient&#39;s address, and has the same private key. The response body also returns the address of the minted NFT itself, which is held in the nftAddress parameter. After the NFT is minted, you have to transfer it to the recipient&#39;s address (use the transferNftSolana or transferNftSolanaKMS schema of the request body). In the request body of the transfer call: Set the from parameter to the address that you used in the to parameter in the request body of the minting call. Set the to parameter to the recipient&#39;s address. Set the contractAddress parameter to the address from the nftAddress parameter returned in the response body of the minting call. Set the fromPrivateKey/signatureId parameter to the private key/signature ID of the blockchain address that you specified in the from parameter. Use your own smart contract to mint NFTs If you want to mint NFTs using your own smart contract, you are going to use an NTF minter, a special blockchain address provided by Tatum that will cover the minting fees. The number of credits equivalent to the fees will be then deducted from the monthly credit allowance of your paid pricing plan. IMPORTANT! Your smart contract must be deployed as a general NFT smart contract. You cannot use cashback and provenance smart contracts with NFT Express. For more information, see our user documentation and the article in the Tatum blog. You can mint NFTs on your own smart contract on the following blockchains: BNB Smart Chain Celo Ethereum Harmony Klaytn Polygon To mint NFTs using your own smart contract, do the following: In the table located under this section, find the blockchain address of the Tatum NFT minter for your blockchain and network (mainnet or testnet). Add the minter address as an NFT minter to your smart contract. Use this API with the MintNftMinter schema of the request body. In the request body, enter the following information: chain is the blockchain that you use. to is the blockchain address where to send the minted NFT to. url is the URL of the NFT metadata. minter is the address of the NFT minter that you found in Step 1. contractAddress is the address of your NFT smart contract. tokenId is the the token ID of the NFT. For example:  {   \&quot;chain\&quot;: \&quot;CELO\&quot;,   \&quot;to\&quot;: \&quot;0x8ce4e40889a13971681391aad29e88efaf91f784\&quot;,   \&quot;url\&quot;: \&quot;ipfs://QmXJJ6UF5WkF4WTJvsdhiA1etGwBLfpva7Vr9AudGMe3pj\&quot;,   \&quot;contractAddress\&quot;: \&quot;0x687422eEA2cB73B5d3e242bA5456b782919AFc85\&quot;,   \&quot;tokenId\&quot;: \&quot;0123\&quot;,   \&quot;minter\&quot;: \&quot;0xBC2eBA680EE50d685cc4Fe65f102AA70AfB27D3F\&quot; } When you make an API call with this request body, the private key of the NFT minter will be added to the request body automatically:  {   \&quot;chain\&quot;: \&quot;CELO\&quot;,   \&quot;to\&quot;: \&quot;0x8ce4e40889a13971681391aad29e88efaf91f784\&quot;,   \&quot;url\&quot;: \&quot;ipfs://QmXJJ6UF5WkF4WTJvsdhiA1etGwBLfpva7Vr9AudGMe3pj\&quot;,   \&quot;contractAddress\&quot;: \&quot;0x687422eEA2cB73B5d3e242bA5456b782919AFc85\&quot;,   \&quot;tokenId\&quot;: \&quot;0123\&quot;,   \&quot;minter\&quot;: \&quot;0xBC2eBA680EE50d685cc4Fe65f102AA70AfB27D3F\&quot;,   \&quot;fromPrivateKey\&quot;: \&quot;0x05e150c73f1920ec14caa1e0b6aa09940899678051a78542840c2668ce5080c2\&quot; } The following table lists the blockchain addresses of the Tatum NFT minters for the testnet and mainnet of the supported blockchains: Blockchain Minter address - testnet* Minter address - mainnet BNB Smart Chain 0xc16ae5e8c985b906935a0cadf4e24f0400531883 0x49678AAB11E001eb3cB2cBD9aA96b36DC2461A94 Celo 0xBC2eBA680EE50d685cc4Fe65f102AA70AfB27D3F 0x49678AAB11E001eb3cB2cBD9aA96b36DC2461A94 Ethereum 0x53e8577C4347C365E4e0DA5B57A589cB6f2AB848 0x49678AAB11E001eb3cB2cBD9aA96b36DC2461A94 Harmony 0x8906f62d40293ddca77fdf6714c3f63265deddf0 0x49678AAB11E001eb3cB2cBD9aA96b36DC2461A94 Klaytn 0x80d8bac9a6901698b3749fe336bbd1385c1f98f2 0x49678AAB11E001eb3cB2cBD9aA96b36DC2461A94 Polygon 0x542b9ac4945a3836fd12ad98acbc76a0c8b743f5 0x49678AAB11E001eb3cB2cBD9aA96b36DC2461A94 *If a minter blockchain address on the testnet does not have sufficient funds to cover the transaction fee, add some amount to it using a crypto faucet of the blockchain. Minting NFTs natively on a blockchain When minting an NFT natively on a blockchain, you are charged a fee for the transaction, and you must sign the transaction with the private key of the blockchain address from which the fee will be deducted. Providing the private key in the API is not a secure way of signing transactions, because the private key can be stolen or exposed. Your private keys should never leave your security perimeter. You should use the private keys only for testing a solution you are building on the testnet of a blockchain. For signing transactions on the mainnet, we strongly recommend that you use the Tatum Key Management System (KMS) and provide the signature ID instead of the private key in the API. Alternatively, you can use the Tatum JavaScript client. You can mint NFTs natively on the following blockchains: Algorand BNB Smart Chain Celo Ethereum Flow Harmony Klaytn KuCoin Community Chain Polygon Solana TRON Depending on what blockchain you use, choose the request body schema to use in the API call. To mint NFTs natively on Algorand and: To sign the transaction with your private key, use this API with the MintNftAlgorand schema of the request body. To sign the transaction with your signature ID, use this API the MintNftAlgorandKMS schema of the request body. NOTE: To be able to burn the minted NFTs any time later, specify the address of the manager account in the manager parameter. An NFT minted on Algorand is automatically transferred to your blockchain address. After the NFT is minted, you have to transfer it to the recipient&#39;s address. The recipient has to agree in advance to receive your NFT because Algorand charges users for storing NFTs on their addresses, and an Algorand blockchain address by default does not receive NFTs unless explicitly agreed. For more information about how it works, see the section about minting NFTs on Algorand using the pre-built NFT smart contract provided by Tatum. To mint NFTs natively on BNB Smart Chain, Ethereum, Harmony, Klaytn, KuCoin Community Chain, or Polygon, and: To sign the transaction with your private key, use this API with the MintNft schema of the request body. To sign the transaction with your signature ID, use this API the MintNftKMS schema of the request body. To mint NFTs natively on Celo and: To sign the transaction with your private key, use this API with the MintNftCelo schema of the request body. To sign the transaction with your signature ID, use this API the MintNftKMSCelo schema of the request body. To mint NFTs natively on Flow and: To sign the transaction with your private key, use this API with the MintNftFlowPK schema of the request body. To sign the transaction with your signature ID, use this API the MintNftFlowMnemonic schema of the request body. To sign the transaction with your wallet mnemonic, use this API the MintNftFlowKMS schema of the request body. To mint NFTs natively on Solana and: To sign the transaction with your private key, use this API with the MintNftSolana schema of the request body. To sign the transaction with your signature ID, use this API the MintNftSolanaKMS schema of the request body. NOTE: When an NFT is minted on Solana, a new blockchain address is created to receive the NFT under the recipient&#39;s account address. After the NFT is minted, you have to transfer it to the recipient&#39;s address. For more information about how it works, see the section about minting NFTs on Solana using the pre-built NFT smart contract provided by Tatum. To mint NFTs natively on TRON and: To sign the transaction with your private key, use this API with the MintNftTron schema of the request body. To sign the transaction with your signature ID, use this API the MintNftKMSTron schema of the request body.
        /// </remarks>
        /// <exception cref="Tatum.CSharp.Bsc.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="mintNftKMS"></param>
        /// <param name="xTestnetType">Type of Ethereum testnet. Defaults to Sepolia. Valid only for ETH invocations for testnet API Key. For mainnet API Key, this value is ignored. (optional, default to ethereum-sepolia)</param>
        /// <returns>SignatureId</returns>
        SignatureId NftMintErc721(MintNftKMS mintNftKMS, string xTestnetType = default(string));
        /// <summary>
        /// Mint multiple NFTs
        /// </summary>
        /// <remarks>
        /// 100 credits per API call on Flow 2 credits per API call on the other blockchains Create multiple NFT Tokens and transfer them to destination account. Create and transfer any NFT tokens from smart contract defined in contractAddress. This API is supported for the following blockchains: BNB Smart Chain Celo Ethereum Flow Harmony Klaytn KuCoin Community Chain Polygon TRON This operation works in two modes. First mode works just like other NFT endpoints. Every time the funds are transferred, the transaction must be signed with the corresponding private key. No one should ever send it&#39;s own private keys to the internet because there is a strong possibility of stealing keys and loss of funds. In this method, it is possible to enter privateKey or signatureId. PrivateKey should be used only for quick development on testnet versions of blockchain when there is no risk of losing funds. In production, Tatum KMS should be used for the highest security standards, and signatureId should be present in the request. Alternatively, using the Tatum client library for supported languages. Second mode enables you to mint on any custom NFT ERC-721 smart contract, on which specified minter address is approved as a minter. You don&#39;t specify private key or signatureId, only minter address, from which the NFT will be minted. It means you perform mint multiple NFT request with following body: {    \&quot;to\&quot;: [\&quot;0x80d8bac9a6901698b3749fe336bbd1385c1f98f2\&quot;],    \&quot;url\&quot;: [\&quot;ipfs://QmXJJ6UF5WkF4WTJvsdhiA1etGwBLfpva7Vr9AudGMe3pj\&quot;],    \&quot;tokenId\&quot;: [\&quot;9876541124516\&quot;],    \&quot;contractAddress\&quot;:\&quot;0xcd2ada00c48a27faa5cc67f9a1ed55b89ddf7f77\&quot;,    \&quot;minter\&quot;: \&quot;0x542b9ac4945a3836fd12ad98acbc76a0c8b743f5\&quot;,    \&quot;chain\&quot;: \&quot;MATIC\&quot; } The blockchain fee of the performed transaction is paid from the address connected with built-in private key and is debited in form of credits. The credits are debited only if NFT mint requests are performed with paid API key plan. We transform fee to the credits in accordance to the rates provided by the Tatum. If you want to batch mint on ERC-721 contract which is not deployed via Tatum API, your smart contract must contain this method: mintMultiple(address[] to, uint256[] tokenId, string[] uri): boolean You can use addresses specified in the bellow table to be used as a minter. Chain Testnet address Mainnet Address MATIC 0x542b9ac4945a3836fd12ad98acbc76a0c8b743f5 0xcf9e127455d28e7362380aec1b92ddee8200b295 BSC 0xc16ae5e8c985b906935a0cadf4e24f0400531883 0xcf9e127455d28e7362380aec1b92ddee8200b295 ONE 0x8906f62d40293ddca77fdf6714c3f63265deddf0 0xcf9e127455d28e7362380aec1b92ddee8200b295 ETH 0x53e8577C4347C365E4e0DA5B57A589cB6f2AB848 0xcf9e127455d28e7362380aec1b92ddee8200b295 CELO 0xBC2eBA680EE50d685cc4Fe65f102AA70AfB27D3F 0xcf9e127455d28e7362380aec1b92ddee8200b295 KLAY 0x80d8bac9a6901698b3749fe336bbd1385c1f98f2 0xcf9e127455d28e7362380aec1b92ddee8200b295 If there are not enough coins on any testnet address, feel free to send coins there.
        /// </remarks>
        /// <exception cref="Tatum.CSharp.Bsc.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="mintMultipleNftMinter"></param>
        /// <param name="xTestnetType">Type of Ethereum testnet. Defaults to Sepolia. Valid only for ETH invocations for testnet API Key. For mainnet API Key, this value is ignored. (optional, default to ethereum-sepolia)</param>
        /// <returns>TransactionHash</returns>
        TransactionHash NftMintMultipleErc721(MintMultipleNftMinter mintMultipleNftMinter, string xTestnetType = default(string));
        /// <summary>
        /// Mint multiple NFTs
        /// </summary>
        /// <remarks>
        /// 100 credits per API call on Flow 2 credits per API call on the other blockchains Create multiple NFT Tokens and transfer them to destination account. Create and transfer any NFT tokens from smart contract defined in contractAddress. This API is supported for the following blockchains: BNB Smart Chain Celo Ethereum Flow Harmony Klaytn KuCoin Community Chain Polygon TRON This operation works in two modes. First mode works just like other NFT endpoints. Every time the funds are transferred, the transaction must be signed with the corresponding private key. No one should ever send it&#39;s own private keys to the internet because there is a strong possibility of stealing keys and loss of funds. In this method, it is possible to enter privateKey or signatureId. PrivateKey should be used only for quick development on testnet versions of blockchain when there is no risk of losing funds. In production, Tatum KMS should be used for the highest security standards, and signatureId should be present in the request. Alternatively, using the Tatum client library for supported languages. Second mode enables you to mint on any custom NFT ERC-721 smart contract, on which specified minter address is approved as a minter. You don&#39;t specify private key or signatureId, only minter address, from which the NFT will be minted. It means you perform mint multiple NFT request with following body: {    \&quot;to\&quot;: [\&quot;0x80d8bac9a6901698b3749fe336bbd1385c1f98f2\&quot;],    \&quot;url\&quot;: [\&quot;ipfs://QmXJJ6UF5WkF4WTJvsdhiA1etGwBLfpva7Vr9AudGMe3pj\&quot;],    \&quot;tokenId\&quot;: [\&quot;9876541124516\&quot;],    \&quot;contractAddress\&quot;:\&quot;0xcd2ada00c48a27faa5cc67f9a1ed55b89ddf7f77\&quot;,    \&quot;minter\&quot;: \&quot;0x542b9ac4945a3836fd12ad98acbc76a0c8b743f5\&quot;,    \&quot;chain\&quot;: \&quot;MATIC\&quot; } The blockchain fee of the performed transaction is paid from the address connected with built-in private key and is debited in form of credits. The credits are debited only if NFT mint requests are performed with paid API key plan. We transform fee to the credits in accordance to the rates provided by the Tatum. If you want to batch mint on ERC-721 contract which is not deployed via Tatum API, your smart contract must contain this method: mintMultiple(address[] to, uint256[] tokenId, string[] uri): boolean You can use addresses specified in the bellow table to be used as a minter. Chain Testnet address Mainnet Address MATIC 0x542b9ac4945a3836fd12ad98acbc76a0c8b743f5 0xcf9e127455d28e7362380aec1b92ddee8200b295 BSC 0xc16ae5e8c985b906935a0cadf4e24f0400531883 0xcf9e127455d28e7362380aec1b92ddee8200b295 ONE 0x8906f62d40293ddca77fdf6714c3f63265deddf0 0xcf9e127455d28e7362380aec1b92ddee8200b295 ETH 0x53e8577C4347C365E4e0DA5B57A589cB6f2AB848 0xcf9e127455d28e7362380aec1b92ddee8200b295 CELO 0xBC2eBA680EE50d685cc4Fe65f102AA70AfB27D3F 0xcf9e127455d28e7362380aec1b92ddee8200b295 KLAY 0x80d8bac9a6901698b3749fe336bbd1385c1f98f2 0xcf9e127455d28e7362380aec1b92ddee8200b295 If there are not enough coins on any testnet address, feel free to send coins there.
        /// </remarks>
        /// <exception cref="Tatum.CSharp.Bsc.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="mintMultipleNft"></param>
        /// <param name="xTestnetType">Type of Ethereum testnet. Defaults to Sepolia. Valid only for ETH invocations for testnet API Key. For mainnet API Key, this value is ignored. (optional, default to ethereum-sepolia)</param>
        /// <returns>TransactionHash</returns>
        TransactionHash NftMintMultipleErc721(MintMultipleNft mintMultipleNft, string xTestnetType = default(string));
        /// <summary>
        /// Mint multiple NFTs
        /// </summary>
        /// <remarks>
        /// 100 credits per API call on Flow 2 credits per API call on the other blockchains Create multiple NFT Tokens and transfer them to destination account. Create and transfer any NFT tokens from smart contract defined in contractAddress. This API is supported for the following blockchains: BNB Smart Chain Celo Ethereum Flow Harmony Klaytn KuCoin Community Chain Polygon TRON This operation works in two modes. First mode works just like other NFT endpoints. Every time the funds are transferred, the transaction must be signed with the corresponding private key. No one should ever send it&#39;s own private keys to the internet because there is a strong possibility of stealing keys and loss of funds. In this method, it is possible to enter privateKey or signatureId. PrivateKey should be used only for quick development on testnet versions of blockchain when there is no risk of losing funds. In production, Tatum KMS should be used for the highest security standards, and signatureId should be present in the request. Alternatively, using the Tatum client library for supported languages. Second mode enables you to mint on any custom NFT ERC-721 smart contract, on which specified minter address is approved as a minter. You don&#39;t specify private key or signatureId, only minter address, from which the NFT will be minted. It means you perform mint multiple NFT request with following body: {    \&quot;to\&quot;: [\&quot;0x80d8bac9a6901698b3749fe336bbd1385c1f98f2\&quot;],    \&quot;url\&quot;: [\&quot;ipfs://QmXJJ6UF5WkF4WTJvsdhiA1etGwBLfpva7Vr9AudGMe3pj\&quot;],    \&quot;tokenId\&quot;: [\&quot;9876541124516\&quot;],    \&quot;contractAddress\&quot;:\&quot;0xcd2ada00c48a27faa5cc67f9a1ed55b89ddf7f77\&quot;,    \&quot;minter\&quot;: \&quot;0x542b9ac4945a3836fd12ad98acbc76a0c8b743f5\&quot;,    \&quot;chain\&quot;: \&quot;MATIC\&quot; } The blockchain fee of the performed transaction is paid from the address connected with built-in private key and is debited in form of credits. The credits are debited only if NFT mint requests are performed with paid API key plan. We transform fee to the credits in accordance to the rates provided by the Tatum. If you want to batch mint on ERC-721 contract which is not deployed via Tatum API, your smart contract must contain this method: mintMultiple(address[] to, uint256[] tokenId, string[] uri): boolean You can use addresses specified in the bellow table to be used as a minter. Chain Testnet address Mainnet Address MATIC 0x542b9ac4945a3836fd12ad98acbc76a0c8b743f5 0xcf9e127455d28e7362380aec1b92ddee8200b295 BSC 0xc16ae5e8c985b906935a0cadf4e24f0400531883 0xcf9e127455d28e7362380aec1b92ddee8200b295 ONE 0x8906f62d40293ddca77fdf6714c3f63265deddf0 0xcf9e127455d28e7362380aec1b92ddee8200b295 ETH 0x53e8577C4347C365E4e0DA5B57A589cB6f2AB848 0xcf9e127455d28e7362380aec1b92ddee8200b295 CELO 0xBC2eBA680EE50d685cc4Fe65f102AA70AfB27D3F 0xcf9e127455d28e7362380aec1b92ddee8200b295 KLAY 0x80d8bac9a6901698b3749fe336bbd1385c1f98f2 0xcf9e127455d28e7362380aec1b92ddee8200b295 If there are not enough coins on any testnet address, feel free to send coins there.
        /// </remarks>
        /// <exception cref="Tatum.CSharp.Bsc.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="mintMultipleNftKMS"></param>
        /// <param name="xTestnetType">Type of Ethereum testnet. Defaults to Sepolia. Valid only for ETH invocations for testnet API Key. For mainnet API Key, this value is ignored. (optional, default to ethereum-sepolia)</param>
        /// <returns>SignatureId</returns>
        SignatureId NftMintMultipleErc721(MintMultipleNftKMS mintMultipleNftKMS, string xTestnetType = default(string));
        /// <summary>
        /// Transfer an NFT
        /// </summary>
        /// <remarks>
        /// 100 credits per API call on Flow 2 credits per API call on the other blockchains Transfer an NFT from the smart contract (the contractAddress parameter in the request body) to the specified blockchain address (the to parameter in the request body). In one API call, you can transfer only one NFT. This API is supported for the following blockchains: Algorand BNB Smart Chain Celo Ethereum Flow Harmony Klaytn KuCoin Community Chain Polygon Solana TRON For Ethereum, Celo, and BNB Smart Chain, transferring NFTs invokes the safeTransfer() method. Transferring NFTs on Algorand On Algorand, the recipient has to agree in advance to receive your NFT because Algorand charges users for storing NFTs on their addresses, and an Algorand blockchain address by default does not receive NFTs unless explicitly agreed. Before transferring an NFT, make sure that the recipient has agreed to receive the NFT to their address. If you want to transfer an NFT that was minted using NFT Express, use the transferNftAlgoExpress schema of the request body. NOTE: On the mainnet, Tatum covers your transaction fees for the NFT transfer and pays for them from its own blockchain address. Then, the fee amount paid by Tatum is converted to the number of credits, and these credits are deducted from the monthly credit allowance of your paid pricing plan. On the testnet, no credits are deducted from the monthly credit allowance. Transferring NFTs on Solana If you want to transfer an NFT that was minted using NFT Express, see the section about minting NFTs on Solana using the pre-built NFT smart contract provided by Tatum for the information about how to set up the parameters in the request body. Signing a transaction When transferring an NFT, you are charged a fee for the transaction, and you must sign the transaction with the private key of the blockchain address from which the fee will be deducted. Providing the private key in the API is not a secure way of signing transactions, because the private key can be stolen or exposed. Your private keys should never leave your security perimeter. You should use the private keys only for testing a solution you are building on the testnet of a blockchain. For signing transactions on the mainnet, we strongly recommend that you use the Tatum Key Management System (KMS) and provide the signature ID instead of the private key in the API. Alternatively, you can use the Tatum JavaScript client. NOTE: This does not apply to transferring NFTs that were minted on Algorand using NFT Express (see earlier in this section).
        /// </remarks>
        /// <exception cref="Tatum.CSharp.Bsc.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="transferNft"></param>
        /// <param name="xTestnetType">Type of Ethereum testnet. Defaults to Sepolia. Valid only for ETH invocations for testnet API Key. For mainnet API Key, this value is ignored. (optional, default to ethereum-sepolia)</param>
        /// <returns>TransactionHash</returns>
        TransactionHash NftTransferErc721(TransferNft transferNft, string xTestnetType = default(string));
        /// <summary>
        /// Transfer an NFT
        /// </summary>
        /// <remarks>
        /// 100 credits per API call on Flow 2 credits per API call on the other blockchains Transfer an NFT from the smart contract (the contractAddress parameter in the request body) to the specified blockchain address (the to parameter in the request body). In one API call, you can transfer only one NFT. This API is supported for the following blockchains: Algorand BNB Smart Chain Celo Ethereum Flow Harmony Klaytn KuCoin Community Chain Polygon Solana TRON For Ethereum, Celo, and BNB Smart Chain, transferring NFTs invokes the safeTransfer() method. Transferring NFTs on Algorand On Algorand, the recipient has to agree in advance to receive your NFT because Algorand charges users for storing NFTs on their addresses, and an Algorand blockchain address by default does not receive NFTs unless explicitly agreed. Before transferring an NFT, make sure that the recipient has agreed to receive the NFT to their address. If you want to transfer an NFT that was minted using NFT Express, use the transferNftAlgoExpress schema of the request body. NOTE: On the mainnet, Tatum covers your transaction fees for the NFT transfer and pays for them from its own blockchain address. Then, the fee amount paid by Tatum is converted to the number of credits, and these credits are deducted from the monthly credit allowance of your paid pricing plan. On the testnet, no credits are deducted from the monthly credit allowance. Transferring NFTs on Solana If you want to transfer an NFT that was minted using NFT Express, see the section about minting NFTs on Solana using the pre-built NFT smart contract provided by Tatum for the information about how to set up the parameters in the request body. Signing a transaction When transferring an NFT, you are charged a fee for the transaction, and you must sign the transaction with the private key of the blockchain address from which the fee will be deducted. Providing the private key in the API is not a secure way of signing transactions, because the private key can be stolen or exposed. Your private keys should never leave your security perimeter. You should use the private keys only for testing a solution you are building on the testnet of a blockchain. For signing transactions on the mainnet, we strongly recommend that you use the Tatum Key Management System (KMS) and provide the signature ID instead of the private key in the API. Alternatively, you can use the Tatum JavaScript client. NOTE: This does not apply to transferring NFTs that were minted on Algorand using NFT Express (see earlier in this section).
        /// </remarks>
        /// <exception cref="Tatum.CSharp.Bsc.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="transferNftKMS"></param>
        /// <param name="xTestnetType">Type of Ethereum testnet. Defaults to Sepolia. Valid only for ETH invocations for testnet API Key. For mainnet API Key, this value is ignored. (optional, default to ethereum-sepolia)</param>
        /// <returns>SignatureId</returns>
        SignatureId NftTransferErc721(TransferNftKMS transferNftKMS, string xTestnetType = default(string));
        /// <summary>
        /// Update NFT royalty information
        /// </summary>
        /// <remarks>
        /// 2 credits per API call Update the value of the royalty cashback set for an NFT. The royalty cashback value can be updated only from the address of the NFT author (the address that is listed as a royalty cashback receiver in the NFT royalty information). The royalty cashback value cannot be updated from the address of the NFT owner. In one API call, you can update the first value of the royalty cashback for the NFT author for one NFT. To disable the royalties for the NFT completely, set it to 0. This API is supported for the following blockchains: BNB Smart Chain Celo Ethereum Harmony Klaytn KuCoin Community Chain Polygon TRON Signing a transaction When updating NFT royalty, you are charged a fee for the transaction, and you must sign the transaction with the private key of the blockchain address from which the fee will be deducted. Providing the private key in the API is not a secure way of signing transactions, because the private key can be stolen or exposed. Your private keys should never leave your security perimeter. You should use the private keys only for testing a solution you are building on the testnet of a blockchain. For signing transactions on the mainnet, we strongly recommend that you use the Tatum Key Management System (KMS) and provide the signature ID instead of the private key in the API. Alternatively, you can use the Tatum JavaScript client.
        /// </remarks>
        /// <exception cref="Tatum.CSharp.Bsc.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="updateCashbackValueForAuthorNft"></param>
        /// <param name="xTestnetType">Type of Ethereum testnet. Defaults to Sepolia. Valid only for ETH invocations for testnet API Key. For mainnet API Key, this value is ignored. (optional, default to ethereum-sepolia)</param>
        /// <returns>TransactionHash</returns>
        TransactionHash NftUpdateCashbackErc721(UpdateCashbackValueForAuthorNft updateCashbackValueForAuthorNft, string xTestnetType = default(string));
        /// <summary>
        /// Update NFT royalty information
        /// </summary>
        /// <remarks>
        /// 2 credits per API call Update the value of the royalty cashback set for an NFT. The royalty cashback value can be updated only from the address of the NFT author (the address that is listed as a royalty cashback receiver in the NFT royalty information). The royalty cashback value cannot be updated from the address of the NFT owner. In one API call, you can update the first value of the royalty cashback for the NFT author for one NFT. To disable the royalties for the NFT completely, set it to 0. This API is supported for the following blockchains: BNB Smart Chain Celo Ethereum Harmony Klaytn KuCoin Community Chain Polygon TRON Signing a transaction When updating NFT royalty, you are charged a fee for the transaction, and you must sign the transaction with the private key of the blockchain address from which the fee will be deducted. Providing the private key in the API is not a secure way of signing transactions, because the private key can be stolen or exposed. Your private keys should never leave your security perimeter. You should use the private keys only for testing a solution you are building on the testnet of a blockchain. For signing transactions on the mainnet, we strongly recommend that you use the Tatum Key Management System (KMS) and provide the signature ID instead of the private key in the API. Alternatively, you can use the Tatum JavaScript client.
        /// </remarks>
        /// <exception cref="Tatum.CSharp.Bsc.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="updateCashbackValueForAuthorNftKMS"></param>
        /// <param name="xTestnetType">Type of Ethereum testnet. Defaults to Sepolia. Valid only for ETH invocations for testnet API Key. For mainnet API Key, this value is ignored. (optional, default to ethereum-sepolia)</param>
        /// <returns>SignatureId</returns>
        SignatureId NftUpdateCashbackErc721(UpdateCashbackValueForAuthorNftKMS updateCashbackValueForAuthorNftKMS, string xTestnetType = default(string));
        #endregion Synchronous Operations
    }

    /// <summary>
    /// Represents a collection of functions to interact with the API endpoints
    /// </summary>
    public interface INFTBscApiWithHttpInfoSync : IApiAccessor
    {
        #region Synchronous Operations With Http Info
        /// <summary>
        /// Add an NFT minter to an NFT smart contract
        /// </summary>
        /// <remarks>
        /// 2 credits per API call Allow a blockchain address (the minter parameter in the request body) to mint NFTs on the NFT smart contract (the contractAddress parameter in the request body). Use this API when you are using NFT Express with your own smart contract to mint NFTs and need to add the Tatum NFT minter&#39;s address as an NFT minter to your smart contract. For more information about the Tatum NFT minter, see \&quot;Use your own smart contract to mint NFTs\&quot; in Mint an NFT. This API is supported for the following blockchains: BNB Smart Chain Celo Ethereum Harmony Klaytn KuCoin Community Chain Polygon Signing a transaction When adding an NFT minter, you are charged a fee for the transaction, and you must sign the transaction with the private key of the blockchain address from which the fee will be deducted. Providing the private key in the API is not a secure way of signing transactions, because the private key can be stolen or exposed. Your private keys should never leave your security perimeter. You should use the private keys only for testing a solution you are building on the testnet of a blockchain. For signing transactions on the mainnet, we strongly recommend that you use the Tatum Key Management System (KMS) and provide the signature ID instead of the private key in the API. Alternatively, you can use the Tatum JavaScript client.
        /// </remarks>
        /// <exception cref="Tatum.CSharp.Bsc.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="addNftMinter"></param>
        /// <param name="xTestnetType">Type of Ethereum testnet. Defaults to Sepolia. Valid only for ETH invocations for testnet API Key. For mainnet API Key, this value is ignored. (optional, default to ethereum-sepolia)</param>
        /// <returns>ApiResponse of TransactionHash</returns>
        ApiResponse<TransactionHash> NftAddMinterWithHttpInfo(AddNftMinter addNftMinter, string xTestnetType = default(string));
        /// <summary>
        /// Add an NFT minter to an NFT smart contract
        /// </summary>
        /// <remarks>
        /// 2 credits per API call Allow a blockchain address (the minter parameter in the request body) to mint NFTs on the NFT smart contract (the contractAddress parameter in the request body). Use this API when you are using NFT Express with your own smart contract to mint NFTs and need to add the Tatum NFT minter&#39;s address as an NFT minter to your smart contract. For more information about the Tatum NFT minter, see \&quot;Use your own smart contract to mint NFTs\&quot; in Mint an NFT. This API is supported for the following blockchains: BNB Smart Chain Celo Ethereum Harmony Klaytn KuCoin Community Chain Polygon Signing a transaction When adding an NFT minter, you are charged a fee for the transaction, and you must sign the transaction with the private key of the blockchain address from which the fee will be deducted. Providing the private key in the API is not a secure way of signing transactions, because the private key can be stolen or exposed. Your private keys should never leave your security perimeter. You should use the private keys only for testing a solution you are building on the testnet of a blockchain. For signing transactions on the mainnet, we strongly recommend that you use the Tatum Key Management System (KMS) and provide the signature ID instead of the private key in the API. Alternatively, you can use the Tatum JavaScript client.
        /// </remarks>
        /// <exception cref="Tatum.CSharp.Bsc.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="addNftMinterKMS"></param>
        /// <param name="xTestnetType">Type of Ethereum testnet. Defaults to Sepolia. Valid only for ETH invocations for testnet API Key. For mainnet API Key, this value is ignored. (optional, default to ethereum-sepolia)</param>
        /// <returns>ApiResponse of SignatureId</returns>
        ApiResponse<SignatureId> NftAddMinterWithHttpInfo(AddNftMinterKMS addNftMinterKMS, string xTestnetType = default(string));
        /// <summary>
        /// Burn an NFT
        /// </summary>
        /// <remarks>
        /// 100 credits per API call on Flow 2 credits per API call on the other blockchains Destroy an NFT. Burning the NFT transfers it to an un-spendable blockchain address that no one can access. This API is supported for the following blockchains: Algorand BNB Smart Chain Celo Ethereum Flow Harmony Klaytn KuCoin Community Chain Polygon TRON Burning NFTs on Algorand You can burn only the NFTs that were minted with the address of the manager account specified in the manager parameter in the minting call (see the MintNftExpressAlgorand, MintNftAlgorand, and MintNftAlgorandKMS schemas of the request body). Signing a transaction When burning an NFT, you are charged a fee for the transaction, and you must sign the transaction with the private key of the blockchain address from which the fee will be deducted. Providing the private key in the API is not a secure way of signing transactions, because the private key can be stolen or exposed. Your private keys should never leave your security perimeter. You should use the private keys only for testing a solution you are building on the testnet of a blockchain. For signing transactions on the mainnet, we strongly recommend that you use the Tatum Key Management System (KMS) and provide the signature ID instead of the private key in the API. Alternatively, you can use the Tatum JavaScript client.
        /// </remarks>
        /// <exception cref="Tatum.CSharp.Bsc.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="burnNft"></param>
        /// <param name="xTestnetType">Type of Ethereum testnet. Defaults to Sepolia. Valid only for ETH invocations for testnet API Key. For mainnet API Key, this value is ignored. (optional, default to ethereum-sepolia)</param>
        /// <returns>ApiResponse of TransactionHash</returns>
        ApiResponse<TransactionHash> NftBurnErc721WithHttpInfo(BurnNft burnNft, string xTestnetType = default(string));
        /// <summary>
        /// Burn an NFT
        /// </summary>
        /// <remarks>
        /// 100 credits per API call on Flow 2 credits per API call on the other blockchains Destroy an NFT. Burning the NFT transfers it to an un-spendable blockchain address that no one can access. This API is supported for the following blockchains: Algorand BNB Smart Chain Celo Ethereum Flow Harmony Klaytn KuCoin Community Chain Polygon TRON Burning NFTs on Algorand You can burn only the NFTs that were minted with the address of the manager account specified in the manager parameter in the minting call (see the MintNftExpressAlgorand, MintNftAlgorand, and MintNftAlgorandKMS schemas of the request body). Signing a transaction When burning an NFT, you are charged a fee for the transaction, and you must sign the transaction with the private key of the blockchain address from which the fee will be deducted. Providing the private key in the API is not a secure way of signing transactions, because the private key can be stolen or exposed. Your private keys should never leave your security perimeter. You should use the private keys only for testing a solution you are building on the testnet of a blockchain. For signing transactions on the mainnet, we strongly recommend that you use the Tatum Key Management System (KMS) and provide the signature ID instead of the private key in the API. Alternatively, you can use the Tatum JavaScript client.
        /// </remarks>
        /// <exception cref="Tatum.CSharp.Bsc.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="burnNftKMS"></param>
        /// <param name="xTestnetType">Type of Ethereum testnet. Defaults to Sepolia. Valid only for ETH invocations for testnet API Key. For mainnet API Key, this value is ignored. (optional, default to ethereum-sepolia)</param>
        /// <returns>ApiResponse of SignatureId</returns>
        ApiResponse<SignatureId> NftBurnErc721WithHttpInfo(BurnNftKMS burnNftKMS, string xTestnetType = default(string));
        /// <summary>
        /// Deploy an NFT smart contract
        /// </summary>
        /// <remarks>
        /// 100 credits per API call on Flow 2 credits per API call on the other blockchains Deploy an NFT smart contract on the blockchain. In a deployed NFT smart contract, you can mint NFTs (one NFT at a time or multiple NFTs at once), burn, and transfer NFTs. Smart contracts are standardized and audited. You can review the code of a deployed NFT smart contract here (if the contract is deployed on Flow) or here (if the contract is deployed on any other supported blockchain). This API is supported for the following blockchains: BNB Smart Chain Celo Ethereum Flow Harmony Klaytn KuCoin Community Chain Polygon TRON General NFT smart contracts By default, an NFT smart contract is deployed as a general NFT smart contract compatible with OpenSea royalties. This is a standard NFT contract with AccessControl and Ownable, enhanced with NFT batch minting. NFTs minted on this smart contract are compatible with OpenSea and its royalty structure. Cashback and provenance NFT smart contracts In addition to the general NFT contract, you can deploy the following types of NFT smart contracts for the supported blockchains except for Flow and TRON: Cashback NFT smart contract is an NFT smart contract that forces on-chain royalties to be paid every time an NFT is transferred, and the royalties are defined as a fixed value. The royalties are not OpenSea-compatible. To deploy an NFT smart contract as a cashback contract, deploy the contract with the cashback parameter set to true in the request body. Provenance NFT smart contract is an NFT smart contract that forces on-chain royalties to be paid every time an NFT is transferred, and the royalties are defined as a percentage of the NFT price. The royalties are not OpenSea-compatible. To deploy an NFT smart contract as a provenance contract, deploy the contract with the provenance parameter set to true in the request body. You can enable public minting for cashback and provenance smart contracts. By default, public minting is disabled, which means that only the blockchain address whose private key was used to create the smart contract or the blockchain addresses added to the smart contract as NFT minters will be able to mint NFTs for the contract. To enable public minting and allow anyone to mint NFTs on top of the smart contract, deploy the contract with the publicMint parameter set to true in the request body. NFT smart contracts and NFT Express If you want to use NFT Express to mint NFTs on the deployed smart contract, deploy the smart contract as a general NFT smart contract (that is, deploy the contract with the cashback, provenance, and publicMint parameters either set to false or not set at all in the request body). After you have deployed the NFT smart contract, add the Tatum minter address as an NFT minter to your smart contract. For the complete information about using NFT Express on your smart contract, see \&quot;Use your own smart contract to mint NFTs\&quot; in Mint an NFT. Signing a transaction When deploying an NFT smart contract, you are charged a fee for the transaction, and you must sign the transaction with the private key of the blockchain address from which the fee will be deducted. Providing the private key in the API is not a secure way of signing transactions, because the private key can be stolen or exposed. Your private keys should never leave your security perimeter. You should use the private keys only for testing a solution you are building on the testnet of a blockchain. For signing transactions on the mainnet, we strongly recommend that you use the Tatum Key Management System (KMS) and provide the signature ID instead of the private key in the API. Alternatively, you can use the Tatum JavaScript client.
        /// </remarks>
        /// <exception cref="Tatum.CSharp.Bsc.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="deployNft"></param>
        /// <param name="xTestnetType">Type of Ethereum testnet. Defaults to Sepolia. Valid only for ETH invocations for testnet API Key. For mainnet API Key, this value is ignored. (optional, default to ethereum-sepolia)</param>
        /// <returns>ApiResponse of TransactionHash</returns>
        ApiResponse<TransactionHash> NftDeployErc721WithHttpInfo(DeployNft deployNft, string xTestnetType = default(string));
        /// <summary>
        /// Deploy an NFT smart contract
        /// </summary>
        /// <remarks>
        /// 100 credits per API call on Flow 2 credits per API call on the other blockchains Deploy an NFT smart contract on the blockchain. In a deployed NFT smart contract, you can mint NFTs (one NFT at a time or multiple NFTs at once), burn, and transfer NFTs. Smart contracts are standardized and audited. You can review the code of a deployed NFT smart contract here (if the contract is deployed on Flow) or here (if the contract is deployed on any other supported blockchain). This API is supported for the following blockchains: BNB Smart Chain Celo Ethereum Flow Harmony Klaytn KuCoin Community Chain Polygon TRON General NFT smart contracts By default, an NFT smart contract is deployed as a general NFT smart contract compatible with OpenSea royalties. This is a standard NFT contract with AccessControl and Ownable, enhanced with NFT batch minting. NFTs minted on this smart contract are compatible with OpenSea and its royalty structure. Cashback and provenance NFT smart contracts In addition to the general NFT contract, you can deploy the following types of NFT smart contracts for the supported blockchains except for Flow and TRON: Cashback NFT smart contract is an NFT smart contract that forces on-chain royalties to be paid every time an NFT is transferred, and the royalties are defined as a fixed value. The royalties are not OpenSea-compatible. To deploy an NFT smart contract as a cashback contract, deploy the contract with the cashback parameter set to true in the request body. Provenance NFT smart contract is an NFT smart contract that forces on-chain royalties to be paid every time an NFT is transferred, and the royalties are defined as a percentage of the NFT price. The royalties are not OpenSea-compatible. To deploy an NFT smart contract as a provenance contract, deploy the contract with the provenance parameter set to true in the request body. You can enable public minting for cashback and provenance smart contracts. By default, public minting is disabled, which means that only the blockchain address whose private key was used to create the smart contract or the blockchain addresses added to the smart contract as NFT minters will be able to mint NFTs for the contract. To enable public minting and allow anyone to mint NFTs on top of the smart contract, deploy the contract with the publicMint parameter set to true in the request body. NFT smart contracts and NFT Express If you want to use NFT Express to mint NFTs on the deployed smart contract, deploy the smart contract as a general NFT smart contract (that is, deploy the contract with the cashback, provenance, and publicMint parameters either set to false or not set at all in the request body). After you have deployed the NFT smart contract, add the Tatum minter address as an NFT minter to your smart contract. For the complete information about using NFT Express on your smart contract, see \&quot;Use your own smart contract to mint NFTs\&quot; in Mint an NFT. Signing a transaction When deploying an NFT smart contract, you are charged a fee for the transaction, and you must sign the transaction with the private key of the blockchain address from which the fee will be deducted. Providing the private key in the API is not a secure way of signing transactions, because the private key can be stolen or exposed. Your private keys should never leave your security perimeter. You should use the private keys only for testing a solution you are building on the testnet of a blockchain. For signing transactions on the mainnet, we strongly recommend that you use the Tatum Key Management System (KMS) and provide the signature ID instead of the private key in the API. Alternatively, you can use the Tatum JavaScript client.
        /// </remarks>
        /// <exception cref="Tatum.CSharp.Bsc.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="deployNftKMS"></param>
        /// <param name="xTestnetType">Type of Ethereum testnet. Defaults to Sepolia. Valid only for ETH invocations for testnet API Key. For mainnet API Key, this value is ignored. (optional, default to ethereum-sepolia)</param>
        /// <returns>ApiResponse of SignatureId</returns>
        ApiResponse<SignatureId> NftDeployErc721WithHttpInfo(DeployNftKMS deployNftKMS, string xTestnetType = default(string));
        /// <summary>
        /// Get the NFTs from a specific smart contract that a blockchain address holds
        /// </summary>
        /// <remarks>
        /// 1 credit per API call Get the NFTs minted on a specific smart contract (the contractAddress path parameter in the request endpoint URL) that a blockchain address holds. NOTE: This API works only for the NFT smart contracts deployed using the Tatum smart contract API. This API is supported for the following blockchains: Algorand BNB Smart Chain Celo Elrond Ethereum Flow Harmony Klaytn KuCoin Community Chain Polygon Solana TRON
        /// </remarks>
        /// <exception cref="Tatum.CSharp.Bsc.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="address">The blockchain address that you want to get the token balance of</param>
        /// <param name="contractAddress">The address of the NFT smart contract</param>
        /// <param name="xTestnetType">Type of Ethereum testnet. Defaults to Sepolia. Valid only for ETH invocations for testnet API Key. For mainnet API Key, this value is ignored. (optional, default to ethereum-sepolia)</param>
        /// <returns>ApiResponse of NftGetBalanceSc</returns>
        ApiResponse<NftGetBalanceSc> NftGetBalanceErc721WithHttpInfo(string address, string contractAddress, string xTestnetType = default(string));
        /// <summary>
        /// Get NFT metadata
        /// </summary>
        /// <remarks>
        /// 1 credit per API call Get metadata of an NFT. This API is supported for the following blockchains: BNB Smart Chain Celo Ethereum Flow Harmony Klaytn KuCoin Community Chain Polygon Solana TRON
        /// </remarks>
        /// <exception cref="Tatum.CSharp.Bsc.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="contractAddress">The blockchain address of the NFT to get metadata for</param>
        /// <param name="tokenId">The ID of the NFT to get metadata for&lt;br/&gt;Do &lt;b&gt;not&lt;/b&gt; use this parameter if you are getting metadata for an NFT on Solana, this parameter is irrelevant on Solana.</param>
        /// <param name="account">(Flow only) The account that holds the NFT (optional)</param>
        /// <param name="xTestnetType">Type of Ethereum testnet. Defaults to Sepolia. Valid only for ETH invocations for testnet API Key. For mainnet API Key, this value is ignored. (optional, default to ethereum-sepolia)</param>
        /// <returns>ApiResponse of NftMetadataErc721</returns>
        ApiResponse<NftMetadataErc721> NftGetMetadataErc721WithHttpInfo(string contractAddress, string tokenId, string account = default(string), string xTestnetType = default(string));
        /// <summary>
        /// Get NFT provenance information
        /// </summary>
        /// <remarks>
        /// 1 credit per API call Get provenance information for an NFT. NOTE: This API works only for provenance NFT smart contracts. This API is supported for the following blockchains: BNB Smart Chain Celo Ethereum Harmony Klaytn KuCoin Community Chain Polygon
        /// </remarks>
        /// <exception cref="Tatum.CSharp.Bsc.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="contractAddress">The blockchain address of the NFT to get provenance information for</param>
        /// <param name="tokenId">The ID of the NFT to get provenance information for.</param>
        /// <param name="xTestnetType">Type of Ethereum testnet. Defaults to Sepolia. Valid only for ETH invocations for testnet API Key. For mainnet API Key, this value is ignored. (optional, default to ethereum-sepolia)</param>
        /// <returns>ApiResponse of List&lt;NftProvenanceDataErc721&gt;</returns>
        ApiResponse<List<NftProvenanceDataErc721>> NftGetProvenanceDataErc721WithHttpInfo(string contractAddress, string tokenId, string xTestnetType = default(string));
        /// <summary>
        /// Get NFT royalty information
        /// </summary>
        /// <remarks>
        /// 1 credit per API call Get information about royalties for an NFT. This API is supported for the following blockchains: BNB Smart Chain Celo Ethereum Harmony Klaytn KuCoin Community Chain Polygon Solana TRON
        /// </remarks>
        /// <exception cref="Tatum.CSharp.Bsc.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="contractAddress">The blockchain address of the NFT to get royalty information for</param>
        /// <param name="tokenId">The ID of the NFT to get royalty information for&lt;br/&gt;Do &lt;b&gt;not&lt;/b&gt; use this parameter if you are getting metadata for an NFT on Solana, this parameter is irrelevant on Solana.</param>
        /// <param name="xTestnetType">Type of Ethereum testnet. Defaults to Sepolia. Valid only for ETH invocations for testnet API Key. For mainnet API Key, this value is ignored. (optional, default to ethereum-sepolia)</param>
        /// <returns>ApiResponse of NftRoyaltyErc721</returns>
        ApiResponse<NftRoyaltyErc721> NftGetRoyaltyErc721WithHttpInfo(string contractAddress, string tokenId, string xTestnetType = default(string));
        /// <summary>
        /// Get all NFTs that a blockchain address holds
        /// </summary>
        /// <remarks>
        /// 1 credit per API call + 5 credits for each owned NFT Get all NFTs that a blockchain address holds. The NFTs are returned grouped by the smart contracts they were minted on. This API is supported for the following blockchains: Algorand BNB Smart Chain - mainnet only Celo Ethereum Polygon Solana On Solana and Algorand, if a blockchain address holds fewer than 50 NFTs, the API also returns each NFT&#39;s metadata. If the metadata is not returned, you can obtain it using the API for getting NFT metadata.
        /// </remarks>
        /// <exception cref="Tatum.CSharp.Bsc.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="address">The blockchain address that you want to get the token balance of</param>
        /// <returns>ApiResponse of List&lt;NftTokenByAddressErc721&gt;</returns>
        ApiResponse<List<NftTokenByAddressErc721>> NftGetTokensByAddressErc721WithHttpInfo(string address);
        /// <summary>
        /// Get an NFT transaction by its hash
        /// </summary>
        /// <remarks>
        /// 1 credit per API call Get an NFT transaction by its hash. This API is supported for the following blockchains: BNB Smart Chain Celo Ethereum Flow Harmony Klaytn KuCoin Community Chain Polygon TRON
        /// </remarks>
        /// <exception cref="Tatum.CSharp.Bsc.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="hash">The hash (ID) of the NFT transaction</param>
        /// <param name="xTestnetType">Type of Ethereum testnet. Defaults to Sepolia. Valid only for ETH invocations for testnet API Key. For mainnet API Key, this value is ignored. (optional, default to ethereum-sepolia)</param>
        /// <returns>ApiResponse of EthTx</returns>
        ApiResponse<EthTx> NftGetTransactErc721WithHttpInfo(string hash, string xTestnetType = default(string));
        /// <summary>
        /// Mint an NFT
        /// </summary>
        /// <remarks>
        /// 100 credits per API call on Flow 2 credits per API call on the other blockchains You can mint NFTs using either of the following methods: Using NFT Express Natively on a blockchain Minting NFTs using NFT Express NFT Express is Tatum&#39;s feature that helps you mint NFTs easier than minting natively on a blockchain. You do not need to enter your private key or signature ID. NFT Express uses the private key provided by Tatum. You do not need to hold crypto or keep addresses topped up with crypto to pay for minting transactions. To use NFT Express on the mainnet, you have to have a paid pricing plan. Tatum covers your transaction fees for NFT minting and pays for them from its own blockchain address. Then, the fee amount paid by Tatum is converted to the number of credits, and these credits are deducted from the monthly credit allowance of your paid pricing plan. The transaction fees and the corresponding numbers of credits deducted from your allowance vary depending on what blockchain you mint NFTs on. On the testnet, no credits are deducted from the monthly credit allowance. You can mint NFTs with NFT Express regardless of your pricing plan. With NFT Express, you can choose whether to mint NFTs on the pre-built NFT smart contract provided by Tatum or on your own smart contract. Use the pre-built smart contract provided by Tatum to mint NFTs If you want to mint NFTs using the pre-built smart contract, you do not need to deploy your own NFT smart contract. You do not need to provide the address of the NFT smart contract and the token ID in the request body either. The address of the smart contract and the token ID are provided automatically by Tatum. The token ID is autogenerated. It starts with 0 and is increased by 1 for each new NFT. The token ID is calculated separately for each supported blockchain and its mainnet and testnet. For more information, see our user documentation. You can mint NFTs on the pre-built smart contract provided by Tatum on the following blockchains: Algorand BNB Smart Chain Celo Ethereum Harmony Klaytn Polygon Solana Depending on what blockchain you use, choose the request body schema to use in the API call. To mint NFTs on BNB Smart Chain, Celo, Ethereum, Harmony, Klaytn, or Polygon, use this API with the MintNftExpress schema of the request body. To mint NFTs on Algorand, use this API with the MintNftExpressAlgorand schema of the request body. To be able to burn the minted NFTs any time later, specify the address of the manager account in the manager parameter. An NFT minted on Algorand is automatically transferred to your blockchain address. After the NFT is minted, you have to transfer it to the recipient&#39;s address. The recipient has to agree in advance to receive your NFT because Algorand charges users for storing NFTs on their addresses, and an Algorand blockchain address by default does not receive NFTs unless explicitly agreed. This how it works: The recipient agrees to receive the NFT to their address. You transfer the NFT to the recipient&#39;s address (use the transferNftAlgoExpress schema of the request body). NOTE: On the mainnet, Tatum covers your transaction fees for the NFT transfer and pays for them from its own blockchain address. Then, the fee amount paid by Tatum is converted to the number of credits, and these credits are deducted from the monthly credit allowance of your paid pricing plan. On the testnet, no credits are deducted from the monthly credit allowance. To mint NFTs on Solana, use this API with the MintNftExpressSolana schema of the request body. Solana uses the Metaplex Protocol, a smart contract and metadata standard for creating and working with NFTs. When you mint an NFT on Solana with NFT Express, the pre-built smart contract based on the Metaplex Protocol is used. When an NFT is minted on Solana, a new blockchain address is created to receive the NFT under the recipient&#39;s account address (the one in the to parameter of the request body). This address is returned in the nftAccountAddress parameter in the response body, is owned by the recipient&#39;s address, and has the same private key. The response body also returns the address of the minted NFT itself, which is held in the nftAddress parameter. After the NFT is minted, you have to transfer it to the recipient&#39;s address (use the transferNftSolana or transferNftSolanaKMS schema of the request body). In the request body of the transfer call: Set the from parameter to the address that you used in the to parameter in the request body of the minting call. Set the to parameter to the recipient&#39;s address. Set the contractAddress parameter to the address from the nftAddress parameter returned in the response body of the minting call. Set the fromPrivateKey/signatureId parameter to the private key/signature ID of the blockchain address that you specified in the from parameter. Use your own smart contract to mint NFTs If you want to mint NFTs using your own smart contract, you are going to use an NTF minter, a special blockchain address provided by Tatum that will cover the minting fees. The number of credits equivalent to the fees will be then deducted from the monthly credit allowance of your paid pricing plan. IMPORTANT! Your smart contract must be deployed as a general NFT smart contract. You cannot use cashback and provenance smart contracts with NFT Express. For more information, see our user documentation and the article in the Tatum blog. You can mint NFTs on your own smart contract on the following blockchains: BNB Smart Chain Celo Ethereum Harmony Klaytn Polygon To mint NFTs using your own smart contract, do the following: In the table located under this section, find the blockchain address of the Tatum NFT minter for your blockchain and network (mainnet or testnet). Add the minter address as an NFT minter to your smart contract. Use this API with the MintNftMinter schema of the request body. In the request body, enter the following information: chain is the blockchain that you use. to is the blockchain address where to send the minted NFT to. url is the URL of the NFT metadata. minter is the address of the NFT minter that you found in Step 1. contractAddress is the address of your NFT smart contract. tokenId is the the token ID of the NFT. For example:  {   \&quot;chain\&quot;: \&quot;CELO\&quot;,   \&quot;to\&quot;: \&quot;0x8ce4e40889a13971681391aad29e88efaf91f784\&quot;,   \&quot;url\&quot;: \&quot;ipfs://QmXJJ6UF5WkF4WTJvsdhiA1etGwBLfpva7Vr9AudGMe3pj\&quot;,   \&quot;contractAddress\&quot;: \&quot;0x687422eEA2cB73B5d3e242bA5456b782919AFc85\&quot;,   \&quot;tokenId\&quot;: \&quot;0123\&quot;,   \&quot;minter\&quot;: \&quot;0xBC2eBA680EE50d685cc4Fe65f102AA70AfB27D3F\&quot; } When you make an API call with this request body, the private key of the NFT minter will be added to the request body automatically:  {   \&quot;chain\&quot;: \&quot;CELO\&quot;,   \&quot;to\&quot;: \&quot;0x8ce4e40889a13971681391aad29e88efaf91f784\&quot;,   \&quot;url\&quot;: \&quot;ipfs://QmXJJ6UF5WkF4WTJvsdhiA1etGwBLfpva7Vr9AudGMe3pj\&quot;,   \&quot;contractAddress\&quot;: \&quot;0x687422eEA2cB73B5d3e242bA5456b782919AFc85\&quot;,   \&quot;tokenId\&quot;: \&quot;0123\&quot;,   \&quot;minter\&quot;: \&quot;0xBC2eBA680EE50d685cc4Fe65f102AA70AfB27D3F\&quot;,   \&quot;fromPrivateKey\&quot;: \&quot;0x05e150c73f1920ec14caa1e0b6aa09940899678051a78542840c2668ce5080c2\&quot; } The following table lists the blockchain addresses of the Tatum NFT minters for the testnet and mainnet of the supported blockchains: Blockchain Minter address - testnet* Minter address - mainnet BNB Smart Chain 0xc16ae5e8c985b906935a0cadf4e24f0400531883 0x49678AAB11E001eb3cB2cBD9aA96b36DC2461A94 Celo 0xBC2eBA680EE50d685cc4Fe65f102AA70AfB27D3F 0x49678AAB11E001eb3cB2cBD9aA96b36DC2461A94 Ethereum 0x53e8577C4347C365E4e0DA5B57A589cB6f2AB848 0x49678AAB11E001eb3cB2cBD9aA96b36DC2461A94 Harmony 0x8906f62d40293ddca77fdf6714c3f63265deddf0 0x49678AAB11E001eb3cB2cBD9aA96b36DC2461A94 Klaytn 0x80d8bac9a6901698b3749fe336bbd1385c1f98f2 0x49678AAB11E001eb3cB2cBD9aA96b36DC2461A94 Polygon 0x542b9ac4945a3836fd12ad98acbc76a0c8b743f5 0x49678AAB11E001eb3cB2cBD9aA96b36DC2461A94 *If a minter blockchain address on the testnet does not have sufficient funds to cover the transaction fee, add some amount to it using a crypto faucet of the blockchain. Minting NFTs natively on a blockchain When minting an NFT natively on a blockchain, you are charged a fee for the transaction, and you must sign the transaction with the private key of the blockchain address from which the fee will be deducted. Providing the private key in the API is not a secure way of signing transactions, because the private key can be stolen or exposed. Your private keys should never leave your security perimeter. You should use the private keys only for testing a solution you are building on the testnet of a blockchain. For signing transactions on the mainnet, we strongly recommend that you use the Tatum Key Management System (KMS) and provide the signature ID instead of the private key in the API. Alternatively, you can use the Tatum JavaScript client. You can mint NFTs natively on the following blockchains: Algorand BNB Smart Chain Celo Ethereum Flow Harmony Klaytn KuCoin Community Chain Polygon Solana TRON Depending on what blockchain you use, choose the request body schema to use in the API call. To mint NFTs natively on Algorand and: To sign the transaction with your private key, use this API with the MintNftAlgorand schema of the request body. To sign the transaction with your signature ID, use this API the MintNftAlgorandKMS schema of the request body. NOTE: To be able to burn the minted NFTs any time later, specify the address of the manager account in the manager parameter. An NFT minted on Algorand is automatically transferred to your blockchain address. After the NFT is minted, you have to transfer it to the recipient&#39;s address. The recipient has to agree in advance to receive your NFT because Algorand charges users for storing NFTs on their addresses, and an Algorand blockchain address by default does not receive NFTs unless explicitly agreed. For more information about how it works, see the section about minting NFTs on Algorand using the pre-built NFT smart contract provided by Tatum. To mint NFTs natively on BNB Smart Chain, Ethereum, Harmony, Klaytn, KuCoin Community Chain, or Polygon, and: To sign the transaction with your private key, use this API with the MintNft schema of the request body. To sign the transaction with your signature ID, use this API the MintNftKMS schema of the request body. To mint NFTs natively on Celo and: To sign the transaction with your private key, use this API with the MintNftCelo schema of the request body. To sign the transaction with your signature ID, use this API the MintNftKMSCelo schema of the request body. To mint NFTs natively on Flow and: To sign the transaction with your private key, use this API with the MintNftFlowPK schema of the request body. To sign the transaction with your signature ID, use this API the MintNftFlowMnemonic schema of the request body. To sign the transaction with your wallet mnemonic, use this API the MintNftFlowKMS schema of the request body. To mint NFTs natively on Solana and: To sign the transaction with your private key, use this API with the MintNftSolana schema of the request body. To sign the transaction with your signature ID, use this API the MintNftSolanaKMS schema of the request body. NOTE: When an NFT is minted on Solana, a new blockchain address is created to receive the NFT under the recipient&#39;s account address. After the NFT is minted, you have to transfer it to the recipient&#39;s address. For more information about how it works, see the section about minting NFTs on Solana using the pre-built NFT smart contract provided by Tatum. To mint NFTs natively on TRON and: To sign the transaction with your private key, use this API with the MintNftTron schema of the request body. To sign the transaction with your signature ID, use this API the MintNftKMSTron schema of the request body.
        /// </remarks>
        /// <exception cref="Tatum.CSharp.Bsc.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="mintNftExpress"></param>
        /// <param name="xTestnetType">Type of Ethereum testnet. Defaults to Sepolia. Valid only for ETH invocations for testnet API Key. For mainnet API Key, this value is ignored. (optional, default to ethereum-sepolia)</param>
        /// <returns>ApiResponse of TransactionHash</returns>
        ApiResponse<TransactionHash> NftMintErc721WithHttpInfo(MintNftExpress mintNftExpress, string xTestnetType = default(string));
        /// <summary>
        /// Mint an NFT
        /// </summary>
        /// <remarks>
        /// 100 credits per API call on Flow 2 credits per API call on the other blockchains You can mint NFTs using either of the following methods: Using NFT Express Natively on a blockchain Minting NFTs using NFT Express NFT Express is Tatum&#39;s feature that helps you mint NFTs easier than minting natively on a blockchain. You do not need to enter your private key or signature ID. NFT Express uses the private key provided by Tatum. You do not need to hold crypto or keep addresses topped up with crypto to pay for minting transactions. To use NFT Express on the mainnet, you have to have a paid pricing plan. Tatum covers your transaction fees for NFT minting and pays for them from its own blockchain address. Then, the fee amount paid by Tatum is converted to the number of credits, and these credits are deducted from the monthly credit allowance of your paid pricing plan. The transaction fees and the corresponding numbers of credits deducted from your allowance vary depending on what blockchain you mint NFTs on. On the testnet, no credits are deducted from the monthly credit allowance. You can mint NFTs with NFT Express regardless of your pricing plan. With NFT Express, you can choose whether to mint NFTs on the pre-built NFT smart contract provided by Tatum or on your own smart contract. Use the pre-built smart contract provided by Tatum to mint NFTs If you want to mint NFTs using the pre-built smart contract, you do not need to deploy your own NFT smart contract. You do not need to provide the address of the NFT smart contract and the token ID in the request body either. The address of the smart contract and the token ID are provided automatically by Tatum. The token ID is autogenerated. It starts with 0 and is increased by 1 for each new NFT. The token ID is calculated separately for each supported blockchain and its mainnet and testnet. For more information, see our user documentation. You can mint NFTs on the pre-built smart contract provided by Tatum on the following blockchains: Algorand BNB Smart Chain Celo Ethereum Harmony Klaytn Polygon Solana Depending on what blockchain you use, choose the request body schema to use in the API call. To mint NFTs on BNB Smart Chain, Celo, Ethereum, Harmony, Klaytn, or Polygon, use this API with the MintNftExpress schema of the request body. To mint NFTs on Algorand, use this API with the MintNftExpressAlgorand schema of the request body. To be able to burn the minted NFTs any time later, specify the address of the manager account in the manager parameter. An NFT minted on Algorand is automatically transferred to your blockchain address. After the NFT is minted, you have to transfer it to the recipient&#39;s address. The recipient has to agree in advance to receive your NFT because Algorand charges users for storing NFTs on their addresses, and an Algorand blockchain address by default does not receive NFTs unless explicitly agreed. This how it works: The recipient agrees to receive the NFT to their address. You transfer the NFT to the recipient&#39;s address (use the transferNftAlgoExpress schema of the request body). NOTE: On the mainnet, Tatum covers your transaction fees for the NFT transfer and pays for them from its own blockchain address. Then, the fee amount paid by Tatum is converted to the number of credits, and these credits are deducted from the monthly credit allowance of your paid pricing plan. On the testnet, no credits are deducted from the monthly credit allowance. To mint NFTs on Solana, use this API with the MintNftExpressSolana schema of the request body. Solana uses the Metaplex Protocol, a smart contract and metadata standard for creating and working with NFTs. When you mint an NFT on Solana with NFT Express, the pre-built smart contract based on the Metaplex Protocol is used. When an NFT is minted on Solana, a new blockchain address is created to receive the NFT under the recipient&#39;s account address (the one in the to parameter of the request body). This address is returned in the nftAccountAddress parameter in the response body, is owned by the recipient&#39;s address, and has the same private key. The response body also returns the address of the minted NFT itself, which is held in the nftAddress parameter. After the NFT is minted, you have to transfer it to the recipient&#39;s address (use the transferNftSolana or transferNftSolanaKMS schema of the request body). In the request body of the transfer call: Set the from parameter to the address that you used in the to parameter in the request body of the minting call. Set the to parameter to the recipient&#39;s address. Set the contractAddress parameter to the address from the nftAddress parameter returned in the response body of the minting call. Set the fromPrivateKey/signatureId parameter to the private key/signature ID of the blockchain address that you specified in the from parameter. Use your own smart contract to mint NFTs If you want to mint NFTs using your own smart contract, you are going to use an NTF minter, a special blockchain address provided by Tatum that will cover the minting fees. The number of credits equivalent to the fees will be then deducted from the monthly credit allowance of your paid pricing plan. IMPORTANT! Your smart contract must be deployed as a general NFT smart contract. You cannot use cashback and provenance smart contracts with NFT Express. For more information, see our user documentation and the article in the Tatum blog. You can mint NFTs on your own smart contract on the following blockchains: BNB Smart Chain Celo Ethereum Harmony Klaytn Polygon To mint NFTs using your own smart contract, do the following: In the table located under this section, find the blockchain address of the Tatum NFT minter for your blockchain and network (mainnet or testnet). Add the minter address as an NFT minter to your smart contract. Use this API with the MintNftMinter schema of the request body. In the request body, enter the following information: chain is the blockchain that you use. to is the blockchain address where to send the minted NFT to. url is the URL of the NFT metadata. minter is the address of the NFT minter that you found in Step 1. contractAddress is the address of your NFT smart contract. tokenId is the the token ID of the NFT. For example:  {   \&quot;chain\&quot;: \&quot;CELO\&quot;,   \&quot;to\&quot;: \&quot;0x8ce4e40889a13971681391aad29e88efaf91f784\&quot;,   \&quot;url\&quot;: \&quot;ipfs://QmXJJ6UF5WkF4WTJvsdhiA1etGwBLfpva7Vr9AudGMe3pj\&quot;,   \&quot;contractAddress\&quot;: \&quot;0x687422eEA2cB73B5d3e242bA5456b782919AFc85\&quot;,   \&quot;tokenId\&quot;: \&quot;0123\&quot;,   \&quot;minter\&quot;: \&quot;0xBC2eBA680EE50d685cc4Fe65f102AA70AfB27D3F\&quot; } When you make an API call with this request body, the private key of the NFT minter will be added to the request body automatically:  {   \&quot;chain\&quot;: \&quot;CELO\&quot;,   \&quot;to\&quot;: \&quot;0x8ce4e40889a13971681391aad29e88efaf91f784\&quot;,   \&quot;url\&quot;: \&quot;ipfs://QmXJJ6UF5WkF4WTJvsdhiA1etGwBLfpva7Vr9AudGMe3pj\&quot;,   \&quot;contractAddress\&quot;: \&quot;0x687422eEA2cB73B5d3e242bA5456b782919AFc85\&quot;,   \&quot;tokenId\&quot;: \&quot;0123\&quot;,   \&quot;minter\&quot;: \&quot;0xBC2eBA680EE50d685cc4Fe65f102AA70AfB27D3F\&quot;,   \&quot;fromPrivateKey\&quot;: \&quot;0x05e150c73f1920ec14caa1e0b6aa09940899678051a78542840c2668ce5080c2\&quot; } The following table lists the blockchain addresses of the Tatum NFT minters for the testnet and mainnet of the supported blockchains: Blockchain Minter address - testnet* Minter address - mainnet BNB Smart Chain 0xc16ae5e8c985b906935a0cadf4e24f0400531883 0x49678AAB11E001eb3cB2cBD9aA96b36DC2461A94 Celo 0xBC2eBA680EE50d685cc4Fe65f102AA70AfB27D3F 0x49678AAB11E001eb3cB2cBD9aA96b36DC2461A94 Ethereum 0x53e8577C4347C365E4e0DA5B57A589cB6f2AB848 0x49678AAB11E001eb3cB2cBD9aA96b36DC2461A94 Harmony 0x8906f62d40293ddca77fdf6714c3f63265deddf0 0x49678AAB11E001eb3cB2cBD9aA96b36DC2461A94 Klaytn 0x80d8bac9a6901698b3749fe336bbd1385c1f98f2 0x49678AAB11E001eb3cB2cBD9aA96b36DC2461A94 Polygon 0x542b9ac4945a3836fd12ad98acbc76a0c8b743f5 0x49678AAB11E001eb3cB2cBD9aA96b36DC2461A94 *If a minter blockchain address on the testnet does not have sufficient funds to cover the transaction fee, add some amount to it using a crypto faucet of the blockchain. Minting NFTs natively on a blockchain When minting an NFT natively on a blockchain, you are charged a fee for the transaction, and you must sign the transaction with the private key of the blockchain address from which the fee will be deducted. Providing the private key in the API is not a secure way of signing transactions, because the private key can be stolen or exposed. Your private keys should never leave your security perimeter. You should use the private keys only for testing a solution you are building on the testnet of a blockchain. For signing transactions on the mainnet, we strongly recommend that you use the Tatum Key Management System (KMS) and provide the signature ID instead of the private key in the API. Alternatively, you can use the Tatum JavaScript client. You can mint NFTs natively on the following blockchains: Algorand BNB Smart Chain Celo Ethereum Flow Harmony Klaytn KuCoin Community Chain Polygon Solana TRON Depending on what blockchain you use, choose the request body schema to use in the API call. To mint NFTs natively on Algorand and: To sign the transaction with your private key, use this API with the MintNftAlgorand schema of the request body. To sign the transaction with your signature ID, use this API the MintNftAlgorandKMS schema of the request body. NOTE: To be able to burn the minted NFTs any time later, specify the address of the manager account in the manager parameter. An NFT minted on Algorand is automatically transferred to your blockchain address. After the NFT is minted, you have to transfer it to the recipient&#39;s address. The recipient has to agree in advance to receive your NFT because Algorand charges users for storing NFTs on their addresses, and an Algorand blockchain address by default does not receive NFTs unless explicitly agreed. For more information about how it works, see the section about minting NFTs on Algorand using the pre-built NFT smart contract provided by Tatum. To mint NFTs natively on BNB Smart Chain, Ethereum, Harmony, Klaytn, KuCoin Community Chain, or Polygon, and: To sign the transaction with your private key, use this API with the MintNft schema of the request body. To sign the transaction with your signature ID, use this API the MintNftKMS schema of the request body. To mint NFTs natively on Celo and: To sign the transaction with your private key, use this API with the MintNftCelo schema of the request body. To sign the transaction with your signature ID, use this API the MintNftKMSCelo schema of the request body. To mint NFTs natively on Flow and: To sign the transaction with your private key, use this API with the MintNftFlowPK schema of the request body. To sign the transaction with your signature ID, use this API the MintNftFlowMnemonic schema of the request body. To sign the transaction with your wallet mnemonic, use this API the MintNftFlowKMS schema of the request body. To mint NFTs natively on Solana and: To sign the transaction with your private key, use this API with the MintNftSolana schema of the request body. To sign the transaction with your signature ID, use this API the MintNftSolanaKMS schema of the request body. NOTE: When an NFT is minted on Solana, a new blockchain address is created to receive the NFT under the recipient&#39;s account address. After the NFT is minted, you have to transfer it to the recipient&#39;s address. For more information about how it works, see the section about minting NFTs on Solana using the pre-built NFT smart contract provided by Tatum. To mint NFTs natively on TRON and: To sign the transaction with your private key, use this API with the MintNftTron schema of the request body. To sign the transaction with your signature ID, use this API the MintNftKMSTron schema of the request body.
        /// </remarks>
        /// <exception cref="Tatum.CSharp.Bsc.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="mintNftMinter"></param>
        /// <param name="xTestnetType">Type of Ethereum testnet. Defaults to Sepolia. Valid only for ETH invocations for testnet API Key. For mainnet API Key, this value is ignored. (optional, default to ethereum-sepolia)</param>
        /// <returns>ApiResponse of TransactionHash</returns>
        ApiResponse<TransactionHash> NftMintErc721WithHttpInfo(MintNftMinter mintNftMinter, string xTestnetType = default(string));
        /// <summary>
        /// Mint an NFT
        /// </summary>
        /// <remarks>
        /// 100 credits per API call on Flow 2 credits per API call on the other blockchains You can mint NFTs using either of the following methods: Using NFT Express Natively on a blockchain Minting NFTs using NFT Express NFT Express is Tatum&#39;s feature that helps you mint NFTs easier than minting natively on a blockchain. You do not need to enter your private key or signature ID. NFT Express uses the private key provided by Tatum. You do not need to hold crypto or keep addresses topped up with crypto to pay for minting transactions. To use NFT Express on the mainnet, you have to have a paid pricing plan. Tatum covers your transaction fees for NFT minting and pays for them from its own blockchain address. Then, the fee amount paid by Tatum is converted to the number of credits, and these credits are deducted from the monthly credit allowance of your paid pricing plan. The transaction fees and the corresponding numbers of credits deducted from your allowance vary depending on what blockchain you mint NFTs on. On the testnet, no credits are deducted from the monthly credit allowance. You can mint NFTs with NFT Express regardless of your pricing plan. With NFT Express, you can choose whether to mint NFTs on the pre-built NFT smart contract provided by Tatum or on your own smart contract. Use the pre-built smart contract provided by Tatum to mint NFTs If you want to mint NFTs using the pre-built smart contract, you do not need to deploy your own NFT smart contract. You do not need to provide the address of the NFT smart contract and the token ID in the request body either. The address of the smart contract and the token ID are provided automatically by Tatum. The token ID is autogenerated. It starts with 0 and is increased by 1 for each new NFT. The token ID is calculated separately for each supported blockchain and its mainnet and testnet. For more information, see our user documentation. You can mint NFTs on the pre-built smart contract provided by Tatum on the following blockchains: Algorand BNB Smart Chain Celo Ethereum Harmony Klaytn Polygon Solana Depending on what blockchain you use, choose the request body schema to use in the API call. To mint NFTs on BNB Smart Chain, Celo, Ethereum, Harmony, Klaytn, or Polygon, use this API with the MintNftExpress schema of the request body. To mint NFTs on Algorand, use this API with the MintNftExpressAlgorand schema of the request body. To be able to burn the minted NFTs any time later, specify the address of the manager account in the manager parameter. An NFT minted on Algorand is automatically transferred to your blockchain address. After the NFT is minted, you have to transfer it to the recipient&#39;s address. The recipient has to agree in advance to receive your NFT because Algorand charges users for storing NFTs on their addresses, and an Algorand blockchain address by default does not receive NFTs unless explicitly agreed. This how it works: The recipient agrees to receive the NFT to their address. You transfer the NFT to the recipient&#39;s address (use the transferNftAlgoExpress schema of the request body). NOTE: On the mainnet, Tatum covers your transaction fees for the NFT transfer and pays for them from its own blockchain address. Then, the fee amount paid by Tatum is converted to the number of credits, and these credits are deducted from the monthly credit allowance of your paid pricing plan. On the testnet, no credits are deducted from the monthly credit allowance. To mint NFTs on Solana, use this API with the MintNftExpressSolana schema of the request body. Solana uses the Metaplex Protocol, a smart contract and metadata standard for creating and working with NFTs. When you mint an NFT on Solana with NFT Express, the pre-built smart contract based on the Metaplex Protocol is used. When an NFT is minted on Solana, a new blockchain address is created to receive the NFT under the recipient&#39;s account address (the one in the to parameter of the request body). This address is returned in the nftAccountAddress parameter in the response body, is owned by the recipient&#39;s address, and has the same private key. The response body also returns the address of the minted NFT itself, which is held in the nftAddress parameter. After the NFT is minted, you have to transfer it to the recipient&#39;s address (use the transferNftSolana or transferNftSolanaKMS schema of the request body). In the request body of the transfer call: Set the from parameter to the address that you used in the to parameter in the request body of the minting call. Set the to parameter to the recipient&#39;s address. Set the contractAddress parameter to the address from the nftAddress parameter returned in the response body of the minting call. Set the fromPrivateKey/signatureId parameter to the private key/signature ID of the blockchain address that you specified in the from parameter. Use your own smart contract to mint NFTs If you want to mint NFTs using your own smart contract, you are going to use an NTF minter, a special blockchain address provided by Tatum that will cover the minting fees. The number of credits equivalent to the fees will be then deducted from the monthly credit allowance of your paid pricing plan. IMPORTANT! Your smart contract must be deployed as a general NFT smart contract. You cannot use cashback and provenance smart contracts with NFT Express. For more information, see our user documentation and the article in the Tatum blog. You can mint NFTs on your own smart contract on the following blockchains: BNB Smart Chain Celo Ethereum Harmony Klaytn Polygon To mint NFTs using your own smart contract, do the following: In the table located under this section, find the blockchain address of the Tatum NFT minter for your blockchain and network (mainnet or testnet). Add the minter address as an NFT minter to your smart contract. Use this API with the MintNftMinter schema of the request body. In the request body, enter the following information: chain is the blockchain that you use. to is the blockchain address where to send the minted NFT to. url is the URL of the NFT metadata. minter is the address of the NFT minter that you found in Step 1. contractAddress is the address of your NFT smart contract. tokenId is the the token ID of the NFT. For example:  {   \&quot;chain\&quot;: \&quot;CELO\&quot;,   \&quot;to\&quot;: \&quot;0x8ce4e40889a13971681391aad29e88efaf91f784\&quot;,   \&quot;url\&quot;: \&quot;ipfs://QmXJJ6UF5WkF4WTJvsdhiA1etGwBLfpva7Vr9AudGMe3pj\&quot;,   \&quot;contractAddress\&quot;: \&quot;0x687422eEA2cB73B5d3e242bA5456b782919AFc85\&quot;,   \&quot;tokenId\&quot;: \&quot;0123\&quot;,   \&quot;minter\&quot;: \&quot;0xBC2eBA680EE50d685cc4Fe65f102AA70AfB27D3F\&quot; } When you make an API call with this request body, the private key of the NFT minter will be added to the request body automatically:  {   \&quot;chain\&quot;: \&quot;CELO\&quot;,   \&quot;to\&quot;: \&quot;0x8ce4e40889a13971681391aad29e88efaf91f784\&quot;,   \&quot;url\&quot;: \&quot;ipfs://QmXJJ6UF5WkF4WTJvsdhiA1etGwBLfpva7Vr9AudGMe3pj\&quot;,   \&quot;contractAddress\&quot;: \&quot;0x687422eEA2cB73B5d3e242bA5456b782919AFc85\&quot;,   \&quot;tokenId\&quot;: \&quot;0123\&quot;,   \&quot;minter\&quot;: \&quot;0xBC2eBA680EE50d685cc4Fe65f102AA70AfB27D3F\&quot;,   \&quot;fromPrivateKey\&quot;: \&quot;0x05e150c73f1920ec14caa1e0b6aa09940899678051a78542840c2668ce5080c2\&quot; } The following table lists the blockchain addresses of the Tatum NFT minters for the testnet and mainnet of the supported blockchains: Blockchain Minter address - testnet* Minter address - mainnet BNB Smart Chain 0xc16ae5e8c985b906935a0cadf4e24f0400531883 0x49678AAB11E001eb3cB2cBD9aA96b36DC2461A94 Celo 0xBC2eBA680EE50d685cc4Fe65f102AA70AfB27D3F 0x49678AAB11E001eb3cB2cBD9aA96b36DC2461A94 Ethereum 0x53e8577C4347C365E4e0DA5B57A589cB6f2AB848 0x49678AAB11E001eb3cB2cBD9aA96b36DC2461A94 Harmony 0x8906f62d40293ddca77fdf6714c3f63265deddf0 0x49678AAB11E001eb3cB2cBD9aA96b36DC2461A94 Klaytn 0x80d8bac9a6901698b3749fe336bbd1385c1f98f2 0x49678AAB11E001eb3cB2cBD9aA96b36DC2461A94 Polygon 0x542b9ac4945a3836fd12ad98acbc76a0c8b743f5 0x49678AAB11E001eb3cB2cBD9aA96b36DC2461A94 *If a minter blockchain address on the testnet does not have sufficient funds to cover the transaction fee, add some amount to it using a crypto faucet of the blockchain. Minting NFTs natively on a blockchain When minting an NFT natively on a blockchain, you are charged a fee for the transaction, and you must sign the transaction with the private key of the blockchain address from which the fee will be deducted. Providing the private key in the API is not a secure way of signing transactions, because the private key can be stolen or exposed. Your private keys should never leave your security perimeter. You should use the private keys only for testing a solution you are building on the testnet of a blockchain. For signing transactions on the mainnet, we strongly recommend that you use the Tatum Key Management System (KMS) and provide the signature ID instead of the private key in the API. Alternatively, you can use the Tatum JavaScript client. You can mint NFTs natively on the following blockchains: Algorand BNB Smart Chain Celo Ethereum Flow Harmony Klaytn KuCoin Community Chain Polygon Solana TRON Depending on what blockchain you use, choose the request body schema to use in the API call. To mint NFTs natively on Algorand and: To sign the transaction with your private key, use this API with the MintNftAlgorand schema of the request body. To sign the transaction with your signature ID, use this API the MintNftAlgorandKMS schema of the request body. NOTE: To be able to burn the minted NFTs any time later, specify the address of the manager account in the manager parameter. An NFT minted on Algorand is automatically transferred to your blockchain address. After the NFT is minted, you have to transfer it to the recipient&#39;s address. The recipient has to agree in advance to receive your NFT because Algorand charges users for storing NFTs on their addresses, and an Algorand blockchain address by default does not receive NFTs unless explicitly agreed. For more information about how it works, see the section about minting NFTs on Algorand using the pre-built NFT smart contract provided by Tatum. To mint NFTs natively on BNB Smart Chain, Ethereum, Harmony, Klaytn, KuCoin Community Chain, or Polygon, and: To sign the transaction with your private key, use this API with the MintNft schema of the request body. To sign the transaction with your signature ID, use this API the MintNftKMS schema of the request body. To mint NFTs natively on Celo and: To sign the transaction with your private key, use this API with the MintNftCelo schema of the request body. To sign the transaction with your signature ID, use this API the MintNftKMSCelo schema of the request body. To mint NFTs natively on Flow and: To sign the transaction with your private key, use this API with the MintNftFlowPK schema of the request body. To sign the transaction with your signature ID, use this API the MintNftFlowMnemonic schema of the request body. To sign the transaction with your wallet mnemonic, use this API the MintNftFlowKMS schema of the request body. To mint NFTs natively on Solana and: To sign the transaction with your private key, use this API with the MintNftSolana schema of the request body. To sign the transaction with your signature ID, use this API the MintNftSolanaKMS schema of the request body. NOTE: When an NFT is minted on Solana, a new blockchain address is created to receive the NFT under the recipient&#39;s account address. After the NFT is minted, you have to transfer it to the recipient&#39;s address. For more information about how it works, see the section about minting NFTs on Solana using the pre-built NFT smart contract provided by Tatum. To mint NFTs natively on TRON and: To sign the transaction with your private key, use this API with the MintNftTron schema of the request body. To sign the transaction with your signature ID, use this API the MintNftKMSTron schema of the request body.
        /// </remarks>
        /// <exception cref="Tatum.CSharp.Bsc.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="mintNft"></param>
        /// <param name="xTestnetType">Type of Ethereum testnet. Defaults to Sepolia. Valid only for ETH invocations for testnet API Key. For mainnet API Key, this value is ignored. (optional, default to ethereum-sepolia)</param>
        /// <returns>ApiResponse of TransactionHash</returns>
        ApiResponse<TransactionHash> NftMintErc721WithHttpInfo(MintNft mintNft, string xTestnetType = default(string));
        /// <summary>
        /// Mint an NFT
        /// </summary>
        /// <remarks>
        /// 100 credits per API call on Flow 2 credits per API call on the other blockchains You can mint NFTs using either of the following methods: Using NFT Express Natively on a blockchain Minting NFTs using NFT Express NFT Express is Tatum&#39;s feature that helps you mint NFTs easier than minting natively on a blockchain. You do not need to enter your private key or signature ID. NFT Express uses the private key provided by Tatum. You do not need to hold crypto or keep addresses topped up with crypto to pay for minting transactions. To use NFT Express on the mainnet, you have to have a paid pricing plan. Tatum covers your transaction fees for NFT minting and pays for them from its own blockchain address. Then, the fee amount paid by Tatum is converted to the number of credits, and these credits are deducted from the monthly credit allowance of your paid pricing plan. The transaction fees and the corresponding numbers of credits deducted from your allowance vary depending on what blockchain you mint NFTs on. On the testnet, no credits are deducted from the monthly credit allowance. You can mint NFTs with NFT Express regardless of your pricing plan. With NFT Express, you can choose whether to mint NFTs on the pre-built NFT smart contract provided by Tatum or on your own smart contract. Use the pre-built smart contract provided by Tatum to mint NFTs If you want to mint NFTs using the pre-built smart contract, you do not need to deploy your own NFT smart contract. You do not need to provide the address of the NFT smart contract and the token ID in the request body either. The address of the smart contract and the token ID are provided automatically by Tatum. The token ID is autogenerated. It starts with 0 and is increased by 1 for each new NFT. The token ID is calculated separately for each supported blockchain and its mainnet and testnet. For more information, see our user documentation. You can mint NFTs on the pre-built smart contract provided by Tatum on the following blockchains: Algorand BNB Smart Chain Celo Ethereum Harmony Klaytn Polygon Solana Depending on what blockchain you use, choose the request body schema to use in the API call. To mint NFTs on BNB Smart Chain, Celo, Ethereum, Harmony, Klaytn, or Polygon, use this API with the MintNftExpress schema of the request body. To mint NFTs on Algorand, use this API with the MintNftExpressAlgorand schema of the request body. To be able to burn the minted NFTs any time later, specify the address of the manager account in the manager parameter. An NFT minted on Algorand is automatically transferred to your blockchain address. After the NFT is minted, you have to transfer it to the recipient&#39;s address. The recipient has to agree in advance to receive your NFT because Algorand charges users for storing NFTs on their addresses, and an Algorand blockchain address by default does not receive NFTs unless explicitly agreed. This how it works: The recipient agrees to receive the NFT to their address. You transfer the NFT to the recipient&#39;s address (use the transferNftAlgoExpress schema of the request body). NOTE: On the mainnet, Tatum covers your transaction fees for the NFT transfer and pays for them from its own blockchain address. Then, the fee amount paid by Tatum is converted to the number of credits, and these credits are deducted from the monthly credit allowance of your paid pricing plan. On the testnet, no credits are deducted from the monthly credit allowance. To mint NFTs on Solana, use this API with the MintNftExpressSolana schema of the request body. Solana uses the Metaplex Protocol, a smart contract and metadata standard for creating and working with NFTs. When you mint an NFT on Solana with NFT Express, the pre-built smart contract based on the Metaplex Protocol is used. When an NFT is minted on Solana, a new blockchain address is created to receive the NFT under the recipient&#39;s account address (the one in the to parameter of the request body). This address is returned in the nftAccountAddress parameter in the response body, is owned by the recipient&#39;s address, and has the same private key. The response body also returns the address of the minted NFT itself, which is held in the nftAddress parameter. After the NFT is minted, you have to transfer it to the recipient&#39;s address (use the transferNftSolana or transferNftSolanaKMS schema of the request body). In the request body of the transfer call: Set the from parameter to the address that you used in the to parameter in the request body of the minting call. Set the to parameter to the recipient&#39;s address. Set the contractAddress parameter to the address from the nftAddress parameter returned in the response body of the minting call. Set the fromPrivateKey/signatureId parameter to the private key/signature ID of the blockchain address that you specified in the from parameter. Use your own smart contract to mint NFTs If you want to mint NFTs using your own smart contract, you are going to use an NTF minter, a special blockchain address provided by Tatum that will cover the minting fees. The number of credits equivalent to the fees will be then deducted from the monthly credit allowance of your paid pricing plan. IMPORTANT! Your smart contract must be deployed as a general NFT smart contract. You cannot use cashback and provenance smart contracts with NFT Express. For more information, see our user documentation and the article in the Tatum blog. You can mint NFTs on your own smart contract on the following blockchains: BNB Smart Chain Celo Ethereum Harmony Klaytn Polygon To mint NFTs using your own smart contract, do the following: In the table located under this section, find the blockchain address of the Tatum NFT minter for your blockchain and network (mainnet or testnet). Add the minter address as an NFT minter to your smart contract. Use this API with the MintNftMinter schema of the request body. In the request body, enter the following information: chain is the blockchain that you use. to is the blockchain address where to send the minted NFT to. url is the URL of the NFT metadata. minter is the address of the NFT minter that you found in Step 1. contractAddress is the address of your NFT smart contract. tokenId is the the token ID of the NFT. For example:  {   \&quot;chain\&quot;: \&quot;CELO\&quot;,   \&quot;to\&quot;: \&quot;0x8ce4e40889a13971681391aad29e88efaf91f784\&quot;,   \&quot;url\&quot;: \&quot;ipfs://QmXJJ6UF5WkF4WTJvsdhiA1etGwBLfpva7Vr9AudGMe3pj\&quot;,   \&quot;contractAddress\&quot;: \&quot;0x687422eEA2cB73B5d3e242bA5456b782919AFc85\&quot;,   \&quot;tokenId\&quot;: \&quot;0123\&quot;,   \&quot;minter\&quot;: \&quot;0xBC2eBA680EE50d685cc4Fe65f102AA70AfB27D3F\&quot; } When you make an API call with this request body, the private key of the NFT minter will be added to the request body automatically:  {   \&quot;chain\&quot;: \&quot;CELO\&quot;,   \&quot;to\&quot;: \&quot;0x8ce4e40889a13971681391aad29e88efaf91f784\&quot;,   \&quot;url\&quot;: \&quot;ipfs://QmXJJ6UF5WkF4WTJvsdhiA1etGwBLfpva7Vr9AudGMe3pj\&quot;,   \&quot;contractAddress\&quot;: \&quot;0x687422eEA2cB73B5d3e242bA5456b782919AFc85\&quot;,   \&quot;tokenId\&quot;: \&quot;0123\&quot;,   \&quot;minter\&quot;: \&quot;0xBC2eBA680EE50d685cc4Fe65f102AA70AfB27D3F\&quot;,   \&quot;fromPrivateKey\&quot;: \&quot;0x05e150c73f1920ec14caa1e0b6aa09940899678051a78542840c2668ce5080c2\&quot; } The following table lists the blockchain addresses of the Tatum NFT minters for the testnet and mainnet of the supported blockchains: Blockchain Minter address - testnet* Minter address - mainnet BNB Smart Chain 0xc16ae5e8c985b906935a0cadf4e24f0400531883 0x49678AAB11E001eb3cB2cBD9aA96b36DC2461A94 Celo 0xBC2eBA680EE50d685cc4Fe65f102AA70AfB27D3F 0x49678AAB11E001eb3cB2cBD9aA96b36DC2461A94 Ethereum 0x53e8577C4347C365E4e0DA5B57A589cB6f2AB848 0x49678AAB11E001eb3cB2cBD9aA96b36DC2461A94 Harmony 0x8906f62d40293ddca77fdf6714c3f63265deddf0 0x49678AAB11E001eb3cB2cBD9aA96b36DC2461A94 Klaytn 0x80d8bac9a6901698b3749fe336bbd1385c1f98f2 0x49678AAB11E001eb3cB2cBD9aA96b36DC2461A94 Polygon 0x542b9ac4945a3836fd12ad98acbc76a0c8b743f5 0x49678AAB11E001eb3cB2cBD9aA96b36DC2461A94 *If a minter blockchain address on the testnet does not have sufficient funds to cover the transaction fee, add some amount to it using a crypto faucet of the blockchain. Minting NFTs natively on a blockchain When minting an NFT natively on a blockchain, you are charged a fee for the transaction, and you must sign the transaction with the private key of the blockchain address from which the fee will be deducted. Providing the private key in the API is not a secure way of signing transactions, because the private key can be stolen or exposed. Your private keys should never leave your security perimeter. You should use the private keys only for testing a solution you are building on the testnet of a blockchain. For signing transactions on the mainnet, we strongly recommend that you use the Tatum Key Management System (KMS) and provide the signature ID instead of the private key in the API. Alternatively, you can use the Tatum JavaScript client. You can mint NFTs natively on the following blockchains: Algorand BNB Smart Chain Celo Ethereum Flow Harmony Klaytn KuCoin Community Chain Polygon Solana TRON Depending on what blockchain you use, choose the request body schema to use in the API call. To mint NFTs natively on Algorand and: To sign the transaction with your private key, use this API with the MintNftAlgorand schema of the request body. To sign the transaction with your signature ID, use this API the MintNftAlgorandKMS schema of the request body. NOTE: To be able to burn the minted NFTs any time later, specify the address of the manager account in the manager parameter. An NFT minted on Algorand is automatically transferred to your blockchain address. After the NFT is minted, you have to transfer it to the recipient&#39;s address. The recipient has to agree in advance to receive your NFT because Algorand charges users for storing NFTs on their addresses, and an Algorand blockchain address by default does not receive NFTs unless explicitly agreed. For more information about how it works, see the section about minting NFTs on Algorand using the pre-built NFT smart contract provided by Tatum. To mint NFTs natively on BNB Smart Chain, Ethereum, Harmony, Klaytn, KuCoin Community Chain, or Polygon, and: To sign the transaction with your private key, use this API with the MintNft schema of the request body. To sign the transaction with your signature ID, use this API the MintNftKMS schema of the request body. To mint NFTs natively on Celo and: To sign the transaction with your private key, use this API with the MintNftCelo schema of the request body. To sign the transaction with your signature ID, use this API the MintNftKMSCelo schema of the request body. To mint NFTs natively on Flow and: To sign the transaction with your private key, use this API with the MintNftFlowPK schema of the request body. To sign the transaction with your signature ID, use this API the MintNftFlowMnemonic schema of the request body. To sign the transaction with your wallet mnemonic, use this API the MintNftFlowKMS schema of the request body. To mint NFTs natively on Solana and: To sign the transaction with your private key, use this API with the MintNftSolana schema of the request body. To sign the transaction with your signature ID, use this API the MintNftSolanaKMS schema of the request body. NOTE: When an NFT is minted on Solana, a new blockchain address is created to receive the NFT under the recipient&#39;s account address. After the NFT is minted, you have to transfer it to the recipient&#39;s address. For more information about how it works, see the section about minting NFTs on Solana using the pre-built NFT smart contract provided by Tatum. To mint NFTs natively on TRON and: To sign the transaction with your private key, use this API with the MintNftTron schema of the request body. To sign the transaction with your signature ID, use this API the MintNftKMSTron schema of the request body.
        /// </remarks>
        /// <exception cref="Tatum.CSharp.Bsc.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="mintNftKMS"></param>
        /// <param name="xTestnetType">Type of Ethereum testnet. Defaults to Sepolia. Valid only for ETH invocations for testnet API Key. For mainnet API Key, this value is ignored. (optional, default to ethereum-sepolia)</param>
        /// <returns>ApiResponse of SignatureId</returns>
        ApiResponse<SignatureId> NftMintErc721WithHttpInfo(MintNftKMS mintNftKMS, string xTestnetType = default(string));
        /// <summary>
        /// Mint multiple NFTs
        /// </summary>
        /// <remarks>
        /// 100 credits per API call on Flow 2 credits per API call on the other blockchains Create multiple NFT Tokens and transfer them to destination account. Create and transfer any NFT tokens from smart contract defined in contractAddress. This API is supported for the following blockchains: BNB Smart Chain Celo Ethereum Flow Harmony Klaytn KuCoin Community Chain Polygon TRON This operation works in two modes. First mode works just like other NFT endpoints. Every time the funds are transferred, the transaction must be signed with the corresponding private key. No one should ever send it&#39;s own private keys to the internet because there is a strong possibility of stealing keys and loss of funds. In this method, it is possible to enter privateKey or signatureId. PrivateKey should be used only for quick development on testnet versions of blockchain when there is no risk of losing funds. In production, Tatum KMS should be used for the highest security standards, and signatureId should be present in the request. Alternatively, using the Tatum client library for supported languages. Second mode enables you to mint on any custom NFT ERC-721 smart contract, on which specified minter address is approved as a minter. You don&#39;t specify private key or signatureId, only minter address, from which the NFT will be minted. It means you perform mint multiple NFT request with following body: {    \&quot;to\&quot;: [\&quot;0x80d8bac9a6901698b3749fe336bbd1385c1f98f2\&quot;],    \&quot;url\&quot;: [\&quot;ipfs://QmXJJ6UF5WkF4WTJvsdhiA1etGwBLfpva7Vr9AudGMe3pj\&quot;],    \&quot;tokenId\&quot;: [\&quot;9876541124516\&quot;],    \&quot;contractAddress\&quot;:\&quot;0xcd2ada00c48a27faa5cc67f9a1ed55b89ddf7f77\&quot;,    \&quot;minter\&quot;: \&quot;0x542b9ac4945a3836fd12ad98acbc76a0c8b743f5\&quot;,    \&quot;chain\&quot;: \&quot;MATIC\&quot; } The blockchain fee of the performed transaction is paid from the address connected with built-in private key and is debited in form of credits. The credits are debited only if NFT mint requests are performed with paid API key plan. We transform fee to the credits in accordance to the rates provided by the Tatum. If you want to batch mint on ERC-721 contract which is not deployed via Tatum API, your smart contract must contain this method: mintMultiple(address[] to, uint256[] tokenId, string[] uri): boolean You can use addresses specified in the bellow table to be used as a minter. Chain Testnet address Mainnet Address MATIC 0x542b9ac4945a3836fd12ad98acbc76a0c8b743f5 0xcf9e127455d28e7362380aec1b92ddee8200b295 BSC 0xc16ae5e8c985b906935a0cadf4e24f0400531883 0xcf9e127455d28e7362380aec1b92ddee8200b295 ONE 0x8906f62d40293ddca77fdf6714c3f63265deddf0 0xcf9e127455d28e7362380aec1b92ddee8200b295 ETH 0x53e8577C4347C365E4e0DA5B57A589cB6f2AB848 0xcf9e127455d28e7362380aec1b92ddee8200b295 CELO 0xBC2eBA680EE50d685cc4Fe65f102AA70AfB27D3F 0xcf9e127455d28e7362380aec1b92ddee8200b295 KLAY 0x80d8bac9a6901698b3749fe336bbd1385c1f98f2 0xcf9e127455d28e7362380aec1b92ddee8200b295 If there are not enough coins on any testnet address, feel free to send coins there.
        /// </remarks>
        /// <exception cref="Tatum.CSharp.Bsc.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="mintMultipleNftMinter"></param>
        /// <param name="xTestnetType">Type of Ethereum testnet. Defaults to Sepolia. Valid only for ETH invocations for testnet API Key. For mainnet API Key, this value is ignored. (optional, default to ethereum-sepolia)</param>
        /// <returns>ApiResponse of TransactionHash</returns>
        ApiResponse<TransactionHash> NftMintMultipleErc721WithHttpInfo(MintMultipleNftMinter mintMultipleNftMinter, string xTestnetType = default(string));
        /// <summary>
        /// Mint multiple NFTs
        /// </summary>
        /// <remarks>
        /// 100 credits per API call on Flow 2 credits per API call on the other blockchains Create multiple NFT Tokens and transfer them to destination account. Create and transfer any NFT tokens from smart contract defined in contractAddress. This API is supported for the following blockchains: BNB Smart Chain Celo Ethereum Flow Harmony Klaytn KuCoin Community Chain Polygon TRON This operation works in two modes. First mode works just like other NFT endpoints. Every time the funds are transferred, the transaction must be signed with the corresponding private key. No one should ever send it&#39;s own private keys to the internet because there is a strong possibility of stealing keys and loss of funds. In this method, it is possible to enter privateKey or signatureId. PrivateKey should be used only for quick development on testnet versions of blockchain when there is no risk of losing funds. In production, Tatum KMS should be used for the highest security standards, and signatureId should be present in the request. Alternatively, using the Tatum client library for supported languages. Second mode enables you to mint on any custom NFT ERC-721 smart contract, on which specified minter address is approved as a minter. You don&#39;t specify private key or signatureId, only minter address, from which the NFT will be minted. It means you perform mint multiple NFT request with following body: {    \&quot;to\&quot;: [\&quot;0x80d8bac9a6901698b3749fe336bbd1385c1f98f2\&quot;],    \&quot;url\&quot;: [\&quot;ipfs://QmXJJ6UF5WkF4WTJvsdhiA1etGwBLfpva7Vr9AudGMe3pj\&quot;],    \&quot;tokenId\&quot;: [\&quot;9876541124516\&quot;],    \&quot;contractAddress\&quot;:\&quot;0xcd2ada00c48a27faa5cc67f9a1ed55b89ddf7f77\&quot;,    \&quot;minter\&quot;: \&quot;0x542b9ac4945a3836fd12ad98acbc76a0c8b743f5\&quot;,    \&quot;chain\&quot;: \&quot;MATIC\&quot; } The blockchain fee of the performed transaction is paid from the address connected with built-in private key and is debited in form of credits. The credits are debited only if NFT mint requests are performed with paid API key plan. We transform fee to the credits in accordance to the rates provided by the Tatum. If you want to batch mint on ERC-721 contract which is not deployed via Tatum API, your smart contract must contain this method: mintMultiple(address[] to, uint256[] tokenId, string[] uri): boolean You can use addresses specified in the bellow table to be used as a minter. Chain Testnet address Mainnet Address MATIC 0x542b9ac4945a3836fd12ad98acbc76a0c8b743f5 0xcf9e127455d28e7362380aec1b92ddee8200b295 BSC 0xc16ae5e8c985b906935a0cadf4e24f0400531883 0xcf9e127455d28e7362380aec1b92ddee8200b295 ONE 0x8906f62d40293ddca77fdf6714c3f63265deddf0 0xcf9e127455d28e7362380aec1b92ddee8200b295 ETH 0x53e8577C4347C365E4e0DA5B57A589cB6f2AB848 0xcf9e127455d28e7362380aec1b92ddee8200b295 CELO 0xBC2eBA680EE50d685cc4Fe65f102AA70AfB27D3F 0xcf9e127455d28e7362380aec1b92ddee8200b295 KLAY 0x80d8bac9a6901698b3749fe336bbd1385c1f98f2 0xcf9e127455d28e7362380aec1b92ddee8200b295 If there are not enough coins on any testnet address, feel free to send coins there.
        /// </remarks>
        /// <exception cref="Tatum.CSharp.Bsc.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="mintMultipleNft"></param>
        /// <param name="xTestnetType">Type of Ethereum testnet. Defaults to Sepolia. Valid only for ETH invocations for testnet API Key. For mainnet API Key, this value is ignored. (optional, default to ethereum-sepolia)</param>
        /// <returns>ApiResponse of TransactionHash</returns>
        ApiResponse<TransactionHash> NftMintMultipleErc721WithHttpInfo(MintMultipleNft mintMultipleNft, string xTestnetType = default(string));
        /// <summary>
        /// Mint multiple NFTs
        /// </summary>
        /// <remarks>
        /// 100 credits per API call on Flow 2 credits per API call on the other blockchains Create multiple NFT Tokens and transfer them to destination account. Create and transfer any NFT tokens from smart contract defined in contractAddress. This API is supported for the following blockchains: BNB Smart Chain Celo Ethereum Flow Harmony Klaytn KuCoin Community Chain Polygon TRON This operation works in two modes. First mode works just like other NFT endpoints. Every time the funds are transferred, the transaction must be signed with the corresponding private key. No one should ever send it&#39;s own private keys to the internet because there is a strong possibility of stealing keys and loss of funds. In this method, it is possible to enter privateKey or signatureId. PrivateKey should be used only for quick development on testnet versions of blockchain when there is no risk of losing funds. In production, Tatum KMS should be used for the highest security standards, and signatureId should be present in the request. Alternatively, using the Tatum client library for supported languages. Second mode enables you to mint on any custom NFT ERC-721 smart contract, on which specified minter address is approved as a minter. You don&#39;t specify private key or signatureId, only minter address, from which the NFT will be minted. It means you perform mint multiple NFT request with following body: {    \&quot;to\&quot;: [\&quot;0x80d8bac9a6901698b3749fe336bbd1385c1f98f2\&quot;],    \&quot;url\&quot;: [\&quot;ipfs://QmXJJ6UF5WkF4WTJvsdhiA1etGwBLfpva7Vr9AudGMe3pj\&quot;],    \&quot;tokenId\&quot;: [\&quot;9876541124516\&quot;],    \&quot;contractAddress\&quot;:\&quot;0xcd2ada00c48a27faa5cc67f9a1ed55b89ddf7f77\&quot;,    \&quot;minter\&quot;: \&quot;0x542b9ac4945a3836fd12ad98acbc76a0c8b743f5\&quot;,    \&quot;chain\&quot;: \&quot;MATIC\&quot; } The blockchain fee of the performed transaction is paid from the address connected with built-in private key and is debited in form of credits. The credits are debited only if NFT mint requests are performed with paid API key plan. We transform fee to the credits in accordance to the rates provided by the Tatum. If you want to batch mint on ERC-721 contract which is not deployed via Tatum API, your smart contract must contain this method: mintMultiple(address[] to, uint256[] tokenId, string[] uri): boolean You can use addresses specified in the bellow table to be used as a minter. Chain Testnet address Mainnet Address MATIC 0x542b9ac4945a3836fd12ad98acbc76a0c8b743f5 0xcf9e127455d28e7362380aec1b92ddee8200b295 BSC 0xc16ae5e8c985b906935a0cadf4e24f0400531883 0xcf9e127455d28e7362380aec1b92ddee8200b295 ONE 0x8906f62d40293ddca77fdf6714c3f63265deddf0 0xcf9e127455d28e7362380aec1b92ddee8200b295 ETH 0x53e8577C4347C365E4e0DA5B57A589cB6f2AB848 0xcf9e127455d28e7362380aec1b92ddee8200b295 CELO 0xBC2eBA680EE50d685cc4Fe65f102AA70AfB27D3F 0xcf9e127455d28e7362380aec1b92ddee8200b295 KLAY 0x80d8bac9a6901698b3749fe336bbd1385c1f98f2 0xcf9e127455d28e7362380aec1b92ddee8200b295 If there are not enough coins on any testnet address, feel free to send coins there.
        /// </remarks>
        /// <exception cref="Tatum.CSharp.Bsc.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="mintMultipleNftKMS"></param>
        /// <param name="xTestnetType">Type of Ethereum testnet. Defaults to Sepolia. Valid only for ETH invocations for testnet API Key. For mainnet API Key, this value is ignored. (optional, default to ethereum-sepolia)</param>
        /// <returns>ApiResponse of SignatureId</returns>
        ApiResponse<SignatureId> NftMintMultipleErc721WithHttpInfo(MintMultipleNftKMS mintMultipleNftKMS, string xTestnetType = default(string));
        /// <summary>
        /// Transfer an NFT
        /// </summary>
        /// <remarks>
        /// 100 credits per API call on Flow 2 credits per API call on the other blockchains Transfer an NFT from the smart contract (the contractAddress parameter in the request body) to the specified blockchain address (the to parameter in the request body). In one API call, you can transfer only one NFT. This API is supported for the following blockchains: Algorand BNB Smart Chain Celo Ethereum Flow Harmony Klaytn KuCoin Community Chain Polygon Solana TRON For Ethereum, Celo, and BNB Smart Chain, transferring NFTs invokes the safeTransfer() method. Transferring NFTs on Algorand On Algorand, the recipient has to agree in advance to receive your NFT because Algorand charges users for storing NFTs on their addresses, and an Algorand blockchain address by default does not receive NFTs unless explicitly agreed. Before transferring an NFT, make sure that the recipient has agreed to receive the NFT to their address. If you want to transfer an NFT that was minted using NFT Express, use the transferNftAlgoExpress schema of the request body. NOTE: On the mainnet, Tatum covers your transaction fees for the NFT transfer and pays for them from its own blockchain address. Then, the fee amount paid by Tatum is converted to the number of credits, and these credits are deducted from the monthly credit allowance of your paid pricing plan. On the testnet, no credits are deducted from the monthly credit allowance. Transferring NFTs on Solana If you want to transfer an NFT that was minted using NFT Express, see the section about minting NFTs on Solana using the pre-built NFT smart contract provided by Tatum for the information about how to set up the parameters in the request body. Signing a transaction When transferring an NFT, you are charged a fee for the transaction, and you must sign the transaction with the private key of the blockchain address from which the fee will be deducted. Providing the private key in the API is not a secure way of signing transactions, because the private key can be stolen or exposed. Your private keys should never leave your security perimeter. You should use the private keys only for testing a solution you are building on the testnet of a blockchain. For signing transactions on the mainnet, we strongly recommend that you use the Tatum Key Management System (KMS) and provide the signature ID instead of the private key in the API. Alternatively, you can use the Tatum JavaScript client. NOTE: This does not apply to transferring NFTs that were minted on Algorand using NFT Express (see earlier in this section).
        /// </remarks>
        /// <exception cref="Tatum.CSharp.Bsc.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="transferNft"></param>
        /// <param name="xTestnetType">Type of Ethereum testnet. Defaults to Sepolia. Valid only for ETH invocations for testnet API Key. For mainnet API Key, this value is ignored. (optional, default to ethereum-sepolia)</param>
        /// <returns>ApiResponse of TransactionHash</returns>
        ApiResponse<TransactionHash> NftTransferErc721WithHttpInfo(TransferNft transferNft, string xTestnetType = default(string));
        /// <summary>
        /// Transfer an NFT
        /// </summary>
        /// <remarks>
        /// 100 credits per API call on Flow 2 credits per API call on the other blockchains Transfer an NFT from the smart contract (the contractAddress parameter in the request body) to the specified blockchain address (the to parameter in the request body). In one API call, you can transfer only one NFT. This API is supported for the following blockchains: Algorand BNB Smart Chain Celo Ethereum Flow Harmony Klaytn KuCoin Community Chain Polygon Solana TRON For Ethereum, Celo, and BNB Smart Chain, transferring NFTs invokes the safeTransfer() method. Transferring NFTs on Algorand On Algorand, the recipient has to agree in advance to receive your NFT because Algorand charges users for storing NFTs on their addresses, and an Algorand blockchain address by default does not receive NFTs unless explicitly agreed. Before transferring an NFT, make sure that the recipient has agreed to receive the NFT to their address. If you want to transfer an NFT that was minted using NFT Express, use the transferNftAlgoExpress schema of the request body. NOTE: On the mainnet, Tatum covers your transaction fees for the NFT transfer and pays for them from its own blockchain address. Then, the fee amount paid by Tatum is converted to the number of credits, and these credits are deducted from the monthly credit allowance of your paid pricing plan. On the testnet, no credits are deducted from the monthly credit allowance. Transferring NFTs on Solana If you want to transfer an NFT that was minted using NFT Express, see the section about minting NFTs on Solana using the pre-built NFT smart contract provided by Tatum for the information about how to set up the parameters in the request body. Signing a transaction When transferring an NFT, you are charged a fee for the transaction, and you must sign the transaction with the private key of the blockchain address from which the fee will be deducted. Providing the private key in the API is not a secure way of signing transactions, because the private key can be stolen or exposed. Your private keys should never leave your security perimeter. You should use the private keys only for testing a solution you are building on the testnet of a blockchain. For signing transactions on the mainnet, we strongly recommend that you use the Tatum Key Management System (KMS) and provide the signature ID instead of the private key in the API. Alternatively, you can use the Tatum JavaScript client. NOTE: This does not apply to transferring NFTs that were minted on Algorand using NFT Express (see earlier in this section).
        /// </remarks>
        /// <exception cref="Tatum.CSharp.Bsc.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="transferNftKMS"></param>
        /// <param name="xTestnetType">Type of Ethereum testnet. Defaults to Sepolia. Valid only for ETH invocations for testnet API Key. For mainnet API Key, this value is ignored. (optional, default to ethereum-sepolia)</param>
        /// <returns>ApiResponse of SignatureId</returns>
        ApiResponse<SignatureId> NftTransferErc721WithHttpInfo(TransferNftKMS transferNftKMS, string xTestnetType = default(string));
        /// <summary>
        /// Update NFT royalty information
        /// </summary>
        /// <remarks>
        /// 2 credits per API call Update the value of the royalty cashback set for an NFT. The royalty cashback value can be updated only from the address of the NFT author (the address that is listed as a royalty cashback receiver in the NFT royalty information). The royalty cashback value cannot be updated from the address of the NFT owner. In one API call, you can update the first value of the royalty cashback for the NFT author for one NFT. To disable the royalties for the NFT completely, set it to 0. This API is supported for the following blockchains: BNB Smart Chain Celo Ethereum Harmony Klaytn KuCoin Community Chain Polygon TRON Signing a transaction When updating NFT royalty, you are charged a fee for the transaction, and you must sign the transaction with the private key of the blockchain address from which the fee will be deducted. Providing the private key in the API is not a secure way of signing transactions, because the private key can be stolen or exposed. Your private keys should never leave your security perimeter. You should use the private keys only for testing a solution you are building on the testnet of a blockchain. For signing transactions on the mainnet, we strongly recommend that you use the Tatum Key Management System (KMS) and provide the signature ID instead of the private key in the API. Alternatively, you can use the Tatum JavaScript client.
        /// </remarks>
        /// <exception cref="Tatum.CSharp.Bsc.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="updateCashbackValueForAuthorNft"></param>
        /// <param name="xTestnetType">Type of Ethereum testnet. Defaults to Sepolia. Valid only for ETH invocations for testnet API Key. For mainnet API Key, this value is ignored. (optional, default to ethereum-sepolia)</param>
        /// <returns>ApiResponse of TransactionHash</returns>
        ApiResponse<TransactionHash> NftUpdateCashbackErc721WithHttpInfo(UpdateCashbackValueForAuthorNft updateCashbackValueForAuthorNft, string xTestnetType = default(string));
        /// <summary>
        /// Update NFT royalty information
        /// </summary>
        /// <remarks>
        /// 2 credits per API call Update the value of the royalty cashback set for an NFT. The royalty cashback value can be updated only from the address of the NFT author (the address that is listed as a royalty cashback receiver in the NFT royalty information). The royalty cashback value cannot be updated from the address of the NFT owner. In one API call, you can update the first value of the royalty cashback for the NFT author for one NFT. To disable the royalties for the NFT completely, set it to 0. This API is supported for the following blockchains: BNB Smart Chain Celo Ethereum Harmony Klaytn KuCoin Community Chain Polygon TRON Signing a transaction When updating NFT royalty, you are charged a fee for the transaction, and you must sign the transaction with the private key of the blockchain address from which the fee will be deducted. Providing the private key in the API is not a secure way of signing transactions, because the private key can be stolen or exposed. Your private keys should never leave your security perimeter. You should use the private keys only for testing a solution you are building on the testnet of a blockchain. For signing transactions on the mainnet, we strongly recommend that you use the Tatum Key Management System (KMS) and provide the signature ID instead of the private key in the API. Alternatively, you can use the Tatum JavaScript client.
        /// </remarks>
        /// <exception cref="Tatum.CSharp.Bsc.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="updateCashbackValueForAuthorNftKMS"></param>
        /// <param name="xTestnetType">Type of Ethereum testnet. Defaults to Sepolia. Valid only for ETH invocations for testnet API Key. For mainnet API Key, this value is ignored. (optional, default to ethereum-sepolia)</param>
        /// <returns>ApiResponse of SignatureId</returns>
        ApiResponse<SignatureId> NftUpdateCashbackErc721WithHttpInfo(UpdateCashbackValueForAuthorNftKMS updateCashbackValueForAuthorNftKMS, string xTestnetType = default(string));
        #endregion Synchronous Operations With Http Info
    }

    /// <summary>
    /// Represents a collection of functions to interact with the API endpoints
    /// </summary>
    public interface INFTBscApiAsync : IApiAccessor
    {
        #region Asynchronous Operations
        /// <summary>
        /// Add an NFT minter to an NFT smart contract
        /// </summary>
        /// <remarks>
        /// 2 credits per API call Allow a blockchain address (the minter parameter in the request body) to mint NFTs on the NFT smart contract (the contractAddress parameter in the request body). Use this API when you are using NFT Express with your own smart contract to mint NFTs and need to add the Tatum NFT minter&#39;s address as an NFT minter to your smart contract. For more information about the Tatum NFT minter, see \&quot;Use your own smart contract to mint NFTs\&quot; in Mint an NFT. This API is supported for the following blockchains: BNB Smart Chain Celo Ethereum Harmony Klaytn KuCoin Community Chain Polygon Signing a transaction When adding an NFT minter, you are charged a fee for the transaction, and you must sign the transaction with the private key of the blockchain address from which the fee will be deducted. Providing the private key in the API is not a secure way of signing transactions, because the private key can be stolen or exposed. Your private keys should never leave your security perimeter. You should use the private keys only for testing a solution you are building on the testnet of a blockchain. For signing transactions on the mainnet, we strongly recommend that you use the Tatum Key Management System (KMS) and provide the signature ID instead of the private key in the API. Alternatively, you can use the Tatum JavaScript client.
        /// </remarks>
        /// <exception cref="Tatum.CSharp.Bsc.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="addNftMinter"></param>
        /// <param name="xTestnetType">Type of Ethereum testnet. Defaults to Sepolia. Valid only for ETH invocations for testnet API Key. For mainnet API Key, this value is ignored. (optional, default to ethereum-sepolia)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of TransactionHash</returns>
        System.Threading.Tasks.Task<TransactionHash> NftAddMinterAsync(AddNftMinter addNftMinter, string xTestnetType = default(string), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        /// <summary>
        /// Add an NFT minter to an NFT smart contract
        /// </summary>
        /// <remarks>
        /// 2 credits per API call Allow a blockchain address (the minter parameter in the request body) to mint NFTs on the NFT smart contract (the contractAddress parameter in the request body). Use this API when you are using NFT Express with your own smart contract to mint NFTs and need to add the Tatum NFT minter&#39;s address as an NFT minter to your smart contract. For more information about the Tatum NFT minter, see \&quot;Use your own smart contract to mint NFTs\&quot; in Mint an NFT. This API is supported for the following blockchains: BNB Smart Chain Celo Ethereum Harmony Klaytn KuCoin Community Chain Polygon Signing a transaction When adding an NFT minter, you are charged a fee for the transaction, and you must sign the transaction with the private key of the blockchain address from which the fee will be deducted. Providing the private key in the API is not a secure way of signing transactions, because the private key can be stolen or exposed. Your private keys should never leave your security perimeter. You should use the private keys only for testing a solution you are building on the testnet of a blockchain. For signing transactions on the mainnet, we strongly recommend that you use the Tatum Key Management System (KMS) and provide the signature ID instead of the private key in the API. Alternatively, you can use the Tatum JavaScript client.
        /// </remarks>
        /// <exception cref="Tatum.CSharp.Bsc.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="addNftMinterKMS"></param>
        /// <param name="xTestnetType">Type of Ethereum testnet. Defaults to Sepolia. Valid only for ETH invocations for testnet API Key. For mainnet API Key, this value is ignored. (optional, default to ethereum-sepolia)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of SignatureId</returns>
        System.Threading.Tasks.Task<SignatureId> NftAddMinterAsync(AddNftMinterKMS addNftMinterKMS, string xTestnetType = default(string), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        /// <summary>
        /// Burn an NFT
        /// </summary>
        /// <remarks>
        /// 100 credits per API call on Flow 2 credits per API call on the other blockchains Destroy an NFT. Burning the NFT transfers it to an un-spendable blockchain address that no one can access. This API is supported for the following blockchains: Algorand BNB Smart Chain Celo Ethereum Flow Harmony Klaytn KuCoin Community Chain Polygon TRON Burning NFTs on Algorand You can burn only the NFTs that were minted with the address of the manager account specified in the manager parameter in the minting call (see the MintNftExpressAlgorand, MintNftAlgorand, and MintNftAlgorandKMS schemas of the request body). Signing a transaction When burning an NFT, you are charged a fee for the transaction, and you must sign the transaction with the private key of the blockchain address from which the fee will be deducted. Providing the private key in the API is not a secure way of signing transactions, because the private key can be stolen or exposed. Your private keys should never leave your security perimeter. You should use the private keys only for testing a solution you are building on the testnet of a blockchain. For signing transactions on the mainnet, we strongly recommend that you use the Tatum Key Management System (KMS) and provide the signature ID instead of the private key in the API. Alternatively, you can use the Tatum JavaScript client.
        /// </remarks>
        /// <exception cref="Tatum.CSharp.Bsc.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="burnNft"></param>
        /// <param name="xTestnetType">Type of Ethereum testnet. Defaults to Sepolia. Valid only for ETH invocations for testnet API Key. For mainnet API Key, this value is ignored. (optional, default to ethereum-sepolia)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of TransactionHash</returns>
        System.Threading.Tasks.Task<TransactionHash> NftBurnErc721Async(BurnNft burnNft, string xTestnetType = default(string), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        /// <summary>
        /// Burn an NFT
        /// </summary>
        /// <remarks>
        /// 100 credits per API call on Flow 2 credits per API call on the other blockchains Destroy an NFT. Burning the NFT transfers it to an un-spendable blockchain address that no one can access. This API is supported for the following blockchains: Algorand BNB Smart Chain Celo Ethereum Flow Harmony Klaytn KuCoin Community Chain Polygon TRON Burning NFTs on Algorand You can burn only the NFTs that were minted with the address of the manager account specified in the manager parameter in the minting call (see the MintNftExpressAlgorand, MintNftAlgorand, and MintNftAlgorandKMS schemas of the request body). Signing a transaction When burning an NFT, you are charged a fee for the transaction, and you must sign the transaction with the private key of the blockchain address from which the fee will be deducted. Providing the private key in the API is not a secure way of signing transactions, because the private key can be stolen or exposed. Your private keys should never leave your security perimeter. You should use the private keys only for testing a solution you are building on the testnet of a blockchain. For signing transactions on the mainnet, we strongly recommend that you use the Tatum Key Management System (KMS) and provide the signature ID instead of the private key in the API. Alternatively, you can use the Tatum JavaScript client.
        /// </remarks>
        /// <exception cref="Tatum.CSharp.Bsc.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="burnNftKMS"></param>
        /// <param name="xTestnetType">Type of Ethereum testnet. Defaults to Sepolia. Valid only for ETH invocations for testnet API Key. For mainnet API Key, this value is ignored. (optional, default to ethereum-sepolia)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of SignatureId</returns>
        System.Threading.Tasks.Task<SignatureId> NftBurnErc721Async(BurnNftKMS burnNftKMS, string xTestnetType = default(string), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        /// <summary>
        /// Deploy an NFT smart contract
        /// </summary>
        /// <remarks>
        /// 100 credits per API call on Flow 2 credits per API call on the other blockchains Deploy an NFT smart contract on the blockchain. In a deployed NFT smart contract, you can mint NFTs (one NFT at a time or multiple NFTs at once), burn, and transfer NFTs. Smart contracts are standardized and audited. You can review the code of a deployed NFT smart contract here (if the contract is deployed on Flow) or here (if the contract is deployed on any other supported blockchain). This API is supported for the following blockchains: BNB Smart Chain Celo Ethereum Flow Harmony Klaytn KuCoin Community Chain Polygon TRON General NFT smart contracts By default, an NFT smart contract is deployed as a general NFT smart contract compatible with OpenSea royalties. This is a standard NFT contract with AccessControl and Ownable, enhanced with NFT batch minting. NFTs minted on this smart contract are compatible with OpenSea and its royalty structure. Cashback and provenance NFT smart contracts In addition to the general NFT contract, you can deploy the following types of NFT smart contracts for the supported blockchains except for Flow and TRON: Cashback NFT smart contract is an NFT smart contract that forces on-chain royalties to be paid every time an NFT is transferred, and the royalties are defined as a fixed value. The royalties are not OpenSea-compatible. To deploy an NFT smart contract as a cashback contract, deploy the contract with the cashback parameter set to true in the request body. Provenance NFT smart contract is an NFT smart contract that forces on-chain royalties to be paid every time an NFT is transferred, and the royalties are defined as a percentage of the NFT price. The royalties are not OpenSea-compatible. To deploy an NFT smart contract as a provenance contract, deploy the contract with the provenance parameter set to true in the request body. You can enable public minting for cashback and provenance smart contracts. By default, public minting is disabled, which means that only the blockchain address whose private key was used to create the smart contract or the blockchain addresses added to the smart contract as NFT minters will be able to mint NFTs for the contract. To enable public minting and allow anyone to mint NFTs on top of the smart contract, deploy the contract with the publicMint parameter set to true in the request body. NFT smart contracts and NFT Express If you want to use NFT Express to mint NFTs on the deployed smart contract, deploy the smart contract as a general NFT smart contract (that is, deploy the contract with the cashback, provenance, and publicMint parameters either set to false or not set at all in the request body). After you have deployed the NFT smart contract, add the Tatum minter address as an NFT minter to your smart contract. For the complete information about using NFT Express on your smart contract, see \&quot;Use your own smart contract to mint NFTs\&quot; in Mint an NFT. Signing a transaction When deploying an NFT smart contract, you are charged a fee for the transaction, and you must sign the transaction with the private key of the blockchain address from which the fee will be deducted. Providing the private key in the API is not a secure way of signing transactions, because the private key can be stolen or exposed. Your private keys should never leave your security perimeter. You should use the private keys only for testing a solution you are building on the testnet of a blockchain. For signing transactions on the mainnet, we strongly recommend that you use the Tatum Key Management System (KMS) and provide the signature ID instead of the private key in the API. Alternatively, you can use the Tatum JavaScript client.
        /// </remarks>
        /// <exception cref="Tatum.CSharp.Bsc.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="deployNft"></param>
        /// <param name="xTestnetType">Type of Ethereum testnet. Defaults to Sepolia. Valid only for ETH invocations for testnet API Key. For mainnet API Key, this value is ignored. (optional, default to ethereum-sepolia)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of TransactionHash</returns>
        System.Threading.Tasks.Task<TransactionHash> NftDeployErc721Async(DeployNft deployNft, string xTestnetType = default(string), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        /// <summary>
        /// Deploy an NFT smart contract
        /// </summary>
        /// <remarks>
        /// 100 credits per API call on Flow 2 credits per API call on the other blockchains Deploy an NFT smart contract on the blockchain. In a deployed NFT smart contract, you can mint NFTs (one NFT at a time or multiple NFTs at once), burn, and transfer NFTs. Smart contracts are standardized and audited. You can review the code of a deployed NFT smart contract here (if the contract is deployed on Flow) or here (if the contract is deployed on any other supported blockchain). This API is supported for the following blockchains: BNB Smart Chain Celo Ethereum Flow Harmony Klaytn KuCoin Community Chain Polygon TRON General NFT smart contracts By default, an NFT smart contract is deployed as a general NFT smart contract compatible with OpenSea royalties. This is a standard NFT contract with AccessControl and Ownable, enhanced with NFT batch minting. NFTs minted on this smart contract are compatible with OpenSea and its royalty structure. Cashback and provenance NFT smart contracts In addition to the general NFT contract, you can deploy the following types of NFT smart contracts for the supported blockchains except for Flow and TRON: Cashback NFT smart contract is an NFT smart contract that forces on-chain royalties to be paid every time an NFT is transferred, and the royalties are defined as a fixed value. The royalties are not OpenSea-compatible. To deploy an NFT smart contract as a cashback contract, deploy the contract with the cashback parameter set to true in the request body. Provenance NFT smart contract is an NFT smart contract that forces on-chain royalties to be paid every time an NFT is transferred, and the royalties are defined as a percentage of the NFT price. The royalties are not OpenSea-compatible. To deploy an NFT smart contract as a provenance contract, deploy the contract with the provenance parameter set to true in the request body. You can enable public minting for cashback and provenance smart contracts. By default, public minting is disabled, which means that only the blockchain address whose private key was used to create the smart contract or the blockchain addresses added to the smart contract as NFT minters will be able to mint NFTs for the contract. To enable public minting and allow anyone to mint NFTs on top of the smart contract, deploy the contract with the publicMint parameter set to true in the request body. NFT smart contracts and NFT Express If you want to use NFT Express to mint NFTs on the deployed smart contract, deploy the smart contract as a general NFT smart contract (that is, deploy the contract with the cashback, provenance, and publicMint parameters either set to false or not set at all in the request body). After you have deployed the NFT smart contract, add the Tatum minter address as an NFT minter to your smart contract. For the complete information about using NFT Express on your smart contract, see \&quot;Use your own smart contract to mint NFTs\&quot; in Mint an NFT. Signing a transaction When deploying an NFT smart contract, you are charged a fee for the transaction, and you must sign the transaction with the private key of the blockchain address from which the fee will be deducted. Providing the private key in the API is not a secure way of signing transactions, because the private key can be stolen or exposed. Your private keys should never leave your security perimeter. You should use the private keys only for testing a solution you are building on the testnet of a blockchain. For signing transactions on the mainnet, we strongly recommend that you use the Tatum Key Management System (KMS) and provide the signature ID instead of the private key in the API. Alternatively, you can use the Tatum JavaScript client.
        /// </remarks>
        /// <exception cref="Tatum.CSharp.Bsc.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="deployNftKMS"></param>
        /// <param name="xTestnetType">Type of Ethereum testnet. Defaults to Sepolia. Valid only for ETH invocations for testnet API Key. For mainnet API Key, this value is ignored. (optional, default to ethereum-sepolia)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of SignatureId</returns>
        System.Threading.Tasks.Task<SignatureId> NftDeployErc721Async(DeployNftKMS deployNftKMS, string xTestnetType = default(string), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        /// <summary>
        /// Get the NFTs from a specific smart contract that a blockchain address holds
        /// </summary>
        /// <remarks>
        /// 1 credit per API call Get the NFTs minted on a specific smart contract (the contractAddress path parameter in the request endpoint URL) that a blockchain address holds. NOTE: This API works only for the NFT smart contracts deployed using the Tatum smart contract API. This API is supported for the following blockchains: Algorand BNB Smart Chain Celo Elrond Ethereum Flow Harmony Klaytn KuCoin Community Chain Polygon Solana TRON
        /// </remarks>
        /// <exception cref="Tatum.CSharp.Bsc.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="address">The blockchain address that you want to get the token balance of</param>
        /// <param name="contractAddress">The address of the NFT smart contract</param>
        /// <param name="xTestnetType">Type of Ethereum testnet. Defaults to Sepolia. Valid only for ETH invocations for testnet API Key. For mainnet API Key, this value is ignored. (optional, default to ethereum-sepolia)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of NftGetBalanceSc</returns>
        System.Threading.Tasks.Task<NftGetBalanceSc> NftGetBalanceErc721Async(string address, string contractAddress, string xTestnetType = default(string), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        /// <summary>
        /// Get NFT metadata
        /// </summary>
        /// <remarks>
        /// 1 credit per API call Get metadata of an NFT. This API is supported for the following blockchains: BNB Smart Chain Celo Ethereum Flow Harmony Klaytn KuCoin Community Chain Polygon Solana TRON
        /// </remarks>
        /// <exception cref="Tatum.CSharp.Bsc.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="contractAddress">The blockchain address of the NFT to get metadata for</param>
        /// <param name="tokenId">The ID of the NFT to get metadata for&lt;br/&gt;Do &lt;b&gt;not&lt;/b&gt; use this parameter if you are getting metadata for an NFT on Solana, this parameter is irrelevant on Solana.</param>
        /// <param name="account">(Flow only) The account that holds the NFT (optional)</param>
        /// <param name="xTestnetType">Type of Ethereum testnet. Defaults to Sepolia. Valid only for ETH invocations for testnet API Key. For mainnet API Key, this value is ignored. (optional, default to ethereum-sepolia)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of NftMetadataErc721</returns>
        System.Threading.Tasks.Task<NftMetadataErc721> NftGetMetadataErc721Async(string contractAddress, string tokenId, string account = default(string), string xTestnetType = default(string), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        /// <summary>
        /// Get NFT provenance information
        /// </summary>
        /// <remarks>
        /// 1 credit per API call Get provenance information for an NFT. NOTE: This API works only for provenance NFT smart contracts. This API is supported for the following blockchains: BNB Smart Chain Celo Ethereum Harmony Klaytn KuCoin Community Chain Polygon
        /// </remarks>
        /// <exception cref="Tatum.CSharp.Bsc.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="contractAddress">The blockchain address of the NFT to get provenance information for</param>
        /// <param name="tokenId">The ID of the NFT to get provenance information for.</param>
        /// <param name="xTestnetType">Type of Ethereum testnet. Defaults to Sepolia. Valid only for ETH invocations for testnet API Key. For mainnet API Key, this value is ignored. (optional, default to ethereum-sepolia)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of List&lt;NftProvenanceDataErc721&gt;</returns>
        System.Threading.Tasks.Task<List<NftProvenanceDataErc721>> NftGetProvenanceDataErc721Async(string contractAddress, string tokenId, string xTestnetType = default(string), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        /// <summary>
        /// Get NFT royalty information
        /// </summary>
        /// <remarks>
        /// 1 credit per API call Get information about royalties for an NFT. This API is supported for the following blockchains: BNB Smart Chain Celo Ethereum Harmony Klaytn KuCoin Community Chain Polygon Solana TRON
        /// </remarks>
        /// <exception cref="Tatum.CSharp.Bsc.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="contractAddress">The blockchain address of the NFT to get royalty information for</param>
        /// <param name="tokenId">The ID of the NFT to get royalty information for&lt;br/&gt;Do &lt;b&gt;not&lt;/b&gt; use this parameter if you are getting metadata for an NFT on Solana, this parameter is irrelevant on Solana.</param>
        /// <param name="xTestnetType">Type of Ethereum testnet. Defaults to Sepolia. Valid only for ETH invocations for testnet API Key. For mainnet API Key, this value is ignored. (optional, default to ethereum-sepolia)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of NftRoyaltyErc721</returns>
        System.Threading.Tasks.Task<NftRoyaltyErc721> NftGetRoyaltyErc721Async(string contractAddress, string tokenId, string xTestnetType = default(string), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        /// <summary>
        /// Get all NFTs that a blockchain address holds
        /// </summary>
        /// <remarks>
        /// 1 credit per API call + 5 credits for each owned NFT Get all NFTs that a blockchain address holds. The NFTs are returned grouped by the smart contracts they were minted on. This API is supported for the following blockchains: Algorand BNB Smart Chain - mainnet only Celo Ethereum Polygon Solana On Solana and Algorand, if a blockchain address holds fewer than 50 NFTs, the API also returns each NFT&#39;s metadata. If the metadata is not returned, you can obtain it using the API for getting NFT metadata.
        /// </remarks>
        /// <exception cref="Tatum.CSharp.Bsc.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="address">The blockchain address that you want to get the token balance of</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of List&lt;NftTokenByAddressErc721&gt;</returns>
        System.Threading.Tasks.Task<List<NftTokenByAddressErc721>> NftGetTokensByAddressErc721Async(string address, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        /// <summary>
        /// Get an NFT transaction by its hash
        /// </summary>
        /// <remarks>
        /// 1 credit per API call Get an NFT transaction by its hash. This API is supported for the following blockchains: BNB Smart Chain Celo Ethereum Flow Harmony Klaytn KuCoin Community Chain Polygon TRON
        /// </remarks>
        /// <exception cref="Tatum.CSharp.Bsc.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="hash">The hash (ID) of the NFT transaction</param>
        /// <param name="xTestnetType">Type of Ethereum testnet. Defaults to Sepolia. Valid only for ETH invocations for testnet API Key. For mainnet API Key, this value is ignored. (optional, default to ethereum-sepolia)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of EthTx</returns>
        System.Threading.Tasks.Task<EthTx> NftGetTransactErc721Async(string hash, string xTestnetType = default(string), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        /// <summary>
        /// Mint an NFT
        /// </summary>
        /// <remarks>
        /// 100 credits per API call on Flow 2 credits per API call on the other blockchains You can mint NFTs using either of the following methods: Using NFT Express Natively on a blockchain Minting NFTs using NFT Express NFT Express is Tatum&#39;s feature that helps you mint NFTs easier than minting natively on a blockchain. You do not need to enter your private key or signature ID. NFT Express uses the private key provided by Tatum. You do not need to hold crypto or keep addresses topped up with crypto to pay for minting transactions. To use NFT Express on the mainnet, you have to have a paid pricing plan. Tatum covers your transaction fees for NFT minting and pays for them from its own blockchain address. Then, the fee amount paid by Tatum is converted to the number of credits, and these credits are deducted from the monthly credit allowance of your paid pricing plan. The transaction fees and the corresponding numbers of credits deducted from your allowance vary depending on what blockchain you mint NFTs on. On the testnet, no credits are deducted from the monthly credit allowance. You can mint NFTs with NFT Express regardless of your pricing plan. With NFT Express, you can choose whether to mint NFTs on the pre-built NFT smart contract provided by Tatum or on your own smart contract. Use the pre-built smart contract provided by Tatum to mint NFTs If you want to mint NFTs using the pre-built smart contract, you do not need to deploy your own NFT smart contract. You do not need to provide the address of the NFT smart contract and the token ID in the request body either. The address of the smart contract and the token ID are provided automatically by Tatum. The token ID is autogenerated. It starts with 0 and is increased by 1 for each new NFT. The token ID is calculated separately for each supported blockchain and its mainnet and testnet. For more information, see our user documentation. You can mint NFTs on the pre-built smart contract provided by Tatum on the following blockchains: Algorand BNB Smart Chain Celo Ethereum Harmony Klaytn Polygon Solana Depending on what blockchain you use, choose the request body schema to use in the API call. To mint NFTs on BNB Smart Chain, Celo, Ethereum, Harmony, Klaytn, or Polygon, use this API with the MintNftExpress schema of the request body. To mint NFTs on Algorand, use this API with the MintNftExpressAlgorand schema of the request body. To be able to burn the minted NFTs any time later, specify the address of the manager account in the manager parameter. An NFT minted on Algorand is automatically transferred to your blockchain address. After the NFT is minted, you have to transfer it to the recipient&#39;s address. The recipient has to agree in advance to receive your NFT because Algorand charges users for storing NFTs on their addresses, and an Algorand blockchain address by default does not receive NFTs unless explicitly agreed. This how it works: The recipient agrees to receive the NFT to their address. You transfer the NFT to the recipient&#39;s address (use the transferNftAlgoExpress schema of the request body). NOTE: On the mainnet, Tatum covers your transaction fees for the NFT transfer and pays for them from its own blockchain address. Then, the fee amount paid by Tatum is converted to the number of credits, and these credits are deducted from the monthly credit allowance of your paid pricing plan. On the testnet, no credits are deducted from the monthly credit allowance. To mint NFTs on Solana, use this API with the MintNftExpressSolana schema of the request body. Solana uses the Metaplex Protocol, a smart contract and metadata standard for creating and working with NFTs. When you mint an NFT on Solana with NFT Express, the pre-built smart contract based on the Metaplex Protocol is used. When an NFT is minted on Solana, a new blockchain address is created to receive the NFT under the recipient&#39;s account address (the one in the to parameter of the request body). This address is returned in the nftAccountAddress parameter in the response body, is owned by the recipient&#39;s address, and has the same private key. The response body also returns the address of the minted NFT itself, which is held in the nftAddress parameter. After the NFT is minted, you have to transfer it to the recipient&#39;s address (use the transferNftSolana or transferNftSolanaKMS schema of the request body). In the request body of the transfer call: Set the from parameter to the address that you used in the to parameter in the request body of the minting call. Set the to parameter to the recipient&#39;s address. Set the contractAddress parameter to the address from the nftAddress parameter returned in the response body of the minting call. Set the fromPrivateKey/signatureId parameter to the private key/signature ID of the blockchain address that you specified in the from parameter. Use your own smart contract to mint NFTs If you want to mint NFTs using your own smart contract, you are going to use an NTF minter, a special blockchain address provided by Tatum that will cover the minting fees. The number of credits equivalent to the fees will be then deducted from the monthly credit allowance of your paid pricing plan. IMPORTANT! Your smart contract must be deployed as a general NFT smart contract. You cannot use cashback and provenance smart contracts with NFT Express. For more information, see our user documentation and the article in the Tatum blog. You can mint NFTs on your own smart contract on the following blockchains: BNB Smart Chain Celo Ethereum Harmony Klaytn Polygon To mint NFTs using your own smart contract, do the following: In the table located under this section, find the blockchain address of the Tatum NFT minter for your blockchain and network (mainnet or testnet). Add the minter address as an NFT minter to your smart contract. Use this API with the MintNftMinter schema of the request body. In the request body, enter the following information: chain is the blockchain that you use. to is the blockchain address where to send the minted NFT to. url is the URL of the NFT metadata. minter is the address of the NFT minter that you found in Step 1. contractAddress is the address of your NFT smart contract. tokenId is the the token ID of the NFT. For example:  {   \&quot;chain\&quot;: \&quot;CELO\&quot;,   \&quot;to\&quot;: \&quot;0x8ce4e40889a13971681391aad29e88efaf91f784\&quot;,   \&quot;url\&quot;: \&quot;ipfs://QmXJJ6UF5WkF4WTJvsdhiA1etGwBLfpva7Vr9AudGMe3pj\&quot;,   \&quot;contractAddress\&quot;: \&quot;0x687422eEA2cB73B5d3e242bA5456b782919AFc85\&quot;,   \&quot;tokenId\&quot;: \&quot;0123\&quot;,   \&quot;minter\&quot;: \&quot;0xBC2eBA680EE50d685cc4Fe65f102AA70AfB27D3F\&quot; } When you make an API call with this request body, the private key of the NFT minter will be added to the request body automatically:  {   \&quot;chain\&quot;: \&quot;CELO\&quot;,   \&quot;to\&quot;: \&quot;0x8ce4e40889a13971681391aad29e88efaf91f784\&quot;,   \&quot;url\&quot;: \&quot;ipfs://QmXJJ6UF5WkF4WTJvsdhiA1etGwBLfpva7Vr9AudGMe3pj\&quot;,   \&quot;contractAddress\&quot;: \&quot;0x687422eEA2cB73B5d3e242bA5456b782919AFc85\&quot;,   \&quot;tokenId\&quot;: \&quot;0123\&quot;,   \&quot;minter\&quot;: \&quot;0xBC2eBA680EE50d685cc4Fe65f102AA70AfB27D3F\&quot;,   \&quot;fromPrivateKey\&quot;: \&quot;0x05e150c73f1920ec14caa1e0b6aa09940899678051a78542840c2668ce5080c2\&quot; } The following table lists the blockchain addresses of the Tatum NFT minters for the testnet and mainnet of the supported blockchains: Blockchain Minter address - testnet* Minter address - mainnet BNB Smart Chain 0xc16ae5e8c985b906935a0cadf4e24f0400531883 0x49678AAB11E001eb3cB2cBD9aA96b36DC2461A94 Celo 0xBC2eBA680EE50d685cc4Fe65f102AA70AfB27D3F 0x49678AAB11E001eb3cB2cBD9aA96b36DC2461A94 Ethereum 0x53e8577C4347C365E4e0DA5B57A589cB6f2AB848 0x49678AAB11E001eb3cB2cBD9aA96b36DC2461A94 Harmony 0x8906f62d40293ddca77fdf6714c3f63265deddf0 0x49678AAB11E001eb3cB2cBD9aA96b36DC2461A94 Klaytn 0x80d8bac9a6901698b3749fe336bbd1385c1f98f2 0x49678AAB11E001eb3cB2cBD9aA96b36DC2461A94 Polygon 0x542b9ac4945a3836fd12ad98acbc76a0c8b743f5 0x49678AAB11E001eb3cB2cBD9aA96b36DC2461A94 *If a minter blockchain address on the testnet does not have sufficient funds to cover the transaction fee, add some amount to it using a crypto faucet of the blockchain. Minting NFTs natively on a blockchain When minting an NFT natively on a blockchain, you are charged a fee for the transaction, and you must sign the transaction with the private key of the blockchain address from which the fee will be deducted. Providing the private key in the API is not a secure way of signing transactions, because the private key can be stolen or exposed. Your private keys should never leave your security perimeter. You should use the private keys only for testing a solution you are building on the testnet of a blockchain. For signing transactions on the mainnet, we strongly recommend that you use the Tatum Key Management System (KMS) and provide the signature ID instead of the private key in the API. Alternatively, you can use the Tatum JavaScript client. You can mint NFTs natively on the following blockchains: Algorand BNB Smart Chain Celo Ethereum Flow Harmony Klaytn KuCoin Community Chain Polygon Solana TRON Depending on what blockchain you use, choose the request body schema to use in the API call. To mint NFTs natively on Algorand and: To sign the transaction with your private key, use this API with the MintNftAlgorand schema of the request body. To sign the transaction with your signature ID, use this API the MintNftAlgorandKMS schema of the request body. NOTE: To be able to burn the minted NFTs any time later, specify the address of the manager account in the manager parameter. An NFT minted on Algorand is automatically transferred to your blockchain address. After the NFT is minted, you have to transfer it to the recipient&#39;s address. The recipient has to agree in advance to receive your NFT because Algorand charges users for storing NFTs on their addresses, and an Algorand blockchain address by default does not receive NFTs unless explicitly agreed. For more information about how it works, see the section about minting NFTs on Algorand using the pre-built NFT smart contract provided by Tatum. To mint NFTs natively on BNB Smart Chain, Ethereum, Harmony, Klaytn, KuCoin Community Chain, or Polygon, and: To sign the transaction with your private key, use this API with the MintNft schema of the request body. To sign the transaction with your signature ID, use this API the MintNftKMS schema of the request body. To mint NFTs natively on Celo and: To sign the transaction with your private key, use this API with the MintNftCelo schema of the request body. To sign the transaction with your signature ID, use this API the MintNftKMSCelo schema of the request body. To mint NFTs natively on Flow and: To sign the transaction with your private key, use this API with the MintNftFlowPK schema of the request body. To sign the transaction with your signature ID, use this API the MintNftFlowMnemonic schema of the request body. To sign the transaction with your wallet mnemonic, use this API the MintNftFlowKMS schema of the request body. To mint NFTs natively on Solana and: To sign the transaction with your private key, use this API with the MintNftSolana schema of the request body. To sign the transaction with your signature ID, use this API the MintNftSolanaKMS schema of the request body. NOTE: When an NFT is minted on Solana, a new blockchain address is created to receive the NFT under the recipient&#39;s account address. After the NFT is minted, you have to transfer it to the recipient&#39;s address. For more information about how it works, see the section about minting NFTs on Solana using the pre-built NFT smart contract provided by Tatum. To mint NFTs natively on TRON and: To sign the transaction with your private key, use this API with the MintNftTron schema of the request body. To sign the transaction with your signature ID, use this API the MintNftKMSTron schema of the request body.
        /// </remarks>
        /// <exception cref="Tatum.CSharp.Bsc.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="mintNftExpress"></param>
        /// <param name="xTestnetType">Type of Ethereum testnet. Defaults to Sepolia. Valid only for ETH invocations for testnet API Key. For mainnet API Key, this value is ignored. (optional, default to ethereum-sepolia)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of TransactionHash</returns>
        System.Threading.Tasks.Task<TransactionHash> NftMintErc721Async(MintNftExpress mintNftExpress, string xTestnetType = default(string), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        /// <summary>
        /// Mint an NFT
        /// </summary>
        /// <remarks>
        /// 100 credits per API call on Flow 2 credits per API call on the other blockchains You can mint NFTs using either of the following methods: Using NFT Express Natively on a blockchain Minting NFTs using NFT Express NFT Express is Tatum&#39;s feature that helps you mint NFTs easier than minting natively on a blockchain. You do not need to enter your private key or signature ID. NFT Express uses the private key provided by Tatum. You do not need to hold crypto or keep addresses topped up with crypto to pay for minting transactions. To use NFT Express on the mainnet, you have to have a paid pricing plan. Tatum covers your transaction fees for NFT minting and pays for them from its own blockchain address. Then, the fee amount paid by Tatum is converted to the number of credits, and these credits are deducted from the monthly credit allowance of your paid pricing plan. The transaction fees and the corresponding numbers of credits deducted from your allowance vary depending on what blockchain you mint NFTs on. On the testnet, no credits are deducted from the monthly credit allowance. You can mint NFTs with NFT Express regardless of your pricing plan. With NFT Express, you can choose whether to mint NFTs on the pre-built NFT smart contract provided by Tatum or on your own smart contract. Use the pre-built smart contract provided by Tatum to mint NFTs If you want to mint NFTs using the pre-built smart contract, you do not need to deploy your own NFT smart contract. You do not need to provide the address of the NFT smart contract and the token ID in the request body either. The address of the smart contract and the token ID are provided automatically by Tatum. The token ID is autogenerated. It starts with 0 and is increased by 1 for each new NFT. The token ID is calculated separately for each supported blockchain and its mainnet and testnet. For more information, see our user documentation. You can mint NFTs on the pre-built smart contract provided by Tatum on the following blockchains: Algorand BNB Smart Chain Celo Ethereum Harmony Klaytn Polygon Solana Depending on what blockchain you use, choose the request body schema to use in the API call. To mint NFTs on BNB Smart Chain, Celo, Ethereum, Harmony, Klaytn, or Polygon, use this API with the MintNftExpress schema of the request body. To mint NFTs on Algorand, use this API with the MintNftExpressAlgorand schema of the request body. To be able to burn the minted NFTs any time later, specify the address of the manager account in the manager parameter. An NFT minted on Algorand is automatically transferred to your blockchain address. After the NFT is minted, you have to transfer it to the recipient&#39;s address. The recipient has to agree in advance to receive your NFT because Algorand charges users for storing NFTs on their addresses, and an Algorand blockchain address by default does not receive NFTs unless explicitly agreed. This how it works: The recipient agrees to receive the NFT to their address. You transfer the NFT to the recipient&#39;s address (use the transferNftAlgoExpress schema of the request body). NOTE: On the mainnet, Tatum covers your transaction fees for the NFT transfer and pays for them from its own blockchain address. Then, the fee amount paid by Tatum is converted to the number of credits, and these credits are deducted from the monthly credit allowance of your paid pricing plan. On the testnet, no credits are deducted from the monthly credit allowance. To mint NFTs on Solana, use this API with the MintNftExpressSolana schema of the request body. Solana uses the Metaplex Protocol, a smart contract and metadata standard for creating and working with NFTs. When you mint an NFT on Solana with NFT Express, the pre-built smart contract based on the Metaplex Protocol is used. When an NFT is minted on Solana, a new blockchain address is created to receive the NFT under the recipient&#39;s account address (the one in the to parameter of the request body). This address is returned in the nftAccountAddress parameter in the response body, is owned by the recipient&#39;s address, and has the same private key. The response body also returns the address of the minted NFT itself, which is held in the nftAddress parameter. After the NFT is minted, you have to transfer it to the recipient&#39;s address (use the transferNftSolana or transferNftSolanaKMS schema of the request body). In the request body of the transfer call: Set the from parameter to the address that you used in the to parameter in the request body of the minting call. Set the to parameter to the recipient&#39;s address. Set the contractAddress parameter to the address from the nftAddress parameter returned in the response body of the minting call. Set the fromPrivateKey/signatureId parameter to the private key/signature ID of the blockchain address that you specified in the from parameter. Use your own smart contract to mint NFTs If you want to mint NFTs using your own smart contract, you are going to use an NTF minter, a special blockchain address provided by Tatum that will cover the minting fees. The number of credits equivalent to the fees will be then deducted from the monthly credit allowance of your paid pricing plan. IMPORTANT! Your smart contract must be deployed as a general NFT smart contract. You cannot use cashback and provenance smart contracts with NFT Express. For more information, see our user documentation and the article in the Tatum blog. You can mint NFTs on your own smart contract on the following blockchains: BNB Smart Chain Celo Ethereum Harmony Klaytn Polygon To mint NFTs using your own smart contract, do the following: In the table located under this section, find the blockchain address of the Tatum NFT minter for your blockchain and network (mainnet or testnet). Add the minter address as an NFT minter to your smart contract. Use this API with the MintNftMinter schema of the request body. In the request body, enter the following information: chain is the blockchain that you use. to is the blockchain address where to send the minted NFT to. url is the URL of the NFT metadata. minter is the address of the NFT minter that you found in Step 1. contractAddress is the address of your NFT smart contract. tokenId is the the token ID of the NFT. For example:  {   \&quot;chain\&quot;: \&quot;CELO\&quot;,   \&quot;to\&quot;: \&quot;0x8ce4e40889a13971681391aad29e88efaf91f784\&quot;,   \&quot;url\&quot;: \&quot;ipfs://QmXJJ6UF5WkF4WTJvsdhiA1etGwBLfpva7Vr9AudGMe3pj\&quot;,   \&quot;contractAddress\&quot;: \&quot;0x687422eEA2cB73B5d3e242bA5456b782919AFc85\&quot;,   \&quot;tokenId\&quot;: \&quot;0123\&quot;,   \&quot;minter\&quot;: \&quot;0xBC2eBA680EE50d685cc4Fe65f102AA70AfB27D3F\&quot; } When you make an API call with this request body, the private key of the NFT minter will be added to the request body automatically:  {   \&quot;chain\&quot;: \&quot;CELO\&quot;,   \&quot;to\&quot;: \&quot;0x8ce4e40889a13971681391aad29e88efaf91f784\&quot;,   \&quot;url\&quot;: \&quot;ipfs://QmXJJ6UF5WkF4WTJvsdhiA1etGwBLfpva7Vr9AudGMe3pj\&quot;,   \&quot;contractAddress\&quot;: \&quot;0x687422eEA2cB73B5d3e242bA5456b782919AFc85\&quot;,   \&quot;tokenId\&quot;: \&quot;0123\&quot;,   \&quot;minter\&quot;: \&quot;0xBC2eBA680EE50d685cc4Fe65f102AA70AfB27D3F\&quot;,   \&quot;fromPrivateKey\&quot;: \&quot;0x05e150c73f1920ec14caa1e0b6aa09940899678051a78542840c2668ce5080c2\&quot; } The following table lists the blockchain addresses of the Tatum NFT minters for the testnet and mainnet of the supported blockchains: Blockchain Minter address - testnet* Minter address - mainnet BNB Smart Chain 0xc16ae5e8c985b906935a0cadf4e24f0400531883 0x49678AAB11E001eb3cB2cBD9aA96b36DC2461A94 Celo 0xBC2eBA680EE50d685cc4Fe65f102AA70AfB27D3F 0x49678AAB11E001eb3cB2cBD9aA96b36DC2461A94 Ethereum 0x53e8577C4347C365E4e0DA5B57A589cB6f2AB848 0x49678AAB11E001eb3cB2cBD9aA96b36DC2461A94 Harmony 0x8906f62d40293ddca77fdf6714c3f63265deddf0 0x49678AAB11E001eb3cB2cBD9aA96b36DC2461A94 Klaytn 0x80d8bac9a6901698b3749fe336bbd1385c1f98f2 0x49678AAB11E001eb3cB2cBD9aA96b36DC2461A94 Polygon 0x542b9ac4945a3836fd12ad98acbc76a0c8b743f5 0x49678AAB11E001eb3cB2cBD9aA96b36DC2461A94 *If a minter blockchain address on the testnet does not have sufficient funds to cover the transaction fee, add some amount to it using a crypto faucet of the blockchain. Minting NFTs natively on a blockchain When minting an NFT natively on a blockchain, you are charged a fee for the transaction, and you must sign the transaction with the private key of the blockchain address from which the fee will be deducted. Providing the private key in the API is not a secure way of signing transactions, because the private key can be stolen or exposed. Your private keys should never leave your security perimeter. You should use the private keys only for testing a solution you are building on the testnet of a blockchain. For signing transactions on the mainnet, we strongly recommend that you use the Tatum Key Management System (KMS) and provide the signature ID instead of the private key in the API. Alternatively, you can use the Tatum JavaScript client. You can mint NFTs natively on the following blockchains: Algorand BNB Smart Chain Celo Ethereum Flow Harmony Klaytn KuCoin Community Chain Polygon Solana TRON Depending on what blockchain you use, choose the request body schema to use in the API call. To mint NFTs natively on Algorand and: To sign the transaction with your private key, use this API with the MintNftAlgorand schema of the request body. To sign the transaction with your signature ID, use this API the MintNftAlgorandKMS schema of the request body. NOTE: To be able to burn the minted NFTs any time later, specify the address of the manager account in the manager parameter. An NFT minted on Algorand is automatically transferred to your blockchain address. After the NFT is minted, you have to transfer it to the recipient&#39;s address. The recipient has to agree in advance to receive your NFT because Algorand charges users for storing NFTs on their addresses, and an Algorand blockchain address by default does not receive NFTs unless explicitly agreed. For more information about how it works, see the section about minting NFTs on Algorand using the pre-built NFT smart contract provided by Tatum. To mint NFTs natively on BNB Smart Chain, Ethereum, Harmony, Klaytn, KuCoin Community Chain, or Polygon, and: To sign the transaction with your private key, use this API with the MintNft schema of the request body. To sign the transaction with your signature ID, use this API the MintNftKMS schema of the request body. To mint NFTs natively on Celo and: To sign the transaction with your private key, use this API with the MintNftCelo schema of the request body. To sign the transaction with your signature ID, use this API the MintNftKMSCelo schema of the request body. To mint NFTs natively on Flow and: To sign the transaction with your private key, use this API with the MintNftFlowPK schema of the request body. To sign the transaction with your signature ID, use this API the MintNftFlowMnemonic schema of the request body. To sign the transaction with your wallet mnemonic, use this API the MintNftFlowKMS schema of the request body. To mint NFTs natively on Solana and: To sign the transaction with your private key, use this API with the MintNftSolana schema of the request body. To sign the transaction with your signature ID, use this API the MintNftSolanaKMS schema of the request body. NOTE: When an NFT is minted on Solana, a new blockchain address is created to receive the NFT under the recipient&#39;s account address. After the NFT is minted, you have to transfer it to the recipient&#39;s address. For more information about how it works, see the section about minting NFTs on Solana using the pre-built NFT smart contract provided by Tatum. To mint NFTs natively on TRON and: To sign the transaction with your private key, use this API with the MintNftTron schema of the request body. To sign the transaction with your signature ID, use this API the MintNftKMSTron schema of the request body.
        /// </remarks>
        /// <exception cref="Tatum.CSharp.Bsc.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="mintNftMinter"></param>
        /// <param name="xTestnetType">Type of Ethereum testnet. Defaults to Sepolia. Valid only for ETH invocations for testnet API Key. For mainnet API Key, this value is ignored. (optional, default to ethereum-sepolia)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of TransactionHash</returns>
        System.Threading.Tasks.Task<TransactionHash> NftMintErc721Async(MintNftMinter mintNftMinter, string xTestnetType = default(string), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        /// <summary>
        /// Mint an NFT
        /// </summary>
        /// <remarks>
        /// 100 credits per API call on Flow 2 credits per API call on the other blockchains You can mint NFTs using either of the following methods: Using NFT Express Natively on a blockchain Minting NFTs using NFT Express NFT Express is Tatum&#39;s feature that helps you mint NFTs easier than minting natively on a blockchain. You do not need to enter your private key or signature ID. NFT Express uses the private key provided by Tatum. You do not need to hold crypto or keep addresses topped up with crypto to pay for minting transactions. To use NFT Express on the mainnet, you have to have a paid pricing plan. Tatum covers your transaction fees for NFT minting and pays for them from its own blockchain address. Then, the fee amount paid by Tatum is converted to the number of credits, and these credits are deducted from the monthly credit allowance of your paid pricing plan. The transaction fees and the corresponding numbers of credits deducted from your allowance vary depending on what blockchain you mint NFTs on. On the testnet, no credits are deducted from the monthly credit allowance. You can mint NFTs with NFT Express regardless of your pricing plan. With NFT Express, you can choose whether to mint NFTs on the pre-built NFT smart contract provided by Tatum or on your own smart contract. Use the pre-built smart contract provided by Tatum to mint NFTs If you want to mint NFTs using the pre-built smart contract, you do not need to deploy your own NFT smart contract. You do not need to provide the address of the NFT smart contract and the token ID in the request body either. The address of the smart contract and the token ID are provided automatically by Tatum. The token ID is autogenerated. It starts with 0 and is increased by 1 for each new NFT. The token ID is calculated separately for each supported blockchain and its mainnet and testnet. For more information, see our user documentation. You can mint NFTs on the pre-built smart contract provided by Tatum on the following blockchains: Algorand BNB Smart Chain Celo Ethereum Harmony Klaytn Polygon Solana Depending on what blockchain you use, choose the request body schema to use in the API call. To mint NFTs on BNB Smart Chain, Celo, Ethereum, Harmony, Klaytn, or Polygon, use this API with the MintNftExpress schema of the request body. To mint NFTs on Algorand, use this API with the MintNftExpressAlgorand schema of the request body. To be able to burn the minted NFTs any time later, specify the address of the manager account in the manager parameter. An NFT minted on Algorand is automatically transferred to your blockchain address. After the NFT is minted, you have to transfer it to the recipient&#39;s address. The recipient has to agree in advance to receive your NFT because Algorand charges users for storing NFTs on their addresses, and an Algorand blockchain address by default does not receive NFTs unless explicitly agreed. This how it works: The recipient agrees to receive the NFT to their address. You transfer the NFT to the recipient&#39;s address (use the transferNftAlgoExpress schema of the request body). NOTE: On the mainnet, Tatum covers your transaction fees for the NFT transfer and pays for them from its own blockchain address. Then, the fee amount paid by Tatum is converted to the number of credits, and these credits are deducted from the monthly credit allowance of your paid pricing plan. On the testnet, no credits are deducted from the monthly credit allowance. To mint NFTs on Solana, use this API with the MintNftExpressSolana schema of the request body. Solana uses the Metaplex Protocol, a smart contract and metadata standard for creating and working with NFTs. When you mint an NFT on Solana with NFT Express, the pre-built smart contract based on the Metaplex Protocol is used. When an NFT is minted on Solana, a new blockchain address is created to receive the NFT under the recipient&#39;s account address (the one in the to parameter of the request body). This address is returned in the nftAccountAddress parameter in the response body, is owned by the recipient&#39;s address, and has the same private key. The response body also returns the address of the minted NFT itself, which is held in the nftAddress parameter. After the NFT is minted, you have to transfer it to the recipient&#39;s address (use the transferNftSolana or transferNftSolanaKMS schema of the request body). In the request body of the transfer call: Set the from parameter to the address that you used in the to parameter in the request body of the minting call. Set the to parameter to the recipient&#39;s address. Set the contractAddress parameter to the address from the nftAddress parameter returned in the response body of the minting call. Set the fromPrivateKey/signatureId parameter to the private key/signature ID of the blockchain address that you specified in the from parameter. Use your own smart contract to mint NFTs If you want to mint NFTs using your own smart contract, you are going to use an NTF minter, a special blockchain address provided by Tatum that will cover the minting fees. The number of credits equivalent to the fees will be then deducted from the monthly credit allowance of your paid pricing plan. IMPORTANT! Your smart contract must be deployed as a general NFT smart contract. You cannot use cashback and provenance smart contracts with NFT Express. For more information, see our user documentation and the article in the Tatum blog. You can mint NFTs on your own smart contract on the following blockchains: BNB Smart Chain Celo Ethereum Harmony Klaytn Polygon To mint NFTs using your own smart contract, do the following: In the table located under this section, find the blockchain address of the Tatum NFT minter for your blockchain and network (mainnet or testnet). Add the minter address as an NFT minter to your smart contract. Use this API with the MintNftMinter schema of the request body. In the request body, enter the following information: chain is the blockchain that you use. to is the blockchain address where to send the minted NFT to. url is the URL of the NFT metadata. minter is the address of the NFT minter that you found in Step 1. contractAddress is the address of your NFT smart contract. tokenId is the the token ID of the NFT. For example:  {   \&quot;chain\&quot;: \&quot;CELO\&quot;,   \&quot;to\&quot;: \&quot;0x8ce4e40889a13971681391aad29e88efaf91f784\&quot;,   \&quot;url\&quot;: \&quot;ipfs://QmXJJ6UF5WkF4WTJvsdhiA1etGwBLfpva7Vr9AudGMe3pj\&quot;,   \&quot;contractAddress\&quot;: \&quot;0x687422eEA2cB73B5d3e242bA5456b782919AFc85\&quot;,   \&quot;tokenId\&quot;: \&quot;0123\&quot;,   \&quot;minter\&quot;: \&quot;0xBC2eBA680EE50d685cc4Fe65f102AA70AfB27D3F\&quot; } When you make an API call with this request body, the private key of the NFT minter will be added to the request body automatically:  {   \&quot;chain\&quot;: \&quot;CELO\&quot;,   \&quot;to\&quot;: \&quot;0x8ce4e40889a13971681391aad29e88efaf91f784\&quot;,   \&quot;url\&quot;: \&quot;ipfs://QmXJJ6UF5WkF4WTJvsdhiA1etGwBLfpva7Vr9AudGMe3pj\&quot;,   \&quot;contractAddress\&quot;: \&quot;0x687422eEA2cB73B5d3e242bA5456b782919AFc85\&quot;,   \&quot;tokenId\&quot;: \&quot;0123\&quot;,   \&quot;minter\&quot;: \&quot;0xBC2eBA680EE50d685cc4Fe65f102AA70AfB27D3F\&quot;,   \&quot;fromPrivateKey\&quot;: \&quot;0x05e150c73f1920ec14caa1e0b6aa09940899678051a78542840c2668ce5080c2\&quot; } The following table lists the blockchain addresses of the Tatum NFT minters for the testnet and mainnet of the supported blockchains: Blockchain Minter address - testnet* Minter address - mainnet BNB Smart Chain 0xc16ae5e8c985b906935a0cadf4e24f0400531883 0x49678AAB11E001eb3cB2cBD9aA96b36DC2461A94 Celo 0xBC2eBA680EE50d685cc4Fe65f102AA70AfB27D3F 0x49678AAB11E001eb3cB2cBD9aA96b36DC2461A94 Ethereum 0x53e8577C4347C365E4e0DA5B57A589cB6f2AB848 0x49678AAB11E001eb3cB2cBD9aA96b36DC2461A94 Harmony 0x8906f62d40293ddca77fdf6714c3f63265deddf0 0x49678AAB11E001eb3cB2cBD9aA96b36DC2461A94 Klaytn 0x80d8bac9a6901698b3749fe336bbd1385c1f98f2 0x49678AAB11E001eb3cB2cBD9aA96b36DC2461A94 Polygon 0x542b9ac4945a3836fd12ad98acbc76a0c8b743f5 0x49678AAB11E001eb3cB2cBD9aA96b36DC2461A94 *If a minter blockchain address on the testnet does not have sufficient funds to cover the transaction fee, add some amount to it using a crypto faucet of the blockchain. Minting NFTs natively on a blockchain When minting an NFT natively on a blockchain, you are charged a fee for the transaction, and you must sign the transaction with the private key of the blockchain address from which the fee will be deducted. Providing the private key in the API is not a secure way of signing transactions, because the private key can be stolen or exposed. Your private keys should never leave your security perimeter. You should use the private keys only for testing a solution you are building on the testnet of a blockchain. For signing transactions on the mainnet, we strongly recommend that you use the Tatum Key Management System (KMS) and provide the signature ID instead of the private key in the API. Alternatively, you can use the Tatum JavaScript client. You can mint NFTs natively on the following blockchains: Algorand BNB Smart Chain Celo Ethereum Flow Harmony Klaytn KuCoin Community Chain Polygon Solana TRON Depending on what blockchain you use, choose the request body schema to use in the API call. To mint NFTs natively on Algorand and: To sign the transaction with your private key, use this API with the MintNftAlgorand schema of the request body. To sign the transaction with your signature ID, use this API the MintNftAlgorandKMS schema of the request body. NOTE: To be able to burn the minted NFTs any time later, specify the address of the manager account in the manager parameter. An NFT minted on Algorand is automatically transferred to your blockchain address. After the NFT is minted, you have to transfer it to the recipient&#39;s address. The recipient has to agree in advance to receive your NFT because Algorand charges users for storing NFTs on their addresses, and an Algorand blockchain address by default does not receive NFTs unless explicitly agreed. For more information about how it works, see the section about minting NFTs on Algorand using the pre-built NFT smart contract provided by Tatum. To mint NFTs natively on BNB Smart Chain, Ethereum, Harmony, Klaytn, KuCoin Community Chain, or Polygon, and: To sign the transaction with your private key, use this API with the MintNft schema of the request body. To sign the transaction with your signature ID, use this API the MintNftKMS schema of the request body. To mint NFTs natively on Celo and: To sign the transaction with your private key, use this API with the MintNftCelo schema of the request body. To sign the transaction with your signature ID, use this API the MintNftKMSCelo schema of the request body. To mint NFTs natively on Flow and: To sign the transaction with your private key, use this API with the MintNftFlowPK schema of the request body. To sign the transaction with your signature ID, use this API the MintNftFlowMnemonic schema of the request body. To sign the transaction with your wallet mnemonic, use this API the MintNftFlowKMS schema of the request body. To mint NFTs natively on Solana and: To sign the transaction with your private key, use this API with the MintNftSolana schema of the request body. To sign the transaction with your signature ID, use this API the MintNftSolanaKMS schema of the request body. NOTE: When an NFT is minted on Solana, a new blockchain address is created to receive the NFT under the recipient&#39;s account address. After the NFT is minted, you have to transfer it to the recipient&#39;s address. For more information about how it works, see the section about minting NFTs on Solana using the pre-built NFT smart contract provided by Tatum. To mint NFTs natively on TRON and: To sign the transaction with your private key, use this API with the MintNftTron schema of the request body. To sign the transaction with your signature ID, use this API the MintNftKMSTron schema of the request body.
        /// </remarks>
        /// <exception cref="Tatum.CSharp.Bsc.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="mintNft"></param>
        /// <param name="xTestnetType">Type of Ethereum testnet. Defaults to Sepolia. Valid only for ETH invocations for testnet API Key. For mainnet API Key, this value is ignored. (optional, default to ethereum-sepolia)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of TransactionHash</returns>
        System.Threading.Tasks.Task<TransactionHash> NftMintErc721Async(MintNft mintNft, string xTestnetType = default(string), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        /// <summary>
        /// Mint an NFT
        /// </summary>
        /// <remarks>
        /// 100 credits per API call on Flow 2 credits per API call on the other blockchains You can mint NFTs using either of the following methods: Using NFT Express Natively on a blockchain Minting NFTs using NFT Express NFT Express is Tatum&#39;s feature that helps you mint NFTs easier than minting natively on a blockchain. You do not need to enter your private key or signature ID. NFT Express uses the private key provided by Tatum. You do not need to hold crypto or keep addresses topped up with crypto to pay for minting transactions. To use NFT Express on the mainnet, you have to have a paid pricing plan. Tatum covers your transaction fees for NFT minting and pays for them from its own blockchain address. Then, the fee amount paid by Tatum is converted to the number of credits, and these credits are deducted from the monthly credit allowance of your paid pricing plan. The transaction fees and the corresponding numbers of credits deducted from your allowance vary depending on what blockchain you mint NFTs on. On the testnet, no credits are deducted from the monthly credit allowance. You can mint NFTs with NFT Express regardless of your pricing plan. With NFT Express, you can choose whether to mint NFTs on the pre-built NFT smart contract provided by Tatum or on your own smart contract. Use the pre-built smart contract provided by Tatum to mint NFTs If you want to mint NFTs using the pre-built smart contract, you do not need to deploy your own NFT smart contract. You do not need to provide the address of the NFT smart contract and the token ID in the request body either. The address of the smart contract and the token ID are provided automatically by Tatum. The token ID is autogenerated. It starts with 0 and is increased by 1 for each new NFT. The token ID is calculated separately for each supported blockchain and its mainnet and testnet. For more information, see our user documentation. You can mint NFTs on the pre-built smart contract provided by Tatum on the following blockchains: Algorand BNB Smart Chain Celo Ethereum Harmony Klaytn Polygon Solana Depending on what blockchain you use, choose the request body schema to use in the API call. To mint NFTs on BNB Smart Chain, Celo, Ethereum, Harmony, Klaytn, or Polygon, use this API with the MintNftExpress schema of the request body. To mint NFTs on Algorand, use this API with the MintNftExpressAlgorand schema of the request body. To be able to burn the minted NFTs any time later, specify the address of the manager account in the manager parameter. An NFT minted on Algorand is automatically transferred to your blockchain address. After the NFT is minted, you have to transfer it to the recipient&#39;s address. The recipient has to agree in advance to receive your NFT because Algorand charges users for storing NFTs on their addresses, and an Algorand blockchain address by default does not receive NFTs unless explicitly agreed. This how it works: The recipient agrees to receive the NFT to their address. You transfer the NFT to the recipient&#39;s address (use the transferNftAlgoExpress schema of the request body). NOTE: On the mainnet, Tatum covers your transaction fees for the NFT transfer and pays for them from its own blockchain address. Then, the fee amount paid by Tatum is converted to the number of credits, and these credits are deducted from the monthly credit allowance of your paid pricing plan. On the testnet, no credits are deducted from the monthly credit allowance. To mint NFTs on Solana, use this API with the MintNftExpressSolana schema of the request body. Solana uses the Metaplex Protocol, a smart contract and metadata standard for creating and working with NFTs. When you mint an NFT on Solana with NFT Express, the pre-built smart contract based on the Metaplex Protocol is used. When an NFT is minted on Solana, a new blockchain address is created to receive the NFT under the recipient&#39;s account address (the one in the to parameter of the request body). This address is returned in the nftAccountAddress parameter in the response body, is owned by the recipient&#39;s address, and has the same private key. The response body also returns the address of the minted NFT itself, which is held in the nftAddress parameter. After the NFT is minted, you have to transfer it to the recipient&#39;s address (use the transferNftSolana or transferNftSolanaKMS schema of the request body). In the request body of the transfer call: Set the from parameter to the address that you used in the to parameter in the request body of the minting call. Set the to parameter to the recipient&#39;s address. Set the contractAddress parameter to the address from the nftAddress parameter returned in the response body of the minting call. Set the fromPrivateKey/signatureId parameter to the private key/signature ID of the blockchain address that you specified in the from parameter. Use your own smart contract to mint NFTs If you want to mint NFTs using your own smart contract, you are going to use an NTF minter, a special blockchain address provided by Tatum that will cover the minting fees. The number of credits equivalent to the fees will be then deducted from the monthly credit allowance of your paid pricing plan. IMPORTANT! Your smart contract must be deployed as a general NFT smart contract. You cannot use cashback and provenance smart contracts with NFT Express. For more information, see our user documentation and the article in the Tatum blog. You can mint NFTs on your own smart contract on the following blockchains: BNB Smart Chain Celo Ethereum Harmony Klaytn Polygon To mint NFTs using your own smart contract, do the following: In the table located under this section, find the blockchain address of the Tatum NFT minter for your blockchain and network (mainnet or testnet). Add the minter address as an NFT minter to your smart contract. Use this API with the MintNftMinter schema of the request body. In the request body, enter the following information: chain is the blockchain that you use. to is the blockchain address where to send the minted NFT to. url is the URL of the NFT metadata. minter is the address of the NFT minter that you found in Step 1. contractAddress is the address of your NFT smart contract. tokenId is the the token ID of the NFT. For example:  {   \&quot;chain\&quot;: \&quot;CELO\&quot;,   \&quot;to\&quot;: \&quot;0x8ce4e40889a13971681391aad29e88efaf91f784\&quot;,   \&quot;url\&quot;: \&quot;ipfs://QmXJJ6UF5WkF4WTJvsdhiA1etGwBLfpva7Vr9AudGMe3pj\&quot;,   \&quot;contractAddress\&quot;: \&quot;0x687422eEA2cB73B5d3e242bA5456b782919AFc85\&quot;,   \&quot;tokenId\&quot;: \&quot;0123\&quot;,   \&quot;minter\&quot;: \&quot;0xBC2eBA680EE50d685cc4Fe65f102AA70AfB27D3F\&quot; } When you make an API call with this request body, the private key of the NFT minter will be added to the request body automatically:  {   \&quot;chain\&quot;: \&quot;CELO\&quot;,   \&quot;to\&quot;: \&quot;0x8ce4e40889a13971681391aad29e88efaf91f784\&quot;,   \&quot;url\&quot;: \&quot;ipfs://QmXJJ6UF5WkF4WTJvsdhiA1etGwBLfpva7Vr9AudGMe3pj\&quot;,   \&quot;contractAddress\&quot;: \&quot;0x687422eEA2cB73B5d3e242bA5456b782919AFc85\&quot;,   \&quot;tokenId\&quot;: \&quot;0123\&quot;,   \&quot;minter\&quot;: \&quot;0xBC2eBA680EE50d685cc4Fe65f102AA70AfB27D3F\&quot;,   \&quot;fromPrivateKey\&quot;: \&quot;0x05e150c73f1920ec14caa1e0b6aa09940899678051a78542840c2668ce5080c2\&quot; } The following table lists the blockchain addresses of the Tatum NFT minters for the testnet and mainnet of the supported blockchains: Blockchain Minter address - testnet* Minter address - mainnet BNB Smart Chain 0xc16ae5e8c985b906935a0cadf4e24f0400531883 0x49678AAB11E001eb3cB2cBD9aA96b36DC2461A94 Celo 0xBC2eBA680EE50d685cc4Fe65f102AA70AfB27D3F 0x49678AAB11E001eb3cB2cBD9aA96b36DC2461A94 Ethereum 0x53e8577C4347C365E4e0DA5B57A589cB6f2AB848 0x49678AAB11E001eb3cB2cBD9aA96b36DC2461A94 Harmony 0x8906f62d40293ddca77fdf6714c3f63265deddf0 0x49678AAB11E001eb3cB2cBD9aA96b36DC2461A94 Klaytn 0x80d8bac9a6901698b3749fe336bbd1385c1f98f2 0x49678AAB11E001eb3cB2cBD9aA96b36DC2461A94 Polygon 0x542b9ac4945a3836fd12ad98acbc76a0c8b743f5 0x49678AAB11E001eb3cB2cBD9aA96b36DC2461A94 *If a minter blockchain address on the testnet does not have sufficient funds to cover the transaction fee, add some amount to it using a crypto faucet of the blockchain. Minting NFTs natively on a blockchain When minting an NFT natively on a blockchain, you are charged a fee for the transaction, and you must sign the transaction with the private key of the blockchain address from which the fee will be deducted. Providing the private key in the API is not a secure way of signing transactions, because the private key can be stolen or exposed. Your private keys should never leave your security perimeter. You should use the private keys only for testing a solution you are building on the testnet of a blockchain. For signing transactions on the mainnet, we strongly recommend that you use the Tatum Key Management System (KMS) and provide the signature ID instead of the private key in the API. Alternatively, you can use the Tatum JavaScript client. You can mint NFTs natively on the following blockchains: Algorand BNB Smart Chain Celo Ethereum Flow Harmony Klaytn KuCoin Community Chain Polygon Solana TRON Depending on what blockchain you use, choose the request body schema to use in the API call. To mint NFTs natively on Algorand and: To sign the transaction with your private key, use this API with the MintNftAlgorand schema of the request body. To sign the transaction with your signature ID, use this API the MintNftAlgorandKMS schema of the request body. NOTE: To be able to burn the minted NFTs any time later, specify the address of the manager account in the manager parameter. An NFT minted on Algorand is automatically transferred to your blockchain address. After the NFT is minted, you have to transfer it to the recipient&#39;s address. The recipient has to agree in advance to receive your NFT because Algorand charges users for storing NFTs on their addresses, and an Algorand blockchain address by default does not receive NFTs unless explicitly agreed. For more information about how it works, see the section about minting NFTs on Algorand using the pre-built NFT smart contract provided by Tatum. To mint NFTs natively on BNB Smart Chain, Ethereum, Harmony, Klaytn, KuCoin Community Chain, or Polygon, and: To sign the transaction with your private key, use this API with the MintNft schema of the request body. To sign the transaction with your signature ID, use this API the MintNftKMS schema of the request body. To mint NFTs natively on Celo and: To sign the transaction with your private key, use this API with the MintNftCelo schema of the request body. To sign the transaction with your signature ID, use this API the MintNftKMSCelo schema of the request body. To mint NFTs natively on Flow and: To sign the transaction with your private key, use this API with the MintNftFlowPK schema of the request body. To sign the transaction with your signature ID, use this API the MintNftFlowMnemonic schema of the request body. To sign the transaction with your wallet mnemonic, use this API the MintNftFlowKMS schema of the request body. To mint NFTs natively on Solana and: To sign the transaction with your private key, use this API with the MintNftSolana schema of the request body. To sign the transaction with your signature ID, use this API the MintNftSolanaKMS schema of the request body. NOTE: When an NFT is minted on Solana, a new blockchain address is created to receive the NFT under the recipient&#39;s account address. After the NFT is minted, you have to transfer it to the recipient&#39;s address. For more information about how it works, see the section about minting NFTs on Solana using the pre-built NFT smart contract provided by Tatum. To mint NFTs natively on TRON and: To sign the transaction with your private key, use this API with the MintNftTron schema of the request body. To sign the transaction with your signature ID, use this API the MintNftKMSTron schema of the request body.
        /// </remarks>
        /// <exception cref="Tatum.CSharp.Bsc.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="mintNftKMS"></param>
        /// <param name="xTestnetType">Type of Ethereum testnet. Defaults to Sepolia. Valid only for ETH invocations for testnet API Key. For mainnet API Key, this value is ignored. (optional, default to ethereum-sepolia)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of SignatureId</returns>
        System.Threading.Tasks.Task<SignatureId> NftMintErc721Async(MintNftKMS mintNftKMS, string xTestnetType = default(string), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        /// <summary>
        /// Mint multiple NFTs
        /// </summary>
        /// <remarks>
        /// 100 credits per API call on Flow 2 credits per API call on the other blockchains Create multiple NFT Tokens and transfer them to destination account. Create and transfer any NFT tokens from smart contract defined in contractAddress. This API is supported for the following blockchains: BNB Smart Chain Celo Ethereum Flow Harmony Klaytn KuCoin Community Chain Polygon TRON This operation works in two modes. First mode works just like other NFT endpoints. Every time the funds are transferred, the transaction must be signed with the corresponding private key. No one should ever send it&#39;s own private keys to the internet because there is a strong possibility of stealing keys and loss of funds. In this method, it is possible to enter privateKey or signatureId. PrivateKey should be used only for quick development on testnet versions of blockchain when there is no risk of losing funds. In production, Tatum KMS should be used for the highest security standards, and signatureId should be present in the request. Alternatively, using the Tatum client library for supported languages. Second mode enables you to mint on any custom NFT ERC-721 smart contract, on which specified minter address is approved as a minter. You don&#39;t specify private key or signatureId, only minter address, from which the NFT will be minted. It means you perform mint multiple NFT request with following body: {    \&quot;to\&quot;: [\&quot;0x80d8bac9a6901698b3749fe336bbd1385c1f98f2\&quot;],    \&quot;url\&quot;: [\&quot;ipfs://QmXJJ6UF5WkF4WTJvsdhiA1etGwBLfpva7Vr9AudGMe3pj\&quot;],    \&quot;tokenId\&quot;: [\&quot;9876541124516\&quot;],    \&quot;contractAddress\&quot;:\&quot;0xcd2ada00c48a27faa5cc67f9a1ed55b89ddf7f77\&quot;,    \&quot;minter\&quot;: \&quot;0x542b9ac4945a3836fd12ad98acbc76a0c8b743f5\&quot;,    \&quot;chain\&quot;: \&quot;MATIC\&quot; } The blockchain fee of the performed transaction is paid from the address connected with built-in private key and is debited in form of credits. The credits are debited only if NFT mint requests are performed with paid API key plan. We transform fee to the credits in accordance to the rates provided by the Tatum. If you want to batch mint on ERC-721 contract which is not deployed via Tatum API, your smart contract must contain this method: mintMultiple(address[] to, uint256[] tokenId, string[] uri): boolean You can use addresses specified in the bellow table to be used as a minter. Chain Testnet address Mainnet Address MATIC 0x542b9ac4945a3836fd12ad98acbc76a0c8b743f5 0xcf9e127455d28e7362380aec1b92ddee8200b295 BSC 0xc16ae5e8c985b906935a0cadf4e24f0400531883 0xcf9e127455d28e7362380aec1b92ddee8200b295 ONE 0x8906f62d40293ddca77fdf6714c3f63265deddf0 0xcf9e127455d28e7362380aec1b92ddee8200b295 ETH 0x53e8577C4347C365E4e0DA5B57A589cB6f2AB848 0xcf9e127455d28e7362380aec1b92ddee8200b295 CELO 0xBC2eBA680EE50d685cc4Fe65f102AA70AfB27D3F 0xcf9e127455d28e7362380aec1b92ddee8200b295 KLAY 0x80d8bac9a6901698b3749fe336bbd1385c1f98f2 0xcf9e127455d28e7362380aec1b92ddee8200b295 If there are not enough coins on any testnet address, feel free to send coins there.
        /// </remarks>
        /// <exception cref="Tatum.CSharp.Bsc.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="mintMultipleNftMinter"></param>
        /// <param name="xTestnetType">Type of Ethereum testnet. Defaults to Sepolia. Valid only for ETH invocations for testnet API Key. For mainnet API Key, this value is ignored. (optional, default to ethereum-sepolia)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of TransactionHash</returns>
        System.Threading.Tasks.Task<TransactionHash> NftMintMultipleErc721Async(MintMultipleNftMinter mintMultipleNftMinter, string xTestnetType = default(string), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        /// <summary>
        /// Mint multiple NFTs
        /// </summary>
        /// <remarks>
        /// 100 credits per API call on Flow 2 credits per API call on the other blockchains Create multiple NFT Tokens and transfer them to destination account. Create and transfer any NFT tokens from smart contract defined in contractAddress. This API is supported for the following blockchains: BNB Smart Chain Celo Ethereum Flow Harmony Klaytn KuCoin Community Chain Polygon TRON This operation works in two modes. First mode works just like other NFT endpoints. Every time the funds are transferred, the transaction must be signed with the corresponding private key. No one should ever send it&#39;s own private keys to the internet because there is a strong possibility of stealing keys and loss of funds. In this method, it is possible to enter privateKey or signatureId. PrivateKey should be used only for quick development on testnet versions of blockchain when there is no risk of losing funds. In production, Tatum KMS should be used for the highest security standards, and signatureId should be present in the request. Alternatively, using the Tatum client library for supported languages. Second mode enables you to mint on any custom NFT ERC-721 smart contract, on which specified minter address is approved as a minter. You don&#39;t specify private key or signatureId, only minter address, from which the NFT will be minted. It means you perform mint multiple NFT request with following body: {    \&quot;to\&quot;: [\&quot;0x80d8bac9a6901698b3749fe336bbd1385c1f98f2\&quot;],    \&quot;url\&quot;: [\&quot;ipfs://QmXJJ6UF5WkF4WTJvsdhiA1etGwBLfpva7Vr9AudGMe3pj\&quot;],    \&quot;tokenId\&quot;: [\&quot;9876541124516\&quot;],    \&quot;contractAddress\&quot;:\&quot;0xcd2ada00c48a27faa5cc67f9a1ed55b89ddf7f77\&quot;,    \&quot;minter\&quot;: \&quot;0x542b9ac4945a3836fd12ad98acbc76a0c8b743f5\&quot;,    \&quot;chain\&quot;: \&quot;MATIC\&quot; } The blockchain fee of the performed transaction is paid from the address connected with built-in private key and is debited in form of credits. The credits are debited only if NFT mint requests are performed with paid API key plan. We transform fee to the credits in accordance to the rates provided by the Tatum. If you want to batch mint on ERC-721 contract which is not deployed via Tatum API, your smart contract must contain this method: mintMultiple(address[] to, uint256[] tokenId, string[] uri): boolean You can use addresses specified in the bellow table to be used as a minter. Chain Testnet address Mainnet Address MATIC 0x542b9ac4945a3836fd12ad98acbc76a0c8b743f5 0xcf9e127455d28e7362380aec1b92ddee8200b295 BSC 0xc16ae5e8c985b906935a0cadf4e24f0400531883 0xcf9e127455d28e7362380aec1b92ddee8200b295 ONE 0x8906f62d40293ddca77fdf6714c3f63265deddf0 0xcf9e127455d28e7362380aec1b92ddee8200b295 ETH 0x53e8577C4347C365E4e0DA5B57A589cB6f2AB848 0xcf9e127455d28e7362380aec1b92ddee8200b295 CELO 0xBC2eBA680EE50d685cc4Fe65f102AA70AfB27D3F 0xcf9e127455d28e7362380aec1b92ddee8200b295 KLAY 0x80d8bac9a6901698b3749fe336bbd1385c1f98f2 0xcf9e127455d28e7362380aec1b92ddee8200b295 If there are not enough coins on any testnet address, feel free to send coins there.
        /// </remarks>
        /// <exception cref="Tatum.CSharp.Bsc.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="mintMultipleNft"></param>
        /// <param name="xTestnetType">Type of Ethereum testnet. Defaults to Sepolia. Valid only for ETH invocations for testnet API Key. For mainnet API Key, this value is ignored. (optional, default to ethereum-sepolia)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of TransactionHash</returns>
        System.Threading.Tasks.Task<TransactionHash> NftMintMultipleErc721Async(MintMultipleNft mintMultipleNft, string xTestnetType = default(string), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        /// <summary>
        /// Mint multiple NFTs
        /// </summary>
        /// <remarks>
        /// 100 credits per API call on Flow 2 credits per API call on the other blockchains Create multiple NFT Tokens and transfer them to destination account. Create and transfer any NFT tokens from smart contract defined in contractAddress. This API is supported for the following blockchains: BNB Smart Chain Celo Ethereum Flow Harmony Klaytn KuCoin Community Chain Polygon TRON This operation works in two modes. First mode works just like other NFT endpoints. Every time the funds are transferred, the transaction must be signed with the corresponding private key. No one should ever send it&#39;s own private keys to the internet because there is a strong possibility of stealing keys and loss of funds. In this method, it is possible to enter privateKey or signatureId. PrivateKey should be used only for quick development on testnet versions of blockchain when there is no risk of losing funds. In production, Tatum KMS should be used for the highest security standards, and signatureId should be present in the request. Alternatively, using the Tatum client library for supported languages. Second mode enables you to mint on any custom NFT ERC-721 smart contract, on which specified minter address is approved as a minter. You don&#39;t specify private key or signatureId, only minter address, from which the NFT will be minted. It means you perform mint multiple NFT request with following body: {    \&quot;to\&quot;: [\&quot;0x80d8bac9a6901698b3749fe336bbd1385c1f98f2\&quot;],    \&quot;url\&quot;: [\&quot;ipfs://QmXJJ6UF5WkF4WTJvsdhiA1etGwBLfpva7Vr9AudGMe3pj\&quot;],    \&quot;tokenId\&quot;: [\&quot;9876541124516\&quot;],    \&quot;contractAddress\&quot;:\&quot;0xcd2ada00c48a27faa5cc67f9a1ed55b89ddf7f77\&quot;,    \&quot;minter\&quot;: \&quot;0x542b9ac4945a3836fd12ad98acbc76a0c8b743f5\&quot;,    \&quot;chain\&quot;: \&quot;MATIC\&quot; } The blockchain fee of the performed transaction is paid from the address connected with built-in private key and is debited in form of credits. The credits are debited only if NFT mint requests are performed with paid API key plan. We transform fee to the credits in accordance to the rates provided by the Tatum. If you want to batch mint on ERC-721 contract which is not deployed via Tatum API, your smart contract must contain this method: mintMultiple(address[] to, uint256[] tokenId, string[] uri): boolean You can use addresses specified in the bellow table to be used as a minter. Chain Testnet address Mainnet Address MATIC 0x542b9ac4945a3836fd12ad98acbc76a0c8b743f5 0xcf9e127455d28e7362380aec1b92ddee8200b295 BSC 0xc16ae5e8c985b906935a0cadf4e24f0400531883 0xcf9e127455d28e7362380aec1b92ddee8200b295 ONE 0x8906f62d40293ddca77fdf6714c3f63265deddf0 0xcf9e127455d28e7362380aec1b92ddee8200b295 ETH 0x53e8577C4347C365E4e0DA5B57A589cB6f2AB848 0xcf9e127455d28e7362380aec1b92ddee8200b295 CELO 0xBC2eBA680EE50d685cc4Fe65f102AA70AfB27D3F 0xcf9e127455d28e7362380aec1b92ddee8200b295 KLAY 0x80d8bac9a6901698b3749fe336bbd1385c1f98f2 0xcf9e127455d28e7362380aec1b92ddee8200b295 If there are not enough coins on any testnet address, feel free to send coins there.
        /// </remarks>
        /// <exception cref="Tatum.CSharp.Bsc.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="mintMultipleNftKMS"></param>
        /// <param name="xTestnetType">Type of Ethereum testnet. Defaults to Sepolia. Valid only for ETH invocations for testnet API Key. For mainnet API Key, this value is ignored. (optional, default to ethereum-sepolia)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of SignatureId</returns>
        System.Threading.Tasks.Task<SignatureId> NftMintMultipleErc721Async(MintMultipleNftKMS mintMultipleNftKMS, string xTestnetType = default(string), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        /// <summary>
        /// Transfer an NFT
        /// </summary>
        /// <remarks>
        /// 100 credits per API call on Flow 2 credits per API call on the other blockchains Transfer an NFT from the smart contract (the contractAddress parameter in the request body) to the specified blockchain address (the to parameter in the request body). In one API call, you can transfer only one NFT. This API is supported for the following blockchains: Algorand BNB Smart Chain Celo Ethereum Flow Harmony Klaytn KuCoin Community Chain Polygon Solana TRON For Ethereum, Celo, and BNB Smart Chain, transferring NFTs invokes the safeTransfer() method. Transferring NFTs on Algorand On Algorand, the recipient has to agree in advance to receive your NFT because Algorand charges users for storing NFTs on their addresses, and an Algorand blockchain address by default does not receive NFTs unless explicitly agreed. Before transferring an NFT, make sure that the recipient has agreed to receive the NFT to their address. If you want to transfer an NFT that was minted using NFT Express, use the transferNftAlgoExpress schema of the request body. NOTE: On the mainnet, Tatum covers your transaction fees for the NFT transfer and pays for them from its own blockchain address. Then, the fee amount paid by Tatum is converted to the number of credits, and these credits are deducted from the monthly credit allowance of your paid pricing plan. On the testnet, no credits are deducted from the monthly credit allowance. Transferring NFTs on Solana If you want to transfer an NFT that was minted using NFT Express, see the section about minting NFTs on Solana using the pre-built NFT smart contract provided by Tatum for the information about how to set up the parameters in the request body. Signing a transaction When transferring an NFT, you are charged a fee for the transaction, and you must sign the transaction with the private key of the blockchain address from which the fee will be deducted. Providing the private key in the API is not a secure way of signing transactions, because the private key can be stolen or exposed. Your private keys should never leave your security perimeter. You should use the private keys only for testing a solution you are building on the testnet of a blockchain. For signing transactions on the mainnet, we strongly recommend that you use the Tatum Key Management System (KMS) and provide the signature ID instead of the private key in the API. Alternatively, you can use the Tatum JavaScript client. NOTE: This does not apply to transferring NFTs that were minted on Algorand using NFT Express (see earlier in this section).
        /// </remarks>
        /// <exception cref="Tatum.CSharp.Bsc.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="transferNft"></param>
        /// <param name="xTestnetType">Type of Ethereum testnet. Defaults to Sepolia. Valid only for ETH invocations for testnet API Key. For mainnet API Key, this value is ignored. (optional, default to ethereum-sepolia)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of TransactionHash</returns>
        System.Threading.Tasks.Task<TransactionHash> NftTransferErc721Async(TransferNft transferNft, string xTestnetType = default(string), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        /// <summary>
        /// Transfer an NFT
        /// </summary>
        /// <remarks>
        /// 100 credits per API call on Flow 2 credits per API call on the other blockchains Transfer an NFT from the smart contract (the contractAddress parameter in the request body) to the specified blockchain address (the to parameter in the request body). In one API call, you can transfer only one NFT. This API is supported for the following blockchains: Algorand BNB Smart Chain Celo Ethereum Flow Harmony Klaytn KuCoin Community Chain Polygon Solana TRON For Ethereum, Celo, and BNB Smart Chain, transferring NFTs invokes the safeTransfer() method. Transferring NFTs on Algorand On Algorand, the recipient has to agree in advance to receive your NFT because Algorand charges users for storing NFTs on their addresses, and an Algorand blockchain address by default does not receive NFTs unless explicitly agreed. Before transferring an NFT, make sure that the recipient has agreed to receive the NFT to their address. If you want to transfer an NFT that was minted using NFT Express, use the transferNftAlgoExpress schema of the request body. NOTE: On the mainnet, Tatum covers your transaction fees for the NFT transfer and pays for them from its own blockchain address. Then, the fee amount paid by Tatum is converted to the number of credits, and these credits are deducted from the monthly credit allowance of your paid pricing plan. On the testnet, no credits are deducted from the monthly credit allowance. Transferring NFTs on Solana If you want to transfer an NFT that was minted using NFT Express, see the section about minting NFTs on Solana using the pre-built NFT smart contract provided by Tatum for the information about how to set up the parameters in the request body. Signing a transaction When transferring an NFT, you are charged a fee for the transaction, and you must sign the transaction with the private key of the blockchain address from which the fee will be deducted. Providing the private key in the API is not a secure way of signing transactions, because the private key can be stolen or exposed. Your private keys should never leave your security perimeter. You should use the private keys only for testing a solution you are building on the testnet of a blockchain. For signing transactions on the mainnet, we strongly recommend that you use the Tatum Key Management System (KMS) and provide the signature ID instead of the private key in the API. Alternatively, you can use the Tatum JavaScript client. NOTE: This does not apply to transferring NFTs that were minted on Algorand using NFT Express (see earlier in this section).
        /// </remarks>
        /// <exception cref="Tatum.CSharp.Bsc.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="transferNftKMS"></param>
        /// <param name="xTestnetType">Type of Ethereum testnet. Defaults to Sepolia. Valid only for ETH invocations for testnet API Key. For mainnet API Key, this value is ignored. (optional, default to ethereum-sepolia)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of SignatureId</returns>
        System.Threading.Tasks.Task<SignatureId> NftTransferErc721Async(TransferNftKMS transferNftKMS, string xTestnetType = default(string), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        /// <summary>
        /// Update NFT royalty information
        /// </summary>
        /// <remarks>
        /// 2 credits per API call Update the value of the royalty cashback set for an NFT. The royalty cashback value can be updated only from the address of the NFT author (the address that is listed as a royalty cashback receiver in the NFT royalty information). The royalty cashback value cannot be updated from the address of the NFT owner. In one API call, you can update the first value of the royalty cashback for the NFT author for one NFT. To disable the royalties for the NFT completely, set it to 0. This API is supported for the following blockchains: BNB Smart Chain Celo Ethereum Harmony Klaytn KuCoin Community Chain Polygon TRON Signing a transaction When updating NFT royalty, you are charged a fee for the transaction, and you must sign the transaction with the private key of the blockchain address from which the fee will be deducted. Providing the private key in the API is not a secure way of signing transactions, because the private key can be stolen or exposed. Your private keys should never leave your security perimeter. You should use the private keys only for testing a solution you are building on the testnet of a blockchain. For signing transactions on the mainnet, we strongly recommend that you use the Tatum Key Management System (KMS) and provide the signature ID instead of the private key in the API. Alternatively, you can use the Tatum JavaScript client.
        /// </remarks>
        /// <exception cref="Tatum.CSharp.Bsc.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="updateCashbackValueForAuthorNft"></param>
        /// <param name="xTestnetType">Type of Ethereum testnet. Defaults to Sepolia. Valid only for ETH invocations for testnet API Key. For mainnet API Key, this value is ignored. (optional, default to ethereum-sepolia)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of TransactionHash</returns>
        System.Threading.Tasks.Task<TransactionHash> NftUpdateCashbackErc721Async(UpdateCashbackValueForAuthorNft updateCashbackValueForAuthorNft, string xTestnetType = default(string), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        /// <summary>
        /// Update NFT royalty information
        /// </summary>
        /// <remarks>
        /// 2 credits per API call Update the value of the royalty cashback set for an NFT. The royalty cashback value can be updated only from the address of the NFT author (the address that is listed as a royalty cashback receiver in the NFT royalty information). The royalty cashback value cannot be updated from the address of the NFT owner. In one API call, you can update the first value of the royalty cashback for the NFT author for one NFT. To disable the royalties for the NFT completely, set it to 0. This API is supported for the following blockchains: BNB Smart Chain Celo Ethereum Harmony Klaytn KuCoin Community Chain Polygon TRON Signing a transaction When updating NFT royalty, you are charged a fee for the transaction, and you must sign the transaction with the private key of the blockchain address from which the fee will be deducted. Providing the private key in the API is not a secure way of signing transactions, because the private key can be stolen or exposed. Your private keys should never leave your security perimeter. You should use the private keys only for testing a solution you are building on the testnet of a blockchain. For signing transactions on the mainnet, we strongly recommend that you use the Tatum Key Management System (KMS) and provide the signature ID instead of the private key in the API. Alternatively, you can use the Tatum JavaScript client.
        /// </remarks>
        /// <exception cref="Tatum.CSharp.Bsc.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="updateCashbackValueForAuthorNftKMS"></param>
        /// <param name="xTestnetType">Type of Ethereum testnet. Defaults to Sepolia. Valid only for ETH invocations for testnet API Key. For mainnet API Key, this value is ignored. (optional, default to ethereum-sepolia)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of SignatureId</returns>
        System.Threading.Tasks.Task<SignatureId> NftUpdateCashbackErc721Async(UpdateCashbackValueForAuthorNftKMS updateCashbackValueForAuthorNftKMS, string xTestnetType = default(string), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        #endregion Asynchronous Operations
    }

    /// <summary>
    /// Represents a collection of functions to interact with the API endpoints
    /// </summary>
    public interface INFTBscApiWithHttpInfoAsync : IApiAccessor
    {
        #region Asynchronous Operations With Http Info
        /// <summary>
        /// Add an NFT minter to an NFT smart contract
        /// </summary>
        /// <remarks>
        /// 2 credits per API call Allow a blockchain address (the minter parameter in the request body) to mint NFTs on the NFT smart contract (the contractAddress parameter in the request body). Use this API when you are using NFT Express with your own smart contract to mint NFTs and need to add the Tatum NFT minter&#39;s address as an NFT minter to your smart contract. For more information about the Tatum NFT minter, see \&quot;Use your own smart contract to mint NFTs\&quot; in Mint an NFT. This API is supported for the following blockchains: BNB Smart Chain Celo Ethereum Harmony Klaytn KuCoin Community Chain Polygon Signing a transaction When adding an NFT minter, you are charged a fee for the transaction, and you must sign the transaction with the private key of the blockchain address from which the fee will be deducted. Providing the private key in the API is not a secure way of signing transactions, because the private key can be stolen or exposed. Your private keys should never leave your security perimeter. You should use the private keys only for testing a solution you are building on the testnet of a blockchain. For signing transactions on the mainnet, we strongly recommend that you use the Tatum Key Management System (KMS) and provide the signature ID instead of the private key in the API. Alternatively, you can use the Tatum JavaScript client.
        /// </remarks>
        /// <exception cref="Tatum.CSharp.Bsc.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="addNftMinter"></param>
        /// <param name="xTestnetType">Type of Ethereum testnet. Defaults to Sepolia. Valid only for ETH invocations for testnet API Key. For mainnet API Key, this value is ignored. (optional, default to ethereum-sepolia)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (TransactionHash)</returns>
        System.Threading.Tasks.Task<ApiResponse<TransactionHash>> NftAddMinterWithHttpInfoAsync(AddNftMinter addNftMinter, string xTestnetType = default(string), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        /// <summary>
        /// Add an NFT minter to an NFT smart contract
        /// </summary>
        /// <remarks>
        /// 2 credits per API call Allow a blockchain address (the minter parameter in the request body) to mint NFTs on the NFT smart contract (the contractAddress parameter in the request body). Use this API when you are using NFT Express with your own smart contract to mint NFTs and need to add the Tatum NFT minter&#39;s address as an NFT minter to your smart contract. For more information about the Tatum NFT minter, see \&quot;Use your own smart contract to mint NFTs\&quot; in Mint an NFT. This API is supported for the following blockchains: BNB Smart Chain Celo Ethereum Harmony Klaytn KuCoin Community Chain Polygon Signing a transaction When adding an NFT minter, you are charged a fee for the transaction, and you must sign the transaction with the private key of the blockchain address from which the fee will be deducted. Providing the private key in the API is not a secure way of signing transactions, because the private key can be stolen or exposed. Your private keys should never leave your security perimeter. You should use the private keys only for testing a solution you are building on the testnet of a blockchain. For signing transactions on the mainnet, we strongly recommend that you use the Tatum Key Management System (KMS) and provide the signature ID instead of the private key in the API. Alternatively, you can use the Tatum JavaScript client.
        /// </remarks>
        /// <exception cref="Tatum.CSharp.Bsc.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="addNftMinterKMS"></param>
        /// <param name="xTestnetType">Type of Ethereum testnet. Defaults to Sepolia. Valid only for ETH invocations for testnet API Key. For mainnet API Key, this value is ignored. (optional, default to ethereum-sepolia)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (SignatureId)</returns>
        System.Threading.Tasks.Task<ApiResponse<SignatureId>> NftAddMinterWithHttpInfoAsync(AddNftMinterKMS addNftMinterKMS, string xTestnetType = default(string), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        /// <summary>
        /// Burn an NFT
        /// </summary>
        /// <remarks>
        /// 100 credits per API call on Flow 2 credits per API call on the other blockchains Destroy an NFT. Burning the NFT transfers it to an un-spendable blockchain address that no one can access. This API is supported for the following blockchains: Algorand BNB Smart Chain Celo Ethereum Flow Harmony Klaytn KuCoin Community Chain Polygon TRON Burning NFTs on Algorand You can burn only the NFTs that were minted with the address of the manager account specified in the manager parameter in the minting call (see the MintNftExpressAlgorand, MintNftAlgorand, and MintNftAlgorandKMS schemas of the request body). Signing a transaction When burning an NFT, you are charged a fee for the transaction, and you must sign the transaction with the private key of the blockchain address from which the fee will be deducted. Providing the private key in the API is not a secure way of signing transactions, because the private key can be stolen or exposed. Your private keys should never leave your security perimeter. You should use the private keys only for testing a solution you are building on the testnet of a blockchain. For signing transactions on the mainnet, we strongly recommend that you use the Tatum Key Management System (KMS) and provide the signature ID instead of the private key in the API. Alternatively, you can use the Tatum JavaScript client.
        /// </remarks>
        /// <exception cref="Tatum.CSharp.Bsc.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="burnNft"></param>
        /// <param name="xTestnetType">Type of Ethereum testnet. Defaults to Sepolia. Valid only for ETH invocations for testnet API Key. For mainnet API Key, this value is ignored. (optional, default to ethereum-sepolia)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (TransactionHash)</returns>
        System.Threading.Tasks.Task<ApiResponse<TransactionHash>> NftBurnErc721WithHttpInfoAsync(BurnNft burnNft, string xTestnetType = default(string), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        /// <summary>
        /// Burn an NFT
        /// </summary>
        /// <remarks>
        /// 100 credits per API call on Flow 2 credits per API call on the other blockchains Destroy an NFT. Burning the NFT transfers it to an un-spendable blockchain address that no one can access. This API is supported for the following blockchains: Algorand BNB Smart Chain Celo Ethereum Flow Harmony Klaytn KuCoin Community Chain Polygon TRON Burning NFTs on Algorand You can burn only the NFTs that were minted with the address of the manager account specified in the manager parameter in the minting call (see the MintNftExpressAlgorand, MintNftAlgorand, and MintNftAlgorandKMS schemas of the request body). Signing a transaction When burning an NFT, you are charged a fee for the transaction, and you must sign the transaction with the private key of the blockchain address from which the fee will be deducted. Providing the private key in the API is not a secure way of signing transactions, because the private key can be stolen or exposed. Your private keys should never leave your security perimeter. You should use the private keys only for testing a solution you are building on the testnet of a blockchain. For signing transactions on the mainnet, we strongly recommend that you use the Tatum Key Management System (KMS) and provide the signature ID instead of the private key in the API. Alternatively, you can use the Tatum JavaScript client.
        /// </remarks>
        /// <exception cref="Tatum.CSharp.Bsc.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="burnNftKMS"></param>
        /// <param name="xTestnetType">Type of Ethereum testnet. Defaults to Sepolia. Valid only for ETH invocations for testnet API Key. For mainnet API Key, this value is ignored. (optional, default to ethereum-sepolia)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (SignatureId)</returns>
        System.Threading.Tasks.Task<ApiResponse<SignatureId>> NftBurnErc721WithHttpInfoAsync(BurnNftKMS burnNftKMS, string xTestnetType = default(string), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        /// <summary>
        /// Deploy an NFT smart contract
        /// </summary>
        /// <remarks>
        /// 100 credits per API call on Flow 2 credits per API call on the other blockchains Deploy an NFT smart contract on the blockchain. In a deployed NFT smart contract, you can mint NFTs (one NFT at a time or multiple NFTs at once), burn, and transfer NFTs. Smart contracts are standardized and audited. You can review the code of a deployed NFT smart contract here (if the contract is deployed on Flow) or here (if the contract is deployed on any other supported blockchain). This API is supported for the following blockchains: BNB Smart Chain Celo Ethereum Flow Harmony Klaytn KuCoin Community Chain Polygon TRON General NFT smart contracts By default, an NFT smart contract is deployed as a general NFT smart contract compatible with OpenSea royalties. This is a standard NFT contract with AccessControl and Ownable, enhanced with NFT batch minting. NFTs minted on this smart contract are compatible with OpenSea and its royalty structure. Cashback and provenance NFT smart contracts In addition to the general NFT contract, you can deploy the following types of NFT smart contracts for the supported blockchains except for Flow and TRON: Cashback NFT smart contract is an NFT smart contract that forces on-chain royalties to be paid every time an NFT is transferred, and the royalties are defined as a fixed value. The royalties are not OpenSea-compatible. To deploy an NFT smart contract as a cashback contract, deploy the contract with the cashback parameter set to true in the request body. Provenance NFT smart contract is an NFT smart contract that forces on-chain royalties to be paid every time an NFT is transferred, and the royalties are defined as a percentage of the NFT price. The royalties are not OpenSea-compatible. To deploy an NFT smart contract as a provenance contract, deploy the contract with the provenance parameter set to true in the request body. You can enable public minting for cashback and provenance smart contracts. By default, public minting is disabled, which means that only the blockchain address whose private key was used to create the smart contract or the blockchain addresses added to the smart contract as NFT minters will be able to mint NFTs for the contract. To enable public minting and allow anyone to mint NFTs on top of the smart contract, deploy the contract with the publicMint parameter set to true in the request body. NFT smart contracts and NFT Express If you want to use NFT Express to mint NFTs on the deployed smart contract, deploy the smart contract as a general NFT smart contract (that is, deploy the contract with the cashback, provenance, and publicMint parameters either set to false or not set at all in the request body). After you have deployed the NFT smart contract, add the Tatum minter address as an NFT minter to your smart contract. For the complete information about using NFT Express on your smart contract, see \&quot;Use your own smart contract to mint NFTs\&quot; in Mint an NFT. Signing a transaction When deploying an NFT smart contract, you are charged a fee for the transaction, and you must sign the transaction with the private key of the blockchain address from which the fee will be deducted. Providing the private key in the API is not a secure way of signing transactions, because the private key can be stolen or exposed. Your private keys should never leave your security perimeter. You should use the private keys only for testing a solution you are building on the testnet of a blockchain. For signing transactions on the mainnet, we strongly recommend that you use the Tatum Key Management System (KMS) and provide the signature ID instead of the private key in the API. Alternatively, you can use the Tatum JavaScript client.
        /// </remarks>
        /// <exception cref="Tatum.CSharp.Bsc.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="deployNft"></param>
        /// <param name="xTestnetType">Type of Ethereum testnet. Defaults to Sepolia. Valid only for ETH invocations for testnet API Key. For mainnet API Key, this value is ignored. (optional, default to ethereum-sepolia)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (TransactionHash)</returns>
        System.Threading.Tasks.Task<ApiResponse<TransactionHash>> NftDeployErc721WithHttpInfoAsync(DeployNft deployNft, string xTestnetType = default(string), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        /// <summary>
        /// Deploy an NFT smart contract
        /// </summary>
        /// <remarks>
        /// 100 credits per API call on Flow 2 credits per API call on the other blockchains Deploy an NFT smart contract on the blockchain. In a deployed NFT smart contract, you can mint NFTs (one NFT at a time or multiple NFTs at once), burn, and transfer NFTs. Smart contracts are standardized and audited. You can review the code of a deployed NFT smart contract here (if the contract is deployed on Flow) or here (if the contract is deployed on any other supported blockchain). This API is supported for the following blockchains: BNB Smart Chain Celo Ethereum Flow Harmony Klaytn KuCoin Community Chain Polygon TRON General NFT smart contracts By default, an NFT smart contract is deployed as a general NFT smart contract compatible with OpenSea royalties. This is a standard NFT contract with AccessControl and Ownable, enhanced with NFT batch minting. NFTs minted on this smart contract are compatible with OpenSea and its royalty structure. Cashback and provenance NFT smart contracts In addition to the general NFT contract, you can deploy the following types of NFT smart contracts for the supported blockchains except for Flow and TRON: Cashback NFT smart contract is an NFT smart contract that forces on-chain royalties to be paid every time an NFT is transferred, and the royalties are defined as a fixed value. The royalties are not OpenSea-compatible. To deploy an NFT smart contract as a cashback contract, deploy the contract with the cashback parameter set to true in the request body. Provenance NFT smart contract is an NFT smart contract that forces on-chain royalties to be paid every time an NFT is transferred, and the royalties are defined as a percentage of the NFT price. The royalties are not OpenSea-compatible. To deploy an NFT smart contract as a provenance contract, deploy the contract with the provenance parameter set to true in the request body. You can enable public minting for cashback and provenance smart contracts. By default, public minting is disabled, which means that only the blockchain address whose private key was used to create the smart contract or the blockchain addresses added to the smart contract as NFT minters will be able to mint NFTs for the contract. To enable public minting and allow anyone to mint NFTs on top of the smart contract, deploy the contract with the publicMint parameter set to true in the request body. NFT smart contracts and NFT Express If you want to use NFT Express to mint NFTs on the deployed smart contract, deploy the smart contract as a general NFT smart contract (that is, deploy the contract with the cashback, provenance, and publicMint parameters either set to false or not set at all in the request body). After you have deployed the NFT smart contract, add the Tatum minter address as an NFT minter to your smart contract. For the complete information about using NFT Express on your smart contract, see \&quot;Use your own smart contract to mint NFTs\&quot; in Mint an NFT. Signing a transaction When deploying an NFT smart contract, you are charged a fee for the transaction, and you must sign the transaction with the private key of the blockchain address from which the fee will be deducted. Providing the private key in the API is not a secure way of signing transactions, because the private key can be stolen or exposed. Your private keys should never leave your security perimeter. You should use the private keys only for testing a solution you are building on the testnet of a blockchain. For signing transactions on the mainnet, we strongly recommend that you use the Tatum Key Management System (KMS) and provide the signature ID instead of the private key in the API. Alternatively, you can use the Tatum JavaScript client.
        /// </remarks>
        /// <exception cref="Tatum.CSharp.Bsc.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="deployNftKMS"></param>
        /// <param name="xTestnetType">Type of Ethereum testnet. Defaults to Sepolia. Valid only for ETH invocations for testnet API Key. For mainnet API Key, this value is ignored. (optional, default to ethereum-sepolia)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (SignatureId)</returns>
        System.Threading.Tasks.Task<ApiResponse<SignatureId>> NftDeployErc721WithHttpInfoAsync(DeployNftKMS deployNftKMS, string xTestnetType = default(string), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        /// <summary>
        /// Get the NFTs from a specific smart contract that a blockchain address holds
        /// </summary>
        /// <remarks>
        /// 1 credit per API call Get the NFTs minted on a specific smart contract (the contractAddress path parameter in the request endpoint URL) that a blockchain address holds. NOTE: This API works only for the NFT smart contracts deployed using the Tatum smart contract API. This API is supported for the following blockchains: Algorand BNB Smart Chain Celo Elrond Ethereum Flow Harmony Klaytn KuCoin Community Chain Polygon Solana TRON
        /// </remarks>
        /// <exception cref="Tatum.CSharp.Bsc.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="address">The blockchain address that you want to get the token balance of</param>
        /// <param name="contractAddress">The address of the NFT smart contract</param>
        /// <param name="xTestnetType">Type of Ethereum testnet. Defaults to Sepolia. Valid only for ETH invocations for testnet API Key. For mainnet API Key, this value is ignored. (optional, default to ethereum-sepolia)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (NftGetBalanceSc)</returns>
        System.Threading.Tasks.Task<ApiResponse<NftGetBalanceSc>> NftGetBalanceErc721WithHttpInfoAsync(string address, string contractAddress, string xTestnetType = default(string), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        /// <summary>
        /// Get NFT metadata
        /// </summary>
        /// <remarks>
        /// 1 credit per API call Get metadata of an NFT. This API is supported for the following blockchains: BNB Smart Chain Celo Ethereum Flow Harmony Klaytn KuCoin Community Chain Polygon Solana TRON
        /// </remarks>
        /// <exception cref="Tatum.CSharp.Bsc.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="contractAddress">The blockchain address of the NFT to get metadata for</param>
        /// <param name="tokenId">The ID of the NFT to get metadata for&lt;br/&gt;Do &lt;b&gt;not&lt;/b&gt; use this parameter if you are getting metadata for an NFT on Solana, this parameter is irrelevant on Solana.</param>
        /// <param name="account">(Flow only) The account that holds the NFT (optional)</param>
        /// <param name="xTestnetType">Type of Ethereum testnet. Defaults to Sepolia. Valid only for ETH invocations for testnet API Key. For mainnet API Key, this value is ignored. (optional, default to ethereum-sepolia)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (NftMetadataErc721)</returns>
        System.Threading.Tasks.Task<ApiResponse<NftMetadataErc721>> NftGetMetadataErc721WithHttpInfoAsync(string contractAddress, string tokenId, string account = default(string), string xTestnetType = default(string), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        /// <summary>
        /// Get NFT provenance information
        /// </summary>
        /// <remarks>
        /// 1 credit per API call Get provenance information for an NFT. NOTE: This API works only for provenance NFT smart contracts. This API is supported for the following blockchains: BNB Smart Chain Celo Ethereum Harmony Klaytn KuCoin Community Chain Polygon
        /// </remarks>
        /// <exception cref="Tatum.CSharp.Bsc.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="contractAddress">The blockchain address of the NFT to get provenance information for</param>
        /// <param name="tokenId">The ID of the NFT to get provenance information for.</param>
        /// <param name="xTestnetType">Type of Ethereum testnet. Defaults to Sepolia. Valid only for ETH invocations for testnet API Key. For mainnet API Key, this value is ignored. (optional, default to ethereum-sepolia)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (List&lt;NftProvenanceDataErc721&gt;)</returns>
        System.Threading.Tasks.Task<ApiResponse<List<NftProvenanceDataErc721>>> NftGetProvenanceDataErc721WithHttpInfoAsync(string contractAddress, string tokenId, string xTestnetType = default(string), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        /// <summary>
        /// Get NFT royalty information
        /// </summary>
        /// <remarks>
        /// 1 credit per API call Get information about royalties for an NFT. This API is supported for the following blockchains: BNB Smart Chain Celo Ethereum Harmony Klaytn KuCoin Community Chain Polygon Solana TRON
        /// </remarks>
        /// <exception cref="Tatum.CSharp.Bsc.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="contractAddress">The blockchain address of the NFT to get royalty information for</param>
        /// <param name="tokenId">The ID of the NFT to get royalty information for&lt;br/&gt;Do &lt;b&gt;not&lt;/b&gt; use this parameter if you are getting metadata for an NFT on Solana, this parameter is irrelevant on Solana.</param>
        /// <param name="xTestnetType">Type of Ethereum testnet. Defaults to Sepolia. Valid only for ETH invocations for testnet API Key. For mainnet API Key, this value is ignored. (optional, default to ethereum-sepolia)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (NftRoyaltyErc721)</returns>
        System.Threading.Tasks.Task<ApiResponse<NftRoyaltyErc721>> NftGetRoyaltyErc721WithHttpInfoAsync(string contractAddress, string tokenId, string xTestnetType = default(string), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        /// <summary>
        /// Get all NFTs that a blockchain address holds
        /// </summary>
        /// <remarks>
        /// 1 credit per API call + 5 credits for each owned NFT Get all NFTs that a blockchain address holds. The NFTs are returned grouped by the smart contracts they were minted on. This API is supported for the following blockchains: Algorand BNB Smart Chain - mainnet only Celo Ethereum Polygon Solana On Solana and Algorand, if a blockchain address holds fewer than 50 NFTs, the API also returns each NFT&#39;s metadata. If the metadata is not returned, you can obtain it using the API for getting NFT metadata.
        /// </remarks>
        /// <exception cref="Tatum.CSharp.Bsc.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="address">The blockchain address that you want to get the token balance of</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (List&lt;NftTokenByAddressErc721&gt;)</returns>
        System.Threading.Tasks.Task<ApiResponse<List<NftTokenByAddressErc721>>> NftGetTokensByAddressErc721WithHttpInfoAsync(string address, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        /// <summary>
        /// Get an NFT transaction by its hash
        /// </summary>
        /// <remarks>
        /// 1 credit per API call Get an NFT transaction by its hash. This API is supported for the following blockchains: BNB Smart Chain Celo Ethereum Flow Harmony Klaytn KuCoin Community Chain Polygon TRON
        /// </remarks>
        /// <exception cref="Tatum.CSharp.Bsc.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="hash">The hash (ID) of the NFT transaction</param>
        /// <param name="xTestnetType">Type of Ethereum testnet. Defaults to Sepolia. Valid only for ETH invocations for testnet API Key. For mainnet API Key, this value is ignored. (optional, default to ethereum-sepolia)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (EthTx)</returns>
        System.Threading.Tasks.Task<ApiResponse<EthTx>> NftGetTransactErc721WithHttpInfoAsync(string hash, string xTestnetType = default(string), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        /// <summary>
        /// Mint an NFT
        /// </summary>
        /// <remarks>
        /// 100 credits per API call on Flow 2 credits per API call on the other blockchains You can mint NFTs using either of the following methods: Using NFT Express Natively on a blockchain Minting NFTs using NFT Express NFT Express is Tatum&#39;s feature that helps you mint NFTs easier than minting natively on a blockchain. You do not need to enter your private key or signature ID. NFT Express uses the private key provided by Tatum. You do not need to hold crypto or keep addresses topped up with crypto to pay for minting transactions. To use NFT Express on the mainnet, you have to have a paid pricing plan. Tatum covers your transaction fees for NFT minting and pays for them from its own blockchain address. Then, the fee amount paid by Tatum is converted to the number of credits, and these credits are deducted from the monthly credit allowance of your paid pricing plan. The transaction fees and the corresponding numbers of credits deducted from your allowance vary depending on what blockchain you mint NFTs on. On the testnet, no credits are deducted from the monthly credit allowance. You can mint NFTs with NFT Express regardless of your pricing plan. With NFT Express, you can choose whether to mint NFTs on the pre-built NFT smart contract provided by Tatum or on your own smart contract. Use the pre-built smart contract provided by Tatum to mint NFTs If you want to mint NFTs using the pre-built smart contract, you do not need to deploy your own NFT smart contract. You do not need to provide the address of the NFT smart contract and the token ID in the request body either. The address of the smart contract and the token ID are provided automatically by Tatum. The token ID is autogenerated. It starts with 0 and is increased by 1 for each new NFT. The token ID is calculated separately for each supported blockchain and its mainnet and testnet. For more information, see our user documentation. You can mint NFTs on the pre-built smart contract provided by Tatum on the following blockchains: Algorand BNB Smart Chain Celo Ethereum Harmony Klaytn Polygon Solana Depending on what blockchain you use, choose the request body schema to use in the API call. To mint NFTs on BNB Smart Chain, Celo, Ethereum, Harmony, Klaytn, or Polygon, use this API with the MintNftExpress schema of the request body. To mint NFTs on Algorand, use this API with the MintNftExpressAlgorand schema of the request body. To be able to burn the minted NFTs any time later, specify the address of the manager account in the manager parameter. An NFT minted on Algorand is automatically transferred to your blockchain address. After the NFT is minted, you have to transfer it to the recipient&#39;s address. The recipient has to agree in advance to receive your NFT because Algorand charges users for storing NFTs on their addresses, and an Algorand blockchain address by default does not receive NFTs unless explicitly agreed. This how it works: The recipient agrees to receive the NFT to their address. You transfer the NFT to the recipient&#39;s address (use the transferNftAlgoExpress schema of the request body). NOTE: On the mainnet, Tatum covers your transaction fees for the NFT transfer and pays for them from its own blockchain address. Then, the fee amount paid by Tatum is converted to the number of credits, and these credits are deducted from the monthly credit allowance of your paid pricing plan. On the testnet, no credits are deducted from the monthly credit allowance. To mint NFTs on Solana, use this API with the MintNftExpressSolana schema of the request body. Solana uses the Metaplex Protocol, a smart contract and metadata standard for creating and working with NFTs. When you mint an NFT on Solana with NFT Express, the pre-built smart contract based on the Metaplex Protocol is used. When an NFT is minted on Solana, a new blockchain address is created to receive the NFT under the recipient&#39;s account address (the one in the to parameter of the request body). This address is returned in the nftAccountAddress parameter in the response body, is owned by the recipient&#39;s address, and has the same private key. The response body also returns the address of the minted NFT itself, which is held in the nftAddress parameter. After the NFT is minted, you have to transfer it to the recipient&#39;s address (use the transferNftSolana or transferNftSolanaKMS schema of the request body). In the request body of the transfer call: Set the from parameter to the address that you used in the to parameter in the request body of the minting call. Set the to parameter to the recipient&#39;s address. Set the contractAddress parameter to the address from the nftAddress parameter returned in the response body of the minting call. Set the fromPrivateKey/signatureId parameter to the private key/signature ID of the blockchain address that you specified in the from parameter. Use your own smart contract to mint NFTs If you want to mint NFTs using your own smart contract, you are going to use an NTF minter, a special blockchain address provided by Tatum that will cover the minting fees. The number of credits equivalent to the fees will be then deducted from the monthly credit allowance of your paid pricing plan. IMPORTANT! Your smart contract must be deployed as a general NFT smart contract. You cannot use cashback and provenance smart contracts with NFT Express. For more information, see our user documentation and the article in the Tatum blog. You can mint NFTs on your own smart contract on the following blockchains: BNB Smart Chain Celo Ethereum Harmony Klaytn Polygon To mint NFTs using your own smart contract, do the following: In the table located under this section, find the blockchain address of the Tatum NFT minter for your blockchain and network (mainnet or testnet). Add the minter address as an NFT minter to your smart contract. Use this API with the MintNftMinter schema of the request body. In the request body, enter the following information: chain is the blockchain that you use. to is the blockchain address where to send the minted NFT to. url is the URL of the NFT metadata. minter is the address of the NFT minter that you found in Step 1. contractAddress is the address of your NFT smart contract. tokenId is the the token ID of the NFT. For example:  {   \&quot;chain\&quot;: \&quot;CELO\&quot;,   \&quot;to\&quot;: \&quot;0x8ce4e40889a13971681391aad29e88efaf91f784\&quot;,   \&quot;url\&quot;: \&quot;ipfs://QmXJJ6UF5WkF4WTJvsdhiA1etGwBLfpva7Vr9AudGMe3pj\&quot;,   \&quot;contractAddress\&quot;: \&quot;0x687422eEA2cB73B5d3e242bA5456b782919AFc85\&quot;,   \&quot;tokenId\&quot;: \&quot;0123\&quot;,   \&quot;minter\&quot;: \&quot;0xBC2eBA680EE50d685cc4Fe65f102AA70AfB27D3F\&quot; } When you make an API call with this request body, the private key of the NFT minter will be added to the request body automatically:  {   \&quot;chain\&quot;: \&quot;CELO\&quot;,   \&quot;to\&quot;: \&quot;0x8ce4e40889a13971681391aad29e88efaf91f784\&quot;,   \&quot;url\&quot;: \&quot;ipfs://QmXJJ6UF5WkF4WTJvsdhiA1etGwBLfpva7Vr9AudGMe3pj\&quot;,   \&quot;contractAddress\&quot;: \&quot;0x687422eEA2cB73B5d3e242bA5456b782919AFc85\&quot;,   \&quot;tokenId\&quot;: \&quot;0123\&quot;,   \&quot;minter\&quot;: \&quot;0xBC2eBA680EE50d685cc4Fe65f102AA70AfB27D3F\&quot;,   \&quot;fromPrivateKey\&quot;: \&quot;0x05e150c73f1920ec14caa1e0b6aa09940899678051a78542840c2668ce5080c2\&quot; } The following table lists the blockchain addresses of the Tatum NFT minters for the testnet and mainnet of the supported blockchains: Blockchain Minter address - testnet* Minter address - mainnet BNB Smart Chain 0xc16ae5e8c985b906935a0cadf4e24f0400531883 0x49678AAB11E001eb3cB2cBD9aA96b36DC2461A94 Celo 0xBC2eBA680EE50d685cc4Fe65f102AA70AfB27D3F 0x49678AAB11E001eb3cB2cBD9aA96b36DC2461A94 Ethereum 0x53e8577C4347C365E4e0DA5B57A589cB6f2AB848 0x49678AAB11E001eb3cB2cBD9aA96b36DC2461A94 Harmony 0x8906f62d40293ddca77fdf6714c3f63265deddf0 0x49678AAB11E001eb3cB2cBD9aA96b36DC2461A94 Klaytn 0x80d8bac9a6901698b3749fe336bbd1385c1f98f2 0x49678AAB11E001eb3cB2cBD9aA96b36DC2461A94 Polygon 0x542b9ac4945a3836fd12ad98acbc76a0c8b743f5 0x49678AAB11E001eb3cB2cBD9aA96b36DC2461A94 *If a minter blockchain address on the testnet does not have sufficient funds to cover the transaction fee, add some amount to it using a crypto faucet of the blockchain. Minting NFTs natively on a blockchain When minting an NFT natively on a blockchain, you are charged a fee for the transaction, and you must sign the transaction with the private key of the blockchain address from which the fee will be deducted. Providing the private key in the API is not a secure way of signing transactions, because the private key can be stolen or exposed. Your private keys should never leave your security perimeter. You should use the private keys only for testing a solution you are building on the testnet of a blockchain. For signing transactions on the mainnet, we strongly recommend that you use the Tatum Key Management System (KMS) and provide the signature ID instead of the private key in the API. Alternatively, you can use the Tatum JavaScript client. You can mint NFTs natively on the following blockchains: Algorand BNB Smart Chain Celo Ethereum Flow Harmony Klaytn KuCoin Community Chain Polygon Solana TRON Depending on what blockchain you use, choose the request body schema to use in the API call. To mint NFTs natively on Algorand and: To sign the transaction with your private key, use this API with the MintNftAlgorand schema of the request body. To sign the transaction with your signature ID, use this API the MintNftAlgorandKMS schema of the request body. NOTE: To be able to burn the minted NFTs any time later, specify the address of the manager account in the manager parameter. An NFT minted on Algorand is automatically transferred to your blockchain address. After the NFT is minted, you have to transfer it to the recipient&#39;s address. The recipient has to agree in advance to receive your NFT because Algorand charges users for storing NFTs on their addresses, and an Algorand blockchain address by default does not receive NFTs unless explicitly agreed. For more information about how it works, see the section about minting NFTs on Algorand using the pre-built NFT smart contract provided by Tatum. To mint NFTs natively on BNB Smart Chain, Ethereum, Harmony, Klaytn, KuCoin Community Chain, or Polygon, and: To sign the transaction with your private key, use this API with the MintNft schema of the request body. To sign the transaction with your signature ID, use this API the MintNftKMS schema of the request body. To mint NFTs natively on Celo and: To sign the transaction with your private key, use this API with the MintNftCelo schema of the request body. To sign the transaction with your signature ID, use this API the MintNftKMSCelo schema of the request body. To mint NFTs natively on Flow and: To sign the transaction with your private key, use this API with the MintNftFlowPK schema of the request body. To sign the transaction with your signature ID, use this API the MintNftFlowMnemonic schema of the request body. To sign the transaction with your wallet mnemonic, use this API the MintNftFlowKMS schema of the request body. To mint NFTs natively on Solana and: To sign the transaction with your private key, use this API with the MintNftSolana schema of the request body. To sign the transaction with your signature ID, use this API the MintNftSolanaKMS schema of the request body. NOTE: When an NFT is minted on Solana, a new blockchain address is created to receive the NFT under the recipient&#39;s account address. After the NFT is minted, you have to transfer it to the recipient&#39;s address. For more information about how it works, see the section about minting NFTs on Solana using the pre-built NFT smart contract provided by Tatum. To mint NFTs natively on TRON and: To sign the transaction with your private key, use this API with the MintNftTron schema of the request body. To sign the transaction with your signature ID, use this API the MintNftKMSTron schema of the request body.
        /// </remarks>
        /// <exception cref="Tatum.CSharp.Bsc.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="mintNftExpress"></param>
        /// <param name="xTestnetType">Type of Ethereum testnet. Defaults to Sepolia. Valid only for ETH invocations for testnet API Key. For mainnet API Key, this value is ignored. (optional, default to ethereum-sepolia)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (TransactionHash)</returns>
        System.Threading.Tasks.Task<ApiResponse<TransactionHash>> NftMintErc721WithHttpInfoAsync(MintNftExpress mintNftExpress, string xTestnetType = default(string), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        /// <summary>
        /// Mint an NFT
        /// </summary>
        /// <remarks>
        /// 100 credits per API call on Flow 2 credits per API call on the other blockchains You can mint NFTs using either of the following methods: Using NFT Express Natively on a blockchain Minting NFTs using NFT Express NFT Express is Tatum&#39;s feature that helps you mint NFTs easier than minting natively on a blockchain. You do not need to enter your private key or signature ID. NFT Express uses the private key provided by Tatum. You do not need to hold crypto or keep addresses topped up with crypto to pay for minting transactions. To use NFT Express on the mainnet, you have to have a paid pricing plan. Tatum covers your transaction fees for NFT minting and pays for them from its own blockchain address. Then, the fee amount paid by Tatum is converted to the number of credits, and these credits are deducted from the monthly credit allowance of your paid pricing plan. The transaction fees and the corresponding numbers of credits deducted from your allowance vary depending on what blockchain you mint NFTs on. On the testnet, no credits are deducted from the monthly credit allowance. You can mint NFTs with NFT Express regardless of your pricing plan. With NFT Express, you can choose whether to mint NFTs on the pre-built NFT smart contract provided by Tatum or on your own smart contract. Use the pre-built smart contract provided by Tatum to mint NFTs If you want to mint NFTs using the pre-built smart contract, you do not need to deploy your own NFT smart contract. You do not need to provide the address of the NFT smart contract and the token ID in the request body either. The address of the smart contract and the token ID are provided automatically by Tatum. The token ID is autogenerated. It starts with 0 and is increased by 1 for each new NFT. The token ID is calculated separately for each supported blockchain and its mainnet and testnet. For more information, see our user documentation. You can mint NFTs on the pre-built smart contract provided by Tatum on the following blockchains: Algorand BNB Smart Chain Celo Ethereum Harmony Klaytn Polygon Solana Depending on what blockchain you use, choose the request body schema to use in the API call. To mint NFTs on BNB Smart Chain, Celo, Ethereum, Harmony, Klaytn, or Polygon, use this API with the MintNftExpress schema of the request body. To mint NFTs on Algorand, use this API with the MintNftExpressAlgorand schema of the request body. To be able to burn the minted NFTs any time later, specify the address of the manager account in the manager parameter. An NFT minted on Algorand is automatically transferred to your blockchain address. After the NFT is minted, you have to transfer it to the recipient&#39;s address. The recipient has to agree in advance to receive your NFT because Algorand charges users for storing NFTs on their addresses, and an Algorand blockchain address by default does not receive NFTs unless explicitly agreed. This how it works: The recipient agrees to receive the NFT to their address. You transfer the NFT to the recipient&#39;s address (use the transferNftAlgoExpress schema of the request body). NOTE: On the mainnet, Tatum covers your transaction fees for the NFT transfer and pays for them from its own blockchain address. Then, the fee amount paid by Tatum is converted to the number of credits, and these credits are deducted from the monthly credit allowance of your paid pricing plan. On the testnet, no credits are deducted from the monthly credit allowance. To mint NFTs on Solana, use this API with the MintNftExpressSolana schema of the request body. Solana uses the Metaplex Protocol, a smart contract and metadata standard for creating and working with NFTs. When you mint an NFT on Solana with NFT Express, the pre-built smart contract based on the Metaplex Protocol is used. When an NFT is minted on Solana, a new blockchain address is created to receive the NFT under the recipient&#39;s account address (the one in the to parameter of the request body). This address is returned in the nftAccountAddress parameter in the response body, is owned by the recipient&#39;s address, and has the same private key. The response body also returns the address of the minted NFT itself, which is held in the nftAddress parameter. After the NFT is minted, you have to transfer it to the recipient&#39;s address (use the transferNftSolana or transferNftSolanaKMS schema of the request body). In the request body of the transfer call: Set the from parameter to the address that you used in the to parameter in the request body of the minting call. Set the to parameter to the recipient&#39;s address. Set the contractAddress parameter to the address from the nftAddress parameter returned in the response body of the minting call. Set the fromPrivateKey/signatureId parameter to the private key/signature ID of the blockchain address that you specified in the from parameter. Use your own smart contract to mint NFTs If you want to mint NFTs using your own smart contract, you are going to use an NTF minter, a special blockchain address provided by Tatum that will cover the minting fees. The number of credits equivalent to the fees will be then deducted from the monthly credit allowance of your paid pricing plan. IMPORTANT! Your smart contract must be deployed as a general NFT smart contract. You cannot use cashback and provenance smart contracts with NFT Express. For more information, see our user documentation and the article in the Tatum blog. You can mint NFTs on your own smart contract on the following blockchains: BNB Smart Chain Celo Ethereum Harmony Klaytn Polygon To mint NFTs using your own smart contract, do the following: In the table located under this section, find the blockchain address of the Tatum NFT minter for your blockchain and network (mainnet or testnet). Add the minter address as an NFT minter to your smart contract. Use this API with the MintNftMinter schema of the request body. In the request body, enter the following information: chain is the blockchain that you use. to is the blockchain address where to send the minted NFT to. url is the URL of the NFT metadata. minter is the address of the NFT minter that you found in Step 1. contractAddress is the address of your NFT smart contract. tokenId is the the token ID of the NFT. For example:  {   \&quot;chain\&quot;: \&quot;CELO\&quot;,   \&quot;to\&quot;: \&quot;0x8ce4e40889a13971681391aad29e88efaf91f784\&quot;,   \&quot;url\&quot;: \&quot;ipfs://QmXJJ6UF5WkF4WTJvsdhiA1etGwBLfpva7Vr9AudGMe3pj\&quot;,   \&quot;contractAddress\&quot;: \&quot;0x687422eEA2cB73B5d3e242bA5456b782919AFc85\&quot;,   \&quot;tokenId\&quot;: \&quot;0123\&quot;,   \&quot;minter\&quot;: \&quot;0xBC2eBA680EE50d685cc4Fe65f102AA70AfB27D3F\&quot; } When you make an API call with this request body, the private key of the NFT minter will be added to the request body automatically:  {   \&quot;chain\&quot;: \&quot;CELO\&quot;,   \&quot;to\&quot;: \&quot;0x8ce4e40889a13971681391aad29e88efaf91f784\&quot;,   \&quot;url\&quot;: \&quot;ipfs://QmXJJ6UF5WkF4WTJvsdhiA1etGwBLfpva7Vr9AudGMe3pj\&quot;,   \&quot;contractAddress\&quot;: \&quot;0x687422eEA2cB73B5d3e242bA5456b782919AFc85\&quot;,   \&quot;tokenId\&quot;: \&quot;0123\&quot;,   \&quot;minter\&quot;: \&quot;0xBC2eBA680EE50d685cc4Fe65f102AA70AfB27D3F\&quot;,   \&quot;fromPrivateKey\&quot;: \&quot;0x05e150c73f1920ec14caa1e0b6aa09940899678051a78542840c2668ce5080c2\&quot; } The following table lists the blockchain addresses of the Tatum NFT minters for the testnet and mainnet of the supported blockchains: Blockchain Minter address - testnet* Minter address - mainnet BNB Smart Chain 0xc16ae5e8c985b906935a0cadf4e24f0400531883 0x49678AAB11E001eb3cB2cBD9aA96b36DC2461A94 Celo 0xBC2eBA680EE50d685cc4Fe65f102AA70AfB27D3F 0x49678AAB11E001eb3cB2cBD9aA96b36DC2461A94 Ethereum 0x53e8577C4347C365E4e0DA5B57A589cB6f2AB848 0x49678AAB11E001eb3cB2cBD9aA96b36DC2461A94 Harmony 0x8906f62d40293ddca77fdf6714c3f63265deddf0 0x49678AAB11E001eb3cB2cBD9aA96b36DC2461A94 Klaytn 0x80d8bac9a6901698b3749fe336bbd1385c1f98f2 0x49678AAB11E001eb3cB2cBD9aA96b36DC2461A94 Polygon 0x542b9ac4945a3836fd12ad98acbc76a0c8b743f5 0x49678AAB11E001eb3cB2cBD9aA96b36DC2461A94 *If a minter blockchain address on the testnet does not have sufficient funds to cover the transaction fee, add some amount to it using a crypto faucet of the blockchain. Minting NFTs natively on a blockchain When minting an NFT natively on a blockchain, you are charged a fee for the transaction, and you must sign the transaction with the private key of the blockchain address from which the fee will be deducted. Providing the private key in the API is not a secure way of signing transactions, because the private key can be stolen or exposed. Your private keys should never leave your security perimeter. You should use the private keys only for testing a solution you are building on the testnet of a blockchain. For signing transactions on the mainnet, we strongly recommend that you use the Tatum Key Management System (KMS) and provide the signature ID instead of the private key in the API. Alternatively, you can use the Tatum JavaScript client. You can mint NFTs natively on the following blockchains: Algorand BNB Smart Chain Celo Ethereum Flow Harmony Klaytn KuCoin Community Chain Polygon Solana TRON Depending on what blockchain you use, choose the request body schema to use in the API call. To mint NFTs natively on Algorand and: To sign the transaction with your private key, use this API with the MintNftAlgorand schema of the request body. To sign the transaction with your signature ID, use this API the MintNftAlgorandKMS schema of the request body. NOTE: To be able to burn the minted NFTs any time later, specify the address of the manager account in the manager parameter. An NFT minted on Algorand is automatically transferred to your blockchain address. After the NFT is minted, you have to transfer it to the recipient&#39;s address. The recipient has to agree in advance to receive your NFT because Algorand charges users for storing NFTs on their addresses, and an Algorand blockchain address by default does not receive NFTs unless explicitly agreed. For more information about how it works, see the section about minting NFTs on Algorand using the pre-built NFT smart contract provided by Tatum. To mint NFTs natively on BNB Smart Chain, Ethereum, Harmony, Klaytn, KuCoin Community Chain, or Polygon, and: To sign the transaction with your private key, use this API with the MintNft schema of the request body. To sign the transaction with your signature ID, use this API the MintNftKMS schema of the request body. To mint NFTs natively on Celo and: To sign the transaction with your private key, use this API with the MintNftCelo schema of the request body. To sign the transaction with your signature ID, use this API the MintNftKMSCelo schema of the request body. To mint NFTs natively on Flow and: To sign the transaction with your private key, use this API with the MintNftFlowPK schema of the request body. To sign the transaction with your signature ID, use this API the MintNftFlowMnemonic schema of the request body. To sign the transaction with your wallet mnemonic, use this API the MintNftFlowKMS schema of the request body. To mint NFTs natively on Solana and: To sign the transaction with your private key, use this API with the MintNftSolana schema of the request body. To sign the transaction with your signature ID, use this API the MintNftSolanaKMS schema of the request body. NOTE: When an NFT is minted on Solana, a new blockchain address is created to receive the NFT under the recipient&#39;s account address. After the NFT is minted, you have to transfer it to the recipient&#39;s address. For more information about how it works, see the section about minting NFTs on Solana using the pre-built NFT smart contract provided by Tatum. To mint NFTs natively on TRON and: To sign the transaction with your private key, use this API with the MintNftTron schema of the request body. To sign the transaction with your signature ID, use this API the MintNftKMSTron schema of the request body.
        /// </remarks>
        /// <exception cref="Tatum.CSharp.Bsc.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="mintNftMinter"></param>
        /// <param name="xTestnetType">Type of Ethereum testnet. Defaults to Sepolia. Valid only for ETH invocations for testnet API Key. For mainnet API Key, this value is ignored. (optional, default to ethereum-sepolia)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (TransactionHash)</returns>
        System.Threading.Tasks.Task<ApiResponse<TransactionHash>> NftMintErc721WithHttpInfoAsync(MintNftMinter mintNftMinter, string xTestnetType = default(string), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        /// <summary>
        /// Mint an NFT
        /// </summary>
        /// <remarks>
        /// 100 credits per API call on Flow 2 credits per API call on the other blockchains You can mint NFTs using either of the following methods: Using NFT Express Natively on a blockchain Minting NFTs using NFT Express NFT Express is Tatum&#39;s feature that helps you mint NFTs easier than minting natively on a blockchain. You do not need to enter your private key or signature ID. NFT Express uses the private key provided by Tatum. You do not need to hold crypto or keep addresses topped up with crypto to pay for minting transactions. To use NFT Express on the mainnet, you have to have a paid pricing plan. Tatum covers your transaction fees for NFT minting and pays for them from its own blockchain address. Then, the fee amount paid by Tatum is converted to the number of credits, and these credits are deducted from the monthly credit allowance of your paid pricing plan. The transaction fees and the corresponding numbers of credits deducted from your allowance vary depending on what blockchain you mint NFTs on. On the testnet, no credits are deducted from the monthly credit allowance. You can mint NFTs with NFT Express regardless of your pricing plan. With NFT Express, you can choose whether to mint NFTs on the pre-built NFT smart contract provided by Tatum or on your own smart contract. Use the pre-built smart contract provided by Tatum to mint NFTs If you want to mint NFTs using the pre-built smart contract, you do not need to deploy your own NFT smart contract. You do not need to provide the address of the NFT smart contract and the token ID in the request body either. The address of the smart contract and the token ID are provided automatically by Tatum. The token ID is autogenerated. It starts with 0 and is increased by 1 for each new NFT. The token ID is calculated separately for each supported blockchain and its mainnet and testnet. For more information, see our user documentation. You can mint NFTs on the pre-built smart contract provided by Tatum on the following blockchains: Algorand BNB Smart Chain Celo Ethereum Harmony Klaytn Polygon Solana Depending on what blockchain you use, choose the request body schema to use in the API call. To mint NFTs on BNB Smart Chain, Celo, Ethereum, Harmony, Klaytn, or Polygon, use this API with the MintNftExpress schema of the request body. To mint NFTs on Algorand, use this API with the MintNftExpressAlgorand schema of the request body. To be able to burn the minted NFTs any time later, specify the address of the manager account in the manager parameter. An NFT minted on Algorand is automatically transferred to your blockchain address. After the NFT is minted, you have to transfer it to the recipient&#39;s address. The recipient has to agree in advance to receive your NFT because Algorand charges users for storing NFTs on their addresses, and an Algorand blockchain address by default does not receive NFTs unless explicitly agreed. This how it works: The recipient agrees to receive the NFT to their address. You transfer the NFT to the recipient&#39;s address (use the transferNftAlgoExpress schema of the request body). NOTE: On the mainnet, Tatum covers your transaction fees for the NFT transfer and pays for them from its own blockchain address. Then, the fee amount paid by Tatum is converted to the number of credits, and these credits are deducted from the monthly credit allowance of your paid pricing plan. On the testnet, no credits are deducted from the monthly credit allowance. To mint NFTs on Solana, use this API with the MintNftExpressSolana schema of the request body. Solana uses the Metaplex Protocol, a smart contract and metadata standard for creating and working with NFTs. When you mint an NFT on Solana with NFT Express, the pre-built smart contract based on the Metaplex Protocol is used. When an NFT is minted on Solana, a new blockchain address is created to receive the NFT under the recipient&#39;s account address (the one in the to parameter of the request body). This address is returned in the nftAccountAddress parameter in the response body, is owned by the recipient&#39;s address, and has the same private key. The response body also returns the address of the minted NFT itself, which is held in the nftAddress parameter. After the NFT is minted, you have to transfer it to the recipient&#39;s address (use the transferNftSolana or transferNftSolanaKMS schema of the request body). In the request body of the transfer call: Set the from parameter to the address that you used in the to parameter in the request body of the minting call. Set the to parameter to the recipient&#39;s address. Set the contractAddress parameter to the address from the nftAddress parameter returned in the response body of the minting call. Set the fromPrivateKey/signatureId parameter to the private key/signature ID of the blockchain address that you specified in the from parameter. Use your own smart contract to mint NFTs If you want to mint NFTs using your own smart contract, you are going to use an NTF minter, a special blockchain address provided by Tatum that will cover the minting fees. The number of credits equivalent to the fees will be then deducted from the monthly credit allowance of your paid pricing plan. IMPORTANT! Your smart contract must be deployed as a general NFT smart contract. You cannot use cashback and provenance smart contracts with NFT Express. For more information, see our user documentation and the article in the Tatum blog. You can mint NFTs on your own smart contract on the following blockchains: BNB Smart Chain Celo Ethereum Harmony Klaytn Polygon To mint NFTs using your own smart contract, do the following: In the table located under this section, find the blockchain address of the Tatum NFT minter for your blockchain and network (mainnet or testnet). Add the minter address as an NFT minter to your smart contract. Use this API with the MintNftMinter schema of the request body. In the request body, enter the following information: chain is the blockchain that you use. to is the blockchain address where to send the minted NFT to. url is the URL of the NFT metadata. minter is the address of the NFT minter that you found in Step 1. contractAddress is the address of your NFT smart contract. tokenId is the the token ID of the NFT. For example:  {   \&quot;chain\&quot;: \&quot;CELO\&quot;,   \&quot;to\&quot;: \&quot;0x8ce4e40889a13971681391aad29e88efaf91f784\&quot;,   \&quot;url\&quot;: \&quot;ipfs://QmXJJ6UF5WkF4WTJvsdhiA1etGwBLfpva7Vr9AudGMe3pj\&quot;,   \&quot;contractAddress\&quot;: \&quot;0x687422eEA2cB73B5d3e242bA5456b782919AFc85\&quot;,   \&quot;tokenId\&quot;: \&quot;0123\&quot;,   \&quot;minter\&quot;: \&quot;0xBC2eBA680EE50d685cc4Fe65f102AA70AfB27D3F\&quot; } When you make an API call with this request body, the private key of the NFT minter will be added to the request body automatically:  {   \&quot;chain\&quot;: \&quot;CELO\&quot;,   \&quot;to\&quot;: \&quot;0x8ce4e40889a13971681391aad29e88efaf91f784\&quot;,   \&quot;url\&quot;: \&quot;ipfs://QmXJJ6UF5WkF4WTJvsdhiA1etGwBLfpva7Vr9AudGMe3pj\&quot;,   \&quot;contractAddress\&quot;: \&quot;0x687422eEA2cB73B5d3e242bA5456b782919AFc85\&quot;,   \&quot;tokenId\&quot;: \&quot;0123\&quot;,   \&quot;minter\&quot;: \&quot;0xBC2eBA680EE50d685cc4Fe65f102AA70AfB27D3F\&quot;,   \&quot;fromPrivateKey\&quot;: \&quot;0x05e150c73f1920ec14caa1e0b6aa09940899678051a78542840c2668ce5080c2\&quot; } The following table lists the blockchain addresses of the Tatum NFT minters for the testnet and mainnet of the supported blockchains: Blockchain Minter address - testnet* Minter address - mainnet BNB Smart Chain 0xc16ae5e8c985b906935a0cadf4e24f0400531883 0x49678AAB11E001eb3cB2cBD9aA96b36DC2461A94 Celo 0xBC2eBA680EE50d685cc4Fe65f102AA70AfB27D3F 0x49678AAB11E001eb3cB2cBD9aA96b36DC2461A94 Ethereum 0x53e8577C4347C365E4e0DA5B57A589cB6f2AB848 0x49678AAB11E001eb3cB2cBD9aA96b36DC2461A94 Harmony 0x8906f62d40293ddca77fdf6714c3f63265deddf0 0x49678AAB11E001eb3cB2cBD9aA96b36DC2461A94 Klaytn 0x80d8bac9a6901698b3749fe336bbd1385c1f98f2 0x49678AAB11E001eb3cB2cBD9aA96b36DC2461A94 Polygon 0x542b9ac4945a3836fd12ad98acbc76a0c8b743f5 0x49678AAB11E001eb3cB2cBD9aA96b36DC2461A94 *If a minter blockchain address on the testnet does not have sufficient funds to cover the transaction fee, add some amount to it using a crypto faucet of the blockchain. Minting NFTs natively on a blockchain When minting an NFT natively on a blockchain, you are charged a fee for the transaction, and you must sign the transaction with the private key of the blockchain address from which the fee will be deducted. Providing the private key in the API is not a secure way of signing transactions, because the private key can be stolen or exposed. Your private keys should never leave your security perimeter. You should use the private keys only for testing a solution you are building on the testnet of a blockchain. For signing transactions on the mainnet, we strongly recommend that you use the Tatum Key Management System (KMS) and provide the signature ID instead of the private key in the API. Alternatively, you can use the Tatum JavaScript client. You can mint NFTs natively on the following blockchains: Algorand BNB Smart Chain Celo Ethereum Flow Harmony Klaytn KuCoin Community Chain Polygon Solana TRON Depending on what blockchain you use, choose the request body schema to use in the API call. To mint NFTs natively on Algorand and: To sign the transaction with your private key, use this API with the MintNftAlgorand schema of the request body. To sign the transaction with your signature ID, use this API the MintNftAlgorandKMS schema of the request body. NOTE: To be able to burn the minted NFTs any time later, specify the address of the manager account in the manager parameter. An NFT minted on Algorand is automatically transferred to your blockchain address. After the NFT is minted, you have to transfer it to the recipient&#39;s address. The recipient has to agree in advance to receive your NFT because Algorand charges users for storing NFTs on their addresses, and an Algorand blockchain address by default does not receive NFTs unless explicitly agreed. For more information about how it works, see the section about minting NFTs on Algorand using the pre-built NFT smart contract provided by Tatum. To mint NFTs natively on BNB Smart Chain, Ethereum, Harmony, Klaytn, KuCoin Community Chain, or Polygon, and: To sign the transaction with your private key, use this API with the MintNft schema of the request body. To sign the transaction with your signature ID, use this API the MintNftKMS schema of the request body. To mint NFTs natively on Celo and: To sign the transaction with your private key, use this API with the MintNftCelo schema of the request body. To sign the transaction with your signature ID, use this API the MintNftKMSCelo schema of the request body. To mint NFTs natively on Flow and: To sign the transaction with your private key, use this API with the MintNftFlowPK schema of the request body. To sign the transaction with your signature ID, use this API the MintNftFlowMnemonic schema of the request body. To sign the transaction with your wallet mnemonic, use this API the MintNftFlowKMS schema of the request body. To mint NFTs natively on Solana and: To sign the transaction with your private key, use this API with the MintNftSolana schema of the request body. To sign the transaction with your signature ID, use this API the MintNftSolanaKMS schema of the request body. NOTE: When an NFT is minted on Solana, a new blockchain address is created to receive the NFT under the recipient&#39;s account address. After the NFT is minted, you have to transfer it to the recipient&#39;s address. For more information about how it works, see the section about minting NFTs on Solana using the pre-built NFT smart contract provided by Tatum. To mint NFTs natively on TRON and: To sign the transaction with your private key, use this API with the MintNftTron schema of the request body. To sign the transaction with your signature ID, use this API the MintNftKMSTron schema of the request body.
        /// </remarks>
        /// <exception cref="Tatum.CSharp.Bsc.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="mintNft"></param>
        /// <param name="xTestnetType">Type of Ethereum testnet. Defaults to Sepolia. Valid only for ETH invocations for testnet API Key. For mainnet API Key, this value is ignored. (optional, default to ethereum-sepolia)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (TransactionHash)</returns>
        System.Threading.Tasks.Task<ApiResponse<TransactionHash>> NftMintErc721WithHttpInfoAsync(MintNft mintNft, string xTestnetType = default(string), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        /// <summary>
        /// Mint an NFT
        /// </summary>
        /// <remarks>
        /// 100 credits per API call on Flow 2 credits per API call on the other blockchains You can mint NFTs using either of the following methods: Using NFT Express Natively on a blockchain Minting NFTs using NFT Express NFT Express is Tatum&#39;s feature that helps you mint NFTs easier than minting natively on a blockchain. You do not need to enter your private key or signature ID. NFT Express uses the private key provided by Tatum. You do not need to hold crypto or keep addresses topped up with crypto to pay for minting transactions. To use NFT Express on the mainnet, you have to have a paid pricing plan. Tatum covers your transaction fees for NFT minting and pays for them from its own blockchain address. Then, the fee amount paid by Tatum is converted to the number of credits, and these credits are deducted from the monthly credit allowance of your paid pricing plan. The transaction fees and the corresponding numbers of credits deducted from your allowance vary depending on what blockchain you mint NFTs on. On the testnet, no credits are deducted from the monthly credit allowance. You can mint NFTs with NFT Express regardless of your pricing plan. With NFT Express, you can choose whether to mint NFTs on the pre-built NFT smart contract provided by Tatum or on your own smart contract. Use the pre-built smart contract provided by Tatum to mint NFTs If you want to mint NFTs using the pre-built smart contract, you do not need to deploy your own NFT smart contract. You do not need to provide the address of the NFT smart contract and the token ID in the request body either. The address of the smart contract and the token ID are provided automatically by Tatum. The token ID is autogenerated. It starts with 0 and is increased by 1 for each new NFT. The token ID is calculated separately for each supported blockchain and its mainnet and testnet. For more information, see our user documentation. You can mint NFTs on the pre-built smart contract provided by Tatum on the following blockchains: Algorand BNB Smart Chain Celo Ethereum Harmony Klaytn Polygon Solana Depending on what blockchain you use, choose the request body schema to use in the API call. To mint NFTs on BNB Smart Chain, Celo, Ethereum, Harmony, Klaytn, or Polygon, use this API with the MintNftExpress schema of the request body. To mint NFTs on Algorand, use this API with the MintNftExpressAlgorand schema of the request body. To be able to burn the minted NFTs any time later, specify the address of the manager account in the manager parameter. An NFT minted on Algorand is automatically transferred to your blockchain address. After the NFT is minted, you have to transfer it to the recipient&#39;s address. The recipient has to agree in advance to receive your NFT because Algorand charges users for storing NFTs on their addresses, and an Algorand blockchain address by default does not receive NFTs unless explicitly agreed. This how it works: The recipient agrees to receive the NFT to their address. You transfer the NFT to the recipient&#39;s address (use the transferNftAlgoExpress schema of the request body). NOTE: On the mainnet, Tatum covers your transaction fees for the NFT transfer and pays for them from its own blockchain address. Then, the fee amount paid by Tatum is converted to the number of credits, and these credits are deducted from the monthly credit allowance of your paid pricing plan. On the testnet, no credits are deducted from the monthly credit allowance. To mint NFTs on Solana, use this API with the MintNftExpressSolana schema of the request body. Solana uses the Metaplex Protocol, a smart contract and metadata standard for creating and working with NFTs. When you mint an NFT on Solana with NFT Express, the pre-built smart contract based on the Metaplex Protocol is used. When an NFT is minted on Solana, a new blockchain address is created to receive the NFT under the recipient&#39;s account address (the one in the to parameter of the request body). This address is returned in the nftAccountAddress parameter in the response body, is owned by the recipient&#39;s address, and has the same private key. The response body also returns the address of the minted NFT itself, which is held in the nftAddress parameter. After the NFT is minted, you have to transfer it to the recipient&#39;s address (use the transferNftSolana or transferNftSolanaKMS schema of the request body). In the request body of the transfer call: Set the from parameter to the address that you used in the to parameter in the request body of the minting call. Set the to parameter to the recipient&#39;s address. Set the contractAddress parameter to the address from the nftAddress parameter returned in the response body of the minting call. Set the fromPrivateKey/signatureId parameter to the private key/signature ID of the blockchain address that you specified in the from parameter. Use your own smart contract to mint NFTs If you want to mint NFTs using your own smart contract, you are going to use an NTF minter, a special blockchain address provided by Tatum that will cover the minting fees. The number of credits equivalent to the fees will be then deducted from the monthly credit allowance of your paid pricing plan. IMPORTANT! Your smart contract must be deployed as a general NFT smart contract. You cannot use cashback and provenance smart contracts with NFT Express. For more information, see our user documentation and the article in the Tatum blog. You can mint NFTs on your own smart contract on the following blockchains: BNB Smart Chain Celo Ethereum Harmony Klaytn Polygon To mint NFTs using your own smart contract, do the following: In the table located under this section, find the blockchain address of the Tatum NFT minter for your blockchain and network (mainnet or testnet). Add the minter address as an NFT minter to your smart contract. Use this API with the MintNftMinter schema of the request body. In the request body, enter the following information: chain is the blockchain that you use. to is the blockchain address where to send the minted NFT to. url is the URL of the NFT metadata. minter is the address of the NFT minter that you found in Step 1. contractAddress is the address of your NFT smart contract. tokenId is the the token ID of the NFT. For example:  {   \&quot;chain\&quot;: \&quot;CELO\&quot;,   \&quot;to\&quot;: \&quot;0x8ce4e40889a13971681391aad29e88efaf91f784\&quot;,   \&quot;url\&quot;: \&quot;ipfs://QmXJJ6UF5WkF4WTJvsdhiA1etGwBLfpva7Vr9AudGMe3pj\&quot;,   \&quot;contractAddress\&quot;: \&quot;0x687422eEA2cB73B5d3e242bA5456b782919AFc85\&quot;,   \&quot;tokenId\&quot;: \&quot;0123\&quot;,   \&quot;minter\&quot;: \&quot;0xBC2eBA680EE50d685cc4Fe65f102AA70AfB27D3F\&quot; } When you make an API call with this request body, the private key of the NFT minter will be added to the request body automatically:  {   \&quot;chain\&quot;: \&quot;CELO\&quot;,   \&quot;to\&quot;: \&quot;0x8ce4e40889a13971681391aad29e88efaf91f784\&quot;,   \&quot;url\&quot;: \&quot;ipfs://QmXJJ6UF5WkF4WTJvsdhiA1etGwBLfpva7Vr9AudGMe3pj\&quot;,   \&quot;contractAddress\&quot;: \&quot;0x687422eEA2cB73B5d3e242bA5456b782919AFc85\&quot;,   \&quot;tokenId\&quot;: \&quot;0123\&quot;,   \&quot;minter\&quot;: \&quot;0xBC2eBA680EE50d685cc4Fe65f102AA70AfB27D3F\&quot;,   \&quot;fromPrivateKey\&quot;: \&quot;0x05e150c73f1920ec14caa1e0b6aa09940899678051a78542840c2668ce5080c2\&quot; } The following table lists the blockchain addresses of the Tatum NFT minters for the testnet and mainnet of the supported blockchains: Blockchain Minter address - testnet* Minter address - mainnet BNB Smart Chain 0xc16ae5e8c985b906935a0cadf4e24f0400531883 0x49678AAB11E001eb3cB2cBD9aA96b36DC2461A94 Celo 0xBC2eBA680EE50d685cc4Fe65f102AA70AfB27D3F 0x49678AAB11E001eb3cB2cBD9aA96b36DC2461A94 Ethereum 0x53e8577C4347C365E4e0DA5B57A589cB6f2AB848 0x49678AAB11E001eb3cB2cBD9aA96b36DC2461A94 Harmony 0x8906f62d40293ddca77fdf6714c3f63265deddf0 0x49678AAB11E001eb3cB2cBD9aA96b36DC2461A94 Klaytn 0x80d8bac9a6901698b3749fe336bbd1385c1f98f2 0x49678AAB11E001eb3cB2cBD9aA96b36DC2461A94 Polygon 0x542b9ac4945a3836fd12ad98acbc76a0c8b743f5 0x49678AAB11E001eb3cB2cBD9aA96b36DC2461A94 *If a minter blockchain address on the testnet does not have sufficient funds to cover the transaction fee, add some amount to it using a crypto faucet of the blockchain. Minting NFTs natively on a blockchain When minting an NFT natively on a blockchain, you are charged a fee for the transaction, and you must sign the transaction with the private key of the blockchain address from which the fee will be deducted. Providing the private key in the API is not a secure way of signing transactions, because the private key can be stolen or exposed. Your private keys should never leave your security perimeter. You should use the private keys only for testing a solution you are building on the testnet of a blockchain. For signing transactions on the mainnet, we strongly recommend that you use the Tatum Key Management System (KMS) and provide the signature ID instead of the private key in the API. Alternatively, you can use the Tatum JavaScript client. You can mint NFTs natively on the following blockchains: Algorand BNB Smart Chain Celo Ethereum Flow Harmony Klaytn KuCoin Community Chain Polygon Solana TRON Depending on what blockchain you use, choose the request body schema to use in the API call. To mint NFTs natively on Algorand and: To sign the transaction with your private key, use this API with the MintNftAlgorand schema of the request body. To sign the transaction with your signature ID, use this API the MintNftAlgorandKMS schema of the request body. NOTE: To be able to burn the minted NFTs any time later, specify the address of the manager account in the manager parameter. An NFT minted on Algorand is automatically transferred to your blockchain address. After the NFT is minted, you have to transfer it to the recipient&#39;s address. The recipient has to agree in advance to receive your NFT because Algorand charges users for storing NFTs on their addresses, and an Algorand blockchain address by default does not receive NFTs unless explicitly agreed. For more information about how it works, see the section about minting NFTs on Algorand using the pre-built NFT smart contract provided by Tatum. To mint NFTs natively on BNB Smart Chain, Ethereum, Harmony, Klaytn, KuCoin Community Chain, or Polygon, and: To sign the transaction with your private key, use this API with the MintNft schema of the request body. To sign the transaction with your signature ID, use this API the MintNftKMS schema of the request body. To mint NFTs natively on Celo and: To sign the transaction with your private key, use this API with the MintNftCelo schema of the request body. To sign the transaction with your signature ID, use this API the MintNftKMSCelo schema of the request body. To mint NFTs natively on Flow and: To sign the transaction with your private key, use this API with the MintNftFlowPK schema of the request body. To sign the transaction with your signature ID, use this API the MintNftFlowMnemonic schema of the request body. To sign the transaction with your wallet mnemonic, use this API the MintNftFlowKMS schema of the request body. To mint NFTs natively on Solana and: To sign the transaction with your private key, use this API with the MintNftSolana schema of the request body. To sign the transaction with your signature ID, use this API the MintNftSolanaKMS schema of the request body. NOTE: When an NFT is minted on Solana, a new blockchain address is created to receive the NFT under the recipient&#39;s account address. After the NFT is minted, you have to transfer it to the recipient&#39;s address. For more information about how it works, see the section about minting NFTs on Solana using the pre-built NFT smart contract provided by Tatum. To mint NFTs natively on TRON and: To sign the transaction with your private key, use this API with the MintNftTron schema of the request body. To sign the transaction with your signature ID, use this API the MintNftKMSTron schema of the request body.
        /// </remarks>
        /// <exception cref="Tatum.CSharp.Bsc.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="mintNftKMS"></param>
        /// <param name="xTestnetType">Type of Ethereum testnet. Defaults to Sepolia. Valid only for ETH invocations for testnet API Key. For mainnet API Key, this value is ignored. (optional, default to ethereum-sepolia)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (SignatureId)</returns>
        System.Threading.Tasks.Task<ApiResponse<SignatureId>> NftMintErc721WithHttpInfoAsync(MintNftKMS mintNftKMS, string xTestnetType = default(string), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        /// <summary>
        /// Mint multiple NFTs
        /// </summary>
        /// <remarks>
        /// 100 credits per API call on Flow 2 credits per API call on the other blockchains Create multiple NFT Tokens and transfer them to destination account. Create and transfer any NFT tokens from smart contract defined in contractAddress. This API is supported for the following blockchains: BNB Smart Chain Celo Ethereum Flow Harmony Klaytn KuCoin Community Chain Polygon TRON This operation works in two modes. First mode works just like other NFT endpoints. Every time the funds are transferred, the transaction must be signed with the corresponding private key. No one should ever send it&#39;s own private keys to the internet because there is a strong possibility of stealing keys and loss of funds. In this method, it is possible to enter privateKey or signatureId. PrivateKey should be used only for quick development on testnet versions of blockchain when there is no risk of losing funds. In production, Tatum KMS should be used for the highest security standards, and signatureId should be present in the request. Alternatively, using the Tatum client library for supported languages. Second mode enables you to mint on any custom NFT ERC-721 smart contract, on which specified minter address is approved as a minter. You don&#39;t specify private key or signatureId, only minter address, from which the NFT will be minted. It means you perform mint multiple NFT request with following body: {    \&quot;to\&quot;: [\&quot;0x80d8bac9a6901698b3749fe336bbd1385c1f98f2\&quot;],    \&quot;url\&quot;: [\&quot;ipfs://QmXJJ6UF5WkF4WTJvsdhiA1etGwBLfpva7Vr9AudGMe3pj\&quot;],    \&quot;tokenId\&quot;: [\&quot;9876541124516\&quot;],    \&quot;contractAddress\&quot;:\&quot;0xcd2ada00c48a27faa5cc67f9a1ed55b89ddf7f77\&quot;,    \&quot;minter\&quot;: \&quot;0x542b9ac4945a3836fd12ad98acbc76a0c8b743f5\&quot;,    \&quot;chain\&quot;: \&quot;MATIC\&quot; } The blockchain fee of the performed transaction is paid from the address connected with built-in private key and is debited in form of credits. The credits are debited only if NFT mint requests are performed with paid API key plan. We transform fee to the credits in accordance to the rates provided by the Tatum. If you want to batch mint on ERC-721 contract which is not deployed via Tatum API, your smart contract must contain this method: mintMultiple(address[] to, uint256[] tokenId, string[] uri): boolean You can use addresses specified in the bellow table to be used as a minter. Chain Testnet address Mainnet Address MATIC 0x542b9ac4945a3836fd12ad98acbc76a0c8b743f5 0xcf9e127455d28e7362380aec1b92ddee8200b295 BSC 0xc16ae5e8c985b906935a0cadf4e24f0400531883 0xcf9e127455d28e7362380aec1b92ddee8200b295 ONE 0x8906f62d40293ddca77fdf6714c3f63265deddf0 0xcf9e127455d28e7362380aec1b92ddee8200b295 ETH 0x53e8577C4347C365E4e0DA5B57A589cB6f2AB848 0xcf9e127455d28e7362380aec1b92ddee8200b295 CELO 0xBC2eBA680EE50d685cc4Fe65f102AA70AfB27D3F 0xcf9e127455d28e7362380aec1b92ddee8200b295 KLAY 0x80d8bac9a6901698b3749fe336bbd1385c1f98f2 0xcf9e127455d28e7362380aec1b92ddee8200b295 If there are not enough coins on any testnet address, feel free to send coins there.
        /// </remarks>
        /// <exception cref="Tatum.CSharp.Bsc.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="mintMultipleNftMinter"></param>
        /// <param name="xTestnetType">Type of Ethereum testnet. Defaults to Sepolia. Valid only for ETH invocations for testnet API Key. For mainnet API Key, this value is ignored. (optional, default to ethereum-sepolia)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (TransactionHash)</returns>
        System.Threading.Tasks.Task<ApiResponse<TransactionHash>> NftMintMultipleErc721WithHttpInfoAsync(MintMultipleNftMinter mintMultipleNftMinter, string xTestnetType = default(string), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        /// <summary>
        /// Mint multiple NFTs
        /// </summary>
        /// <remarks>
        /// 100 credits per API call on Flow 2 credits per API call on the other blockchains Create multiple NFT Tokens and transfer them to destination account. Create and transfer any NFT tokens from smart contract defined in contractAddress. This API is supported for the following blockchains: BNB Smart Chain Celo Ethereum Flow Harmony Klaytn KuCoin Community Chain Polygon TRON This operation works in two modes. First mode works just like other NFT endpoints. Every time the funds are transferred, the transaction must be signed with the corresponding private key. No one should ever send it&#39;s own private keys to the internet because there is a strong possibility of stealing keys and loss of funds. In this method, it is possible to enter privateKey or signatureId. PrivateKey should be used only for quick development on testnet versions of blockchain when there is no risk of losing funds. In production, Tatum KMS should be used for the highest security standards, and signatureId should be present in the request. Alternatively, using the Tatum client library for supported languages. Second mode enables you to mint on any custom NFT ERC-721 smart contract, on which specified minter address is approved as a minter. You don&#39;t specify private key or signatureId, only minter address, from which the NFT will be minted. It means you perform mint multiple NFT request with following body: {    \&quot;to\&quot;: [\&quot;0x80d8bac9a6901698b3749fe336bbd1385c1f98f2\&quot;],    \&quot;url\&quot;: [\&quot;ipfs://QmXJJ6UF5WkF4WTJvsdhiA1etGwBLfpva7Vr9AudGMe3pj\&quot;],    \&quot;tokenId\&quot;: [\&quot;9876541124516\&quot;],    \&quot;contractAddress\&quot;:\&quot;0xcd2ada00c48a27faa5cc67f9a1ed55b89ddf7f77\&quot;,    \&quot;minter\&quot;: \&quot;0x542b9ac4945a3836fd12ad98acbc76a0c8b743f5\&quot;,    \&quot;chain\&quot;: \&quot;MATIC\&quot; } The blockchain fee of the performed transaction is paid from the address connected with built-in private key and is debited in form of credits. The credits are debited only if NFT mint requests are performed with paid API key plan. We transform fee to the credits in accordance to the rates provided by the Tatum. If you want to batch mint on ERC-721 contract which is not deployed via Tatum API, your smart contract must contain this method: mintMultiple(address[] to, uint256[] tokenId, string[] uri): boolean You can use addresses specified in the bellow table to be used as a minter. Chain Testnet address Mainnet Address MATIC 0x542b9ac4945a3836fd12ad98acbc76a0c8b743f5 0xcf9e127455d28e7362380aec1b92ddee8200b295 BSC 0xc16ae5e8c985b906935a0cadf4e24f0400531883 0xcf9e127455d28e7362380aec1b92ddee8200b295 ONE 0x8906f62d40293ddca77fdf6714c3f63265deddf0 0xcf9e127455d28e7362380aec1b92ddee8200b295 ETH 0x53e8577C4347C365E4e0DA5B57A589cB6f2AB848 0xcf9e127455d28e7362380aec1b92ddee8200b295 CELO 0xBC2eBA680EE50d685cc4Fe65f102AA70AfB27D3F 0xcf9e127455d28e7362380aec1b92ddee8200b295 KLAY 0x80d8bac9a6901698b3749fe336bbd1385c1f98f2 0xcf9e127455d28e7362380aec1b92ddee8200b295 If there are not enough coins on any testnet address, feel free to send coins there.
        /// </remarks>
        /// <exception cref="Tatum.CSharp.Bsc.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="mintMultipleNft"></param>
        /// <param name="xTestnetType">Type of Ethereum testnet. Defaults to Sepolia. Valid only for ETH invocations for testnet API Key. For mainnet API Key, this value is ignored. (optional, default to ethereum-sepolia)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (TransactionHash)</returns>
        System.Threading.Tasks.Task<ApiResponse<TransactionHash>> NftMintMultipleErc721WithHttpInfoAsync(MintMultipleNft mintMultipleNft, string xTestnetType = default(string), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        /// <summary>
        /// Mint multiple NFTs
        /// </summary>
        /// <remarks>
        /// 100 credits per API call on Flow 2 credits per API call on the other blockchains Create multiple NFT Tokens and transfer them to destination account. Create and transfer any NFT tokens from smart contract defined in contractAddress. This API is supported for the following blockchains: BNB Smart Chain Celo Ethereum Flow Harmony Klaytn KuCoin Community Chain Polygon TRON This operation works in two modes. First mode works just like other NFT endpoints. Every time the funds are transferred, the transaction must be signed with the corresponding private key. No one should ever send it&#39;s own private keys to the internet because there is a strong possibility of stealing keys and loss of funds. In this method, it is possible to enter privateKey or signatureId. PrivateKey should be used only for quick development on testnet versions of blockchain when there is no risk of losing funds. In production, Tatum KMS should be used for the highest security standards, and signatureId should be present in the request. Alternatively, using the Tatum client library for supported languages. Second mode enables you to mint on any custom NFT ERC-721 smart contract, on which specified minter address is approved as a minter. You don&#39;t specify private key or signatureId, only minter address, from which the NFT will be minted. It means you perform mint multiple NFT request with following body: {    \&quot;to\&quot;: [\&quot;0x80d8bac9a6901698b3749fe336bbd1385c1f98f2\&quot;],    \&quot;url\&quot;: [\&quot;ipfs://QmXJJ6UF5WkF4WTJvsdhiA1etGwBLfpva7Vr9AudGMe3pj\&quot;],    \&quot;tokenId\&quot;: [\&quot;9876541124516\&quot;],    \&quot;contractAddress\&quot;:\&quot;0xcd2ada00c48a27faa5cc67f9a1ed55b89ddf7f77\&quot;,    \&quot;minter\&quot;: \&quot;0x542b9ac4945a3836fd12ad98acbc76a0c8b743f5\&quot;,    \&quot;chain\&quot;: \&quot;MATIC\&quot; } The blockchain fee of the performed transaction is paid from the address connected with built-in private key and is debited in form of credits. The credits are debited only if NFT mint requests are performed with paid API key plan. We transform fee to the credits in accordance to the rates provided by the Tatum. If you want to batch mint on ERC-721 contract which is not deployed via Tatum API, your smart contract must contain this method: mintMultiple(address[] to, uint256[] tokenId, string[] uri): boolean You can use addresses specified in the bellow table to be used as a minter. Chain Testnet address Mainnet Address MATIC 0x542b9ac4945a3836fd12ad98acbc76a0c8b743f5 0xcf9e127455d28e7362380aec1b92ddee8200b295 BSC 0xc16ae5e8c985b906935a0cadf4e24f0400531883 0xcf9e127455d28e7362380aec1b92ddee8200b295 ONE 0x8906f62d40293ddca77fdf6714c3f63265deddf0 0xcf9e127455d28e7362380aec1b92ddee8200b295 ETH 0x53e8577C4347C365E4e0DA5B57A589cB6f2AB848 0xcf9e127455d28e7362380aec1b92ddee8200b295 CELO 0xBC2eBA680EE50d685cc4Fe65f102AA70AfB27D3F 0xcf9e127455d28e7362380aec1b92ddee8200b295 KLAY 0x80d8bac9a6901698b3749fe336bbd1385c1f98f2 0xcf9e127455d28e7362380aec1b92ddee8200b295 If there are not enough coins on any testnet address, feel free to send coins there.
        /// </remarks>
        /// <exception cref="Tatum.CSharp.Bsc.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="mintMultipleNftKMS"></param>
        /// <param name="xTestnetType">Type of Ethereum testnet. Defaults to Sepolia. Valid only for ETH invocations for testnet API Key. For mainnet API Key, this value is ignored. (optional, default to ethereum-sepolia)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (SignatureId)</returns>
        System.Threading.Tasks.Task<ApiResponse<SignatureId>> NftMintMultipleErc721WithHttpInfoAsync(MintMultipleNftKMS mintMultipleNftKMS, string xTestnetType = default(string), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        /// <summary>
        /// Transfer an NFT
        /// </summary>
        /// <remarks>
        /// 100 credits per API call on Flow 2 credits per API call on the other blockchains Transfer an NFT from the smart contract (the contractAddress parameter in the request body) to the specified blockchain address (the to parameter in the request body). In one API call, you can transfer only one NFT. This API is supported for the following blockchains: Algorand BNB Smart Chain Celo Ethereum Flow Harmony Klaytn KuCoin Community Chain Polygon Solana TRON For Ethereum, Celo, and BNB Smart Chain, transferring NFTs invokes the safeTransfer() method. Transferring NFTs on Algorand On Algorand, the recipient has to agree in advance to receive your NFT because Algorand charges users for storing NFTs on their addresses, and an Algorand blockchain address by default does not receive NFTs unless explicitly agreed. Before transferring an NFT, make sure that the recipient has agreed to receive the NFT to their address. If you want to transfer an NFT that was minted using NFT Express, use the transferNftAlgoExpress schema of the request body. NOTE: On the mainnet, Tatum covers your transaction fees for the NFT transfer and pays for them from its own blockchain address. Then, the fee amount paid by Tatum is converted to the number of credits, and these credits are deducted from the monthly credit allowance of your paid pricing plan. On the testnet, no credits are deducted from the monthly credit allowance. Transferring NFTs on Solana If you want to transfer an NFT that was minted using NFT Express, see the section about minting NFTs on Solana using the pre-built NFT smart contract provided by Tatum for the information about how to set up the parameters in the request body. Signing a transaction When transferring an NFT, you are charged a fee for the transaction, and you must sign the transaction with the private key of the blockchain address from which the fee will be deducted. Providing the private key in the API is not a secure way of signing transactions, because the private key can be stolen or exposed. Your private keys should never leave your security perimeter. You should use the private keys only for testing a solution you are building on the testnet of a blockchain. For signing transactions on the mainnet, we strongly recommend that you use the Tatum Key Management System (KMS) and provide the signature ID instead of the private key in the API. Alternatively, you can use the Tatum JavaScript client. NOTE: This does not apply to transferring NFTs that were minted on Algorand using NFT Express (see earlier in this section).
        /// </remarks>
        /// <exception cref="Tatum.CSharp.Bsc.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="transferNft"></param>
        /// <param name="xTestnetType">Type of Ethereum testnet. Defaults to Sepolia. Valid only for ETH invocations for testnet API Key. For mainnet API Key, this value is ignored. (optional, default to ethereum-sepolia)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (TransactionHash)</returns>
        System.Threading.Tasks.Task<ApiResponse<TransactionHash>> NftTransferErc721WithHttpInfoAsync(TransferNft transferNft, string xTestnetType = default(string), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        /// <summary>
        /// Transfer an NFT
        /// </summary>
        /// <remarks>
        /// 100 credits per API call on Flow 2 credits per API call on the other blockchains Transfer an NFT from the smart contract (the contractAddress parameter in the request body) to the specified blockchain address (the to parameter in the request body). In one API call, you can transfer only one NFT. This API is supported for the following blockchains: Algorand BNB Smart Chain Celo Ethereum Flow Harmony Klaytn KuCoin Community Chain Polygon Solana TRON For Ethereum, Celo, and BNB Smart Chain, transferring NFTs invokes the safeTransfer() method. Transferring NFTs on Algorand On Algorand, the recipient has to agree in advance to receive your NFT because Algorand charges users for storing NFTs on their addresses, and an Algorand blockchain address by default does not receive NFTs unless explicitly agreed. Before transferring an NFT, make sure that the recipient has agreed to receive the NFT to their address. If you want to transfer an NFT that was minted using NFT Express, use the transferNftAlgoExpress schema of the request body. NOTE: On the mainnet, Tatum covers your transaction fees for the NFT transfer and pays for them from its own blockchain address. Then, the fee amount paid by Tatum is converted to the number of credits, and these credits are deducted from the monthly credit allowance of your paid pricing plan. On the testnet, no credits are deducted from the monthly credit allowance. Transferring NFTs on Solana If you want to transfer an NFT that was minted using NFT Express, see the section about minting NFTs on Solana using the pre-built NFT smart contract provided by Tatum for the information about how to set up the parameters in the request body. Signing a transaction When transferring an NFT, you are charged a fee for the transaction, and you must sign the transaction with the private key of the blockchain address from which the fee will be deducted. Providing the private key in the API is not a secure way of signing transactions, because the private key can be stolen or exposed. Your private keys should never leave your security perimeter. You should use the private keys only for testing a solution you are building on the testnet of a blockchain. For signing transactions on the mainnet, we strongly recommend that you use the Tatum Key Management System (KMS) and provide the signature ID instead of the private key in the API. Alternatively, you can use the Tatum JavaScript client. NOTE: This does not apply to transferring NFTs that were minted on Algorand using NFT Express (see earlier in this section).
        /// </remarks>
        /// <exception cref="Tatum.CSharp.Bsc.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="transferNftKMS"></param>
        /// <param name="xTestnetType">Type of Ethereum testnet. Defaults to Sepolia. Valid only for ETH invocations for testnet API Key. For mainnet API Key, this value is ignored. (optional, default to ethereum-sepolia)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (SignatureId)</returns>
        System.Threading.Tasks.Task<ApiResponse<SignatureId>> NftTransferErc721WithHttpInfoAsync(TransferNftKMS transferNftKMS, string xTestnetType = default(string), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        /// <summary>
        /// Update NFT royalty information
        /// </summary>
        /// <remarks>
        /// 2 credits per API call Update the value of the royalty cashback set for an NFT. The royalty cashback value can be updated only from the address of the NFT author (the address that is listed as a royalty cashback receiver in the NFT royalty information). The royalty cashback value cannot be updated from the address of the NFT owner. In one API call, you can update the first value of the royalty cashback for the NFT author for one NFT. To disable the royalties for the NFT completely, set it to 0. This API is supported for the following blockchains: BNB Smart Chain Celo Ethereum Harmony Klaytn KuCoin Community Chain Polygon TRON Signing a transaction When updating NFT royalty, you are charged a fee for the transaction, and you must sign the transaction with the private key of the blockchain address from which the fee will be deducted. Providing the private key in the API is not a secure way of signing transactions, because the private key can be stolen or exposed. Your private keys should never leave your security perimeter. You should use the private keys only for testing a solution you are building on the testnet of a blockchain. For signing transactions on the mainnet, we strongly recommend that you use the Tatum Key Management System (KMS) and provide the signature ID instead of the private key in the API. Alternatively, you can use the Tatum JavaScript client.
        /// </remarks>
        /// <exception cref="Tatum.CSharp.Bsc.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="updateCashbackValueForAuthorNft"></param>
        /// <param name="xTestnetType">Type of Ethereum testnet. Defaults to Sepolia. Valid only for ETH invocations for testnet API Key. For mainnet API Key, this value is ignored. (optional, default to ethereum-sepolia)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (TransactionHash)</returns>
        System.Threading.Tasks.Task<ApiResponse<TransactionHash>> NftUpdateCashbackErc721WithHttpInfoAsync(UpdateCashbackValueForAuthorNft updateCashbackValueForAuthorNft, string xTestnetType = default(string), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        /// <summary>
        /// Update NFT royalty information
        /// </summary>
        /// <remarks>
        /// 2 credits per API call Update the value of the royalty cashback set for an NFT. The royalty cashback value can be updated only from the address of the NFT author (the address that is listed as a royalty cashback receiver in the NFT royalty information). The royalty cashback value cannot be updated from the address of the NFT owner. In one API call, you can update the first value of the royalty cashback for the NFT author for one NFT. To disable the royalties for the NFT completely, set it to 0. This API is supported for the following blockchains: BNB Smart Chain Celo Ethereum Harmony Klaytn KuCoin Community Chain Polygon TRON Signing a transaction When updating NFT royalty, you are charged a fee for the transaction, and you must sign the transaction with the private key of the blockchain address from which the fee will be deducted. Providing the private key in the API is not a secure way of signing transactions, because the private key can be stolen or exposed. Your private keys should never leave your security perimeter. You should use the private keys only for testing a solution you are building on the testnet of a blockchain. For signing transactions on the mainnet, we strongly recommend that you use the Tatum Key Management System (KMS) and provide the signature ID instead of the private key in the API. Alternatively, you can use the Tatum JavaScript client.
        /// </remarks>
        /// <exception cref="Tatum.CSharp.Bsc.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="updateCashbackValueForAuthorNftKMS"></param>
        /// <param name="xTestnetType">Type of Ethereum testnet. Defaults to Sepolia. Valid only for ETH invocations for testnet API Key. For mainnet API Key, this value is ignored. (optional, default to ethereum-sepolia)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (SignatureId)</returns>
        System.Threading.Tasks.Task<ApiResponse<SignatureId>> NftUpdateCashbackErc721WithHttpInfoAsync(UpdateCashbackValueForAuthorNftKMS updateCashbackValueForAuthorNftKMS, string xTestnetType = default(string), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        #endregion Asynchronous Operations With Http Info
    }


    /// <summary>
    /// Represents a collection of functions to interact with the API endpoints
    /// </summary>
    public interface INFTBscApi : INFTBscApiSync, INFTBscApiWithHttpInfoSync, INFTBscApiAsync, INFTBscApiWithHttpInfoAsync
    {

    }

    /// <summary>
    /// Represents a collection of functions to interact with the API endpoints
    /// </summary>
    public partial class NFTBscApi : INFTBscApi
    {
        private ExceptionFactory _exceptionFactory = (name, response) => null;

        /// <summary>
        /// Initializes a new instance of the <see cref="NFTBscApi"/> class.
        /// </summary>
        /// <param name="client">An instance of HttpClient.</param>
        /// <param name="handler">An optional instance of HttpClientHandler that is used by HttpClient.</param>
        /// <exception cref="ArgumentNullException"></exception>
        /// <returns></returns>
        /// <remarks>
        /// Some configuration settings will not be applied without passing an HttpClientHandler.
        /// The features affected are: Setting and Retrieving Cookies, Client Certificates, Proxy settings.
        /// </remarks>
        public NFTBscApi(HttpClient client, HttpClientHandler handler = null) : this(client, (string)null, handler)
        {
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="NFTBscApi"/> class.
        /// </summary>
        /// <param name="client">An instance of HttpClient.</param>
        /// <param name="basePath">The target service's base path in URL format.</param>
        /// <param name="handler">An optional instance of HttpClientHandler that is used by HttpClient.</param>
        /// <exception cref="ArgumentNullException"></exception>
        /// <exception cref="ArgumentException"></exception>
        /// <returns></returns>
        /// <remarks>
        /// Some configuration settings will not be applied without passing an HttpClientHandler.
        /// The features affected are: Setting and Retrieving Cookies, Client Certificates, Proxy settings.
        /// </remarks>
        public NFTBscApi(HttpClient client, string basePath, HttpClientHandler handler = null)
        {
            if (client == null) throw new ArgumentNullException(nameof(client));

            Configuration = Tatum.CSharp.Bsc.Core.Client.Configuration.MergeConfigurations(
                GlobalConfiguration.Instance,
                new Configuration { BasePath = basePath }
            );
            ApiClient = new ApiClient(client, Configuration.BasePath, handler);
            Client =  ApiClient;
            AsynchronousClient = ApiClient;
            ExceptionFactory = Tatum.CSharp.Bsc.Core.Client.Configuration.DefaultExceptionFactory;
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="NFTBscApi"/> class using Configuration object.
        /// </summary>
        /// <param name="client">An instance of HttpClient.</param>
        /// <param name="configuration">An instance of Configuration.</param>
        /// <param name="handler">An optional instance of HttpClientHandler that is used by HttpClient.</param>
        /// <exception cref="ArgumentNullException"></exception>
        /// <returns></returns>
        /// <remarks>
        /// Some configuration settings will not be applied without passing an HttpClientHandler.
        /// The features affected are: Setting and Retrieving Cookies, Client Certificates, Proxy settings.
        /// </remarks>
        public NFTBscApi(HttpClient client, Configuration configuration, HttpClientHandler handler = null)
        {
            if (configuration == null) throw new ArgumentNullException(nameof(configuration));
            if (client == null) throw new ArgumentNullException(nameof(client));

            Configuration = Tatum.CSharp.Bsc.Core.Client.Configuration.MergeConfigurations(
                GlobalConfiguration.Instance,
                configuration
            );
            ApiClient = new ApiClient(client, Configuration.BasePath, handler);
            Client = ApiClient;
            AsynchronousClient = ApiClient;
            ExceptionFactory = Tatum.CSharp.Bsc.Core.Client.Configuration.DefaultExceptionFactory;
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="NFTBscApi"/> class
        /// using a Configuration object and client instance.
        /// </summary>
        /// <param name="client">The client interface for synchronous API access.</param>
        /// <param name="asyncClient">The client interface for asynchronous API access.</param>
        /// <param name="configuration">The configuration object.</param>
        /// <exception cref="ArgumentNullException"></exception>
        public NFTBscApi(ISynchronousClient client, IAsynchronousClient asyncClient, IReadableConfiguration configuration)
        {
            Client = client ?? throw new ArgumentNullException(nameof(client));
            AsynchronousClient = asyncClient ?? throw new ArgumentNullException(nameof(asyncClient));
            Configuration = configuration ?? throw new ArgumentNullException(nameof(configuration));
            ExceptionFactory = Tatum.CSharp.Bsc.Core.Client.Configuration.DefaultExceptionFactory;
        }

        /// <summary>
        /// Holds the ApiClient if created
        /// </summary>
        public ApiClient ApiClient { get; set; }

        /// <summary>
        /// The client for accessing this underlying API asynchronously.
        /// </summary>
        public IAsynchronousClient AsynchronousClient { get; set; }

        /// <summary>
        /// The client for accessing this underlying API synchronously.
        /// </summary>
        public ISynchronousClient Client { get; set; }

        /// <summary>
        /// Gets the base path of the API client.
        /// </summary>
        /// <value>The base path</value>
        public string GetBasePath()
        {
            return Configuration.BasePath;
        }

        /// <summary>
        /// Gets or sets the configuration object
        /// </summary>
        /// <value>An instance of the Configuration</value>
        public IReadableConfiguration Configuration { get; set; }

        /// <summary>
        /// Provides a factory method hook for the creation of exceptions.
        /// </summary>
        public ExceptionFactory ExceptionFactory
        {
            get
            {
                if (_exceptionFactory != null && _exceptionFactory.GetInvocationList().Length > 1)
                {
                    throw new InvalidOperationException("Multicast delegate for ExceptionFactory is unsupported.");
                }
                return _exceptionFactory;
            }
            set => _exceptionFactory = value;
        }

        /// <summary>
        /// Add an NFT minter to an NFT smart contract 2 credits per API call Allow a blockchain address (the minter parameter in the request body) to mint NFTs on the NFT smart contract (the contractAddress parameter in the request body). Use this API when you are using NFT Express with your own smart contract to mint NFTs and need to add the Tatum NFT minter&#39;s address as an NFT minter to your smart contract. For more information about the Tatum NFT minter, see \&quot;Use your own smart contract to mint NFTs\&quot; in Mint an NFT. This API is supported for the following blockchains: BNB Smart Chain Celo Ethereum Harmony Klaytn KuCoin Community Chain Polygon Signing a transaction When adding an NFT minter, you are charged a fee for the transaction, and you must sign the transaction with the private key of the blockchain address from which the fee will be deducted. Providing the private key in the API is not a secure way of signing transactions, because the private key can be stolen or exposed. Your private keys should never leave your security perimeter. You should use the private keys only for testing a solution you are building on the testnet of a blockchain. For signing transactions on the mainnet, we strongly recommend that you use the Tatum Key Management System (KMS) and provide the signature ID instead of the private key in the API. Alternatively, you can use the Tatum JavaScript client.
        /// </summary>
        /// <exception cref="Tatum.CSharp.Bsc.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="addNftMinter"></param>
        /// <param name="xTestnetType">Type of Ethereum testnet. Defaults to Sepolia. Valid only for ETH invocations for testnet API Key. For mainnet API Key, this value is ignored. (optional, default to ethereum-sepolia)</param>
        /// <returns>TransactionHash</returns>
        public TransactionHash NftAddMinter(AddNftMinter addNftMinter, string xTestnetType = default(string))
        {
            var localVarResponse = NftAddMinterWithHttpInfo(addNftMinter, xTestnetType);

            var exception = ExceptionFactory?.Invoke("NftAddMinter", localVarResponse);
            if (exception != null) throw exception;

            return localVarResponse.Data;
        }

        /// <summary>
        /// Add an NFT minter to an NFT smart contract 2 credits per API call Allow a blockchain address (the minter parameter in the request body) to mint NFTs on the NFT smart contract (the contractAddress parameter in the request body). Use this API when you are using NFT Express with your own smart contract to mint NFTs and need to add the Tatum NFT minter&#39;s address as an NFT minter to your smart contract. For more information about the Tatum NFT minter, see \&quot;Use your own smart contract to mint NFTs\&quot; in Mint an NFT. This API is supported for the following blockchains: BNB Smart Chain Celo Ethereum Harmony Klaytn KuCoin Community Chain Polygon Signing a transaction When adding an NFT minter, you are charged a fee for the transaction, and you must sign the transaction with the private key of the blockchain address from which the fee will be deducted. Providing the private key in the API is not a secure way of signing transactions, because the private key can be stolen or exposed. Your private keys should never leave your security perimeter. You should use the private keys only for testing a solution you are building on the testnet of a blockchain. For signing transactions on the mainnet, we strongly recommend that you use the Tatum Key Management System (KMS) and provide the signature ID instead of the private key in the API. Alternatively, you can use the Tatum JavaScript client.
        /// </summary>
        /// <exception cref="Tatum.CSharp.Bsc.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="addNftMinter"></param>
        /// <param name="xTestnetType">Type of Ethereum testnet. Defaults to Sepolia. Valid only for ETH invocations for testnet API Key. For mainnet API Key, this value is ignored. (optional, default to ethereum-sepolia)</param>
        /// <returns>ApiResponse of TransactionHash</returns>
        public ApiResponse<TransactionHash> NftAddMinterWithHttpInfo(AddNftMinter addNftMinter, string xTestnetType = default(string))
        {
            // verify the required parameter 'addNftMinter' is set
            if (addNftMinter == null)
                throw new ApiException(400, "Missing required parameter 'addNftMinter' when calling NFTBscApi->NftAddMinter");

            var localVarRequestOptions = new RequestOptions();

            var contentTypes = new string[]{
                "application/json"
            };

            // to determine the Accept header
            var accepts = new string[]{
                "application/json"
            };

            var localVarContentType = ClientUtils.SelectHeaderContentType(contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = ClientUtils.SelectHeaderAccept(accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            if (xTestnetType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("x-testnet-type", ClientUtils.ParameterToString(xTestnetType)); // header parameter
            }
            localVarRequestOptions.Data = addNftMinter;

            // authentication (X-API-Key) required
            if (!string.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("x-api-key")))
            {
                localVarRequestOptions.HeaderParameters.Add("x-api-key", Configuration.GetApiKeyWithPrefix("x-api-key"));
            }

            // make the HTTP request
            var localVarResponse = Client.Post<TransactionHash>("/v3/nft/mint/add", localVarRequestOptions, Configuration);

            return localVarResponse;
        }

        /// <summary>
        /// Add an NFT minter to an NFT smart contract 2 credits per API call Allow a blockchain address (the minter parameter in the request body) to mint NFTs on the NFT smart contract (the contractAddress parameter in the request body). Use this API when you are using NFT Express with your own smart contract to mint NFTs and need to add the Tatum NFT minter&#39;s address as an NFT minter to your smart contract. For more information about the Tatum NFT minter, see \&quot;Use your own smart contract to mint NFTs\&quot; in Mint an NFT. This API is supported for the following blockchains: BNB Smart Chain Celo Ethereum Harmony Klaytn KuCoin Community Chain Polygon Signing a transaction When adding an NFT minter, you are charged a fee for the transaction, and you must sign the transaction with the private key of the blockchain address from which the fee will be deducted. Providing the private key in the API is not a secure way of signing transactions, because the private key can be stolen or exposed. Your private keys should never leave your security perimeter. You should use the private keys only for testing a solution you are building on the testnet of a blockchain. For signing transactions on the mainnet, we strongly recommend that you use the Tatum Key Management System (KMS) and provide the signature ID instead of the private key in the API. Alternatively, you can use the Tatum JavaScript client.
        /// </summary>
        /// <exception cref="Tatum.CSharp.Bsc.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="addNftMinter"></param>
        /// <param name="xTestnetType">Type of Ethereum testnet. Defaults to Sepolia. Valid only for ETH invocations for testnet API Key. For mainnet API Key, this value is ignored. (optional, default to ethereum-sepolia)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of TransactionHash</returns>
        public async System.Threading.Tasks.Task<TransactionHash> NftAddMinterAsync(AddNftMinter addNftMinter, string xTestnetType = default(string), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            var localVarResponse = await NftAddMinterWithHttpInfoAsync(addNftMinter, xTestnetType, cancellationToken).ConfigureAwait(false);
            
            var exception = ExceptionFactory?.Invoke("NftAddMinter", localVarResponse);
            if (exception != null) throw exception;

            return localVarResponse.Data;
        }

        /// <summary>
        /// Add an NFT minter to an NFT smart contract 2 credits per API call Allow a blockchain address (the minter parameter in the request body) to mint NFTs on the NFT smart contract (the contractAddress parameter in the request body). Use this API when you are using NFT Express with your own smart contract to mint NFTs and need to add the Tatum NFT minter&#39;s address as an NFT minter to your smart contract. For more information about the Tatum NFT minter, see \&quot;Use your own smart contract to mint NFTs\&quot; in Mint an NFT. This API is supported for the following blockchains: BNB Smart Chain Celo Ethereum Harmony Klaytn KuCoin Community Chain Polygon Signing a transaction When adding an NFT minter, you are charged a fee for the transaction, and you must sign the transaction with the private key of the blockchain address from which the fee will be deducted. Providing the private key in the API is not a secure way of signing transactions, because the private key can be stolen or exposed. Your private keys should never leave your security perimeter. You should use the private keys only for testing a solution you are building on the testnet of a blockchain. For signing transactions on the mainnet, we strongly recommend that you use the Tatum Key Management System (KMS) and provide the signature ID instead of the private key in the API. Alternatively, you can use the Tatum JavaScript client.
        /// </summary>
        /// <exception cref="Tatum.CSharp.Bsc.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="addNftMinter"></param>
        /// <param name="xTestnetType">Type of Ethereum testnet. Defaults to Sepolia. Valid only for ETH invocations for testnet API Key. For mainnet API Key, this value is ignored. (optional, default to ethereum-sepolia)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (TransactionHash)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<TransactionHash>> NftAddMinterWithHttpInfoAsync(AddNftMinter addNftMinter, string xTestnetType = default(string), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            // verify the required parameter 'addNftMinter' is set
            if (addNftMinter == null)
                throw new ApiException(400, "Missing required parameter 'addNftMinter' when calling NFTBscApi->NftAddMinter");

            var localVarRequestOptions = new RequestOptions();

            var contentTypes = new string[]{
                "application/json"
            };

            // to determine the Accept header
            var accepts = new string[]{
                "application/json"
            };


            var localVarContentType = ClientUtils.SelectHeaderContentType(contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = ClientUtils.SelectHeaderAccept(accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            if (xTestnetType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("x-testnet-type", ClientUtils.ParameterToString(xTestnetType)); // header parameter
            }
            localVarRequestOptions.Data = addNftMinter;

            // authentication (X-API-Key) required
            if (!string.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("x-api-key")))
            {
                localVarRequestOptions.HeaderParameters.Add("x-api-key", Configuration.GetApiKeyWithPrefix("x-api-key"));
            }

            // make the HTTP request

            var localVarResponse = await AsynchronousClient.PostAsync<TransactionHash>("/v3/nft/mint/add", localVarRequestOptions, Configuration, cancellationToken).ConfigureAwait(false);

            return localVarResponse;
        }

        /// <summary>
        /// Add an NFT minter to an NFT smart contract 2 credits per API call Allow a blockchain address (the minter parameter in the request body) to mint NFTs on the NFT smart contract (the contractAddress parameter in the request body). Use this API when you are using NFT Express with your own smart contract to mint NFTs and need to add the Tatum NFT minter&#39;s address as an NFT minter to your smart contract. For more information about the Tatum NFT minter, see \&quot;Use your own smart contract to mint NFTs\&quot; in Mint an NFT. This API is supported for the following blockchains: BNB Smart Chain Celo Ethereum Harmony Klaytn KuCoin Community Chain Polygon Signing a transaction When adding an NFT minter, you are charged a fee for the transaction, and you must sign the transaction with the private key of the blockchain address from which the fee will be deducted. Providing the private key in the API is not a secure way of signing transactions, because the private key can be stolen or exposed. Your private keys should never leave your security perimeter. You should use the private keys only for testing a solution you are building on the testnet of a blockchain. For signing transactions on the mainnet, we strongly recommend that you use the Tatum Key Management System (KMS) and provide the signature ID instead of the private key in the API. Alternatively, you can use the Tatum JavaScript client.
        /// </summary>
        /// <exception cref="Tatum.CSharp.Bsc.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="addNftMinterKMS"></param>
        /// <param name="xTestnetType">Type of Ethereum testnet. Defaults to Sepolia. Valid only for ETH invocations for testnet API Key. For mainnet API Key, this value is ignored. (optional, default to ethereum-sepolia)</param>
        /// <returns>SignatureId</returns>
        public SignatureId NftAddMinter(AddNftMinterKMS addNftMinterKMS, string xTestnetType = default(string))
        {
            var localVarResponse = NftAddMinterWithHttpInfo(addNftMinterKMS, xTestnetType);

            var exception = ExceptionFactory?.Invoke("NftAddMinter_0", localVarResponse);
            if (exception != null) throw exception;

            return localVarResponse.Data;
        }

        /// <summary>
        /// Add an NFT minter to an NFT smart contract 2 credits per API call Allow a blockchain address (the minter parameter in the request body) to mint NFTs on the NFT smart contract (the contractAddress parameter in the request body). Use this API when you are using NFT Express with your own smart contract to mint NFTs and need to add the Tatum NFT minter&#39;s address as an NFT minter to your smart contract. For more information about the Tatum NFT minter, see \&quot;Use your own smart contract to mint NFTs\&quot; in Mint an NFT. This API is supported for the following blockchains: BNB Smart Chain Celo Ethereum Harmony Klaytn KuCoin Community Chain Polygon Signing a transaction When adding an NFT minter, you are charged a fee for the transaction, and you must sign the transaction with the private key of the blockchain address from which the fee will be deducted. Providing the private key in the API is not a secure way of signing transactions, because the private key can be stolen or exposed. Your private keys should never leave your security perimeter. You should use the private keys only for testing a solution you are building on the testnet of a blockchain. For signing transactions on the mainnet, we strongly recommend that you use the Tatum Key Management System (KMS) and provide the signature ID instead of the private key in the API. Alternatively, you can use the Tatum JavaScript client.
        /// </summary>
        /// <exception cref="Tatum.CSharp.Bsc.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="addNftMinterKMS"></param>
        /// <param name="xTestnetType">Type of Ethereum testnet. Defaults to Sepolia. Valid only for ETH invocations for testnet API Key. For mainnet API Key, this value is ignored. (optional, default to ethereum-sepolia)</param>
        /// <returns>ApiResponse of SignatureId</returns>
        public ApiResponse<SignatureId> NftAddMinterWithHttpInfo(AddNftMinterKMS addNftMinterKMS, string xTestnetType = default(string))
        {
            // verify the required parameter 'addNftMinterKMS' is set
            if (addNftMinterKMS == null)
                throw new ApiException(400, "Missing required parameter 'addNftMinterKMS' when calling NFTBscApi->NftAddMinter_0");

            var localVarRequestOptions = new RequestOptions();

            var contentTypes = new string[]{
                "application/json"
            };

            // to determine the Accept header
            var accepts = new string[]{
                "application/json"
            };

            var localVarContentType = ClientUtils.SelectHeaderContentType(contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = ClientUtils.SelectHeaderAccept(accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            if (xTestnetType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("x-testnet-type", ClientUtils.ParameterToString(xTestnetType)); // header parameter
            }
            localVarRequestOptions.Data = addNftMinterKMS;

            // authentication (X-API-Key) required
            if (!string.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("x-api-key")))
            {
                localVarRequestOptions.HeaderParameters.Add("x-api-key", Configuration.GetApiKeyWithPrefix("x-api-key"));
            }

            // make the HTTP request
            var localVarResponse = Client.Post<SignatureId>("/v3/nft/mint/add", localVarRequestOptions, Configuration);

            return localVarResponse;
        }

        /// <summary>
        /// Add an NFT minter to an NFT smart contract 2 credits per API call Allow a blockchain address (the minter parameter in the request body) to mint NFTs on the NFT smart contract (the contractAddress parameter in the request body). Use this API when you are using NFT Express with your own smart contract to mint NFTs and need to add the Tatum NFT minter&#39;s address as an NFT minter to your smart contract. For more information about the Tatum NFT minter, see \&quot;Use your own smart contract to mint NFTs\&quot; in Mint an NFT. This API is supported for the following blockchains: BNB Smart Chain Celo Ethereum Harmony Klaytn KuCoin Community Chain Polygon Signing a transaction When adding an NFT minter, you are charged a fee for the transaction, and you must sign the transaction with the private key of the blockchain address from which the fee will be deducted. Providing the private key in the API is not a secure way of signing transactions, because the private key can be stolen or exposed. Your private keys should never leave your security perimeter. You should use the private keys only for testing a solution you are building on the testnet of a blockchain. For signing transactions on the mainnet, we strongly recommend that you use the Tatum Key Management System (KMS) and provide the signature ID instead of the private key in the API. Alternatively, you can use the Tatum JavaScript client.
        /// </summary>
        /// <exception cref="Tatum.CSharp.Bsc.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="addNftMinterKMS"></param>
        /// <param name="xTestnetType">Type of Ethereum testnet. Defaults to Sepolia. Valid only for ETH invocations for testnet API Key. For mainnet API Key, this value is ignored. (optional, default to ethereum-sepolia)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of SignatureId</returns>
        public async System.Threading.Tasks.Task<SignatureId> NftAddMinterAsync(AddNftMinterKMS addNftMinterKMS, string xTestnetType = default(string), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            var localVarResponse = await NftAddMinterWithHttpInfoAsync(addNftMinterKMS, xTestnetType, cancellationToken).ConfigureAwait(false);
            
            var exception = ExceptionFactory?.Invoke("NftAddMinter_0", localVarResponse);
            if (exception != null) throw exception;

            return localVarResponse.Data;
        }

        /// <summary>
        /// Add an NFT minter to an NFT smart contract 2 credits per API call Allow a blockchain address (the minter parameter in the request body) to mint NFTs on the NFT smart contract (the contractAddress parameter in the request body). Use this API when you are using NFT Express with your own smart contract to mint NFTs and need to add the Tatum NFT minter&#39;s address as an NFT minter to your smart contract. For more information about the Tatum NFT minter, see \&quot;Use your own smart contract to mint NFTs\&quot; in Mint an NFT. This API is supported for the following blockchains: BNB Smart Chain Celo Ethereum Harmony Klaytn KuCoin Community Chain Polygon Signing a transaction When adding an NFT minter, you are charged a fee for the transaction, and you must sign the transaction with the private key of the blockchain address from which the fee will be deducted. Providing the private key in the API is not a secure way of signing transactions, because the private key can be stolen or exposed. Your private keys should never leave your security perimeter. You should use the private keys only for testing a solution you are building on the testnet of a blockchain. For signing transactions on the mainnet, we strongly recommend that you use the Tatum Key Management System (KMS) and provide the signature ID instead of the private key in the API. Alternatively, you can use the Tatum JavaScript client.
        /// </summary>
        /// <exception cref="Tatum.CSharp.Bsc.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="addNftMinterKMS"></param>
        /// <param name="xTestnetType">Type of Ethereum testnet. Defaults to Sepolia. Valid only for ETH invocations for testnet API Key. For mainnet API Key, this value is ignored. (optional, default to ethereum-sepolia)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (SignatureId)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<SignatureId>> NftAddMinterWithHttpInfoAsync(AddNftMinterKMS addNftMinterKMS, string xTestnetType = default(string), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            // verify the required parameter 'addNftMinterKMS' is set
            if (addNftMinterKMS == null)
                throw new ApiException(400, "Missing required parameter 'addNftMinterKMS' when calling NFTBscApi->NftAddMinter_0");

            var localVarRequestOptions = new RequestOptions();

            var contentTypes = new string[]{
                "application/json"
            };

            // to determine the Accept header
            var accepts = new string[]{
                "application/json"
            };


            var localVarContentType = ClientUtils.SelectHeaderContentType(contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = ClientUtils.SelectHeaderAccept(accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            if (xTestnetType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("x-testnet-type", ClientUtils.ParameterToString(xTestnetType)); // header parameter
            }
            localVarRequestOptions.Data = addNftMinterKMS;

            // authentication (X-API-Key) required
            if (!string.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("x-api-key")))
            {
                localVarRequestOptions.HeaderParameters.Add("x-api-key", Configuration.GetApiKeyWithPrefix("x-api-key"));
            }

            // make the HTTP request

            var localVarResponse = await AsynchronousClient.PostAsync<SignatureId>("/v3/nft/mint/add", localVarRequestOptions, Configuration, cancellationToken).ConfigureAwait(false);

            return localVarResponse;
        }

        /// <summary>
        /// Burn an NFT 100 credits per API call on Flow 2 credits per API call on the other blockchains Destroy an NFT. Burning the NFT transfers it to an un-spendable blockchain address that no one can access. This API is supported for the following blockchains: Algorand BNB Smart Chain Celo Ethereum Flow Harmony Klaytn KuCoin Community Chain Polygon TRON Burning NFTs on Algorand You can burn only the NFTs that were minted with the address of the manager account specified in the manager parameter in the minting call (see the MintNftExpressAlgorand, MintNftAlgorand, and MintNftAlgorandKMS schemas of the request body). Signing a transaction When burning an NFT, you are charged a fee for the transaction, and you must sign the transaction with the private key of the blockchain address from which the fee will be deducted. Providing the private key in the API is not a secure way of signing transactions, because the private key can be stolen or exposed. Your private keys should never leave your security perimeter. You should use the private keys only for testing a solution you are building on the testnet of a blockchain. For signing transactions on the mainnet, we strongly recommend that you use the Tatum Key Management System (KMS) and provide the signature ID instead of the private key in the API. Alternatively, you can use the Tatum JavaScript client.
        /// </summary>
        /// <exception cref="Tatum.CSharp.Bsc.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="burnNft"></param>
        /// <param name="xTestnetType">Type of Ethereum testnet. Defaults to Sepolia. Valid only for ETH invocations for testnet API Key. For mainnet API Key, this value is ignored. (optional, default to ethereum-sepolia)</param>
        /// <returns>TransactionHash</returns>
        public TransactionHash NftBurnErc721(BurnNft burnNft, string xTestnetType = default(string))
        {
            var localVarResponse = NftBurnErc721WithHttpInfo(burnNft, xTestnetType);

            var exception = ExceptionFactory?.Invoke("NftBurnErc721", localVarResponse);
            if (exception != null) throw exception;

            return localVarResponse.Data;
        }

        /// <summary>
        /// Burn an NFT 100 credits per API call on Flow 2 credits per API call on the other blockchains Destroy an NFT. Burning the NFT transfers it to an un-spendable blockchain address that no one can access. This API is supported for the following blockchains: Algorand BNB Smart Chain Celo Ethereum Flow Harmony Klaytn KuCoin Community Chain Polygon TRON Burning NFTs on Algorand You can burn only the NFTs that were minted with the address of the manager account specified in the manager parameter in the minting call (see the MintNftExpressAlgorand, MintNftAlgorand, and MintNftAlgorandKMS schemas of the request body). Signing a transaction When burning an NFT, you are charged a fee for the transaction, and you must sign the transaction with the private key of the blockchain address from which the fee will be deducted. Providing the private key in the API is not a secure way of signing transactions, because the private key can be stolen or exposed. Your private keys should never leave your security perimeter. You should use the private keys only for testing a solution you are building on the testnet of a blockchain. For signing transactions on the mainnet, we strongly recommend that you use the Tatum Key Management System (KMS) and provide the signature ID instead of the private key in the API. Alternatively, you can use the Tatum JavaScript client.
        /// </summary>
        /// <exception cref="Tatum.CSharp.Bsc.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="burnNft"></param>
        /// <param name="xTestnetType">Type of Ethereum testnet. Defaults to Sepolia. Valid only for ETH invocations for testnet API Key. For mainnet API Key, this value is ignored. (optional, default to ethereum-sepolia)</param>
        /// <returns>ApiResponse of TransactionHash</returns>
        public ApiResponse<TransactionHash> NftBurnErc721WithHttpInfo(BurnNft burnNft, string xTestnetType = default(string))
        {
            // verify the required parameter 'burnNft' is set
            if (burnNft == null)
                throw new ApiException(400, "Missing required parameter 'burnNft' when calling NFTBscApi->NftBurnErc721");

            var localVarRequestOptions = new RequestOptions();

            var contentTypes = new string[]{
                "application/json"
            };

            // to determine the Accept header
            var accepts = new string[]{
                "application/json"
            };

            var localVarContentType = ClientUtils.SelectHeaderContentType(contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = ClientUtils.SelectHeaderAccept(accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            if (xTestnetType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("x-testnet-type", ClientUtils.ParameterToString(xTestnetType)); // header parameter
            }
            localVarRequestOptions.Data = burnNft;

            // authentication (X-API-Key) required
            if (!string.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("x-api-key")))
            {
                localVarRequestOptions.HeaderParameters.Add("x-api-key", Configuration.GetApiKeyWithPrefix("x-api-key"));
            }

            // make the HTTP request
            var localVarResponse = Client.Post<TransactionHash>("/v3/nft/burn", localVarRequestOptions, Configuration);

            return localVarResponse;
        }

        /// <summary>
        /// Burn an NFT 100 credits per API call on Flow 2 credits per API call on the other blockchains Destroy an NFT. Burning the NFT transfers it to an un-spendable blockchain address that no one can access. This API is supported for the following blockchains: Algorand BNB Smart Chain Celo Ethereum Flow Harmony Klaytn KuCoin Community Chain Polygon TRON Burning NFTs on Algorand You can burn only the NFTs that were minted with the address of the manager account specified in the manager parameter in the minting call (see the MintNftExpressAlgorand, MintNftAlgorand, and MintNftAlgorandKMS schemas of the request body). Signing a transaction When burning an NFT, you are charged a fee for the transaction, and you must sign the transaction with the private key of the blockchain address from which the fee will be deducted. Providing the private key in the API is not a secure way of signing transactions, because the private key can be stolen or exposed. Your private keys should never leave your security perimeter. You should use the private keys only for testing a solution you are building on the testnet of a blockchain. For signing transactions on the mainnet, we strongly recommend that you use the Tatum Key Management System (KMS) and provide the signature ID instead of the private key in the API. Alternatively, you can use the Tatum JavaScript client.
        /// </summary>
        /// <exception cref="Tatum.CSharp.Bsc.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="burnNft"></param>
        /// <param name="xTestnetType">Type of Ethereum testnet. Defaults to Sepolia. Valid only for ETH invocations for testnet API Key. For mainnet API Key, this value is ignored. (optional, default to ethereum-sepolia)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of TransactionHash</returns>
        public async System.Threading.Tasks.Task<TransactionHash> NftBurnErc721Async(BurnNft burnNft, string xTestnetType = default(string), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            var localVarResponse = await NftBurnErc721WithHttpInfoAsync(burnNft, xTestnetType, cancellationToken).ConfigureAwait(false);
            
            var exception = ExceptionFactory?.Invoke("NftBurnErc721", localVarResponse);
            if (exception != null) throw exception;

            return localVarResponse.Data;
        }

        /// <summary>
        /// Burn an NFT 100 credits per API call on Flow 2 credits per API call on the other blockchains Destroy an NFT. Burning the NFT transfers it to an un-spendable blockchain address that no one can access. This API is supported for the following blockchains: Algorand BNB Smart Chain Celo Ethereum Flow Harmony Klaytn KuCoin Community Chain Polygon TRON Burning NFTs on Algorand You can burn only the NFTs that were minted with the address of the manager account specified in the manager parameter in the minting call (see the MintNftExpressAlgorand, MintNftAlgorand, and MintNftAlgorandKMS schemas of the request body). Signing a transaction When burning an NFT, you are charged a fee for the transaction, and you must sign the transaction with the private key of the blockchain address from which the fee will be deducted. Providing the private key in the API is not a secure way of signing transactions, because the private key can be stolen or exposed. Your private keys should never leave your security perimeter. You should use the private keys only for testing a solution you are building on the testnet of a blockchain. For signing transactions on the mainnet, we strongly recommend that you use the Tatum Key Management System (KMS) and provide the signature ID instead of the private key in the API. Alternatively, you can use the Tatum JavaScript client.
        /// </summary>
        /// <exception cref="Tatum.CSharp.Bsc.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="burnNft"></param>
        /// <param name="xTestnetType">Type of Ethereum testnet. Defaults to Sepolia. Valid only for ETH invocations for testnet API Key. For mainnet API Key, this value is ignored. (optional, default to ethereum-sepolia)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (TransactionHash)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<TransactionHash>> NftBurnErc721WithHttpInfoAsync(BurnNft burnNft, string xTestnetType = default(string), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            // verify the required parameter 'burnNft' is set
            if (burnNft == null)
                throw new ApiException(400, "Missing required parameter 'burnNft' when calling NFTBscApi->NftBurnErc721");

            var localVarRequestOptions = new RequestOptions();

            var contentTypes = new string[]{
                "application/json"
            };

            // to determine the Accept header
            var accepts = new string[]{
                "application/json"
            };


            var localVarContentType = ClientUtils.SelectHeaderContentType(contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = ClientUtils.SelectHeaderAccept(accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            if (xTestnetType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("x-testnet-type", ClientUtils.ParameterToString(xTestnetType)); // header parameter
            }
            localVarRequestOptions.Data = burnNft;

            // authentication (X-API-Key) required
            if (!string.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("x-api-key")))
            {
                localVarRequestOptions.HeaderParameters.Add("x-api-key", Configuration.GetApiKeyWithPrefix("x-api-key"));
            }

            // make the HTTP request

            var localVarResponse = await AsynchronousClient.PostAsync<TransactionHash>("/v3/nft/burn", localVarRequestOptions, Configuration, cancellationToken).ConfigureAwait(false);

            return localVarResponse;
        }

        /// <summary>
        /// Burn an NFT 100 credits per API call on Flow 2 credits per API call on the other blockchains Destroy an NFT. Burning the NFT transfers it to an un-spendable blockchain address that no one can access. This API is supported for the following blockchains: Algorand BNB Smart Chain Celo Ethereum Flow Harmony Klaytn KuCoin Community Chain Polygon TRON Burning NFTs on Algorand You can burn only the NFTs that were minted with the address of the manager account specified in the manager parameter in the minting call (see the MintNftExpressAlgorand, MintNftAlgorand, and MintNftAlgorandKMS schemas of the request body). Signing a transaction When burning an NFT, you are charged a fee for the transaction, and you must sign the transaction with the private key of the blockchain address from which the fee will be deducted. Providing the private key in the API is not a secure way of signing transactions, because the private key can be stolen or exposed. Your private keys should never leave your security perimeter. You should use the private keys only for testing a solution you are building on the testnet of a blockchain. For signing transactions on the mainnet, we strongly recommend that you use the Tatum Key Management System (KMS) and provide the signature ID instead of the private key in the API. Alternatively, you can use the Tatum JavaScript client.
        /// </summary>
        /// <exception cref="Tatum.CSharp.Bsc.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="burnNftKMS"></param>
        /// <param name="xTestnetType">Type of Ethereum testnet. Defaults to Sepolia. Valid only for ETH invocations for testnet API Key. For mainnet API Key, this value is ignored. (optional, default to ethereum-sepolia)</param>
        /// <returns>SignatureId</returns>
        public SignatureId NftBurnErc721(BurnNftKMS burnNftKMS, string xTestnetType = default(string))
        {
            var localVarResponse = NftBurnErc721WithHttpInfo(burnNftKMS, xTestnetType);

            var exception = ExceptionFactory?.Invoke("NftBurnErc721_0", localVarResponse);
            if (exception != null) throw exception;

            return localVarResponse.Data;
        }

        /// <summary>
        /// Burn an NFT 100 credits per API call on Flow 2 credits per API call on the other blockchains Destroy an NFT. Burning the NFT transfers it to an un-spendable blockchain address that no one can access. This API is supported for the following blockchains: Algorand BNB Smart Chain Celo Ethereum Flow Harmony Klaytn KuCoin Community Chain Polygon TRON Burning NFTs on Algorand You can burn only the NFTs that were minted with the address of the manager account specified in the manager parameter in the minting call (see the MintNftExpressAlgorand, MintNftAlgorand, and MintNftAlgorandKMS schemas of the request body). Signing a transaction When burning an NFT, you are charged a fee for the transaction, and you must sign the transaction with the private key of the blockchain address from which the fee will be deducted. Providing the private key in the API is not a secure way of signing transactions, because the private key can be stolen or exposed. Your private keys should never leave your security perimeter. You should use the private keys only for testing a solution you are building on the testnet of a blockchain. For signing transactions on the mainnet, we strongly recommend that you use the Tatum Key Management System (KMS) and provide the signature ID instead of the private key in the API. Alternatively, you can use the Tatum JavaScript client.
        /// </summary>
        /// <exception cref="Tatum.CSharp.Bsc.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="burnNftKMS"></param>
        /// <param name="xTestnetType">Type of Ethereum testnet. Defaults to Sepolia. Valid only for ETH invocations for testnet API Key. For mainnet API Key, this value is ignored. (optional, default to ethereum-sepolia)</param>
        /// <returns>ApiResponse of SignatureId</returns>
        public ApiResponse<SignatureId> NftBurnErc721WithHttpInfo(BurnNftKMS burnNftKMS, string xTestnetType = default(string))
        {
            // verify the required parameter 'burnNftKMS' is set
            if (burnNftKMS == null)
                throw new ApiException(400, "Missing required parameter 'burnNftKMS' when calling NFTBscApi->NftBurnErc721_0");

            var localVarRequestOptions = new RequestOptions();

            var contentTypes = new string[]{
                "application/json"
            };

            // to determine the Accept header
            var accepts = new string[]{
                "application/json"
            };

            var localVarContentType = ClientUtils.SelectHeaderContentType(contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = ClientUtils.SelectHeaderAccept(accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            if (xTestnetType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("x-testnet-type", ClientUtils.ParameterToString(xTestnetType)); // header parameter
            }
            localVarRequestOptions.Data = burnNftKMS;

            // authentication (X-API-Key) required
            if (!string.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("x-api-key")))
            {
                localVarRequestOptions.HeaderParameters.Add("x-api-key", Configuration.GetApiKeyWithPrefix("x-api-key"));
            }

            // make the HTTP request
            var localVarResponse = Client.Post<SignatureId>("/v3/nft/burn", localVarRequestOptions, Configuration);

            return localVarResponse;
        }

        /// <summary>
        /// Burn an NFT 100 credits per API call on Flow 2 credits per API call on the other blockchains Destroy an NFT. Burning the NFT transfers it to an un-spendable blockchain address that no one can access. This API is supported for the following blockchains: Algorand BNB Smart Chain Celo Ethereum Flow Harmony Klaytn KuCoin Community Chain Polygon TRON Burning NFTs on Algorand You can burn only the NFTs that were minted with the address of the manager account specified in the manager parameter in the minting call (see the MintNftExpressAlgorand, MintNftAlgorand, and MintNftAlgorandKMS schemas of the request body). Signing a transaction When burning an NFT, you are charged a fee for the transaction, and you must sign the transaction with the private key of the blockchain address from which the fee will be deducted. Providing the private key in the API is not a secure way of signing transactions, because the private key can be stolen or exposed. Your private keys should never leave your security perimeter. You should use the private keys only for testing a solution you are building on the testnet of a blockchain. For signing transactions on the mainnet, we strongly recommend that you use the Tatum Key Management System (KMS) and provide the signature ID instead of the private key in the API. Alternatively, you can use the Tatum JavaScript client.
        /// </summary>
        /// <exception cref="Tatum.CSharp.Bsc.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="burnNftKMS"></param>
        /// <param name="xTestnetType">Type of Ethereum testnet. Defaults to Sepolia. Valid only for ETH invocations for testnet API Key. For mainnet API Key, this value is ignored. (optional, default to ethereum-sepolia)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of SignatureId</returns>
        public async System.Threading.Tasks.Task<SignatureId> NftBurnErc721Async(BurnNftKMS burnNftKMS, string xTestnetType = default(string), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            var localVarResponse = await NftBurnErc721WithHttpInfoAsync(burnNftKMS, xTestnetType, cancellationToken).ConfigureAwait(false);
            
            var exception = ExceptionFactory?.Invoke("NftBurnErc721_0", localVarResponse);
            if (exception != null) throw exception;

            return localVarResponse.Data;
        }

        /// <summary>
        /// Burn an NFT 100 credits per API call on Flow 2 credits per API call on the other blockchains Destroy an NFT. Burning the NFT transfers it to an un-spendable blockchain address that no one can access. This API is supported for the following blockchains: Algorand BNB Smart Chain Celo Ethereum Flow Harmony Klaytn KuCoin Community Chain Polygon TRON Burning NFTs on Algorand You can burn only the NFTs that were minted with the address of the manager account specified in the manager parameter in the minting call (see the MintNftExpressAlgorand, MintNftAlgorand, and MintNftAlgorandKMS schemas of the request body). Signing a transaction When burning an NFT, you are charged a fee for the transaction, and you must sign the transaction with the private key of the blockchain address from which the fee will be deducted. Providing the private key in the API is not a secure way of signing transactions, because the private key can be stolen or exposed. Your private keys should never leave your security perimeter. You should use the private keys only for testing a solution you are building on the testnet of a blockchain. For signing transactions on the mainnet, we strongly recommend that you use the Tatum Key Management System (KMS) and provide the signature ID instead of the private key in the API. Alternatively, you can use the Tatum JavaScript client.
        /// </summary>
        /// <exception cref="Tatum.CSharp.Bsc.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="burnNftKMS"></param>
        /// <param name="xTestnetType">Type of Ethereum testnet. Defaults to Sepolia. Valid only for ETH invocations for testnet API Key. For mainnet API Key, this value is ignored. (optional, default to ethereum-sepolia)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (SignatureId)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<SignatureId>> NftBurnErc721WithHttpInfoAsync(BurnNftKMS burnNftKMS, string xTestnetType = default(string), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            // verify the required parameter 'burnNftKMS' is set
            if (burnNftKMS == null)
                throw new ApiException(400, "Missing required parameter 'burnNftKMS' when calling NFTBscApi->NftBurnErc721_0");

            var localVarRequestOptions = new RequestOptions();

            var contentTypes = new string[]{
                "application/json"
            };

            // to determine the Accept header
            var accepts = new string[]{
                "application/json"
            };


            var localVarContentType = ClientUtils.SelectHeaderContentType(contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = ClientUtils.SelectHeaderAccept(accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            if (xTestnetType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("x-testnet-type", ClientUtils.ParameterToString(xTestnetType)); // header parameter
            }
            localVarRequestOptions.Data = burnNftKMS;

            // authentication (X-API-Key) required
            if (!string.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("x-api-key")))
            {
                localVarRequestOptions.HeaderParameters.Add("x-api-key", Configuration.GetApiKeyWithPrefix("x-api-key"));
            }

            // make the HTTP request

            var localVarResponse = await AsynchronousClient.PostAsync<SignatureId>("/v3/nft/burn", localVarRequestOptions, Configuration, cancellationToken).ConfigureAwait(false);

            return localVarResponse;
        }

        /// <summary>
        /// Deploy an NFT smart contract 100 credits per API call on Flow 2 credits per API call on the other blockchains Deploy an NFT smart contract on the blockchain. In a deployed NFT smart contract, you can mint NFTs (one NFT at a time or multiple NFTs at once), burn, and transfer NFTs. Smart contracts are standardized and audited. You can review the code of a deployed NFT smart contract here (if the contract is deployed on Flow) or here (if the contract is deployed on any other supported blockchain). This API is supported for the following blockchains: BNB Smart Chain Celo Ethereum Flow Harmony Klaytn KuCoin Community Chain Polygon TRON General NFT smart contracts By default, an NFT smart contract is deployed as a general NFT smart contract compatible with OpenSea royalties. This is a standard NFT contract with AccessControl and Ownable, enhanced with NFT batch minting. NFTs minted on this smart contract are compatible with OpenSea and its royalty structure. Cashback and provenance NFT smart contracts In addition to the general NFT contract, you can deploy the following types of NFT smart contracts for the supported blockchains except for Flow and TRON: Cashback NFT smart contract is an NFT smart contract that forces on-chain royalties to be paid every time an NFT is transferred, and the royalties are defined as a fixed value. The royalties are not OpenSea-compatible. To deploy an NFT smart contract as a cashback contract, deploy the contract with the cashback parameter set to true in the request body. Provenance NFT smart contract is an NFT smart contract that forces on-chain royalties to be paid every time an NFT is transferred, and the royalties are defined as a percentage of the NFT price. The royalties are not OpenSea-compatible. To deploy an NFT smart contract as a provenance contract, deploy the contract with the provenance parameter set to true in the request body. You can enable public minting for cashback and provenance smart contracts. By default, public minting is disabled, which means that only the blockchain address whose private key was used to create the smart contract or the blockchain addresses added to the smart contract as NFT minters will be able to mint NFTs for the contract. To enable public minting and allow anyone to mint NFTs on top of the smart contract, deploy the contract with the publicMint parameter set to true in the request body. NFT smart contracts and NFT Express If you want to use NFT Express to mint NFTs on the deployed smart contract, deploy the smart contract as a general NFT smart contract (that is, deploy the contract with the cashback, provenance, and publicMint parameters either set to false or not set at all in the request body). After you have deployed the NFT smart contract, add the Tatum minter address as an NFT minter to your smart contract. For the complete information about using NFT Express on your smart contract, see \&quot;Use your own smart contract to mint NFTs\&quot; in Mint an NFT. Signing a transaction When deploying an NFT smart contract, you are charged a fee for the transaction, and you must sign the transaction with the private key of the blockchain address from which the fee will be deducted. Providing the private key in the API is not a secure way of signing transactions, because the private key can be stolen or exposed. Your private keys should never leave your security perimeter. You should use the private keys only for testing a solution you are building on the testnet of a blockchain. For signing transactions on the mainnet, we strongly recommend that you use the Tatum Key Management System (KMS) and provide the signature ID instead of the private key in the API. Alternatively, you can use the Tatum JavaScript client.
        /// </summary>
        /// <exception cref="Tatum.CSharp.Bsc.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="deployNft"></param>
        /// <param name="xTestnetType">Type of Ethereum testnet. Defaults to Sepolia. Valid only for ETH invocations for testnet API Key. For mainnet API Key, this value is ignored. (optional, default to ethereum-sepolia)</param>
        /// <returns>TransactionHash</returns>
        public TransactionHash NftDeployErc721(DeployNft deployNft, string xTestnetType = default(string))
        {
            var localVarResponse = NftDeployErc721WithHttpInfo(deployNft, xTestnetType);

            var exception = ExceptionFactory?.Invoke("NftDeployErc721", localVarResponse);
            if (exception != null) throw exception;

            return localVarResponse.Data;
        }

        /// <summary>
        /// Deploy an NFT smart contract 100 credits per API call on Flow 2 credits per API call on the other blockchains Deploy an NFT smart contract on the blockchain. In a deployed NFT smart contract, you can mint NFTs (one NFT at a time or multiple NFTs at once), burn, and transfer NFTs. Smart contracts are standardized and audited. You can review the code of a deployed NFT smart contract here (if the contract is deployed on Flow) or here (if the contract is deployed on any other supported blockchain). This API is supported for the following blockchains: BNB Smart Chain Celo Ethereum Flow Harmony Klaytn KuCoin Community Chain Polygon TRON General NFT smart contracts By default, an NFT smart contract is deployed as a general NFT smart contract compatible with OpenSea royalties. This is a standard NFT contract with AccessControl and Ownable, enhanced with NFT batch minting. NFTs minted on this smart contract are compatible with OpenSea and its royalty structure. Cashback and provenance NFT smart contracts In addition to the general NFT contract, you can deploy the following types of NFT smart contracts for the supported blockchains except for Flow and TRON: Cashback NFT smart contract is an NFT smart contract that forces on-chain royalties to be paid every time an NFT is transferred, and the royalties are defined as a fixed value. The royalties are not OpenSea-compatible. To deploy an NFT smart contract as a cashback contract, deploy the contract with the cashback parameter set to true in the request body. Provenance NFT smart contract is an NFT smart contract that forces on-chain royalties to be paid every time an NFT is transferred, and the royalties are defined as a percentage of the NFT price. The royalties are not OpenSea-compatible. To deploy an NFT smart contract as a provenance contract, deploy the contract with the provenance parameter set to true in the request body. You can enable public minting for cashback and provenance smart contracts. By default, public minting is disabled, which means that only the blockchain address whose private key was used to create the smart contract or the blockchain addresses added to the smart contract as NFT minters will be able to mint NFTs for the contract. To enable public minting and allow anyone to mint NFTs on top of the smart contract, deploy the contract with the publicMint parameter set to true in the request body. NFT smart contracts and NFT Express If you want to use NFT Express to mint NFTs on the deployed smart contract, deploy the smart contract as a general NFT smart contract (that is, deploy the contract with the cashback, provenance, and publicMint parameters either set to false or not set at all in the request body). After you have deployed the NFT smart contract, add the Tatum minter address as an NFT minter to your smart contract. For the complete information about using NFT Express on your smart contract, see \&quot;Use your own smart contract to mint NFTs\&quot; in Mint an NFT. Signing a transaction When deploying an NFT smart contract, you are charged a fee for the transaction, and you must sign the transaction with the private key of the blockchain address from which the fee will be deducted. Providing the private key in the API is not a secure way of signing transactions, because the private key can be stolen or exposed. Your private keys should never leave your security perimeter. You should use the private keys only for testing a solution you are building on the testnet of a blockchain. For signing transactions on the mainnet, we strongly recommend that you use the Tatum Key Management System (KMS) and provide the signature ID instead of the private key in the API. Alternatively, you can use the Tatum JavaScript client.
        /// </summary>
        /// <exception cref="Tatum.CSharp.Bsc.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="deployNft"></param>
        /// <param name="xTestnetType">Type of Ethereum testnet. Defaults to Sepolia. Valid only for ETH invocations for testnet API Key. For mainnet API Key, this value is ignored. (optional, default to ethereum-sepolia)</param>
        /// <returns>ApiResponse of TransactionHash</returns>
        public ApiResponse<TransactionHash> NftDeployErc721WithHttpInfo(DeployNft deployNft, string xTestnetType = default(string))
        {
            // verify the required parameter 'deployNft' is set
            if (deployNft == null)
                throw new ApiException(400, "Missing required parameter 'deployNft' when calling NFTBscApi->NftDeployErc721");

            var localVarRequestOptions = new RequestOptions();

            var contentTypes = new string[]{
                "application/json"
            };

            // to determine the Accept header
            var accepts = new string[]{
                "application/json"
            };

            var localVarContentType = ClientUtils.SelectHeaderContentType(contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = ClientUtils.SelectHeaderAccept(accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            if (xTestnetType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("x-testnet-type", ClientUtils.ParameterToString(xTestnetType)); // header parameter
            }
            localVarRequestOptions.Data = deployNft;

            // authentication (X-API-Key) required
            if (!string.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("x-api-key")))
            {
                localVarRequestOptions.HeaderParameters.Add("x-api-key", Configuration.GetApiKeyWithPrefix("x-api-key"));
            }

            // make the HTTP request
            var localVarResponse = Client.Post<TransactionHash>("/v3/nft/deploy", localVarRequestOptions, Configuration);

            return localVarResponse;
        }

        /// <summary>
        /// Deploy an NFT smart contract 100 credits per API call on Flow 2 credits per API call on the other blockchains Deploy an NFT smart contract on the blockchain. In a deployed NFT smart contract, you can mint NFTs (one NFT at a time or multiple NFTs at once), burn, and transfer NFTs. Smart contracts are standardized and audited. You can review the code of a deployed NFT smart contract here (if the contract is deployed on Flow) or here (if the contract is deployed on any other supported blockchain). This API is supported for the following blockchains: BNB Smart Chain Celo Ethereum Flow Harmony Klaytn KuCoin Community Chain Polygon TRON General NFT smart contracts By default, an NFT smart contract is deployed as a general NFT smart contract compatible with OpenSea royalties. This is a standard NFT contract with AccessControl and Ownable, enhanced with NFT batch minting. NFTs minted on this smart contract are compatible with OpenSea and its royalty structure. Cashback and provenance NFT smart contracts In addition to the general NFT contract, you can deploy the following types of NFT smart contracts for the supported blockchains except for Flow and TRON: Cashback NFT smart contract is an NFT smart contract that forces on-chain royalties to be paid every time an NFT is transferred, and the royalties are defined as a fixed value. The royalties are not OpenSea-compatible. To deploy an NFT smart contract as a cashback contract, deploy the contract with the cashback parameter set to true in the request body. Provenance NFT smart contract is an NFT smart contract that forces on-chain royalties to be paid every time an NFT is transferred, and the royalties are defined as a percentage of the NFT price. The royalties are not OpenSea-compatible. To deploy an NFT smart contract as a provenance contract, deploy the contract with the provenance parameter set to true in the request body. You can enable public minting for cashback and provenance smart contracts. By default, public minting is disabled, which means that only the blockchain address whose private key was used to create the smart contract or the blockchain addresses added to the smart contract as NFT minters will be able to mint NFTs for the contract. To enable public minting and allow anyone to mint NFTs on top of the smart contract, deploy the contract with the publicMint parameter set to true in the request body. NFT smart contracts and NFT Express If you want to use NFT Express to mint NFTs on the deployed smart contract, deploy the smart contract as a general NFT smart contract (that is, deploy the contract with the cashback, provenance, and publicMint parameters either set to false or not set at all in the request body). After you have deployed the NFT smart contract, add the Tatum minter address as an NFT minter to your smart contract. For the complete information about using NFT Express on your smart contract, see \&quot;Use your own smart contract to mint NFTs\&quot; in Mint an NFT. Signing a transaction When deploying an NFT smart contract, you are charged a fee for the transaction, and you must sign the transaction with the private key of the blockchain address from which the fee will be deducted. Providing the private key in the API is not a secure way of signing transactions, because the private key can be stolen or exposed. Your private keys should never leave your security perimeter. You should use the private keys only for testing a solution you are building on the testnet of a blockchain. For signing transactions on the mainnet, we strongly recommend that you use the Tatum Key Management System (KMS) and provide the signature ID instead of the private key in the API. Alternatively, you can use the Tatum JavaScript client.
        /// </summary>
        /// <exception cref="Tatum.CSharp.Bsc.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="deployNft"></param>
        /// <param name="xTestnetType">Type of Ethereum testnet. Defaults to Sepolia. Valid only for ETH invocations for testnet API Key. For mainnet API Key, this value is ignored. (optional, default to ethereum-sepolia)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of TransactionHash</returns>
        public async System.Threading.Tasks.Task<TransactionHash> NftDeployErc721Async(DeployNft deployNft, string xTestnetType = default(string), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            var localVarResponse = await NftDeployErc721WithHttpInfoAsync(deployNft, xTestnetType, cancellationToken).ConfigureAwait(false);
            
            var exception = ExceptionFactory?.Invoke("NftDeployErc721", localVarResponse);
            if (exception != null) throw exception;

            return localVarResponse.Data;
        }

        /// <summary>
        /// Deploy an NFT smart contract 100 credits per API call on Flow 2 credits per API call on the other blockchains Deploy an NFT smart contract on the blockchain. In a deployed NFT smart contract, you can mint NFTs (one NFT at a time or multiple NFTs at once), burn, and transfer NFTs. Smart contracts are standardized and audited. You can review the code of a deployed NFT smart contract here (if the contract is deployed on Flow) or here (if the contract is deployed on any other supported blockchain). This API is supported for the following blockchains: BNB Smart Chain Celo Ethereum Flow Harmony Klaytn KuCoin Community Chain Polygon TRON General NFT smart contracts By default, an NFT smart contract is deployed as a general NFT smart contract compatible with OpenSea royalties. This is a standard NFT contract with AccessControl and Ownable, enhanced with NFT batch minting. NFTs minted on this smart contract are compatible with OpenSea and its royalty structure. Cashback and provenance NFT smart contracts In addition to the general NFT contract, you can deploy the following types of NFT smart contracts for the supported blockchains except for Flow and TRON: Cashback NFT smart contract is an NFT smart contract that forces on-chain royalties to be paid every time an NFT is transferred, and the royalties are defined as a fixed value. The royalties are not OpenSea-compatible. To deploy an NFT smart contract as a cashback contract, deploy the contract with the cashback parameter set to true in the request body. Provenance NFT smart contract is an NFT smart contract that forces on-chain royalties to be paid every time an NFT is transferred, and the royalties are defined as a percentage of the NFT price. The royalties are not OpenSea-compatible. To deploy an NFT smart contract as a provenance contract, deploy the contract with the provenance parameter set to true in the request body. You can enable public minting for cashback and provenance smart contracts. By default, public minting is disabled, which means that only the blockchain address whose private key was used to create the smart contract or the blockchain addresses added to the smart contract as NFT minters will be able to mint NFTs for the contract. To enable public minting and allow anyone to mint NFTs on top of the smart contract, deploy the contract with the publicMint parameter set to true in the request body. NFT smart contracts and NFT Express If you want to use NFT Express to mint NFTs on the deployed smart contract, deploy the smart contract as a general NFT smart contract (that is, deploy the contract with the cashback, provenance, and publicMint parameters either set to false or not set at all in the request body). After you have deployed the NFT smart contract, add the Tatum minter address as an NFT minter to your smart contract. For the complete information about using NFT Express on your smart contract, see \&quot;Use your own smart contract to mint NFTs\&quot; in Mint an NFT. Signing a transaction When deploying an NFT smart contract, you are charged a fee for the transaction, and you must sign the transaction with the private key of the blockchain address from which the fee will be deducted. Providing the private key in the API is not a secure way of signing transactions, because the private key can be stolen or exposed. Your private keys should never leave your security perimeter. You should use the private keys only for testing a solution you are building on the testnet of a blockchain. For signing transactions on the mainnet, we strongly recommend that you use the Tatum Key Management System (KMS) and provide the signature ID instead of the private key in the API. Alternatively, you can use the Tatum JavaScript client.
        /// </summary>
        /// <exception cref="Tatum.CSharp.Bsc.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="deployNft"></param>
        /// <param name="xTestnetType">Type of Ethereum testnet. Defaults to Sepolia. Valid only for ETH invocations for testnet API Key. For mainnet API Key, this value is ignored. (optional, default to ethereum-sepolia)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (TransactionHash)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<TransactionHash>> NftDeployErc721WithHttpInfoAsync(DeployNft deployNft, string xTestnetType = default(string), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            // verify the required parameter 'deployNft' is set
            if (deployNft == null)
                throw new ApiException(400, "Missing required parameter 'deployNft' when calling NFTBscApi->NftDeployErc721");

            var localVarRequestOptions = new RequestOptions();

            var contentTypes = new string[]{
                "application/json"
            };

            // to determine the Accept header
            var accepts = new string[]{
                "application/json"
            };


            var localVarContentType = ClientUtils.SelectHeaderContentType(contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = ClientUtils.SelectHeaderAccept(accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            if (xTestnetType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("x-testnet-type", ClientUtils.ParameterToString(xTestnetType)); // header parameter
            }
            localVarRequestOptions.Data = deployNft;

            // authentication (X-API-Key) required
            if (!string.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("x-api-key")))
            {
                localVarRequestOptions.HeaderParameters.Add("x-api-key", Configuration.GetApiKeyWithPrefix("x-api-key"));
            }

            // make the HTTP request

            var localVarResponse = await AsynchronousClient.PostAsync<TransactionHash>("/v3/nft/deploy", localVarRequestOptions, Configuration, cancellationToken).ConfigureAwait(false);

            return localVarResponse;
        }

        /// <summary>
        /// Deploy an NFT smart contract 100 credits per API call on Flow 2 credits per API call on the other blockchains Deploy an NFT smart contract on the blockchain. In a deployed NFT smart contract, you can mint NFTs (one NFT at a time or multiple NFTs at once), burn, and transfer NFTs. Smart contracts are standardized and audited. You can review the code of a deployed NFT smart contract here (if the contract is deployed on Flow) or here (if the contract is deployed on any other supported blockchain). This API is supported for the following blockchains: BNB Smart Chain Celo Ethereum Flow Harmony Klaytn KuCoin Community Chain Polygon TRON General NFT smart contracts By default, an NFT smart contract is deployed as a general NFT smart contract compatible with OpenSea royalties. This is a standard NFT contract with AccessControl and Ownable, enhanced with NFT batch minting. NFTs minted on this smart contract are compatible with OpenSea and its royalty structure. Cashback and provenance NFT smart contracts In addition to the general NFT contract, you can deploy the following types of NFT smart contracts for the supported blockchains except for Flow and TRON: Cashback NFT smart contract is an NFT smart contract that forces on-chain royalties to be paid every time an NFT is transferred, and the royalties are defined as a fixed value. The royalties are not OpenSea-compatible. To deploy an NFT smart contract as a cashback contract, deploy the contract with the cashback parameter set to true in the request body. Provenance NFT smart contract is an NFT smart contract that forces on-chain royalties to be paid every time an NFT is transferred, and the royalties are defined as a percentage of the NFT price. The royalties are not OpenSea-compatible. To deploy an NFT smart contract as a provenance contract, deploy the contract with the provenance parameter set to true in the request body. You can enable public minting for cashback and provenance smart contracts. By default, public minting is disabled, which means that only the blockchain address whose private key was used to create the smart contract or the blockchain addresses added to the smart contract as NFT minters will be able to mint NFTs for the contract. To enable public minting and allow anyone to mint NFTs on top of the smart contract, deploy the contract with the publicMint parameter set to true in the request body. NFT smart contracts and NFT Express If you want to use NFT Express to mint NFTs on the deployed smart contract, deploy the smart contract as a general NFT smart contract (that is, deploy the contract with the cashback, provenance, and publicMint parameters either set to false or not set at all in the request body). After you have deployed the NFT smart contract, add the Tatum minter address as an NFT minter to your smart contract. For the complete information about using NFT Express on your smart contract, see \&quot;Use your own smart contract to mint NFTs\&quot; in Mint an NFT. Signing a transaction When deploying an NFT smart contract, you are charged a fee for the transaction, and you must sign the transaction with the private key of the blockchain address from which the fee will be deducted. Providing the private key in the API is not a secure way of signing transactions, because the private key can be stolen or exposed. Your private keys should never leave your security perimeter. You should use the private keys only for testing a solution you are building on the testnet of a blockchain. For signing transactions on the mainnet, we strongly recommend that you use the Tatum Key Management System (KMS) and provide the signature ID instead of the private key in the API. Alternatively, you can use the Tatum JavaScript client.
        /// </summary>
        /// <exception cref="Tatum.CSharp.Bsc.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="deployNftKMS"></param>
        /// <param name="xTestnetType">Type of Ethereum testnet. Defaults to Sepolia. Valid only for ETH invocations for testnet API Key. For mainnet API Key, this value is ignored. (optional, default to ethereum-sepolia)</param>
        /// <returns>SignatureId</returns>
        public SignatureId NftDeployErc721(DeployNftKMS deployNftKMS, string xTestnetType = default(string))
        {
            var localVarResponse = NftDeployErc721WithHttpInfo(deployNftKMS, xTestnetType);

            var exception = ExceptionFactory?.Invoke("NftDeployErc721_0", localVarResponse);
            if (exception != null) throw exception;

            return localVarResponse.Data;
        }

        /// <summary>
        /// Deploy an NFT smart contract 100 credits per API call on Flow 2 credits per API call on the other blockchains Deploy an NFT smart contract on the blockchain. In a deployed NFT smart contract, you can mint NFTs (one NFT at a time or multiple NFTs at once), burn, and transfer NFTs. Smart contracts are standardized and audited. You can review the code of a deployed NFT smart contract here (if the contract is deployed on Flow) or here (if the contract is deployed on any other supported blockchain). This API is supported for the following blockchains: BNB Smart Chain Celo Ethereum Flow Harmony Klaytn KuCoin Community Chain Polygon TRON General NFT smart contracts By default, an NFT smart contract is deployed as a general NFT smart contract compatible with OpenSea royalties. This is a standard NFT contract with AccessControl and Ownable, enhanced with NFT batch minting. NFTs minted on this smart contract are compatible with OpenSea and its royalty structure. Cashback and provenance NFT smart contracts In addition to the general NFT contract, you can deploy the following types of NFT smart contracts for the supported blockchains except for Flow and TRON: Cashback NFT smart contract is an NFT smart contract that forces on-chain royalties to be paid every time an NFT is transferred, and the royalties are defined as a fixed value. The royalties are not OpenSea-compatible. To deploy an NFT smart contract as a cashback contract, deploy the contract with the cashback parameter set to true in the request body. Provenance NFT smart contract is an NFT smart contract that forces on-chain royalties to be paid every time an NFT is transferred, and the royalties are defined as a percentage of the NFT price. The royalties are not OpenSea-compatible. To deploy an NFT smart contract as a provenance contract, deploy the contract with the provenance parameter set to true in the request body. You can enable public minting for cashback and provenance smart contracts. By default, public minting is disabled, which means that only the blockchain address whose private key was used to create the smart contract or the blockchain addresses added to the smart contract as NFT minters will be able to mint NFTs for the contract. To enable public minting and allow anyone to mint NFTs on top of the smart contract, deploy the contract with the publicMint parameter set to true in the request body. NFT smart contracts and NFT Express If you want to use NFT Express to mint NFTs on the deployed smart contract, deploy the smart contract as a general NFT smart contract (that is, deploy the contract with the cashback, provenance, and publicMint parameters either set to false or not set at all in the request body). After you have deployed the NFT smart contract, add the Tatum minter address as an NFT minter to your smart contract. For the complete information about using NFT Express on your smart contract, see \&quot;Use your own smart contract to mint NFTs\&quot; in Mint an NFT. Signing a transaction When deploying an NFT smart contract, you are charged a fee for the transaction, and you must sign the transaction with the private key of the blockchain address from which the fee will be deducted. Providing the private key in the API is not a secure way of signing transactions, because the private key can be stolen or exposed. Your private keys should never leave your security perimeter. You should use the private keys only for testing a solution you are building on the testnet of a blockchain. For signing transactions on the mainnet, we strongly recommend that you use the Tatum Key Management System (KMS) and provide the signature ID instead of the private key in the API. Alternatively, you can use the Tatum JavaScript client.
        /// </summary>
        /// <exception cref="Tatum.CSharp.Bsc.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="deployNftKMS"></param>
        /// <param name="xTestnetType">Type of Ethereum testnet. Defaults to Sepolia. Valid only for ETH invocations for testnet API Key. For mainnet API Key, this value is ignored. (optional, default to ethereum-sepolia)</param>
        /// <returns>ApiResponse of SignatureId</returns>
        public ApiResponse<SignatureId> NftDeployErc721WithHttpInfo(DeployNftKMS deployNftKMS, string xTestnetType = default(string))
        {
            // verify the required parameter 'deployNftKMS' is set
            if (deployNftKMS == null)
                throw new ApiException(400, "Missing required parameter 'deployNftKMS' when calling NFTBscApi->NftDeployErc721_0");

            var localVarRequestOptions = new RequestOptions();

            var contentTypes = new string[]{
                "application/json"
            };

            // to determine the Accept header
            var accepts = new string[]{
                "application/json"
            };

            var localVarContentType = ClientUtils.SelectHeaderContentType(contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = ClientUtils.SelectHeaderAccept(accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            if (xTestnetType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("x-testnet-type", ClientUtils.ParameterToString(xTestnetType)); // header parameter
            }
            localVarRequestOptions.Data = deployNftKMS;

            // authentication (X-API-Key) required
            if (!string.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("x-api-key")))
            {
                localVarRequestOptions.HeaderParameters.Add("x-api-key", Configuration.GetApiKeyWithPrefix("x-api-key"));
            }

            // make the HTTP request
            var localVarResponse = Client.Post<SignatureId>("/v3/nft/deploy", localVarRequestOptions, Configuration);

            return localVarResponse;
        }

        /// <summary>
        /// Deploy an NFT smart contract 100 credits per API call on Flow 2 credits per API call on the other blockchains Deploy an NFT smart contract on the blockchain. In a deployed NFT smart contract, you can mint NFTs (one NFT at a time or multiple NFTs at once), burn, and transfer NFTs. Smart contracts are standardized and audited. You can review the code of a deployed NFT smart contract here (if the contract is deployed on Flow) or here (if the contract is deployed on any other supported blockchain). This API is supported for the following blockchains: BNB Smart Chain Celo Ethereum Flow Harmony Klaytn KuCoin Community Chain Polygon TRON General NFT smart contracts By default, an NFT smart contract is deployed as a general NFT smart contract compatible with OpenSea royalties. This is a standard NFT contract with AccessControl and Ownable, enhanced with NFT batch minting. NFTs minted on this smart contract are compatible with OpenSea and its royalty structure. Cashback and provenance NFT smart contracts In addition to the general NFT contract, you can deploy the following types of NFT smart contracts for the supported blockchains except for Flow and TRON: Cashback NFT smart contract is an NFT smart contract that forces on-chain royalties to be paid every time an NFT is transferred, and the royalties are defined as a fixed value. The royalties are not OpenSea-compatible. To deploy an NFT smart contract as a cashback contract, deploy the contract with the cashback parameter set to true in the request body. Provenance NFT smart contract is an NFT smart contract that forces on-chain royalties to be paid every time an NFT is transferred, and the royalties are defined as a percentage of the NFT price. The royalties are not OpenSea-compatible. To deploy an NFT smart contract as a provenance contract, deploy the contract with the provenance parameter set to true in the request body. You can enable public minting for cashback and provenance smart contracts. By default, public minting is disabled, which means that only the blockchain address whose private key was used to create the smart contract or the blockchain addresses added to the smart contract as NFT minters will be able to mint NFTs for the contract. To enable public minting and allow anyone to mint NFTs on top of the smart contract, deploy the contract with the publicMint parameter set to true in the request body. NFT smart contracts and NFT Express If you want to use NFT Express to mint NFTs on the deployed smart contract, deploy the smart contract as a general NFT smart contract (that is, deploy the contract with the cashback, provenance, and publicMint parameters either set to false or not set at all in the request body). After you have deployed the NFT smart contract, add the Tatum minter address as an NFT minter to your smart contract. For the complete information about using NFT Express on your smart contract, see \&quot;Use your own smart contract to mint NFTs\&quot; in Mint an NFT. Signing a transaction When deploying an NFT smart contract, you are charged a fee for the transaction, and you must sign the transaction with the private key of the blockchain address from which the fee will be deducted. Providing the private key in the API is not a secure way of signing transactions, because the private key can be stolen or exposed. Your private keys should never leave your security perimeter. You should use the private keys only for testing a solution you are building on the testnet of a blockchain. For signing transactions on the mainnet, we strongly recommend that you use the Tatum Key Management System (KMS) and provide the signature ID instead of the private key in the API. Alternatively, you can use the Tatum JavaScript client.
        /// </summary>
        /// <exception cref="Tatum.CSharp.Bsc.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="deployNftKMS"></param>
        /// <param name="xTestnetType">Type of Ethereum testnet. Defaults to Sepolia. Valid only for ETH invocations for testnet API Key. For mainnet API Key, this value is ignored. (optional, default to ethereum-sepolia)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of SignatureId</returns>
        public async System.Threading.Tasks.Task<SignatureId> NftDeployErc721Async(DeployNftKMS deployNftKMS, string xTestnetType = default(string), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            var localVarResponse = await NftDeployErc721WithHttpInfoAsync(deployNftKMS, xTestnetType, cancellationToken).ConfigureAwait(false);
            
            var exception = ExceptionFactory?.Invoke("NftDeployErc721_0", localVarResponse);
            if (exception != null) throw exception;

            return localVarResponse.Data;
        }

        /// <summary>
        /// Deploy an NFT smart contract 100 credits per API call on Flow 2 credits per API call on the other blockchains Deploy an NFT smart contract on the blockchain. In a deployed NFT smart contract, you can mint NFTs (one NFT at a time or multiple NFTs at once), burn, and transfer NFTs. Smart contracts are standardized and audited. You can review the code of a deployed NFT smart contract here (if the contract is deployed on Flow) or here (if the contract is deployed on any other supported blockchain). This API is supported for the following blockchains: BNB Smart Chain Celo Ethereum Flow Harmony Klaytn KuCoin Community Chain Polygon TRON General NFT smart contracts By default, an NFT smart contract is deployed as a general NFT smart contract compatible with OpenSea royalties. This is a standard NFT contract with AccessControl and Ownable, enhanced with NFT batch minting. NFTs minted on this smart contract are compatible with OpenSea and its royalty structure. Cashback and provenance NFT smart contracts In addition to the general NFT contract, you can deploy the following types of NFT smart contracts for the supported blockchains except for Flow and TRON: Cashback NFT smart contract is an NFT smart contract that forces on-chain royalties to be paid every time an NFT is transferred, and the royalties are defined as a fixed value. The royalties are not OpenSea-compatible. To deploy an NFT smart contract as a cashback contract, deploy the contract with the cashback parameter set to true in the request body. Provenance NFT smart contract is an NFT smart contract that forces on-chain royalties to be paid every time an NFT is transferred, and the royalties are defined as a percentage of the NFT price. The royalties are not OpenSea-compatible. To deploy an NFT smart contract as a provenance contract, deploy the contract with the provenance parameter set to true in the request body. You can enable public minting for cashback and provenance smart contracts. By default, public minting is disabled, which means that only the blockchain address whose private key was used to create the smart contract or the blockchain addresses added to the smart contract as NFT minters will be able to mint NFTs for the contract. To enable public minting and allow anyone to mint NFTs on top of the smart contract, deploy the contract with the publicMint parameter set to true in the request body. NFT smart contracts and NFT Express If you want to use NFT Express to mint NFTs on the deployed smart contract, deploy the smart contract as a general NFT smart contract (that is, deploy the contract with the cashback, provenance, and publicMint parameters either set to false or not set at all in the request body). After you have deployed the NFT smart contract, add the Tatum minter address as an NFT minter to your smart contract. For the complete information about using NFT Express on your smart contract, see \&quot;Use your own smart contract to mint NFTs\&quot; in Mint an NFT. Signing a transaction When deploying an NFT smart contract, you are charged a fee for the transaction, and you must sign the transaction with the private key of the blockchain address from which the fee will be deducted. Providing the private key in the API is not a secure way of signing transactions, because the private key can be stolen or exposed. Your private keys should never leave your security perimeter. You should use the private keys only for testing a solution you are building on the testnet of a blockchain. For signing transactions on the mainnet, we strongly recommend that you use the Tatum Key Management System (KMS) and provide the signature ID instead of the private key in the API. Alternatively, you can use the Tatum JavaScript client.
        /// </summary>
        /// <exception cref="Tatum.CSharp.Bsc.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="deployNftKMS"></param>
        /// <param name="xTestnetType">Type of Ethereum testnet. Defaults to Sepolia. Valid only for ETH invocations for testnet API Key. For mainnet API Key, this value is ignored. (optional, default to ethereum-sepolia)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (SignatureId)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<SignatureId>> NftDeployErc721WithHttpInfoAsync(DeployNftKMS deployNftKMS, string xTestnetType = default(string), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            // verify the required parameter 'deployNftKMS' is set
            if (deployNftKMS == null)
                throw new ApiException(400, "Missing required parameter 'deployNftKMS' when calling NFTBscApi->NftDeployErc721_0");

            var localVarRequestOptions = new RequestOptions();

            var contentTypes = new string[]{
                "application/json"
            };

            // to determine the Accept header
            var accepts = new string[]{
                "application/json"
            };


            var localVarContentType = ClientUtils.SelectHeaderContentType(contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = ClientUtils.SelectHeaderAccept(accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            if (xTestnetType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("x-testnet-type", ClientUtils.ParameterToString(xTestnetType)); // header parameter
            }
            localVarRequestOptions.Data = deployNftKMS;

            // authentication (X-API-Key) required
            if (!string.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("x-api-key")))
            {
                localVarRequestOptions.HeaderParameters.Add("x-api-key", Configuration.GetApiKeyWithPrefix("x-api-key"));
            }

            // make the HTTP request

            var localVarResponse = await AsynchronousClient.PostAsync<SignatureId>("/v3/nft/deploy", localVarRequestOptions, Configuration, cancellationToken).ConfigureAwait(false);

            return localVarResponse;
        }

        /// <summary>
        /// Get the NFTs from a specific smart contract that a blockchain address holds 1 credit per API call Get the NFTs minted on a specific smart contract (the contractAddress path parameter in the request endpoint URL) that a blockchain address holds. NOTE: This API works only for the NFT smart contracts deployed using the Tatum smart contract API. This API is supported for the following blockchains: Algorand BNB Smart Chain Celo Elrond Ethereum Flow Harmony Klaytn KuCoin Community Chain Polygon Solana TRON
        /// </summary>
        /// <exception cref="Tatum.CSharp.Bsc.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="address">The blockchain address that you want to get the token balance of</param>
        /// <param name="contractAddress">The address of the NFT smart contract</param>
        /// <param name="xTestnetType">Type of Ethereum testnet. Defaults to Sepolia. Valid only for ETH invocations for testnet API Key. For mainnet API Key, this value is ignored. (optional, default to ethereum-sepolia)</param>
        /// <returns>NftGetBalanceSc</returns>
        public NftGetBalanceSc NftGetBalanceErc721(string address, string contractAddress, string xTestnetType = default(string))
        {
            var localVarResponse = NftGetBalanceErc721WithHttpInfo(address, contractAddress, xTestnetType);

            var exception = ExceptionFactory?.Invoke("NftGetBalanceErc721", localVarResponse);
            if (exception != null) throw exception;

            return localVarResponse.Data;
        }

        /// <summary>
        /// Get the NFTs from a specific smart contract that a blockchain address holds 1 credit per API call Get the NFTs minted on a specific smart contract (the contractAddress path parameter in the request endpoint URL) that a blockchain address holds. NOTE: This API works only for the NFT smart contracts deployed using the Tatum smart contract API. This API is supported for the following blockchains: Algorand BNB Smart Chain Celo Elrond Ethereum Flow Harmony Klaytn KuCoin Community Chain Polygon Solana TRON
        /// </summary>
        /// <exception cref="Tatum.CSharp.Bsc.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="address">The blockchain address that you want to get the token balance of</param>
        /// <param name="contractAddress">The address of the NFT smart contract</param>
        /// <param name="xTestnetType">Type of Ethereum testnet. Defaults to Sepolia. Valid only for ETH invocations for testnet API Key. For mainnet API Key, this value is ignored. (optional, default to ethereum-sepolia)</param>
        /// <returns>ApiResponse of NftGetBalanceSc</returns>
        public ApiResponse<NftGetBalanceSc> NftGetBalanceErc721WithHttpInfo(string address, string contractAddress, string xTestnetType = default(string))
        {
            // verify the required parameter 'address' is set
            if (address == null)
                throw new ApiException(400, "Missing required parameter 'address' when calling NFTBscApi->NftGetBalanceErc721");

            // verify the required parameter 'contractAddress' is set
            if (contractAddress == null)
                throw new ApiException(400, "Missing required parameter 'contractAddress' when calling NFTBscApi->NftGetBalanceErc721");

            var localVarRequestOptions = new RequestOptions();

            var contentTypes = new string[]{
            };

            // to determine the Accept header
            var accepts = new string[]{
                "application/json"
            };

            var localVarContentType = ClientUtils.SelectHeaderContentType(contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = ClientUtils.SelectHeaderAccept(accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.PathParameters.Add("address", ClientUtils.ParameterToString(address)); // path parameter
            localVarRequestOptions.PathParameters.Add("contractAddress", ClientUtils.ParameterToString(contractAddress)); // path parameter
            if (xTestnetType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("x-testnet-type", ClientUtils.ParameterToString(xTestnetType)); // header parameter
            }

            // authentication (X-API-Key) required
            if (!string.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("x-api-key")))
            {
                localVarRequestOptions.HeaderParameters.Add("x-api-key", Configuration.GetApiKeyWithPrefix("x-api-key"));
            }

            // make the HTTP request
            var localVarResponse = Client.Get<NftGetBalanceSc>("/v3/nft/balance/BSC/{contractAddress}/{address}", localVarRequestOptions, Configuration);

            return localVarResponse;
        }

        /// <summary>
        /// Get the NFTs from a specific smart contract that a blockchain address holds 1 credit per API call Get the NFTs minted on a specific smart contract (the contractAddress path parameter in the request endpoint URL) that a blockchain address holds. NOTE: This API works only for the NFT smart contracts deployed using the Tatum smart contract API. This API is supported for the following blockchains: Algorand BNB Smart Chain Celo Elrond Ethereum Flow Harmony Klaytn KuCoin Community Chain Polygon Solana TRON
        /// </summary>
        /// <exception cref="Tatum.CSharp.Bsc.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="address">The blockchain address that you want to get the token balance of</param>
        /// <param name="contractAddress">The address of the NFT smart contract</param>
        /// <param name="xTestnetType">Type of Ethereum testnet. Defaults to Sepolia. Valid only for ETH invocations for testnet API Key. For mainnet API Key, this value is ignored. (optional, default to ethereum-sepolia)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of NftGetBalanceSc</returns>
        public async System.Threading.Tasks.Task<NftGetBalanceSc> NftGetBalanceErc721Async(string address, string contractAddress, string xTestnetType = default(string), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            var localVarResponse = await NftGetBalanceErc721WithHttpInfoAsync(address, contractAddress, xTestnetType, cancellationToken).ConfigureAwait(false);
            
            var exception = ExceptionFactory?.Invoke("NftGetBalanceErc721", localVarResponse);
            if (exception != null) throw exception;

            return localVarResponse.Data;
        }

        /// <summary>
        /// Get the NFTs from a specific smart contract that a blockchain address holds 1 credit per API call Get the NFTs minted on a specific smart contract (the contractAddress path parameter in the request endpoint URL) that a blockchain address holds. NOTE: This API works only for the NFT smart contracts deployed using the Tatum smart contract API. This API is supported for the following blockchains: Algorand BNB Smart Chain Celo Elrond Ethereum Flow Harmony Klaytn KuCoin Community Chain Polygon Solana TRON
        /// </summary>
        /// <exception cref="Tatum.CSharp.Bsc.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="address">The blockchain address that you want to get the token balance of</param>
        /// <param name="contractAddress">The address of the NFT smart contract</param>
        /// <param name="xTestnetType">Type of Ethereum testnet. Defaults to Sepolia. Valid only for ETH invocations for testnet API Key. For mainnet API Key, this value is ignored. (optional, default to ethereum-sepolia)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (NftGetBalanceSc)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<NftGetBalanceSc>> NftGetBalanceErc721WithHttpInfoAsync(string address, string contractAddress, string xTestnetType = default(string), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            // verify the required parameter 'address' is set
            if (address == null)
                throw new ApiException(400, "Missing required parameter 'address' when calling NFTBscApi->NftGetBalanceErc721");

            // verify the required parameter 'contractAddress' is set
            if (contractAddress == null)
                throw new ApiException(400, "Missing required parameter 'contractAddress' when calling NFTBscApi->NftGetBalanceErc721");

            var localVarRequestOptions = new RequestOptions();

            var contentTypes = new string[]{
            };

            // to determine the Accept header
            var accepts = new string[]{
                "application/json"
            };


            var localVarContentType = ClientUtils.SelectHeaderContentType(contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = ClientUtils.SelectHeaderAccept(accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.PathParameters.Add("address", ClientUtils.ParameterToString(address)); // path parameter
            localVarRequestOptions.PathParameters.Add("contractAddress", ClientUtils.ParameterToString(contractAddress)); // path parameter
            if (xTestnetType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("x-testnet-type", ClientUtils.ParameterToString(xTestnetType)); // header parameter
            }

            // authentication (X-API-Key) required
            if (!string.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("x-api-key")))
            {
                localVarRequestOptions.HeaderParameters.Add("x-api-key", Configuration.GetApiKeyWithPrefix("x-api-key"));
            }

            // make the HTTP request

            var localVarResponse = await AsynchronousClient.GetAsync<NftGetBalanceSc>("/v3/nft/balance/BSC/{contractAddress}/{address}", localVarRequestOptions, Configuration, cancellationToken).ConfigureAwait(false);

            return localVarResponse;
        }

        /// <summary>
        /// Get NFT metadata 1 credit per API call Get metadata of an NFT. This API is supported for the following blockchains: BNB Smart Chain Celo Ethereum Flow Harmony Klaytn KuCoin Community Chain Polygon Solana TRON
        /// </summary>
        /// <exception cref="Tatum.CSharp.Bsc.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="contractAddress">The blockchain address of the NFT to get metadata for</param>
        /// <param name="tokenId">The ID of the NFT to get metadata for&lt;br/&gt;Do &lt;b&gt;not&lt;/b&gt; use this parameter if you are getting metadata for an NFT on Solana, this parameter is irrelevant on Solana.</param>
        /// <param name="account">(Flow only) The account that holds the NFT (optional)</param>
        /// <param name="xTestnetType">Type of Ethereum testnet. Defaults to Sepolia. Valid only for ETH invocations for testnet API Key. For mainnet API Key, this value is ignored. (optional, default to ethereum-sepolia)</param>
        /// <returns>NftMetadataErc721</returns>
        public NftMetadataErc721 NftGetMetadataErc721(string contractAddress, string tokenId, string account = default(string), string xTestnetType = default(string))
        {
            var localVarResponse = NftGetMetadataErc721WithHttpInfo(contractAddress, tokenId, account, xTestnetType);

            var exception = ExceptionFactory?.Invoke("NftGetMetadataErc721", localVarResponse);
            if (exception != null) throw exception;

            return localVarResponse.Data;
        }

        /// <summary>
        /// Get NFT metadata 1 credit per API call Get metadata of an NFT. This API is supported for the following blockchains: BNB Smart Chain Celo Ethereum Flow Harmony Klaytn KuCoin Community Chain Polygon Solana TRON
        /// </summary>
        /// <exception cref="Tatum.CSharp.Bsc.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="contractAddress">The blockchain address of the NFT to get metadata for</param>
        /// <param name="tokenId">The ID of the NFT to get metadata for&lt;br/&gt;Do &lt;b&gt;not&lt;/b&gt; use this parameter if you are getting metadata for an NFT on Solana, this parameter is irrelevant on Solana.</param>
        /// <param name="account">(Flow only) The account that holds the NFT (optional)</param>
        /// <param name="xTestnetType">Type of Ethereum testnet. Defaults to Sepolia. Valid only for ETH invocations for testnet API Key. For mainnet API Key, this value is ignored. (optional, default to ethereum-sepolia)</param>
        /// <returns>ApiResponse of NftMetadataErc721</returns>
        public ApiResponse<NftMetadataErc721> NftGetMetadataErc721WithHttpInfo(string contractAddress, string tokenId, string account = default(string), string xTestnetType = default(string))
        {
            // verify the required parameter 'contractAddress' is set
            if (contractAddress == null)
                throw new ApiException(400, "Missing required parameter 'contractAddress' when calling NFTBscApi->NftGetMetadataErc721");

            // verify the required parameter 'tokenId' is set
            if (tokenId == null)
                throw new ApiException(400, "Missing required parameter 'tokenId' when calling NFTBscApi->NftGetMetadataErc721");

            var localVarRequestOptions = new RequestOptions();

            var contentTypes = new string[]{
            };

            // to determine the Accept header
            var accepts = new string[]{
                "application/json"
            };

            var localVarContentType = ClientUtils.SelectHeaderContentType(contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = ClientUtils.SelectHeaderAccept(accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.PathParameters.Add("contractAddress", ClientUtils.ParameterToString(contractAddress)); // path parameter
            localVarRequestOptions.PathParameters.Add("tokenId", ClientUtils.ParameterToString(tokenId)); // path parameter
            if (account != null)
            {
                localVarRequestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "account", account));
            }
            if (xTestnetType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("x-testnet-type", ClientUtils.ParameterToString(xTestnetType)); // header parameter
            }

            // authentication (X-API-Key) required
            if (!string.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("x-api-key")))
            {
                localVarRequestOptions.HeaderParameters.Add("x-api-key", Configuration.GetApiKeyWithPrefix("x-api-key"));
            }

            // make the HTTP request
            var localVarResponse = Client.Get<NftMetadataErc721>("/v3/nft/metadata/BSC/{contractAddress}/{tokenId}", localVarRequestOptions, Configuration);

            return localVarResponse;
        }

        /// <summary>
        /// Get NFT metadata 1 credit per API call Get metadata of an NFT. This API is supported for the following blockchains: BNB Smart Chain Celo Ethereum Flow Harmony Klaytn KuCoin Community Chain Polygon Solana TRON
        /// </summary>
        /// <exception cref="Tatum.CSharp.Bsc.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="contractAddress">The blockchain address of the NFT to get metadata for</param>
        /// <param name="tokenId">The ID of the NFT to get metadata for&lt;br/&gt;Do &lt;b&gt;not&lt;/b&gt; use this parameter if you are getting metadata for an NFT on Solana, this parameter is irrelevant on Solana.</param>
        /// <param name="account">(Flow only) The account that holds the NFT (optional)</param>
        /// <param name="xTestnetType">Type of Ethereum testnet. Defaults to Sepolia. Valid only for ETH invocations for testnet API Key. For mainnet API Key, this value is ignored. (optional, default to ethereum-sepolia)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of NftMetadataErc721</returns>
        public async System.Threading.Tasks.Task<NftMetadataErc721> NftGetMetadataErc721Async(string contractAddress, string tokenId, string account = default(string), string xTestnetType = default(string), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            var localVarResponse = await NftGetMetadataErc721WithHttpInfoAsync(contractAddress, tokenId, account, xTestnetType, cancellationToken).ConfigureAwait(false);
            
            var exception = ExceptionFactory?.Invoke("NftGetMetadataErc721", localVarResponse);
            if (exception != null) throw exception;

            return localVarResponse.Data;
        }

        /// <summary>
        /// Get NFT metadata 1 credit per API call Get metadata of an NFT. This API is supported for the following blockchains: BNB Smart Chain Celo Ethereum Flow Harmony Klaytn KuCoin Community Chain Polygon Solana TRON
        /// </summary>
        /// <exception cref="Tatum.CSharp.Bsc.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="contractAddress">The blockchain address of the NFT to get metadata for</param>
        /// <param name="tokenId">The ID of the NFT to get metadata for&lt;br/&gt;Do &lt;b&gt;not&lt;/b&gt; use this parameter if you are getting metadata for an NFT on Solana, this parameter is irrelevant on Solana.</param>
        /// <param name="account">(Flow only) The account that holds the NFT (optional)</param>
        /// <param name="xTestnetType">Type of Ethereum testnet. Defaults to Sepolia. Valid only for ETH invocations for testnet API Key. For mainnet API Key, this value is ignored. (optional, default to ethereum-sepolia)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (NftMetadataErc721)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<NftMetadataErc721>> NftGetMetadataErc721WithHttpInfoAsync(string contractAddress, string tokenId, string account = default(string), string xTestnetType = default(string), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            // verify the required parameter 'contractAddress' is set
            if (contractAddress == null)
                throw new ApiException(400, "Missing required parameter 'contractAddress' when calling NFTBscApi->NftGetMetadataErc721");

            // verify the required parameter 'tokenId' is set
            if (tokenId == null)
                throw new ApiException(400, "Missing required parameter 'tokenId' when calling NFTBscApi->NftGetMetadataErc721");

            var localVarRequestOptions = new RequestOptions();

            var contentTypes = new string[]{
            };

            // to determine the Accept header
            var accepts = new string[]{
                "application/json"
            };


            var localVarContentType = ClientUtils.SelectHeaderContentType(contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = ClientUtils.SelectHeaderAccept(accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.PathParameters.Add("contractAddress", ClientUtils.ParameterToString(contractAddress)); // path parameter
            localVarRequestOptions.PathParameters.Add("tokenId", ClientUtils.ParameterToString(tokenId)); // path parameter
            if (account != null)
            {
                localVarRequestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "account", account));
            }
            if (xTestnetType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("x-testnet-type", ClientUtils.ParameterToString(xTestnetType)); // header parameter
            }

            // authentication (X-API-Key) required
            if (!string.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("x-api-key")))
            {
                localVarRequestOptions.HeaderParameters.Add("x-api-key", Configuration.GetApiKeyWithPrefix("x-api-key"));
            }

            // make the HTTP request

            var localVarResponse = await AsynchronousClient.GetAsync<NftMetadataErc721>("/v3/nft/metadata/BSC/{contractAddress}/{tokenId}", localVarRequestOptions, Configuration, cancellationToken).ConfigureAwait(false);

            return localVarResponse;
        }

        /// <summary>
        /// Get NFT provenance information 1 credit per API call Get provenance information for an NFT. NOTE: This API works only for provenance NFT smart contracts. This API is supported for the following blockchains: BNB Smart Chain Celo Ethereum Harmony Klaytn KuCoin Community Chain Polygon
        /// </summary>
        /// <exception cref="Tatum.CSharp.Bsc.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="contractAddress">The blockchain address of the NFT to get provenance information for</param>
        /// <param name="tokenId">The ID of the NFT to get provenance information for.</param>
        /// <param name="xTestnetType">Type of Ethereum testnet. Defaults to Sepolia. Valid only for ETH invocations for testnet API Key. For mainnet API Key, this value is ignored. (optional, default to ethereum-sepolia)</param>
        /// <returns>List&lt;NftProvenanceDataErc721&gt;</returns>
        public List<NftProvenanceDataErc721> NftGetProvenanceDataErc721(string contractAddress, string tokenId, string xTestnetType = default(string))
        {
            var localVarResponse = NftGetProvenanceDataErc721WithHttpInfo(contractAddress, tokenId, xTestnetType);

            var exception = ExceptionFactory?.Invoke("NftGetProvenanceDataErc721", localVarResponse);
            if (exception != null) throw exception;

            return localVarResponse.Data;
        }

        /// <summary>
        /// Get NFT provenance information 1 credit per API call Get provenance information for an NFT. NOTE: This API works only for provenance NFT smart contracts. This API is supported for the following blockchains: BNB Smart Chain Celo Ethereum Harmony Klaytn KuCoin Community Chain Polygon
        /// </summary>
        /// <exception cref="Tatum.CSharp.Bsc.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="contractAddress">The blockchain address of the NFT to get provenance information for</param>
        /// <param name="tokenId">The ID of the NFT to get provenance information for.</param>
        /// <param name="xTestnetType">Type of Ethereum testnet. Defaults to Sepolia. Valid only for ETH invocations for testnet API Key. For mainnet API Key, this value is ignored. (optional, default to ethereum-sepolia)</param>
        /// <returns>ApiResponse of List&lt;NftProvenanceDataErc721&gt;</returns>
        public ApiResponse<List<NftProvenanceDataErc721>> NftGetProvenanceDataErc721WithHttpInfo(string contractAddress, string tokenId, string xTestnetType = default(string))
        {
            // verify the required parameter 'contractAddress' is set
            if (contractAddress == null)
                throw new ApiException(400, "Missing required parameter 'contractAddress' when calling NFTBscApi->NftGetProvenanceDataErc721");

            // verify the required parameter 'tokenId' is set
            if (tokenId == null)
                throw new ApiException(400, "Missing required parameter 'tokenId' when calling NFTBscApi->NftGetProvenanceDataErc721");

            var localVarRequestOptions = new RequestOptions();

            var contentTypes = new string[]{
            };

            // to determine the Accept header
            var accepts = new string[]{
                "application/json"
            };

            var localVarContentType = ClientUtils.SelectHeaderContentType(contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = ClientUtils.SelectHeaderAccept(accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.PathParameters.Add("contractAddress", ClientUtils.ParameterToString(contractAddress)); // path parameter
            localVarRequestOptions.PathParameters.Add("tokenId", ClientUtils.ParameterToString(tokenId)); // path parameter
            if (xTestnetType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("x-testnet-type", ClientUtils.ParameterToString(xTestnetType)); // header parameter
            }

            // authentication (X-API-Key) required
            if (!string.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("x-api-key")))
            {
                localVarRequestOptions.HeaderParameters.Add("x-api-key", Configuration.GetApiKeyWithPrefix("x-api-key"));
            }

            // make the HTTP request
            var localVarResponse = Client.Get<List<NftProvenanceDataErc721>>("/v3/nft/provenance/BSC/{contractAddress}/{tokenId}", localVarRequestOptions, Configuration);

            return localVarResponse;
        }

        /// <summary>
        /// Get NFT provenance information 1 credit per API call Get provenance information for an NFT. NOTE: This API works only for provenance NFT smart contracts. This API is supported for the following blockchains: BNB Smart Chain Celo Ethereum Harmony Klaytn KuCoin Community Chain Polygon
        /// </summary>
        /// <exception cref="Tatum.CSharp.Bsc.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="contractAddress">The blockchain address of the NFT to get provenance information for</param>
        /// <param name="tokenId">The ID of the NFT to get provenance information for.</param>
        /// <param name="xTestnetType">Type of Ethereum testnet. Defaults to Sepolia. Valid only for ETH invocations for testnet API Key. For mainnet API Key, this value is ignored. (optional, default to ethereum-sepolia)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of List&lt;NftProvenanceDataErc721&gt;</returns>
        public async System.Threading.Tasks.Task<List<NftProvenanceDataErc721>> NftGetProvenanceDataErc721Async(string contractAddress, string tokenId, string xTestnetType = default(string), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            var localVarResponse = await NftGetProvenanceDataErc721WithHttpInfoAsync(contractAddress, tokenId, xTestnetType, cancellationToken).ConfigureAwait(false);
            
            var exception = ExceptionFactory?.Invoke("NftGetProvenanceDataErc721", localVarResponse);
            if (exception != null) throw exception;

            return localVarResponse.Data;
        }

        /// <summary>
        /// Get NFT provenance information 1 credit per API call Get provenance information for an NFT. NOTE: This API works only for provenance NFT smart contracts. This API is supported for the following blockchains: BNB Smart Chain Celo Ethereum Harmony Klaytn KuCoin Community Chain Polygon
        /// </summary>
        /// <exception cref="Tatum.CSharp.Bsc.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="contractAddress">The blockchain address of the NFT to get provenance information for</param>
        /// <param name="tokenId">The ID of the NFT to get provenance information for.</param>
        /// <param name="xTestnetType">Type of Ethereum testnet. Defaults to Sepolia. Valid only for ETH invocations for testnet API Key. For mainnet API Key, this value is ignored. (optional, default to ethereum-sepolia)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (List&lt;NftProvenanceDataErc721&gt;)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<List<NftProvenanceDataErc721>>> NftGetProvenanceDataErc721WithHttpInfoAsync(string contractAddress, string tokenId, string xTestnetType = default(string), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            // verify the required parameter 'contractAddress' is set
            if (contractAddress == null)
                throw new ApiException(400, "Missing required parameter 'contractAddress' when calling NFTBscApi->NftGetProvenanceDataErc721");

            // verify the required parameter 'tokenId' is set
            if (tokenId == null)
                throw new ApiException(400, "Missing required parameter 'tokenId' when calling NFTBscApi->NftGetProvenanceDataErc721");

            var localVarRequestOptions = new RequestOptions();

            var contentTypes = new string[]{
            };

            // to determine the Accept header
            var accepts = new string[]{
                "application/json"
            };


            var localVarContentType = ClientUtils.SelectHeaderContentType(contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = ClientUtils.SelectHeaderAccept(accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.PathParameters.Add("contractAddress", ClientUtils.ParameterToString(contractAddress)); // path parameter
            localVarRequestOptions.PathParameters.Add("tokenId", ClientUtils.ParameterToString(tokenId)); // path parameter
            if (xTestnetType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("x-testnet-type", ClientUtils.ParameterToString(xTestnetType)); // header parameter
            }

            // authentication (X-API-Key) required
            if (!string.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("x-api-key")))
            {
                localVarRequestOptions.HeaderParameters.Add("x-api-key", Configuration.GetApiKeyWithPrefix("x-api-key"));
            }

            // make the HTTP request

            var localVarResponse = await AsynchronousClient.GetAsync<List<NftProvenanceDataErc721>>("/v3/nft/provenance/BSC/{contractAddress}/{tokenId}", localVarRequestOptions, Configuration, cancellationToken).ConfigureAwait(false);

            return localVarResponse;
        }

        /// <summary>
        /// Get NFT royalty information 1 credit per API call Get information about royalties for an NFT. This API is supported for the following blockchains: BNB Smart Chain Celo Ethereum Harmony Klaytn KuCoin Community Chain Polygon Solana TRON
        /// </summary>
        /// <exception cref="Tatum.CSharp.Bsc.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="contractAddress">The blockchain address of the NFT to get royalty information for</param>
        /// <param name="tokenId">The ID of the NFT to get royalty information for&lt;br/&gt;Do &lt;b&gt;not&lt;/b&gt; use this parameter if you are getting metadata for an NFT on Solana, this parameter is irrelevant on Solana.</param>
        /// <param name="xTestnetType">Type of Ethereum testnet. Defaults to Sepolia. Valid only for ETH invocations for testnet API Key. For mainnet API Key, this value is ignored. (optional, default to ethereum-sepolia)</param>
        /// <returns>NftRoyaltyErc721</returns>
        public NftRoyaltyErc721 NftGetRoyaltyErc721(string contractAddress, string tokenId, string xTestnetType = default(string))
        {
            var localVarResponse = NftGetRoyaltyErc721WithHttpInfo(contractAddress, tokenId, xTestnetType);

            var exception = ExceptionFactory?.Invoke("NftGetRoyaltyErc721", localVarResponse);
            if (exception != null) throw exception;

            return localVarResponse.Data;
        }

        /// <summary>
        /// Get NFT royalty information 1 credit per API call Get information about royalties for an NFT. This API is supported for the following blockchains: BNB Smart Chain Celo Ethereum Harmony Klaytn KuCoin Community Chain Polygon Solana TRON
        /// </summary>
        /// <exception cref="Tatum.CSharp.Bsc.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="contractAddress">The blockchain address of the NFT to get royalty information for</param>
        /// <param name="tokenId">The ID of the NFT to get royalty information for&lt;br/&gt;Do &lt;b&gt;not&lt;/b&gt; use this parameter if you are getting metadata for an NFT on Solana, this parameter is irrelevant on Solana.</param>
        /// <param name="xTestnetType">Type of Ethereum testnet. Defaults to Sepolia. Valid only for ETH invocations for testnet API Key. For mainnet API Key, this value is ignored. (optional, default to ethereum-sepolia)</param>
        /// <returns>ApiResponse of NftRoyaltyErc721</returns>
        public ApiResponse<NftRoyaltyErc721> NftGetRoyaltyErc721WithHttpInfo(string contractAddress, string tokenId, string xTestnetType = default(string))
        {
            // verify the required parameter 'contractAddress' is set
            if (contractAddress == null)
                throw new ApiException(400, "Missing required parameter 'contractAddress' when calling NFTBscApi->NftGetRoyaltyErc721");

            // verify the required parameter 'tokenId' is set
            if (tokenId == null)
                throw new ApiException(400, "Missing required parameter 'tokenId' when calling NFTBscApi->NftGetRoyaltyErc721");

            var localVarRequestOptions = new RequestOptions();

            var contentTypes = new string[]{
            };

            // to determine the Accept header
            var accepts = new string[]{
                "application/json"
            };

            var localVarContentType = ClientUtils.SelectHeaderContentType(contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = ClientUtils.SelectHeaderAccept(accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.PathParameters.Add("contractAddress", ClientUtils.ParameterToString(contractAddress)); // path parameter
            localVarRequestOptions.PathParameters.Add("tokenId", ClientUtils.ParameterToString(tokenId)); // path parameter
            if (xTestnetType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("x-testnet-type", ClientUtils.ParameterToString(xTestnetType)); // header parameter
            }

            // authentication (X-API-Key) required
            if (!string.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("x-api-key")))
            {
                localVarRequestOptions.HeaderParameters.Add("x-api-key", Configuration.GetApiKeyWithPrefix("x-api-key"));
            }

            // make the HTTP request
            var localVarResponse = Client.Get<NftRoyaltyErc721>("/v3/nft/royalty/BSC/{contractAddress}/{tokenId}", localVarRequestOptions, Configuration);

            return localVarResponse;
        }

        /// <summary>
        /// Get NFT royalty information 1 credit per API call Get information about royalties for an NFT. This API is supported for the following blockchains: BNB Smart Chain Celo Ethereum Harmony Klaytn KuCoin Community Chain Polygon Solana TRON
        /// </summary>
        /// <exception cref="Tatum.CSharp.Bsc.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="contractAddress">The blockchain address of the NFT to get royalty information for</param>
        /// <param name="tokenId">The ID of the NFT to get royalty information for&lt;br/&gt;Do &lt;b&gt;not&lt;/b&gt; use this parameter if you are getting metadata for an NFT on Solana, this parameter is irrelevant on Solana.</param>
        /// <param name="xTestnetType">Type of Ethereum testnet. Defaults to Sepolia. Valid only for ETH invocations for testnet API Key. For mainnet API Key, this value is ignored. (optional, default to ethereum-sepolia)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of NftRoyaltyErc721</returns>
        public async System.Threading.Tasks.Task<NftRoyaltyErc721> NftGetRoyaltyErc721Async(string contractAddress, string tokenId, string xTestnetType = default(string), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            var localVarResponse = await NftGetRoyaltyErc721WithHttpInfoAsync(contractAddress, tokenId, xTestnetType, cancellationToken).ConfigureAwait(false);
            
            var exception = ExceptionFactory?.Invoke("NftGetRoyaltyErc721", localVarResponse);
            if (exception != null) throw exception;

            return localVarResponse.Data;
        }

        /// <summary>
        /// Get NFT royalty information 1 credit per API call Get information about royalties for an NFT. This API is supported for the following blockchains: BNB Smart Chain Celo Ethereum Harmony Klaytn KuCoin Community Chain Polygon Solana TRON
        /// </summary>
        /// <exception cref="Tatum.CSharp.Bsc.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="contractAddress">The blockchain address of the NFT to get royalty information for</param>
        /// <param name="tokenId">The ID of the NFT to get royalty information for&lt;br/&gt;Do &lt;b&gt;not&lt;/b&gt; use this parameter if you are getting metadata for an NFT on Solana, this parameter is irrelevant on Solana.</param>
        /// <param name="xTestnetType">Type of Ethereum testnet. Defaults to Sepolia. Valid only for ETH invocations for testnet API Key. For mainnet API Key, this value is ignored. (optional, default to ethereum-sepolia)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (NftRoyaltyErc721)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<NftRoyaltyErc721>> NftGetRoyaltyErc721WithHttpInfoAsync(string contractAddress, string tokenId, string xTestnetType = default(string), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            // verify the required parameter 'contractAddress' is set
            if (contractAddress == null)
                throw new ApiException(400, "Missing required parameter 'contractAddress' when calling NFTBscApi->NftGetRoyaltyErc721");

            // verify the required parameter 'tokenId' is set
            if (tokenId == null)
                throw new ApiException(400, "Missing required parameter 'tokenId' when calling NFTBscApi->NftGetRoyaltyErc721");

            var localVarRequestOptions = new RequestOptions();

            var contentTypes = new string[]{
            };

            // to determine the Accept header
            var accepts = new string[]{
                "application/json"
            };


            var localVarContentType = ClientUtils.SelectHeaderContentType(contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = ClientUtils.SelectHeaderAccept(accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.PathParameters.Add("contractAddress", ClientUtils.ParameterToString(contractAddress)); // path parameter
            localVarRequestOptions.PathParameters.Add("tokenId", ClientUtils.ParameterToString(tokenId)); // path parameter
            if (xTestnetType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("x-testnet-type", ClientUtils.ParameterToString(xTestnetType)); // header parameter
            }

            // authentication (X-API-Key) required
            if (!string.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("x-api-key")))
            {
                localVarRequestOptions.HeaderParameters.Add("x-api-key", Configuration.GetApiKeyWithPrefix("x-api-key"));
            }

            // make the HTTP request

            var localVarResponse = await AsynchronousClient.GetAsync<NftRoyaltyErc721>("/v3/nft/royalty/BSC/{contractAddress}/{tokenId}", localVarRequestOptions, Configuration, cancellationToken).ConfigureAwait(false);

            return localVarResponse;
        }

        /// <summary>
        /// Get all NFTs that a blockchain address holds 1 credit per API call + 5 credits for each owned NFT Get all NFTs that a blockchain address holds. The NFTs are returned grouped by the smart contracts they were minted on. This API is supported for the following blockchains: Algorand BNB Smart Chain - mainnet only Celo Ethereum Polygon Solana On Solana and Algorand, if a blockchain address holds fewer than 50 NFTs, the API also returns each NFT&#39;s metadata. If the metadata is not returned, you can obtain it using the API for getting NFT metadata.
        /// </summary>
        /// <exception cref="Tatum.CSharp.Bsc.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="address">The blockchain address that you want to get the token balance of</param>
        /// <returns>List&lt;NftTokenByAddressErc721&gt;</returns>
        public List<NftTokenByAddressErc721> NftGetTokensByAddressErc721(string address)
        {
            var localVarResponse = NftGetTokensByAddressErc721WithHttpInfo(address);

            var exception = ExceptionFactory?.Invoke("NftGetTokensByAddressErc721", localVarResponse);
            if (exception != null) throw exception;

            return localVarResponse.Data;
        }

        /// <summary>
        /// Get all NFTs that a blockchain address holds 1 credit per API call + 5 credits for each owned NFT Get all NFTs that a blockchain address holds. The NFTs are returned grouped by the smart contracts they were minted on. This API is supported for the following blockchains: Algorand BNB Smart Chain - mainnet only Celo Ethereum Polygon Solana On Solana and Algorand, if a blockchain address holds fewer than 50 NFTs, the API also returns each NFT&#39;s metadata. If the metadata is not returned, you can obtain it using the API for getting NFT metadata.
        /// </summary>
        /// <exception cref="Tatum.CSharp.Bsc.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="address">The blockchain address that you want to get the token balance of</param>
        /// <returns>ApiResponse of List&lt;NftTokenByAddressErc721&gt;</returns>
        public ApiResponse<List<NftTokenByAddressErc721>> NftGetTokensByAddressErc721WithHttpInfo(string address)
        {
            // verify the required parameter 'address' is set
            if (address == null)
                throw new ApiException(400, "Missing required parameter 'address' when calling NFTBscApi->NftGetTokensByAddressErc721");

            var localVarRequestOptions = new RequestOptions();

            var contentTypes = new string[]{
            };

            // to determine the Accept header
            var accepts = new string[]{
                "application/json"
            };

            var localVarContentType = ClientUtils.SelectHeaderContentType(contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = ClientUtils.SelectHeaderAccept(accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.PathParameters.Add("address", ClientUtils.ParameterToString(address)); // path parameter

            // authentication (X-API-Key) required
            if (!string.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("x-api-key")))
            {
                localVarRequestOptions.HeaderParameters.Add("x-api-key", Configuration.GetApiKeyWithPrefix("x-api-key"));
            }

            // make the HTTP request
            var localVarResponse = Client.Get<List<NftTokenByAddressErc721>>("/v3/nft/address/balance/BSC/{address}", localVarRequestOptions, Configuration);

            return localVarResponse;
        }

        /// <summary>
        /// Get all NFTs that a blockchain address holds 1 credit per API call + 5 credits for each owned NFT Get all NFTs that a blockchain address holds. The NFTs are returned grouped by the smart contracts they were minted on. This API is supported for the following blockchains: Algorand BNB Smart Chain - mainnet only Celo Ethereum Polygon Solana On Solana and Algorand, if a blockchain address holds fewer than 50 NFTs, the API also returns each NFT&#39;s metadata. If the metadata is not returned, you can obtain it using the API for getting NFT metadata.
        /// </summary>
        /// <exception cref="Tatum.CSharp.Bsc.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="address">The blockchain address that you want to get the token balance of</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of List&lt;NftTokenByAddressErc721&gt;</returns>
        public async System.Threading.Tasks.Task<List<NftTokenByAddressErc721>> NftGetTokensByAddressErc721Async(string address, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            var localVarResponse = await NftGetTokensByAddressErc721WithHttpInfoAsync(address, cancellationToken).ConfigureAwait(false);
            
            var exception = ExceptionFactory?.Invoke("NftGetTokensByAddressErc721", localVarResponse);
            if (exception != null) throw exception;

            return localVarResponse.Data;
        }

        /// <summary>
        /// Get all NFTs that a blockchain address holds 1 credit per API call + 5 credits for each owned NFT Get all NFTs that a blockchain address holds. The NFTs are returned grouped by the smart contracts they were minted on. This API is supported for the following blockchains: Algorand BNB Smart Chain - mainnet only Celo Ethereum Polygon Solana On Solana and Algorand, if a blockchain address holds fewer than 50 NFTs, the API also returns each NFT&#39;s metadata. If the metadata is not returned, you can obtain it using the API for getting NFT metadata.
        /// </summary>
        /// <exception cref="Tatum.CSharp.Bsc.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="address">The blockchain address that you want to get the token balance of</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (List&lt;NftTokenByAddressErc721&gt;)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<List<NftTokenByAddressErc721>>> NftGetTokensByAddressErc721WithHttpInfoAsync(string address, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            // verify the required parameter 'address' is set
            if (address == null)
                throw new ApiException(400, "Missing required parameter 'address' when calling NFTBscApi->NftGetTokensByAddressErc721");

            var localVarRequestOptions = new RequestOptions();

            var contentTypes = new string[]{
            };

            // to determine the Accept header
            var accepts = new string[]{
                "application/json"
            };


            var localVarContentType = ClientUtils.SelectHeaderContentType(contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = ClientUtils.SelectHeaderAccept(accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.PathParameters.Add("address", ClientUtils.ParameterToString(address)); // path parameter

            // authentication (X-API-Key) required
            if (!string.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("x-api-key")))
            {
                localVarRequestOptions.HeaderParameters.Add("x-api-key", Configuration.GetApiKeyWithPrefix("x-api-key"));
            }

            // make the HTTP request

            var localVarResponse = await AsynchronousClient.GetAsync<List<NftTokenByAddressErc721>>("/v3/nft/address/balance/BSC/{address}", localVarRequestOptions, Configuration, cancellationToken).ConfigureAwait(false);

            return localVarResponse;
        }

        /// <summary>
        /// Get an NFT transaction by its hash 1 credit per API call Get an NFT transaction by its hash. This API is supported for the following blockchains: BNB Smart Chain Celo Ethereum Flow Harmony Klaytn KuCoin Community Chain Polygon TRON
        /// </summary>
        /// <exception cref="Tatum.CSharp.Bsc.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="hash">The hash (ID) of the NFT transaction</param>
        /// <param name="xTestnetType">Type of Ethereum testnet. Defaults to Sepolia. Valid only for ETH invocations for testnet API Key. For mainnet API Key, this value is ignored. (optional, default to ethereum-sepolia)</param>
        /// <returns>EthTx</returns>
        public EthTx NftGetTransactErc721(string hash, string xTestnetType = default(string))
        {
            var localVarResponse = NftGetTransactErc721WithHttpInfo(hash, xTestnetType);

            var exception = ExceptionFactory?.Invoke("NftGetTransactErc721", localVarResponse);
            if (exception != null) throw exception;

            return localVarResponse.Data;
        }

        /// <summary>
        /// Get an NFT transaction by its hash 1 credit per API call Get an NFT transaction by its hash. This API is supported for the following blockchains: BNB Smart Chain Celo Ethereum Flow Harmony Klaytn KuCoin Community Chain Polygon TRON
        /// </summary>
        /// <exception cref="Tatum.CSharp.Bsc.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="hash">The hash (ID) of the NFT transaction</param>
        /// <param name="xTestnetType">Type of Ethereum testnet. Defaults to Sepolia. Valid only for ETH invocations for testnet API Key. For mainnet API Key, this value is ignored. (optional, default to ethereum-sepolia)</param>
        /// <returns>ApiResponse of EthTx</returns>
        public ApiResponse<EthTx> NftGetTransactErc721WithHttpInfo(string hash, string xTestnetType = default(string))
        {
            // verify the required parameter 'hash' is set
            if (hash == null)
                throw new ApiException(400, "Missing required parameter 'hash' when calling NFTBscApi->NftGetTransactErc721");

            var localVarRequestOptions = new RequestOptions();

            var contentTypes = new string[]{
            };

            // to determine the Accept header
            var accepts = new string[]{
                "application/json"
            };

            var localVarContentType = ClientUtils.SelectHeaderContentType(contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = ClientUtils.SelectHeaderAccept(accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.PathParameters.Add("hash", ClientUtils.ParameterToString(hash)); // path parameter
            if (xTestnetType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("x-testnet-type", ClientUtils.ParameterToString(xTestnetType)); // header parameter
            }

            // authentication (X-API-Key) required
            if (!string.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("x-api-key")))
            {
                localVarRequestOptions.HeaderParameters.Add("x-api-key", Configuration.GetApiKeyWithPrefix("x-api-key"));
            }

            // make the HTTP request
            var localVarResponse = Client.Get<EthTx>("/v3/nft/transaction/BSC/{hash}", localVarRequestOptions, Configuration);

            return localVarResponse;
        }

        /// <summary>
        /// Get an NFT transaction by its hash 1 credit per API call Get an NFT transaction by its hash. This API is supported for the following blockchains: BNB Smart Chain Celo Ethereum Flow Harmony Klaytn KuCoin Community Chain Polygon TRON
        /// </summary>
        /// <exception cref="Tatum.CSharp.Bsc.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="hash">The hash (ID) of the NFT transaction</param>
        /// <param name="xTestnetType">Type of Ethereum testnet. Defaults to Sepolia. Valid only for ETH invocations for testnet API Key. For mainnet API Key, this value is ignored. (optional, default to ethereum-sepolia)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of EthTx</returns>
        public async System.Threading.Tasks.Task<EthTx> NftGetTransactErc721Async(string hash, string xTestnetType = default(string), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            var localVarResponse = await NftGetTransactErc721WithHttpInfoAsync(hash, xTestnetType, cancellationToken).ConfigureAwait(false);
            
            var exception = ExceptionFactory?.Invoke("NftGetTransactErc721", localVarResponse);
            if (exception != null) throw exception;

            return localVarResponse.Data;
        }

        /// <summary>
        /// Get an NFT transaction by its hash 1 credit per API call Get an NFT transaction by its hash. This API is supported for the following blockchains: BNB Smart Chain Celo Ethereum Flow Harmony Klaytn KuCoin Community Chain Polygon TRON
        /// </summary>
        /// <exception cref="Tatum.CSharp.Bsc.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="hash">The hash (ID) of the NFT transaction</param>
        /// <param name="xTestnetType">Type of Ethereum testnet. Defaults to Sepolia. Valid only for ETH invocations for testnet API Key. For mainnet API Key, this value is ignored. (optional, default to ethereum-sepolia)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (EthTx)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<EthTx>> NftGetTransactErc721WithHttpInfoAsync(string hash, string xTestnetType = default(string), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            // verify the required parameter 'hash' is set
            if (hash == null)
                throw new ApiException(400, "Missing required parameter 'hash' when calling NFTBscApi->NftGetTransactErc721");

            var localVarRequestOptions = new RequestOptions();

            var contentTypes = new string[]{
            };

            // to determine the Accept header
            var accepts = new string[]{
                "application/json"
            };


            var localVarContentType = ClientUtils.SelectHeaderContentType(contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = ClientUtils.SelectHeaderAccept(accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.PathParameters.Add("hash", ClientUtils.ParameterToString(hash)); // path parameter
            if (xTestnetType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("x-testnet-type", ClientUtils.ParameterToString(xTestnetType)); // header parameter
            }

            // authentication (X-API-Key) required
            if (!string.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("x-api-key")))
            {
                localVarRequestOptions.HeaderParameters.Add("x-api-key", Configuration.GetApiKeyWithPrefix("x-api-key"));
            }

            // make the HTTP request

            var localVarResponse = await AsynchronousClient.GetAsync<EthTx>("/v3/nft/transaction/BSC/{hash}", localVarRequestOptions, Configuration, cancellationToken).ConfigureAwait(false);

            return localVarResponse;
        }

        /// <summary>
        /// Mint an NFT 100 credits per API call on Flow 2 credits per API call on the other blockchains You can mint NFTs using either of the following methods: Using NFT Express Natively on a blockchain Minting NFTs using NFT Express NFT Express is Tatum&#39;s feature that helps you mint NFTs easier than minting natively on a blockchain. You do not need to enter your private key or signature ID. NFT Express uses the private key provided by Tatum. You do not need to hold crypto or keep addresses topped up with crypto to pay for minting transactions. To use NFT Express on the mainnet, you have to have a paid pricing plan. Tatum covers your transaction fees for NFT minting and pays for them from its own blockchain address. Then, the fee amount paid by Tatum is converted to the number of credits, and these credits are deducted from the monthly credit allowance of your paid pricing plan. The transaction fees and the corresponding numbers of credits deducted from your allowance vary depending on what blockchain you mint NFTs on. On the testnet, no credits are deducted from the monthly credit allowance. You can mint NFTs with NFT Express regardless of your pricing plan. With NFT Express, you can choose whether to mint NFTs on the pre-built NFT smart contract provided by Tatum or on your own smart contract. Use the pre-built smart contract provided by Tatum to mint NFTs If you want to mint NFTs using the pre-built smart contract, you do not need to deploy your own NFT smart contract. You do not need to provide the address of the NFT smart contract and the token ID in the request body either. The address of the smart contract and the token ID are provided automatically by Tatum. The token ID is autogenerated. It starts with 0 and is increased by 1 for each new NFT. The token ID is calculated separately for each supported blockchain and its mainnet and testnet. For more information, see our user documentation. You can mint NFTs on the pre-built smart contract provided by Tatum on the following blockchains: Algorand BNB Smart Chain Celo Ethereum Harmony Klaytn Polygon Solana Depending on what blockchain you use, choose the request body schema to use in the API call. To mint NFTs on BNB Smart Chain, Celo, Ethereum, Harmony, Klaytn, or Polygon, use this API with the MintNftExpress schema of the request body. To mint NFTs on Algorand, use this API with the MintNftExpressAlgorand schema of the request body. To be able to burn the minted NFTs any time later, specify the address of the manager account in the manager parameter. An NFT minted on Algorand is automatically transferred to your blockchain address. After the NFT is minted, you have to transfer it to the recipient&#39;s address. The recipient has to agree in advance to receive your NFT because Algorand charges users for storing NFTs on their addresses, and an Algorand blockchain address by default does not receive NFTs unless explicitly agreed. This how it works: The recipient agrees to receive the NFT to their address. You transfer the NFT to the recipient&#39;s address (use the transferNftAlgoExpress schema of the request body). NOTE: On the mainnet, Tatum covers your transaction fees for the NFT transfer and pays for them from its own blockchain address. Then, the fee amount paid by Tatum is converted to the number of credits, and these credits are deducted from the monthly credit allowance of your paid pricing plan. On the testnet, no credits are deducted from the monthly credit allowance. To mint NFTs on Solana, use this API with the MintNftExpressSolana schema of the request body. Solana uses the Metaplex Protocol, a smart contract and metadata standard for creating and working with NFTs. When you mint an NFT on Solana with NFT Express, the pre-built smart contract based on the Metaplex Protocol is used. When an NFT is minted on Solana, a new blockchain address is created to receive the NFT under the recipient&#39;s account address (the one in the to parameter of the request body). This address is returned in the nftAccountAddress parameter in the response body, is owned by the recipient&#39;s address, and has the same private key. The response body also returns the address of the minted NFT itself, which is held in the nftAddress parameter. After the NFT is minted, you have to transfer it to the recipient&#39;s address (use the transferNftSolana or transferNftSolanaKMS schema of the request body). In the request body of the transfer call: Set the from parameter to the address that you used in the to parameter in the request body of the minting call. Set the to parameter to the recipient&#39;s address. Set the contractAddress parameter to the address from the nftAddress parameter returned in the response body of the minting call. Set the fromPrivateKey/signatureId parameter to the private key/signature ID of the blockchain address that you specified in the from parameter. Use your own smart contract to mint NFTs If you want to mint NFTs using your own smart contract, you are going to use an NTF minter, a special blockchain address provided by Tatum that will cover the minting fees. The number of credits equivalent to the fees will be then deducted from the monthly credit allowance of your paid pricing plan. IMPORTANT! Your smart contract must be deployed as a general NFT smart contract. You cannot use cashback and provenance smart contracts with NFT Express. For more information, see our user documentation and the article in the Tatum blog. You can mint NFTs on your own smart contract on the following blockchains: BNB Smart Chain Celo Ethereum Harmony Klaytn Polygon To mint NFTs using your own smart contract, do the following: In the table located under this section, find the blockchain address of the Tatum NFT minter for your blockchain and network (mainnet or testnet). Add the minter address as an NFT minter to your smart contract. Use this API with the MintNftMinter schema of the request body. In the request body, enter the following information: chain is the blockchain that you use. to is the blockchain address where to send the minted NFT to. url is the URL of the NFT metadata. minter is the address of the NFT minter that you found in Step 1. contractAddress is the address of your NFT smart contract. tokenId is the the token ID of the NFT. For example:  {   \&quot;chain\&quot;: \&quot;CELO\&quot;,   \&quot;to\&quot;: \&quot;0x8ce4e40889a13971681391aad29e88efaf91f784\&quot;,   \&quot;url\&quot;: \&quot;ipfs://QmXJJ6UF5WkF4WTJvsdhiA1etGwBLfpva7Vr9AudGMe3pj\&quot;,   \&quot;contractAddress\&quot;: \&quot;0x687422eEA2cB73B5d3e242bA5456b782919AFc85\&quot;,   \&quot;tokenId\&quot;: \&quot;0123\&quot;,   \&quot;minter\&quot;: \&quot;0xBC2eBA680EE50d685cc4Fe65f102AA70AfB27D3F\&quot; } When you make an API call with this request body, the private key of the NFT minter will be added to the request body automatically:  {   \&quot;chain\&quot;: \&quot;CELO\&quot;,   \&quot;to\&quot;: \&quot;0x8ce4e40889a13971681391aad29e88efaf91f784\&quot;,   \&quot;url\&quot;: \&quot;ipfs://QmXJJ6UF5WkF4WTJvsdhiA1etGwBLfpva7Vr9AudGMe3pj\&quot;,   \&quot;contractAddress\&quot;: \&quot;0x687422eEA2cB73B5d3e242bA5456b782919AFc85\&quot;,   \&quot;tokenId\&quot;: \&quot;0123\&quot;,   \&quot;minter\&quot;: \&quot;0xBC2eBA680EE50d685cc4Fe65f102AA70AfB27D3F\&quot;,   \&quot;fromPrivateKey\&quot;: \&quot;0x05e150c73f1920ec14caa1e0b6aa09940899678051a78542840c2668ce5080c2\&quot; } The following table lists the blockchain addresses of the Tatum NFT minters for the testnet and mainnet of the supported blockchains: Blockchain Minter address - testnet* Minter address - mainnet BNB Smart Chain 0xc16ae5e8c985b906935a0cadf4e24f0400531883 0x49678AAB11E001eb3cB2cBD9aA96b36DC2461A94 Celo 0xBC2eBA680EE50d685cc4Fe65f102AA70AfB27D3F 0x49678AAB11E001eb3cB2cBD9aA96b36DC2461A94 Ethereum 0x53e8577C4347C365E4e0DA5B57A589cB6f2AB848 0x49678AAB11E001eb3cB2cBD9aA96b36DC2461A94 Harmony 0x8906f62d40293ddca77fdf6714c3f63265deddf0 0x49678AAB11E001eb3cB2cBD9aA96b36DC2461A94 Klaytn 0x80d8bac9a6901698b3749fe336bbd1385c1f98f2 0x49678AAB11E001eb3cB2cBD9aA96b36DC2461A94 Polygon 0x542b9ac4945a3836fd12ad98acbc76a0c8b743f5 0x49678AAB11E001eb3cB2cBD9aA96b36DC2461A94 *If a minter blockchain address on the testnet does not have sufficient funds to cover the transaction fee, add some amount to it using a crypto faucet of the blockchain. Minting NFTs natively on a blockchain When minting an NFT natively on a blockchain, you are charged a fee for the transaction, and you must sign the transaction with the private key of the blockchain address from which the fee will be deducted. Providing the private key in the API is not a secure way of signing transactions, because the private key can be stolen or exposed. Your private keys should never leave your security perimeter. You should use the private keys only for testing a solution you are building on the testnet of a blockchain. For signing transactions on the mainnet, we strongly recommend that you use the Tatum Key Management System (KMS) and provide the signature ID instead of the private key in the API. Alternatively, you can use the Tatum JavaScript client. You can mint NFTs natively on the following blockchains: Algorand BNB Smart Chain Celo Ethereum Flow Harmony Klaytn KuCoin Community Chain Polygon Solana TRON Depending on what blockchain you use, choose the request body schema to use in the API call. To mint NFTs natively on Algorand and: To sign the transaction with your private key, use this API with the MintNftAlgorand schema of the request body. To sign the transaction with your signature ID, use this API the MintNftAlgorandKMS schema of the request body. NOTE: To be able to burn the minted NFTs any time later, specify the address of the manager account in the manager parameter. An NFT minted on Algorand is automatically transferred to your blockchain address. After the NFT is minted, you have to transfer it to the recipient&#39;s address. The recipient has to agree in advance to receive your NFT because Algorand charges users for storing NFTs on their addresses, and an Algorand blockchain address by default does not receive NFTs unless explicitly agreed. For more information about how it works, see the section about minting NFTs on Algorand using the pre-built NFT smart contract provided by Tatum. To mint NFTs natively on BNB Smart Chain, Ethereum, Harmony, Klaytn, KuCoin Community Chain, or Polygon, and: To sign the transaction with your private key, use this API with the MintNft schema of the request body. To sign the transaction with your signature ID, use this API the MintNftKMS schema of the request body. To mint NFTs natively on Celo and: To sign the transaction with your private key, use this API with the MintNftCelo schema of the request body. To sign the transaction with your signature ID, use this API the MintNftKMSCelo schema of the request body. To mint NFTs natively on Flow and: To sign the transaction with your private key, use this API with the MintNftFlowPK schema of the request body. To sign the transaction with your signature ID, use this API the MintNftFlowMnemonic schema of the request body. To sign the transaction with your wallet mnemonic, use this API the MintNftFlowKMS schema of the request body. To mint NFTs natively on Solana and: To sign the transaction with your private key, use this API with the MintNftSolana schema of the request body. To sign the transaction with your signature ID, use this API the MintNftSolanaKMS schema of the request body. NOTE: When an NFT is minted on Solana, a new blockchain address is created to receive the NFT under the recipient&#39;s account address. After the NFT is minted, you have to transfer it to the recipient&#39;s address. For more information about how it works, see the section about minting NFTs on Solana using the pre-built NFT smart contract provided by Tatum. To mint NFTs natively on TRON and: To sign the transaction with your private key, use this API with the MintNftTron schema of the request body. To sign the transaction with your signature ID, use this API the MintNftKMSTron schema of the request body.
        /// </summary>
        /// <exception cref="Tatum.CSharp.Bsc.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="mintNftExpress"></param>
        /// <param name="xTestnetType">Type of Ethereum testnet. Defaults to Sepolia. Valid only for ETH invocations for testnet API Key. For mainnet API Key, this value is ignored. (optional, default to ethereum-sepolia)</param>
        /// <returns>TransactionHash</returns>
        public TransactionHash NftMintErc721(MintNftExpress mintNftExpress, string xTestnetType = default(string))
        {
            var localVarResponse = NftMintErc721WithHttpInfo(mintNftExpress, xTestnetType);

            var exception = ExceptionFactory?.Invoke("NftMintErc721", localVarResponse);
            if (exception != null) throw exception;

            return localVarResponse.Data;
        }

        /// <summary>
        /// Mint an NFT 100 credits per API call on Flow 2 credits per API call on the other blockchains You can mint NFTs using either of the following methods: Using NFT Express Natively on a blockchain Minting NFTs using NFT Express NFT Express is Tatum&#39;s feature that helps you mint NFTs easier than minting natively on a blockchain. You do not need to enter your private key or signature ID. NFT Express uses the private key provided by Tatum. You do not need to hold crypto or keep addresses topped up with crypto to pay for minting transactions. To use NFT Express on the mainnet, you have to have a paid pricing plan. Tatum covers your transaction fees for NFT minting and pays for them from its own blockchain address. Then, the fee amount paid by Tatum is converted to the number of credits, and these credits are deducted from the monthly credit allowance of your paid pricing plan. The transaction fees and the corresponding numbers of credits deducted from your allowance vary depending on what blockchain you mint NFTs on. On the testnet, no credits are deducted from the monthly credit allowance. You can mint NFTs with NFT Express regardless of your pricing plan. With NFT Express, you can choose whether to mint NFTs on the pre-built NFT smart contract provided by Tatum or on your own smart contract. Use the pre-built smart contract provided by Tatum to mint NFTs If you want to mint NFTs using the pre-built smart contract, you do not need to deploy your own NFT smart contract. You do not need to provide the address of the NFT smart contract and the token ID in the request body either. The address of the smart contract and the token ID are provided automatically by Tatum. The token ID is autogenerated. It starts with 0 and is increased by 1 for each new NFT. The token ID is calculated separately for each supported blockchain and its mainnet and testnet. For more information, see our user documentation. You can mint NFTs on the pre-built smart contract provided by Tatum on the following blockchains: Algorand BNB Smart Chain Celo Ethereum Harmony Klaytn Polygon Solana Depending on what blockchain you use, choose the request body schema to use in the API call. To mint NFTs on BNB Smart Chain, Celo, Ethereum, Harmony, Klaytn, or Polygon, use this API with the MintNftExpress schema of the request body. To mint NFTs on Algorand, use this API with the MintNftExpressAlgorand schema of the request body. To be able to burn the minted NFTs any time later, specify the address of the manager account in the manager parameter. An NFT minted on Algorand is automatically transferred to your blockchain address. After the NFT is minted, you have to transfer it to the recipient&#39;s address. The recipient has to agree in advance to receive your NFT because Algorand charges users for storing NFTs on their addresses, and an Algorand blockchain address by default does not receive NFTs unless explicitly agreed. This how it works: The recipient agrees to receive the NFT to their address. You transfer the NFT to the recipient&#39;s address (use the transferNftAlgoExpress schema of the request body). NOTE: On the mainnet, Tatum covers your transaction fees for the NFT transfer and pays for them from its own blockchain address. Then, the fee amount paid by Tatum is converted to the number of credits, and these credits are deducted from the monthly credit allowance of your paid pricing plan. On the testnet, no credits are deducted from the monthly credit allowance. To mint NFTs on Solana, use this API with the MintNftExpressSolana schema of the request body. Solana uses the Metaplex Protocol, a smart contract and metadata standard for creating and working with NFTs. When you mint an NFT on Solana with NFT Express, the pre-built smart contract based on the Metaplex Protocol is used. When an NFT is minted on Solana, a new blockchain address is created to receive the NFT under the recipient&#39;s account address (the one in the to parameter of the request body). This address is returned in the nftAccountAddress parameter in the response body, is owned by the recipient&#39;s address, and has the same private key. The response body also returns the address of the minted NFT itself, which is held in the nftAddress parameter. After the NFT is minted, you have to transfer it to the recipient&#39;s address (use the transferNftSolana or transferNftSolanaKMS schema of the request body). In the request body of the transfer call: Set the from parameter to the address that you used in the to parameter in the request body of the minting call. Set the to parameter to the recipient&#39;s address. Set the contractAddress parameter to the address from the nftAddress parameter returned in the response body of the minting call. Set the fromPrivateKey/signatureId parameter to the private key/signature ID of the blockchain address that you specified in the from parameter. Use your own smart contract to mint NFTs If you want to mint NFTs using your own smart contract, you are going to use an NTF minter, a special blockchain address provided by Tatum that will cover the minting fees. The number of credits equivalent to the fees will be then deducted from the monthly credit allowance of your paid pricing plan. IMPORTANT! Your smart contract must be deployed as a general NFT smart contract. You cannot use cashback and provenance smart contracts with NFT Express. For more information, see our user documentation and the article in the Tatum blog. You can mint NFTs on your own smart contract on the following blockchains: BNB Smart Chain Celo Ethereum Harmony Klaytn Polygon To mint NFTs using your own smart contract, do the following: In the table located under this section, find the blockchain address of the Tatum NFT minter for your blockchain and network (mainnet or testnet). Add the minter address as an NFT minter to your smart contract. Use this API with the MintNftMinter schema of the request body. In the request body, enter the following information: chain is the blockchain that you use. to is the blockchain address where to send the minted NFT to. url is the URL of the NFT metadata. minter is the address of the NFT minter that you found in Step 1. contractAddress is the address of your NFT smart contract. tokenId is the the token ID of the NFT. For example:  {   \&quot;chain\&quot;: \&quot;CELO\&quot;,   \&quot;to\&quot;: \&quot;0x8ce4e40889a13971681391aad29e88efaf91f784\&quot;,   \&quot;url\&quot;: \&quot;ipfs://QmXJJ6UF5WkF4WTJvsdhiA1etGwBLfpva7Vr9AudGMe3pj\&quot;,   \&quot;contractAddress\&quot;: \&quot;0x687422eEA2cB73B5d3e242bA5456b782919AFc85\&quot;,   \&quot;tokenId\&quot;: \&quot;0123\&quot;,   \&quot;minter\&quot;: \&quot;0xBC2eBA680EE50d685cc4Fe65f102AA70AfB27D3F\&quot; } When you make an API call with this request body, the private key of the NFT minter will be added to the request body automatically:  {   \&quot;chain\&quot;: \&quot;CELO\&quot;,   \&quot;to\&quot;: \&quot;0x8ce4e40889a13971681391aad29e88efaf91f784\&quot;,   \&quot;url\&quot;: \&quot;ipfs://QmXJJ6UF5WkF4WTJvsdhiA1etGwBLfpva7Vr9AudGMe3pj\&quot;,   \&quot;contractAddress\&quot;: \&quot;0x687422eEA2cB73B5d3e242bA5456b782919AFc85\&quot;,   \&quot;tokenId\&quot;: \&quot;0123\&quot;,   \&quot;minter\&quot;: \&quot;0xBC2eBA680EE50d685cc4Fe65f102AA70AfB27D3F\&quot;,   \&quot;fromPrivateKey\&quot;: \&quot;0x05e150c73f1920ec14caa1e0b6aa09940899678051a78542840c2668ce5080c2\&quot; } The following table lists the blockchain addresses of the Tatum NFT minters for the testnet and mainnet of the supported blockchains: Blockchain Minter address - testnet* Minter address - mainnet BNB Smart Chain 0xc16ae5e8c985b906935a0cadf4e24f0400531883 0x49678AAB11E001eb3cB2cBD9aA96b36DC2461A94 Celo 0xBC2eBA680EE50d685cc4Fe65f102AA70AfB27D3F 0x49678AAB11E001eb3cB2cBD9aA96b36DC2461A94 Ethereum 0x53e8577C4347C365E4e0DA5B57A589cB6f2AB848 0x49678AAB11E001eb3cB2cBD9aA96b36DC2461A94 Harmony 0x8906f62d40293ddca77fdf6714c3f63265deddf0 0x49678AAB11E001eb3cB2cBD9aA96b36DC2461A94 Klaytn 0x80d8bac9a6901698b3749fe336bbd1385c1f98f2 0x49678AAB11E001eb3cB2cBD9aA96b36DC2461A94 Polygon 0x542b9ac4945a3836fd12ad98acbc76a0c8b743f5 0x49678AAB11E001eb3cB2cBD9aA96b36DC2461A94 *If a minter blockchain address on the testnet does not have sufficient funds to cover the transaction fee, add some amount to it using a crypto faucet of the blockchain. Minting NFTs natively on a blockchain When minting an NFT natively on a blockchain, you are charged a fee for the transaction, and you must sign the transaction with the private key of the blockchain address from which the fee will be deducted. Providing the private key in the API is not a secure way of signing transactions, because the private key can be stolen or exposed. Your private keys should never leave your security perimeter. You should use the private keys only for testing a solution you are building on the testnet of a blockchain. For signing transactions on the mainnet, we strongly recommend that you use the Tatum Key Management System (KMS) and provide the signature ID instead of the private key in the API. Alternatively, you can use the Tatum JavaScript client. You can mint NFTs natively on the following blockchains: Algorand BNB Smart Chain Celo Ethereum Flow Harmony Klaytn KuCoin Community Chain Polygon Solana TRON Depending on what blockchain you use, choose the request body schema to use in the API call. To mint NFTs natively on Algorand and: To sign the transaction with your private key, use this API with the MintNftAlgorand schema of the request body. To sign the transaction with your signature ID, use this API the MintNftAlgorandKMS schema of the request body. NOTE: To be able to burn the minted NFTs any time later, specify the address of the manager account in the manager parameter. An NFT minted on Algorand is automatically transferred to your blockchain address. After the NFT is minted, you have to transfer it to the recipient&#39;s address. The recipient has to agree in advance to receive your NFT because Algorand charges users for storing NFTs on their addresses, and an Algorand blockchain address by default does not receive NFTs unless explicitly agreed. For more information about how it works, see the section about minting NFTs on Algorand using the pre-built NFT smart contract provided by Tatum. To mint NFTs natively on BNB Smart Chain, Ethereum, Harmony, Klaytn, KuCoin Community Chain, or Polygon, and: To sign the transaction with your private key, use this API with the MintNft schema of the request body. To sign the transaction with your signature ID, use this API the MintNftKMS schema of the request body. To mint NFTs natively on Celo and: To sign the transaction with your private key, use this API with the MintNftCelo schema of the request body. To sign the transaction with your signature ID, use this API the MintNftKMSCelo schema of the request body. To mint NFTs natively on Flow and: To sign the transaction with your private key, use this API with the MintNftFlowPK schema of the request body. To sign the transaction with your signature ID, use this API the MintNftFlowMnemonic schema of the request body. To sign the transaction with your wallet mnemonic, use this API the MintNftFlowKMS schema of the request body. To mint NFTs natively on Solana and: To sign the transaction with your private key, use this API with the MintNftSolana schema of the request body. To sign the transaction with your signature ID, use this API the MintNftSolanaKMS schema of the request body. NOTE: When an NFT is minted on Solana, a new blockchain address is created to receive the NFT under the recipient&#39;s account address. After the NFT is minted, you have to transfer it to the recipient&#39;s address. For more information about how it works, see the section about minting NFTs on Solana using the pre-built NFT smart contract provided by Tatum. To mint NFTs natively on TRON and: To sign the transaction with your private key, use this API with the MintNftTron schema of the request body. To sign the transaction with your signature ID, use this API the MintNftKMSTron schema of the request body.
        /// </summary>
        /// <exception cref="Tatum.CSharp.Bsc.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="mintNftExpress"></param>
        /// <param name="xTestnetType">Type of Ethereum testnet. Defaults to Sepolia. Valid only for ETH invocations for testnet API Key. For mainnet API Key, this value is ignored. (optional, default to ethereum-sepolia)</param>
        /// <returns>ApiResponse of TransactionHash</returns>
        public ApiResponse<TransactionHash> NftMintErc721WithHttpInfo(MintNftExpress mintNftExpress, string xTestnetType = default(string))
        {
            // verify the required parameter 'mintNftExpress' is set
            if (mintNftExpress == null)
                throw new ApiException(400, "Missing required parameter 'mintNftExpress' when calling NFTBscApi->NftMintErc721");

            var localVarRequestOptions = new RequestOptions();

            var contentTypes = new string[]{
                "application/json"
            };

            // to determine the Accept header
            var accepts = new string[]{
                "application/json"
            };

            var localVarContentType = ClientUtils.SelectHeaderContentType(contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = ClientUtils.SelectHeaderAccept(accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            if (xTestnetType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("x-testnet-type", ClientUtils.ParameterToString(xTestnetType)); // header parameter
            }
            localVarRequestOptions.Data = mintNftExpress;

            // authentication (X-API-Key) required
            if (!string.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("x-api-key")))
            {
                localVarRequestOptions.HeaderParameters.Add("x-api-key", Configuration.GetApiKeyWithPrefix("x-api-key"));
            }

            // make the HTTP request
            var localVarResponse = Client.Post<TransactionHash>("/v3/nft/mint", localVarRequestOptions, Configuration);

            return localVarResponse;
        }

        /// <summary>
        /// Mint an NFT 100 credits per API call on Flow 2 credits per API call on the other blockchains You can mint NFTs using either of the following methods: Using NFT Express Natively on a blockchain Minting NFTs using NFT Express NFT Express is Tatum&#39;s feature that helps you mint NFTs easier than minting natively on a blockchain. You do not need to enter your private key or signature ID. NFT Express uses the private key provided by Tatum. You do not need to hold crypto or keep addresses topped up with crypto to pay for minting transactions. To use NFT Express on the mainnet, you have to have a paid pricing plan. Tatum covers your transaction fees for NFT minting and pays for them from its own blockchain address. Then, the fee amount paid by Tatum is converted to the number of credits, and these credits are deducted from the monthly credit allowance of your paid pricing plan. The transaction fees and the corresponding numbers of credits deducted from your allowance vary depending on what blockchain you mint NFTs on. On the testnet, no credits are deducted from the monthly credit allowance. You can mint NFTs with NFT Express regardless of your pricing plan. With NFT Express, you can choose whether to mint NFTs on the pre-built NFT smart contract provided by Tatum or on your own smart contract. Use the pre-built smart contract provided by Tatum to mint NFTs If you want to mint NFTs using the pre-built smart contract, you do not need to deploy your own NFT smart contract. You do not need to provide the address of the NFT smart contract and the token ID in the request body either. The address of the smart contract and the token ID are provided automatically by Tatum. The token ID is autogenerated. It starts with 0 and is increased by 1 for each new NFT. The token ID is calculated separately for each supported blockchain and its mainnet and testnet. For more information, see our user documentation. You can mint NFTs on the pre-built smart contract provided by Tatum on the following blockchains: Algorand BNB Smart Chain Celo Ethereum Harmony Klaytn Polygon Solana Depending on what blockchain you use, choose the request body schema to use in the API call. To mint NFTs on BNB Smart Chain, Celo, Ethereum, Harmony, Klaytn, or Polygon, use this API with the MintNftExpress schema of the request body. To mint NFTs on Algorand, use this API with the MintNftExpressAlgorand schema of the request body. To be able to burn the minted NFTs any time later, specify the address of the manager account in the manager parameter. An NFT minted on Algorand is automatically transferred to your blockchain address. After the NFT is minted, you have to transfer it to the recipient&#39;s address. The recipient has to agree in advance to receive your NFT because Algorand charges users for storing NFTs on their addresses, and an Algorand blockchain address by default does not receive NFTs unless explicitly agreed. This how it works: The recipient agrees to receive the NFT to their address. You transfer the NFT to the recipient&#39;s address (use the transferNftAlgoExpress schema of the request body). NOTE: On the mainnet, Tatum covers your transaction fees for the NFT transfer and pays for them from its own blockchain address. Then, the fee amount paid by Tatum is converted to the number of credits, and these credits are deducted from the monthly credit allowance of your paid pricing plan. On the testnet, no credits are deducted from the monthly credit allowance. To mint NFTs on Solana, use this API with the MintNftExpressSolana schema of the request body. Solana uses the Metaplex Protocol, a smart contract and metadata standard for creating and working with NFTs. When you mint an NFT on Solana with NFT Express, the pre-built smart contract based on the Metaplex Protocol is used. When an NFT is minted on Solana, a new blockchain address is created to receive the NFT under the recipient&#39;s account address (the one in the to parameter of the request body). This address is returned in the nftAccountAddress parameter in the response body, is owned by the recipient&#39;s address, and has the same private key. The response body also returns the address of the minted NFT itself, which is held in the nftAddress parameter. After the NFT is minted, you have to transfer it to the recipient&#39;s address (use the transferNftSolana or transferNftSolanaKMS schema of the request body). In the request body of the transfer call: Set the from parameter to the address that you used in the to parameter in the request body of the minting call. Set the to parameter to the recipient&#39;s address. Set the contractAddress parameter to the address from the nftAddress parameter returned in the response body of the minting call. Set the fromPrivateKey/signatureId parameter to the private key/signature ID of the blockchain address that you specified in the from parameter. Use your own smart contract to mint NFTs If you want to mint NFTs using your own smart contract, you are going to use an NTF minter, a special blockchain address provided by Tatum that will cover the minting fees. The number of credits equivalent to the fees will be then deducted from the monthly credit allowance of your paid pricing plan. IMPORTANT! Your smart contract must be deployed as a general NFT smart contract. You cannot use cashback and provenance smart contracts with NFT Express. For more information, see our user documentation and the article in the Tatum blog. You can mint NFTs on your own smart contract on the following blockchains: BNB Smart Chain Celo Ethereum Harmony Klaytn Polygon To mint NFTs using your own smart contract, do the following: In the table located under this section, find the blockchain address of the Tatum NFT minter for your blockchain and network (mainnet or testnet). Add the minter address as an NFT minter to your smart contract. Use this API with the MintNftMinter schema of the request body. In the request body, enter the following information: chain is the blockchain that you use. to is the blockchain address where to send the minted NFT to. url is the URL of the NFT metadata. minter is the address of the NFT minter that you found in Step 1. contractAddress is the address of your NFT smart contract. tokenId is the the token ID of the NFT. For example:  {   \&quot;chain\&quot;: \&quot;CELO\&quot;,   \&quot;to\&quot;: \&quot;0x8ce4e40889a13971681391aad29e88efaf91f784\&quot;,   \&quot;url\&quot;: \&quot;ipfs://QmXJJ6UF5WkF4WTJvsdhiA1etGwBLfpva7Vr9AudGMe3pj\&quot;,   \&quot;contractAddress\&quot;: \&quot;0x687422eEA2cB73B5d3e242bA5456b782919AFc85\&quot;,   \&quot;tokenId\&quot;: \&quot;0123\&quot;,   \&quot;minter\&quot;: \&quot;0xBC2eBA680EE50d685cc4Fe65f102AA70AfB27D3F\&quot; } When you make an API call with this request body, the private key of the NFT minter will be added to the request body automatically:  {   \&quot;chain\&quot;: \&quot;CELO\&quot;,   \&quot;to\&quot;: \&quot;0x8ce4e40889a13971681391aad29e88efaf91f784\&quot;,   \&quot;url\&quot;: \&quot;ipfs://QmXJJ6UF5WkF4WTJvsdhiA1etGwBLfpva7Vr9AudGMe3pj\&quot;,   \&quot;contractAddress\&quot;: \&quot;0x687422eEA2cB73B5d3e242bA5456b782919AFc85\&quot;,   \&quot;tokenId\&quot;: \&quot;0123\&quot;,   \&quot;minter\&quot;: \&quot;0xBC2eBA680EE50d685cc4Fe65f102AA70AfB27D3F\&quot;,   \&quot;fromPrivateKey\&quot;: \&quot;0x05e150c73f1920ec14caa1e0b6aa09940899678051a78542840c2668ce5080c2\&quot; } The following table lists the blockchain addresses of the Tatum NFT minters for the testnet and mainnet of the supported blockchains: Blockchain Minter address - testnet* Minter address - mainnet BNB Smart Chain 0xc16ae5e8c985b906935a0cadf4e24f0400531883 0x49678AAB11E001eb3cB2cBD9aA96b36DC2461A94 Celo 0xBC2eBA680EE50d685cc4Fe65f102AA70AfB27D3F 0x49678AAB11E001eb3cB2cBD9aA96b36DC2461A94 Ethereum 0x53e8577C4347C365E4e0DA5B57A589cB6f2AB848 0x49678AAB11E001eb3cB2cBD9aA96b36DC2461A94 Harmony 0x8906f62d40293ddca77fdf6714c3f63265deddf0 0x49678AAB11E001eb3cB2cBD9aA96b36DC2461A94 Klaytn 0x80d8bac9a6901698b3749fe336bbd1385c1f98f2 0x49678AAB11E001eb3cB2cBD9aA96b36DC2461A94 Polygon 0x542b9ac4945a3836fd12ad98acbc76a0c8b743f5 0x49678AAB11E001eb3cB2cBD9aA96b36DC2461A94 *If a minter blockchain address on the testnet does not have sufficient funds to cover the transaction fee, add some amount to it using a crypto faucet of the blockchain. Minting NFTs natively on a blockchain When minting an NFT natively on a blockchain, you are charged a fee for the transaction, and you must sign the transaction with the private key of the blockchain address from which the fee will be deducted. Providing the private key in the API is not a secure way of signing transactions, because the private key can be stolen or exposed. Your private keys should never leave your security perimeter. You should use the private keys only for testing a solution you are building on the testnet of a blockchain. For signing transactions on the mainnet, we strongly recommend that you use the Tatum Key Management System (KMS) and provide the signature ID instead of the private key in the API. Alternatively, you can use the Tatum JavaScript client. You can mint NFTs natively on the following blockchains: Algorand BNB Smart Chain Celo Ethereum Flow Harmony Klaytn KuCoin Community Chain Polygon Solana TRON Depending on what blockchain you use, choose the request body schema to use in the API call. To mint NFTs natively on Algorand and: To sign the transaction with your private key, use this API with the MintNftAlgorand schema of the request body. To sign the transaction with your signature ID, use this API the MintNftAlgorandKMS schema of the request body. NOTE: To be able to burn the minted NFTs any time later, specify the address of the manager account in the manager parameter. An NFT minted on Algorand is automatically transferred to your blockchain address. After the NFT is minted, you have to transfer it to the recipient&#39;s address. The recipient has to agree in advance to receive your NFT because Algorand charges users for storing NFTs on their addresses, and an Algorand blockchain address by default does not receive NFTs unless explicitly agreed. For more information about how it works, see the section about minting NFTs on Algorand using the pre-built NFT smart contract provided by Tatum. To mint NFTs natively on BNB Smart Chain, Ethereum, Harmony, Klaytn, KuCoin Community Chain, or Polygon, and: To sign the transaction with your private key, use this API with the MintNft schema of the request body. To sign the transaction with your signature ID, use this API the MintNftKMS schema of the request body. To mint NFTs natively on Celo and: To sign the transaction with your private key, use this API with the MintNftCelo schema of the request body. To sign the transaction with your signature ID, use this API the MintNftKMSCelo schema of the request body. To mint NFTs natively on Flow and: To sign the transaction with your private key, use this API with the MintNftFlowPK schema of the request body. To sign the transaction with your signature ID, use this API the MintNftFlowMnemonic schema of the request body. To sign the transaction with your wallet mnemonic, use this API the MintNftFlowKMS schema of the request body. To mint NFTs natively on Solana and: To sign the transaction with your private key, use this API with the MintNftSolana schema of the request body. To sign the transaction with your signature ID, use this API the MintNftSolanaKMS schema of the request body. NOTE: When an NFT is minted on Solana, a new blockchain address is created to receive the NFT under the recipient&#39;s account address. After the NFT is minted, you have to transfer it to the recipient&#39;s address. For more information about how it works, see the section about minting NFTs on Solana using the pre-built NFT smart contract provided by Tatum. To mint NFTs natively on TRON and: To sign the transaction with your private key, use this API with the MintNftTron schema of the request body. To sign the transaction with your signature ID, use this API the MintNftKMSTron schema of the request body.
        /// </summary>
        /// <exception cref="Tatum.CSharp.Bsc.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="mintNftExpress"></param>
        /// <param name="xTestnetType">Type of Ethereum testnet. Defaults to Sepolia. Valid only for ETH invocations for testnet API Key. For mainnet API Key, this value is ignored. (optional, default to ethereum-sepolia)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of TransactionHash</returns>
        public async System.Threading.Tasks.Task<TransactionHash> NftMintErc721Async(MintNftExpress mintNftExpress, string xTestnetType = default(string), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            var localVarResponse = await NftMintErc721WithHttpInfoAsync(mintNftExpress, xTestnetType, cancellationToken).ConfigureAwait(false);
            
            var exception = ExceptionFactory?.Invoke("NftMintErc721", localVarResponse);
            if (exception != null) throw exception;

            return localVarResponse.Data;
        }

        /// <summary>
        /// Mint an NFT 100 credits per API call on Flow 2 credits per API call on the other blockchains You can mint NFTs using either of the following methods: Using NFT Express Natively on a blockchain Minting NFTs using NFT Express NFT Express is Tatum&#39;s feature that helps you mint NFTs easier than minting natively on a blockchain. You do not need to enter your private key or signature ID. NFT Express uses the private key provided by Tatum. You do not need to hold crypto or keep addresses topped up with crypto to pay for minting transactions. To use NFT Express on the mainnet, you have to have a paid pricing plan. Tatum covers your transaction fees for NFT minting and pays for them from its own blockchain address. Then, the fee amount paid by Tatum is converted to the number of credits, and these credits are deducted from the monthly credit allowance of your paid pricing plan. The transaction fees and the corresponding numbers of credits deducted from your allowance vary depending on what blockchain you mint NFTs on. On the testnet, no credits are deducted from the monthly credit allowance. You can mint NFTs with NFT Express regardless of your pricing plan. With NFT Express, you can choose whether to mint NFTs on the pre-built NFT smart contract provided by Tatum or on your own smart contract. Use the pre-built smart contract provided by Tatum to mint NFTs If you want to mint NFTs using the pre-built smart contract, you do not need to deploy your own NFT smart contract. You do not need to provide the address of the NFT smart contract and the token ID in the request body either. The address of the smart contract and the token ID are provided automatically by Tatum. The token ID is autogenerated. It starts with 0 and is increased by 1 for each new NFT. The token ID is calculated separately for each supported blockchain and its mainnet and testnet. For more information, see our user documentation. You can mint NFTs on the pre-built smart contract provided by Tatum on the following blockchains: Algorand BNB Smart Chain Celo Ethereum Harmony Klaytn Polygon Solana Depending on what blockchain you use, choose the request body schema to use in the API call. To mint NFTs on BNB Smart Chain, Celo, Ethereum, Harmony, Klaytn, or Polygon, use this API with the MintNftExpress schema of the request body. To mint NFTs on Algorand, use this API with the MintNftExpressAlgorand schema of the request body. To be able to burn the minted NFTs any time later, specify the address of the manager account in the manager parameter. An NFT minted on Algorand is automatically transferred to your blockchain address. After the NFT is minted, you have to transfer it to the recipient&#39;s address. The recipient has to agree in advance to receive your NFT because Algorand charges users for storing NFTs on their addresses, and an Algorand blockchain address by default does not receive NFTs unless explicitly agreed. This how it works: The recipient agrees to receive the NFT to their address. You transfer the NFT to the recipient&#39;s address (use the transferNftAlgoExpress schema of the request body). NOTE: On the mainnet, Tatum covers your transaction fees for the NFT transfer and pays for them from its own blockchain address. Then, the fee amount paid by Tatum is converted to the number of credits, and these credits are deducted from the monthly credit allowance of your paid pricing plan. On the testnet, no credits are deducted from the monthly credit allowance. To mint NFTs on Solana, use this API with the MintNftExpressSolana schema of the request body. Solana uses the Metaplex Protocol, a smart contract and metadata standard for creating and working with NFTs. When you mint an NFT on Solana with NFT Express, the pre-built smart contract based on the Metaplex Protocol is used. When an NFT is minted on Solana, a new blockchain address is created to receive the NFT under the recipient&#39;s account address (the one in the to parameter of the request body). This address is returned in the nftAccountAddress parameter in the response body, is owned by the recipient&#39;s address, and has the same private key. The response body also returns the address of the minted NFT itself, which is held in the nftAddress parameter. After the NFT is minted, you have to transfer it to the recipient&#39;s address (use the transferNftSolana or transferNftSolanaKMS schema of the request body). In the request body of the transfer call: Set the from parameter to the address that you used in the to parameter in the request body of the minting call. Set the to parameter to the recipient&#39;s address. Set the contractAddress parameter to the address from the nftAddress parameter returned in the response body of the minting call. Set the fromPrivateKey/signatureId parameter to the private key/signature ID of the blockchain address that you specified in the from parameter. Use your own smart contract to mint NFTs If you want to mint NFTs using your own smart contract, you are going to use an NTF minter, a special blockchain address provided by Tatum that will cover the minting fees. The number of credits equivalent to the fees will be then deducted from the monthly credit allowance of your paid pricing plan. IMPORTANT! Your smart contract must be deployed as a general NFT smart contract. You cannot use cashback and provenance smart contracts with NFT Express. For more information, see our user documentation and the article in the Tatum blog. You can mint NFTs on your own smart contract on the following blockchains: BNB Smart Chain Celo Ethereum Harmony Klaytn Polygon To mint NFTs using your own smart contract, do the following: In the table located under this section, find the blockchain address of the Tatum NFT minter for your blockchain and network (mainnet or testnet). Add the minter address as an NFT minter to your smart contract. Use this API with the MintNftMinter schema of the request body. In the request body, enter the following information: chain is the blockchain that you use. to is the blockchain address where to send the minted NFT to. url is the URL of the NFT metadata. minter is the address of the NFT minter that you found in Step 1. contractAddress is the address of your NFT smart contract. tokenId is the the token ID of the NFT. For example:  {   \&quot;chain\&quot;: \&quot;CELO\&quot;,   \&quot;to\&quot;: \&quot;0x8ce4e40889a13971681391aad29e88efaf91f784\&quot;,   \&quot;url\&quot;: \&quot;ipfs://QmXJJ6UF5WkF4WTJvsdhiA1etGwBLfpva7Vr9AudGMe3pj\&quot;,   \&quot;contractAddress\&quot;: \&quot;0x687422eEA2cB73B5d3e242bA5456b782919AFc85\&quot;,   \&quot;tokenId\&quot;: \&quot;0123\&quot;,   \&quot;minter\&quot;: \&quot;0xBC2eBA680EE50d685cc4Fe65f102AA70AfB27D3F\&quot; } When you make an API call with this request body, the private key of the NFT minter will be added to the request body automatically:  {   \&quot;chain\&quot;: \&quot;CELO\&quot;,   \&quot;to\&quot;: \&quot;0x8ce4e40889a13971681391aad29e88efaf91f784\&quot;,   \&quot;url\&quot;: \&quot;ipfs://QmXJJ6UF5WkF4WTJvsdhiA1etGwBLfpva7Vr9AudGMe3pj\&quot;,   \&quot;contractAddress\&quot;: \&quot;0x687422eEA2cB73B5d3e242bA5456b782919AFc85\&quot;,   \&quot;tokenId\&quot;: \&quot;0123\&quot;,   \&quot;minter\&quot;: \&quot;0xBC2eBA680EE50d685cc4Fe65f102AA70AfB27D3F\&quot;,   \&quot;fromPrivateKey\&quot;: \&quot;0x05e150c73f1920ec14caa1e0b6aa09940899678051a78542840c2668ce5080c2\&quot; } The following table lists the blockchain addresses of the Tatum NFT minters for the testnet and mainnet of the supported blockchains: Blockchain Minter address - testnet* Minter address - mainnet BNB Smart Chain 0xc16ae5e8c985b906935a0cadf4e24f0400531883 0x49678AAB11E001eb3cB2cBD9aA96b36DC2461A94 Celo 0xBC2eBA680EE50d685cc4Fe65f102AA70AfB27D3F 0x49678AAB11E001eb3cB2cBD9aA96b36DC2461A94 Ethereum 0x53e8577C4347C365E4e0DA5B57A589cB6f2AB848 0x49678AAB11E001eb3cB2cBD9aA96b36DC2461A94 Harmony 0x8906f62d40293ddca77fdf6714c3f63265deddf0 0x49678AAB11E001eb3cB2cBD9aA96b36DC2461A94 Klaytn 0x80d8bac9a6901698b3749fe336bbd1385c1f98f2 0x49678AAB11E001eb3cB2cBD9aA96b36DC2461A94 Polygon 0x542b9ac4945a3836fd12ad98acbc76a0c8b743f5 0x49678AAB11E001eb3cB2cBD9aA96b36DC2461A94 *If a minter blockchain address on the testnet does not have sufficient funds to cover the transaction fee, add some amount to it using a crypto faucet of the blockchain. Minting NFTs natively on a blockchain When minting an NFT natively on a blockchain, you are charged a fee for the transaction, and you must sign the transaction with the private key of the blockchain address from which the fee will be deducted. Providing the private key in the API is not a secure way of signing transactions, because the private key can be stolen or exposed. Your private keys should never leave your security perimeter. You should use the private keys only for testing a solution you are building on the testnet of a blockchain. For signing transactions on the mainnet, we strongly recommend that you use the Tatum Key Management System (KMS) and provide the signature ID instead of the private key in the API. Alternatively, you can use the Tatum JavaScript client. You can mint NFTs natively on the following blockchains: Algorand BNB Smart Chain Celo Ethereum Flow Harmony Klaytn KuCoin Community Chain Polygon Solana TRON Depending on what blockchain you use, choose the request body schema to use in the API call. To mint NFTs natively on Algorand and: To sign the transaction with your private key, use this API with the MintNftAlgorand schema of the request body. To sign the transaction with your signature ID, use this API the MintNftAlgorandKMS schema of the request body. NOTE: To be able to burn the minted NFTs any time later, specify the address of the manager account in the manager parameter. An NFT minted on Algorand is automatically transferred to your blockchain address. After the NFT is minted, you have to transfer it to the recipient&#39;s address. The recipient has to agree in advance to receive your NFT because Algorand charges users for storing NFTs on their addresses, and an Algorand blockchain address by default does not receive NFTs unless explicitly agreed. For more information about how it works, see the section about minting NFTs on Algorand using the pre-built NFT smart contract provided by Tatum. To mint NFTs natively on BNB Smart Chain, Ethereum, Harmony, Klaytn, KuCoin Community Chain, or Polygon, and: To sign the transaction with your private key, use this API with the MintNft schema of the request body. To sign the transaction with your signature ID, use this API the MintNftKMS schema of the request body. To mint NFTs natively on Celo and: To sign the transaction with your private key, use this API with the MintNftCelo schema of the request body. To sign the transaction with your signature ID, use this API the MintNftKMSCelo schema of the request body. To mint NFTs natively on Flow and: To sign the transaction with your private key, use this API with the MintNftFlowPK schema of the request body. To sign the transaction with your signature ID, use this API the MintNftFlowMnemonic schema of the request body. To sign the transaction with your wallet mnemonic, use this API the MintNftFlowKMS schema of the request body. To mint NFTs natively on Solana and: To sign the transaction with your private key, use this API with the MintNftSolana schema of the request body. To sign the transaction with your signature ID, use this API the MintNftSolanaKMS schema of the request body. NOTE: When an NFT is minted on Solana, a new blockchain address is created to receive the NFT under the recipient&#39;s account address. After the NFT is minted, you have to transfer it to the recipient&#39;s address. For more information about how it works, see the section about minting NFTs on Solana using the pre-built NFT smart contract provided by Tatum. To mint NFTs natively on TRON and: To sign the transaction with your private key, use this API with the MintNftTron schema of the request body. To sign the transaction with your signature ID, use this API the MintNftKMSTron schema of the request body.
        /// </summary>
        /// <exception cref="Tatum.CSharp.Bsc.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="mintNftExpress"></param>
        /// <param name="xTestnetType">Type of Ethereum testnet. Defaults to Sepolia. Valid only for ETH invocations for testnet API Key. For mainnet API Key, this value is ignored. (optional, default to ethereum-sepolia)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (TransactionHash)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<TransactionHash>> NftMintErc721WithHttpInfoAsync(MintNftExpress mintNftExpress, string xTestnetType = default(string), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            // verify the required parameter 'mintNftExpress' is set
            if (mintNftExpress == null)
                throw new ApiException(400, "Missing required parameter 'mintNftExpress' when calling NFTBscApi->NftMintErc721");

            var localVarRequestOptions = new RequestOptions();

            var contentTypes = new string[]{
                "application/json"
            };

            // to determine the Accept header
            var accepts = new string[]{
                "application/json"
            };


            var localVarContentType = ClientUtils.SelectHeaderContentType(contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = ClientUtils.SelectHeaderAccept(accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            if (xTestnetType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("x-testnet-type", ClientUtils.ParameterToString(xTestnetType)); // header parameter
            }
            localVarRequestOptions.Data = mintNftExpress;

            // authentication (X-API-Key) required
            if (!string.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("x-api-key")))
            {
                localVarRequestOptions.HeaderParameters.Add("x-api-key", Configuration.GetApiKeyWithPrefix("x-api-key"));
            }

            // make the HTTP request

            var localVarResponse = await AsynchronousClient.PostAsync<TransactionHash>("/v3/nft/mint", localVarRequestOptions, Configuration, cancellationToken).ConfigureAwait(false);

            return localVarResponse;
        }

        /// <summary>
        /// Mint an NFT 100 credits per API call on Flow 2 credits per API call on the other blockchains You can mint NFTs using either of the following methods: Using NFT Express Natively on a blockchain Minting NFTs using NFT Express NFT Express is Tatum&#39;s feature that helps you mint NFTs easier than minting natively on a blockchain. You do not need to enter your private key or signature ID. NFT Express uses the private key provided by Tatum. You do not need to hold crypto or keep addresses topped up with crypto to pay for minting transactions. To use NFT Express on the mainnet, you have to have a paid pricing plan. Tatum covers your transaction fees for NFT minting and pays for them from its own blockchain address. Then, the fee amount paid by Tatum is converted to the number of credits, and these credits are deducted from the monthly credit allowance of your paid pricing plan. The transaction fees and the corresponding numbers of credits deducted from your allowance vary depending on what blockchain you mint NFTs on. On the testnet, no credits are deducted from the monthly credit allowance. You can mint NFTs with NFT Express regardless of your pricing plan. With NFT Express, you can choose whether to mint NFTs on the pre-built NFT smart contract provided by Tatum or on your own smart contract. Use the pre-built smart contract provided by Tatum to mint NFTs If you want to mint NFTs using the pre-built smart contract, you do not need to deploy your own NFT smart contract. You do not need to provide the address of the NFT smart contract and the token ID in the request body either. The address of the smart contract and the token ID are provided automatically by Tatum. The token ID is autogenerated. It starts with 0 and is increased by 1 for each new NFT. The token ID is calculated separately for each supported blockchain and its mainnet and testnet. For more information, see our user documentation. You can mint NFTs on the pre-built smart contract provided by Tatum on the following blockchains: Algorand BNB Smart Chain Celo Ethereum Harmony Klaytn Polygon Solana Depending on what blockchain you use, choose the request body schema to use in the API call. To mint NFTs on BNB Smart Chain, Celo, Ethereum, Harmony, Klaytn, or Polygon, use this API with the MintNftExpress schema of the request body. To mint NFTs on Algorand, use this API with the MintNftExpressAlgorand schema of the request body. To be able to burn the minted NFTs any time later, specify the address of the manager account in the manager parameter. An NFT minted on Algorand is automatically transferred to your blockchain address. After the NFT is minted, you have to transfer it to the recipient&#39;s address. The recipient has to agree in advance to receive your NFT because Algorand charges users for storing NFTs on their addresses, and an Algorand blockchain address by default does not receive NFTs unless explicitly agreed. This how it works: The recipient agrees to receive the NFT to their address. You transfer the NFT to the recipient&#39;s address (use the transferNftAlgoExpress schema of the request body). NOTE: On the mainnet, Tatum covers your transaction fees for the NFT transfer and pays for them from its own blockchain address. Then, the fee amount paid by Tatum is converted to the number of credits, and these credits are deducted from the monthly credit allowance of your paid pricing plan. On the testnet, no credits are deducted from the monthly credit allowance. To mint NFTs on Solana, use this API with the MintNftExpressSolana schema of the request body. Solana uses the Metaplex Protocol, a smart contract and metadata standard for creating and working with NFTs. When you mint an NFT on Solana with NFT Express, the pre-built smart contract based on the Metaplex Protocol is used. When an NFT is minted on Solana, a new blockchain address is created to receive the NFT under the recipient&#39;s account address (the one in the to parameter of the request body). This address is returned in the nftAccountAddress parameter in the response body, is owned by the recipient&#39;s address, and has the same private key. The response body also returns the address of the minted NFT itself, which is held in the nftAddress parameter. After the NFT is minted, you have to transfer it to the recipient&#39;s address (use the transferNftSolana or transferNftSolanaKMS schema of the request body). In the request body of the transfer call: Set the from parameter to the address that you used in the to parameter in the request body of the minting call. Set the to parameter to the recipient&#39;s address. Set the contractAddress parameter to the address from the nftAddress parameter returned in the response body of the minting call. Set the fromPrivateKey/signatureId parameter to the private key/signature ID of the blockchain address that you specified in the from parameter. Use your own smart contract to mint NFTs If you want to mint NFTs using your own smart contract, you are going to use an NTF minter, a special blockchain address provided by Tatum that will cover the minting fees. The number of credits equivalent to the fees will be then deducted from the monthly credit allowance of your paid pricing plan. IMPORTANT! Your smart contract must be deployed as a general NFT smart contract. You cannot use cashback and provenance smart contracts with NFT Express. For more information, see our user documentation and the article in the Tatum blog. You can mint NFTs on your own smart contract on the following blockchains: BNB Smart Chain Celo Ethereum Harmony Klaytn Polygon To mint NFTs using your own smart contract, do the following: In the table located under this section, find the blockchain address of the Tatum NFT minter for your blockchain and network (mainnet or testnet). Add the minter address as an NFT minter to your smart contract. Use this API with the MintNftMinter schema of the request body. In the request body, enter the following information: chain is the blockchain that you use. to is the blockchain address where to send the minted NFT to. url is the URL of the NFT metadata. minter is the address of the NFT minter that you found in Step 1. contractAddress is the address of your NFT smart contract. tokenId is the the token ID of the NFT. For example:  {   \&quot;chain\&quot;: \&quot;CELO\&quot;,   \&quot;to\&quot;: \&quot;0x8ce4e40889a13971681391aad29e88efaf91f784\&quot;,   \&quot;url\&quot;: \&quot;ipfs://QmXJJ6UF5WkF4WTJvsdhiA1etGwBLfpva7Vr9AudGMe3pj\&quot;,   \&quot;contractAddress\&quot;: \&quot;0x687422eEA2cB73B5d3e242bA5456b782919AFc85\&quot;,   \&quot;tokenId\&quot;: \&quot;0123\&quot;,   \&quot;minter\&quot;: \&quot;0xBC2eBA680EE50d685cc4Fe65f102AA70AfB27D3F\&quot; } When you make an API call with this request body, the private key of the NFT minter will be added to the request body automatically:  {   \&quot;chain\&quot;: \&quot;CELO\&quot;,   \&quot;to\&quot;: \&quot;0x8ce4e40889a13971681391aad29e88efaf91f784\&quot;,   \&quot;url\&quot;: \&quot;ipfs://QmXJJ6UF5WkF4WTJvsdhiA1etGwBLfpva7Vr9AudGMe3pj\&quot;,   \&quot;contractAddress\&quot;: \&quot;0x687422eEA2cB73B5d3e242bA5456b782919AFc85\&quot;,   \&quot;tokenId\&quot;: \&quot;0123\&quot;,   \&quot;minter\&quot;: \&quot;0xBC2eBA680EE50d685cc4Fe65f102AA70AfB27D3F\&quot;,   \&quot;fromPrivateKey\&quot;: \&quot;0x05e150c73f1920ec14caa1e0b6aa09940899678051a78542840c2668ce5080c2\&quot; } The following table lists the blockchain addresses of the Tatum NFT minters for the testnet and mainnet of the supported blockchains: Blockchain Minter address - testnet* Minter address - mainnet BNB Smart Chain 0xc16ae5e8c985b906935a0cadf4e24f0400531883 0x49678AAB11E001eb3cB2cBD9aA96b36DC2461A94 Celo 0xBC2eBA680EE50d685cc4Fe65f102AA70AfB27D3F 0x49678AAB11E001eb3cB2cBD9aA96b36DC2461A94 Ethereum 0x53e8577C4347C365E4e0DA5B57A589cB6f2AB848 0x49678AAB11E001eb3cB2cBD9aA96b36DC2461A94 Harmony 0x8906f62d40293ddca77fdf6714c3f63265deddf0 0x49678AAB11E001eb3cB2cBD9aA96b36DC2461A94 Klaytn 0x80d8bac9a6901698b3749fe336bbd1385c1f98f2 0x49678AAB11E001eb3cB2cBD9aA96b36DC2461A94 Polygon 0x542b9ac4945a3836fd12ad98acbc76a0c8b743f5 0x49678AAB11E001eb3cB2cBD9aA96b36DC2461A94 *If a minter blockchain address on the testnet does not have sufficient funds to cover the transaction fee, add some amount to it using a crypto faucet of the blockchain. Minting NFTs natively on a blockchain When minting an NFT natively on a blockchain, you are charged a fee for the transaction, and you must sign the transaction with the private key of the blockchain address from which the fee will be deducted. Providing the private key in the API is not a secure way of signing transactions, because the private key can be stolen or exposed. Your private keys should never leave your security perimeter. You should use the private keys only for testing a solution you are building on the testnet of a blockchain. For signing transactions on the mainnet, we strongly recommend that you use the Tatum Key Management System (KMS) and provide the signature ID instead of the private key in the API. Alternatively, you can use the Tatum JavaScript client. You can mint NFTs natively on the following blockchains: Algorand BNB Smart Chain Celo Ethereum Flow Harmony Klaytn KuCoin Community Chain Polygon Solana TRON Depending on what blockchain you use, choose the request body schema to use in the API call. To mint NFTs natively on Algorand and: To sign the transaction with your private key, use this API with the MintNftAlgorand schema of the request body. To sign the transaction with your signature ID, use this API the MintNftAlgorandKMS schema of the request body. NOTE: To be able to burn the minted NFTs any time later, specify the address of the manager account in the manager parameter. An NFT minted on Algorand is automatically transferred to your blockchain address. After the NFT is minted, you have to transfer it to the recipient&#39;s address. The recipient has to agree in advance to receive your NFT because Algorand charges users for storing NFTs on their addresses, and an Algorand blockchain address by default does not receive NFTs unless explicitly agreed. For more information about how it works, see the section about minting NFTs on Algorand using the pre-built NFT smart contract provided by Tatum. To mint NFTs natively on BNB Smart Chain, Ethereum, Harmony, Klaytn, KuCoin Community Chain, or Polygon, and: To sign the transaction with your private key, use this API with the MintNft schema of the request body. To sign the transaction with your signature ID, use this API the MintNftKMS schema of the request body. To mint NFTs natively on Celo and: To sign the transaction with your private key, use this API with the MintNftCelo schema of the request body. To sign the transaction with your signature ID, use this API the MintNftKMSCelo schema of the request body. To mint NFTs natively on Flow and: To sign the transaction with your private key, use this API with the MintNftFlowPK schema of the request body. To sign the transaction with your signature ID, use this API the MintNftFlowMnemonic schema of the request body. To sign the transaction with your wallet mnemonic, use this API the MintNftFlowKMS schema of the request body. To mint NFTs natively on Solana and: To sign the transaction with your private key, use this API with the MintNftSolana schema of the request body. To sign the transaction with your signature ID, use this API the MintNftSolanaKMS schema of the request body. NOTE: When an NFT is minted on Solana, a new blockchain address is created to receive the NFT under the recipient&#39;s account address. After the NFT is minted, you have to transfer it to the recipient&#39;s address. For more information about how it works, see the section about minting NFTs on Solana using the pre-built NFT smart contract provided by Tatum. To mint NFTs natively on TRON and: To sign the transaction with your private key, use this API with the MintNftTron schema of the request body. To sign the transaction with your signature ID, use this API the MintNftKMSTron schema of the request body.
        /// </summary>
        /// <exception cref="Tatum.CSharp.Bsc.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="mintNftMinter"></param>
        /// <param name="xTestnetType">Type of Ethereum testnet. Defaults to Sepolia. Valid only for ETH invocations for testnet API Key. For mainnet API Key, this value is ignored. (optional, default to ethereum-sepolia)</param>
        /// <returns>TransactionHash</returns>
        public TransactionHash NftMintErc721(MintNftMinter mintNftMinter, string xTestnetType = default(string))
        {
            var localVarResponse = NftMintErc721WithHttpInfo(mintNftMinter, xTestnetType);

            var exception = ExceptionFactory?.Invoke("NftMintErc721_0", localVarResponse);
            if (exception != null) throw exception;

            return localVarResponse.Data;
        }

        /// <summary>
        /// Mint an NFT 100 credits per API call on Flow 2 credits per API call on the other blockchains You can mint NFTs using either of the following methods: Using NFT Express Natively on a blockchain Minting NFTs using NFT Express NFT Express is Tatum&#39;s feature that helps you mint NFTs easier than minting natively on a blockchain. You do not need to enter your private key or signature ID. NFT Express uses the private key provided by Tatum. You do not need to hold crypto or keep addresses topped up with crypto to pay for minting transactions. To use NFT Express on the mainnet, you have to have a paid pricing plan. Tatum covers your transaction fees for NFT minting and pays for them from its own blockchain address. Then, the fee amount paid by Tatum is converted to the number of credits, and these credits are deducted from the monthly credit allowance of your paid pricing plan. The transaction fees and the corresponding numbers of credits deducted from your allowance vary depending on what blockchain you mint NFTs on. On the testnet, no credits are deducted from the monthly credit allowance. You can mint NFTs with NFT Express regardless of your pricing plan. With NFT Express, you can choose whether to mint NFTs on the pre-built NFT smart contract provided by Tatum or on your own smart contract. Use the pre-built smart contract provided by Tatum to mint NFTs If you want to mint NFTs using the pre-built smart contract, you do not need to deploy your own NFT smart contract. You do not need to provide the address of the NFT smart contract and the token ID in the request body either. The address of the smart contract and the token ID are provided automatically by Tatum. The token ID is autogenerated. It starts with 0 and is increased by 1 for each new NFT. The token ID is calculated separately for each supported blockchain and its mainnet and testnet. For more information, see our user documentation. You can mint NFTs on the pre-built smart contract provided by Tatum on the following blockchains: Algorand BNB Smart Chain Celo Ethereum Harmony Klaytn Polygon Solana Depending on what blockchain you use, choose the request body schema to use in the API call. To mint NFTs on BNB Smart Chain, Celo, Ethereum, Harmony, Klaytn, or Polygon, use this API with the MintNftExpress schema of the request body. To mint NFTs on Algorand, use this API with the MintNftExpressAlgorand schema of the request body. To be able to burn the minted NFTs any time later, specify the address of the manager account in the manager parameter. An NFT minted on Algorand is automatically transferred to your blockchain address. After the NFT is minted, you have to transfer it to the recipient&#39;s address. The recipient has to agree in advance to receive your NFT because Algorand charges users for storing NFTs on their addresses, and an Algorand blockchain address by default does not receive NFTs unless explicitly agreed. This how it works: The recipient agrees to receive the NFT to their address. You transfer the NFT to the recipient&#39;s address (use the transferNftAlgoExpress schema of the request body). NOTE: On the mainnet, Tatum covers your transaction fees for the NFT transfer and pays for them from its own blockchain address. Then, the fee amount paid by Tatum is converted to the number of credits, and these credits are deducted from the monthly credit allowance of your paid pricing plan. On the testnet, no credits are deducted from the monthly credit allowance. To mint NFTs on Solana, use this API with the MintNftExpressSolana schema of the request body. Solana uses the Metaplex Protocol, a smart contract and metadata standard for creating and working with NFTs. When you mint an NFT on Solana with NFT Express, the pre-built smart contract based on the Metaplex Protocol is used. When an NFT is minted on Solana, a new blockchain address is created to receive the NFT under the recipient&#39;s account address (the one in the to parameter of the request body). This address is returned in the nftAccountAddress parameter in the response body, is owned by the recipient&#39;s address, and has the same private key. The response body also returns the address of the minted NFT itself, which is held in the nftAddress parameter. After the NFT is minted, you have to transfer it to the recipient&#39;s address (use the transferNftSolana or transferNftSolanaKMS schema of the request body). In the request body of the transfer call: Set the from parameter to the address that you used in the to parameter in the request body of the minting call. Set the to parameter to the recipient&#39;s address. Set the contractAddress parameter to the address from the nftAddress parameter returned in the response body of the minting call. Set the fromPrivateKey/signatureId parameter to the private key/signature ID of the blockchain address that you specified in the from parameter. Use your own smart contract to mint NFTs If you want to mint NFTs using your own smart contract, you are going to use an NTF minter, a special blockchain address provided by Tatum that will cover the minting fees. The number of credits equivalent to the fees will be then deducted from the monthly credit allowance of your paid pricing plan. IMPORTANT! Your smart contract must be deployed as a general NFT smart contract. You cannot use cashback and provenance smart contracts with NFT Express. For more information, see our user documentation and the article in the Tatum blog. You can mint NFTs on your own smart contract on the following blockchains: BNB Smart Chain Celo Ethereum Harmony Klaytn Polygon To mint NFTs using your own smart contract, do the following: In the table located under this section, find the blockchain address of the Tatum NFT minter for your blockchain and network (mainnet or testnet). Add the minter address as an NFT minter to your smart contract. Use this API with the MintNftMinter schema of the request body. In the request body, enter the following information: chain is the blockchain that you use. to is the blockchain address where to send the minted NFT to. url is the URL of the NFT metadata. minter is the address of the NFT minter that you found in Step 1. contractAddress is the address of your NFT smart contract. tokenId is the the token ID of the NFT. For example:  {   \&quot;chain\&quot;: \&quot;CELO\&quot;,   \&quot;to\&quot;: \&quot;0x8ce4e40889a13971681391aad29e88efaf91f784\&quot;,   \&quot;url\&quot;: \&quot;ipfs://QmXJJ6UF5WkF4WTJvsdhiA1etGwBLfpva7Vr9AudGMe3pj\&quot;,   \&quot;contractAddress\&quot;: \&quot;0x687422eEA2cB73B5d3e242bA5456b782919AFc85\&quot;,   \&quot;tokenId\&quot;: \&quot;0123\&quot;,   \&quot;minter\&quot;: \&quot;0xBC2eBA680EE50d685cc4Fe65f102AA70AfB27D3F\&quot; } When you make an API call with this request body, the private key of the NFT minter will be added to the request body automatically:  {   \&quot;chain\&quot;: \&quot;CELO\&quot;,   \&quot;to\&quot;: \&quot;0x8ce4e40889a13971681391aad29e88efaf91f784\&quot;,   \&quot;url\&quot;: \&quot;ipfs://QmXJJ6UF5WkF4WTJvsdhiA1etGwBLfpva7Vr9AudGMe3pj\&quot;,   \&quot;contractAddress\&quot;: \&quot;0x687422eEA2cB73B5d3e242bA5456b782919AFc85\&quot;,   \&quot;tokenId\&quot;: \&quot;0123\&quot;,   \&quot;minter\&quot;: \&quot;0xBC2eBA680EE50d685cc4Fe65f102AA70AfB27D3F\&quot;,   \&quot;fromPrivateKey\&quot;: \&quot;0x05e150c73f1920ec14caa1e0b6aa09940899678051a78542840c2668ce5080c2\&quot; } The following table lists the blockchain addresses of the Tatum NFT minters for the testnet and mainnet of the supported blockchains: Blockchain Minter address - testnet* Minter address - mainnet BNB Smart Chain 0xc16ae5e8c985b906935a0cadf4e24f0400531883 0x49678AAB11E001eb3cB2cBD9aA96b36DC2461A94 Celo 0xBC2eBA680EE50d685cc4Fe65f102AA70AfB27D3F 0x49678AAB11E001eb3cB2cBD9aA96b36DC2461A94 Ethereum 0x53e8577C4347C365E4e0DA5B57A589cB6f2AB848 0x49678AAB11E001eb3cB2cBD9aA96b36DC2461A94 Harmony 0x8906f62d40293ddca77fdf6714c3f63265deddf0 0x49678AAB11E001eb3cB2cBD9aA96b36DC2461A94 Klaytn 0x80d8bac9a6901698b3749fe336bbd1385c1f98f2 0x49678AAB11E001eb3cB2cBD9aA96b36DC2461A94 Polygon 0x542b9ac4945a3836fd12ad98acbc76a0c8b743f5 0x49678AAB11E001eb3cB2cBD9aA96b36DC2461A94 *If a minter blockchain address on the testnet does not have sufficient funds to cover the transaction fee, add some amount to it using a crypto faucet of the blockchain. Minting NFTs natively on a blockchain When minting an NFT natively on a blockchain, you are charged a fee for the transaction, and you must sign the transaction with the private key of the blockchain address from which the fee will be deducted. Providing the private key in the API is not a secure way of signing transactions, because the private key can be stolen or exposed. Your private keys should never leave your security perimeter. You should use the private keys only for testing a solution you are building on the testnet of a blockchain. For signing transactions on the mainnet, we strongly recommend that you use the Tatum Key Management System (KMS) and provide the signature ID instead of the private key in the API. Alternatively, you can use the Tatum JavaScript client. You can mint NFTs natively on the following blockchains: Algorand BNB Smart Chain Celo Ethereum Flow Harmony Klaytn KuCoin Community Chain Polygon Solana TRON Depending on what blockchain you use, choose the request body schema to use in the API call. To mint NFTs natively on Algorand and: To sign the transaction with your private key, use this API with the MintNftAlgorand schema of the request body. To sign the transaction with your signature ID, use this API the MintNftAlgorandKMS schema of the request body. NOTE: To be able to burn the minted NFTs any time later, specify the address of the manager account in the manager parameter. An NFT minted on Algorand is automatically transferred to your blockchain address. After the NFT is minted, you have to transfer it to the recipient&#39;s address. The recipient has to agree in advance to receive your NFT because Algorand charges users for storing NFTs on their addresses, and an Algorand blockchain address by default does not receive NFTs unless explicitly agreed. For more information about how it works, see the section about minting NFTs on Algorand using the pre-built NFT smart contract provided by Tatum. To mint NFTs natively on BNB Smart Chain, Ethereum, Harmony, Klaytn, KuCoin Community Chain, or Polygon, and: To sign the transaction with your private key, use this API with the MintNft schema of the request body. To sign the transaction with your signature ID, use this API the MintNftKMS schema of the request body. To mint NFTs natively on Celo and: To sign the transaction with your private key, use this API with the MintNftCelo schema of the request body. To sign the transaction with your signature ID, use this API the MintNftKMSCelo schema of the request body. To mint NFTs natively on Flow and: To sign the transaction with your private key, use this API with the MintNftFlowPK schema of the request body. To sign the transaction with your signature ID, use this API the MintNftFlowMnemonic schema of the request body. To sign the transaction with your wallet mnemonic, use this API the MintNftFlowKMS schema of the request body. To mint NFTs natively on Solana and: To sign the transaction with your private key, use this API with the MintNftSolana schema of the request body. To sign the transaction with your signature ID, use this API the MintNftSolanaKMS schema of the request body. NOTE: When an NFT is minted on Solana, a new blockchain address is created to receive the NFT under the recipient&#39;s account address. After the NFT is minted, you have to transfer it to the recipient&#39;s address. For more information about how it works, see the section about minting NFTs on Solana using the pre-built NFT smart contract provided by Tatum. To mint NFTs natively on TRON and: To sign the transaction with your private key, use this API with the MintNftTron schema of the request body. To sign the transaction with your signature ID, use this API the MintNftKMSTron schema of the request body.
        /// </summary>
        /// <exception cref="Tatum.CSharp.Bsc.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="mintNftMinter"></param>
        /// <param name="xTestnetType">Type of Ethereum testnet. Defaults to Sepolia. Valid only for ETH invocations for testnet API Key. For mainnet API Key, this value is ignored. (optional, default to ethereum-sepolia)</param>
        /// <returns>ApiResponse of TransactionHash</returns>
        public ApiResponse<TransactionHash> NftMintErc721WithHttpInfo(MintNftMinter mintNftMinter, string xTestnetType = default(string))
        {
            // verify the required parameter 'mintNftMinter' is set
            if (mintNftMinter == null)
                throw new ApiException(400, "Missing required parameter 'mintNftMinter' when calling NFTBscApi->NftMintErc721_0");

            var localVarRequestOptions = new RequestOptions();

            var contentTypes = new string[]{
                "application/json"
            };

            // to determine the Accept header
            var accepts = new string[]{
                "application/json"
            };

            var localVarContentType = ClientUtils.SelectHeaderContentType(contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = ClientUtils.SelectHeaderAccept(accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            if (xTestnetType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("x-testnet-type", ClientUtils.ParameterToString(xTestnetType)); // header parameter
            }
            localVarRequestOptions.Data = mintNftMinter;

            // authentication (X-API-Key) required
            if (!string.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("x-api-key")))
            {
                localVarRequestOptions.HeaderParameters.Add("x-api-key", Configuration.GetApiKeyWithPrefix("x-api-key"));
            }

            // make the HTTP request
            var localVarResponse = Client.Post<TransactionHash>("/v3/nft/mint", localVarRequestOptions, Configuration);

            return localVarResponse;
        }

        /// <summary>
        /// Mint an NFT 100 credits per API call on Flow 2 credits per API call on the other blockchains You can mint NFTs using either of the following methods: Using NFT Express Natively on a blockchain Minting NFTs using NFT Express NFT Express is Tatum&#39;s feature that helps you mint NFTs easier than minting natively on a blockchain. You do not need to enter your private key or signature ID. NFT Express uses the private key provided by Tatum. You do not need to hold crypto or keep addresses topped up with crypto to pay for minting transactions. To use NFT Express on the mainnet, you have to have a paid pricing plan. Tatum covers your transaction fees for NFT minting and pays for them from its own blockchain address. Then, the fee amount paid by Tatum is converted to the number of credits, and these credits are deducted from the monthly credit allowance of your paid pricing plan. The transaction fees and the corresponding numbers of credits deducted from your allowance vary depending on what blockchain you mint NFTs on. On the testnet, no credits are deducted from the monthly credit allowance. You can mint NFTs with NFT Express regardless of your pricing plan. With NFT Express, you can choose whether to mint NFTs on the pre-built NFT smart contract provided by Tatum or on your own smart contract. Use the pre-built smart contract provided by Tatum to mint NFTs If you want to mint NFTs using the pre-built smart contract, you do not need to deploy your own NFT smart contract. You do not need to provide the address of the NFT smart contract and the token ID in the request body either. The address of the smart contract and the token ID are provided automatically by Tatum. The token ID is autogenerated. It starts with 0 and is increased by 1 for each new NFT. The token ID is calculated separately for each supported blockchain and its mainnet and testnet. For more information, see our user documentation. You can mint NFTs on the pre-built smart contract provided by Tatum on the following blockchains: Algorand BNB Smart Chain Celo Ethereum Harmony Klaytn Polygon Solana Depending on what blockchain you use, choose the request body schema to use in the API call. To mint NFTs on BNB Smart Chain, Celo, Ethereum, Harmony, Klaytn, or Polygon, use this API with the MintNftExpress schema of the request body. To mint NFTs on Algorand, use this API with the MintNftExpressAlgorand schema of the request body. To be able to burn the minted NFTs any time later, specify the address of the manager account in the manager parameter. An NFT minted on Algorand is automatically transferred to your blockchain address. After the NFT is minted, you have to transfer it to the recipient&#39;s address. The recipient has to agree in advance to receive your NFT because Algorand charges users for storing NFTs on their addresses, and an Algorand blockchain address by default does not receive NFTs unless explicitly agreed. This how it works: The recipient agrees to receive the NFT to their address. You transfer the NFT to the recipient&#39;s address (use the transferNftAlgoExpress schema of the request body). NOTE: On the mainnet, Tatum covers your transaction fees for the NFT transfer and pays for them from its own blockchain address. Then, the fee amount paid by Tatum is converted to the number of credits, and these credits are deducted from the monthly credit allowance of your paid pricing plan. On the testnet, no credits are deducted from the monthly credit allowance. To mint NFTs on Solana, use this API with the MintNftExpressSolana schema of the request body. Solana uses the Metaplex Protocol, a smart contract and metadata standard for creating and working with NFTs. When you mint an NFT on Solana with NFT Express, the pre-built smart contract based on the Metaplex Protocol is used. When an NFT is minted on Solana, a new blockchain address is created to receive the NFT under the recipient&#39;s account address (the one in the to parameter of the request body). This address is returned in the nftAccountAddress parameter in the response body, is owned by the recipient&#39;s address, and has the same private key. The response body also returns the address of the minted NFT itself, which is held in the nftAddress parameter. After the NFT is minted, you have to transfer it to the recipient&#39;s address (use the transferNftSolana or transferNftSolanaKMS schema of the request body). In the request body of the transfer call: Set the from parameter to the address that you used in the to parameter in the request body of the minting call. Set the to parameter to the recipient&#39;s address. Set the contractAddress parameter to the address from the nftAddress parameter returned in the response body of the minting call. Set the fromPrivateKey/signatureId parameter to the private key/signature ID of the blockchain address that you specified in the from parameter. Use your own smart contract to mint NFTs If you want to mint NFTs using your own smart contract, you are going to use an NTF minter, a special blockchain address provided by Tatum that will cover the minting fees. The number of credits equivalent to the fees will be then deducted from the monthly credit allowance of your paid pricing plan. IMPORTANT! Your smart contract must be deployed as a general NFT smart contract. You cannot use cashback and provenance smart contracts with NFT Express. For more information, see our user documentation and the article in the Tatum blog. You can mint NFTs on your own smart contract on the following blockchains: BNB Smart Chain Celo Ethereum Harmony Klaytn Polygon To mint NFTs using your own smart contract, do the following: In the table located under this section, find the blockchain address of the Tatum NFT minter for your blockchain and network (mainnet or testnet). Add the minter address as an NFT minter to your smart contract. Use this API with the MintNftMinter schema of the request body. In the request body, enter the following information: chain is the blockchain that you use. to is the blockchain address where to send the minted NFT to. url is the URL of the NFT metadata. minter is the address of the NFT minter that you found in Step 1. contractAddress is the address of your NFT smart contract. tokenId is the the token ID of the NFT. For example:  {   \&quot;chain\&quot;: \&quot;CELO\&quot;,   \&quot;to\&quot;: \&quot;0x8ce4e40889a13971681391aad29e88efaf91f784\&quot;,   \&quot;url\&quot;: \&quot;ipfs://QmXJJ6UF5WkF4WTJvsdhiA1etGwBLfpva7Vr9AudGMe3pj\&quot;,   \&quot;contractAddress\&quot;: \&quot;0x687422eEA2cB73B5d3e242bA5456b782919AFc85\&quot;,   \&quot;tokenId\&quot;: \&quot;0123\&quot;,   \&quot;minter\&quot;: \&quot;0xBC2eBA680EE50d685cc4Fe65f102AA70AfB27D3F\&quot; } When you make an API call with this request body, the private key of the NFT minter will be added to the request body automatically:  {   \&quot;chain\&quot;: \&quot;CELO\&quot;,   \&quot;to\&quot;: \&quot;0x8ce4e40889a13971681391aad29e88efaf91f784\&quot;,   \&quot;url\&quot;: \&quot;ipfs://QmXJJ6UF5WkF4WTJvsdhiA1etGwBLfpva7Vr9AudGMe3pj\&quot;,   \&quot;contractAddress\&quot;: \&quot;0x687422eEA2cB73B5d3e242bA5456b782919AFc85\&quot;,   \&quot;tokenId\&quot;: \&quot;0123\&quot;,   \&quot;minter\&quot;: \&quot;0xBC2eBA680EE50d685cc4Fe65f102AA70AfB27D3F\&quot;,   \&quot;fromPrivateKey\&quot;: \&quot;0x05e150c73f1920ec14caa1e0b6aa09940899678051a78542840c2668ce5080c2\&quot; } The following table lists the blockchain addresses of the Tatum NFT minters for the testnet and mainnet of the supported blockchains: Blockchain Minter address - testnet* Minter address - mainnet BNB Smart Chain 0xc16ae5e8c985b906935a0cadf4e24f0400531883 0x49678AAB11E001eb3cB2cBD9aA96b36DC2461A94 Celo 0xBC2eBA680EE50d685cc4Fe65f102AA70AfB27D3F 0x49678AAB11E001eb3cB2cBD9aA96b36DC2461A94 Ethereum 0x53e8577C4347C365E4e0DA5B57A589cB6f2AB848 0x49678AAB11E001eb3cB2cBD9aA96b36DC2461A94 Harmony 0x8906f62d40293ddca77fdf6714c3f63265deddf0 0x49678AAB11E001eb3cB2cBD9aA96b36DC2461A94 Klaytn 0x80d8bac9a6901698b3749fe336bbd1385c1f98f2 0x49678AAB11E001eb3cB2cBD9aA96b36DC2461A94 Polygon 0x542b9ac4945a3836fd12ad98acbc76a0c8b743f5 0x49678AAB11E001eb3cB2cBD9aA96b36DC2461A94 *If a minter blockchain address on the testnet does not have sufficient funds to cover the transaction fee, add some amount to it using a crypto faucet of the blockchain. Minting NFTs natively on a blockchain When minting an NFT natively on a blockchain, you are charged a fee for the transaction, and you must sign the transaction with the private key of the blockchain address from which the fee will be deducted. Providing the private key in the API is not a secure way of signing transactions, because the private key can be stolen or exposed. Your private keys should never leave your security perimeter. You should use the private keys only for testing a solution you are building on the testnet of a blockchain. For signing transactions on the mainnet, we strongly recommend that you use the Tatum Key Management System (KMS) and provide the signature ID instead of the private key in the API. Alternatively, you can use the Tatum JavaScript client. You can mint NFTs natively on the following blockchains: Algorand BNB Smart Chain Celo Ethereum Flow Harmony Klaytn KuCoin Community Chain Polygon Solana TRON Depending on what blockchain you use, choose the request body schema to use in the API call. To mint NFTs natively on Algorand and: To sign the transaction with your private key, use this API with the MintNftAlgorand schema of the request body. To sign the transaction with your signature ID, use this API the MintNftAlgorandKMS schema of the request body. NOTE: To be able to burn the minted NFTs any time later, specify the address of the manager account in the manager parameter. An NFT minted on Algorand is automatically transferred to your blockchain address. After the NFT is minted, you have to transfer it to the recipient&#39;s address. The recipient has to agree in advance to receive your NFT because Algorand charges users for storing NFTs on their addresses, and an Algorand blockchain address by default does not receive NFTs unless explicitly agreed. For more information about how it works, see the section about minting NFTs on Algorand using the pre-built NFT smart contract provided by Tatum. To mint NFTs natively on BNB Smart Chain, Ethereum, Harmony, Klaytn, KuCoin Community Chain, or Polygon, and: To sign the transaction with your private key, use this API with the MintNft schema of the request body. To sign the transaction with your signature ID, use this API the MintNftKMS schema of the request body. To mint NFTs natively on Celo and: To sign the transaction with your private key, use this API with the MintNftCelo schema of the request body. To sign the transaction with your signature ID, use this API the MintNftKMSCelo schema of the request body. To mint NFTs natively on Flow and: To sign the transaction with your private key, use this API with the MintNftFlowPK schema of the request body. To sign the transaction with your signature ID, use this API the MintNftFlowMnemonic schema of the request body. To sign the transaction with your wallet mnemonic, use this API the MintNftFlowKMS schema of the request body. To mint NFTs natively on Solana and: To sign the transaction with your private key, use this API with the MintNftSolana schema of the request body. To sign the transaction with your signature ID, use this API the MintNftSolanaKMS schema of the request body. NOTE: When an NFT is minted on Solana, a new blockchain address is created to receive the NFT under the recipient&#39;s account address. After the NFT is minted, you have to transfer it to the recipient&#39;s address. For more information about how it works, see the section about minting NFTs on Solana using the pre-built NFT smart contract provided by Tatum. To mint NFTs natively on TRON and: To sign the transaction with your private key, use this API with the MintNftTron schema of the request body. To sign the transaction with your signature ID, use this API the MintNftKMSTron schema of the request body.
        /// </summary>
        /// <exception cref="Tatum.CSharp.Bsc.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="mintNftMinter"></param>
        /// <param name="xTestnetType">Type of Ethereum testnet. Defaults to Sepolia. Valid only for ETH invocations for testnet API Key. For mainnet API Key, this value is ignored. (optional, default to ethereum-sepolia)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of TransactionHash</returns>
        public async System.Threading.Tasks.Task<TransactionHash> NftMintErc721Async(MintNftMinter mintNftMinter, string xTestnetType = default(string), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            var localVarResponse = await NftMintErc721WithHttpInfoAsync(mintNftMinter, xTestnetType, cancellationToken).ConfigureAwait(false);
            
            var exception = ExceptionFactory?.Invoke("NftMintErc721_0", localVarResponse);
            if (exception != null) throw exception;

            return localVarResponse.Data;
        }

        /// <summary>
        /// Mint an NFT 100 credits per API call on Flow 2 credits per API call on the other blockchains You can mint NFTs using either of the following methods: Using NFT Express Natively on a blockchain Minting NFTs using NFT Express NFT Express is Tatum&#39;s feature that helps you mint NFTs easier than minting natively on a blockchain. You do not need to enter your private key or signature ID. NFT Express uses the private key provided by Tatum. You do not need to hold crypto or keep addresses topped up with crypto to pay for minting transactions. To use NFT Express on the mainnet, you have to have a paid pricing plan. Tatum covers your transaction fees for NFT minting and pays for them from its own blockchain address. Then, the fee amount paid by Tatum is converted to the number of credits, and these credits are deducted from the monthly credit allowance of your paid pricing plan. The transaction fees and the corresponding numbers of credits deducted from your allowance vary depending on what blockchain you mint NFTs on. On the testnet, no credits are deducted from the monthly credit allowance. You can mint NFTs with NFT Express regardless of your pricing plan. With NFT Express, you can choose whether to mint NFTs on the pre-built NFT smart contract provided by Tatum or on your own smart contract. Use the pre-built smart contract provided by Tatum to mint NFTs If you want to mint NFTs using the pre-built smart contract, you do not need to deploy your own NFT smart contract. You do not need to provide the address of the NFT smart contract and the token ID in the request body either. The address of the smart contract and the token ID are provided automatically by Tatum. The token ID is autogenerated. It starts with 0 and is increased by 1 for each new NFT. The token ID is calculated separately for each supported blockchain and its mainnet and testnet. For more information, see our user documentation. You can mint NFTs on the pre-built smart contract provided by Tatum on the following blockchains: Algorand BNB Smart Chain Celo Ethereum Harmony Klaytn Polygon Solana Depending on what blockchain you use, choose the request body schema to use in the API call. To mint NFTs on BNB Smart Chain, Celo, Ethereum, Harmony, Klaytn, or Polygon, use this API with the MintNftExpress schema of the request body. To mint NFTs on Algorand, use this API with the MintNftExpressAlgorand schema of the request body. To be able to burn the minted NFTs any time later, specify the address of the manager account in the manager parameter. An NFT minted on Algorand is automatically transferred to your blockchain address. After the NFT is minted, you have to transfer it to the recipient&#39;s address. The recipient has to agree in advance to receive your NFT because Algorand charges users for storing NFTs on their addresses, and an Algorand blockchain address by default does not receive NFTs unless explicitly agreed. This how it works: The recipient agrees to receive the NFT to their address. You transfer the NFT to the recipient&#39;s address (use the transferNftAlgoExpress schema of the request body). NOTE: On the mainnet, Tatum covers your transaction fees for the NFT transfer and pays for them from its own blockchain address. Then, the fee amount paid by Tatum is converted to the number of credits, and these credits are deducted from the monthly credit allowance of your paid pricing plan. On the testnet, no credits are deducted from the monthly credit allowance. To mint NFTs on Solana, use this API with the MintNftExpressSolana schema of the request body. Solana uses the Metaplex Protocol, a smart contract and metadata standard for creating and working with NFTs. When you mint an NFT on Solana with NFT Express, the pre-built smart contract based on the Metaplex Protocol is used. When an NFT is minted on Solana, a new blockchain address is created to receive the NFT under the recipient&#39;s account address (the one in the to parameter of the request body). This address is returned in the nftAccountAddress parameter in the response body, is owned by the recipient&#39;s address, and has the same private key. The response body also returns the address of the minted NFT itself, which is held in the nftAddress parameter. After the NFT is minted, you have to transfer it to the recipient&#39;s address (use the transferNftSolana or transferNftSolanaKMS schema of the request body). In the request body of the transfer call: Set the from parameter to the address that you used in the to parameter in the request body of the minting call. Set the to parameter to the recipient&#39;s address. Set the contractAddress parameter to the address from the nftAddress parameter returned in the response body of the minting call. Set the fromPrivateKey/signatureId parameter to the private key/signature ID of the blockchain address that you specified in the from parameter. Use your own smart contract to mint NFTs If you want to mint NFTs using your own smart contract, you are going to use an NTF minter, a special blockchain address provided by Tatum that will cover the minting fees. The number of credits equivalent to the fees will be then deducted from the monthly credit allowance of your paid pricing plan. IMPORTANT! Your smart contract must be deployed as a general NFT smart contract. You cannot use cashback and provenance smart contracts with NFT Express. For more information, see our user documentation and the article in the Tatum blog. You can mint NFTs on your own smart contract on the following blockchains: BNB Smart Chain Celo Ethereum Harmony Klaytn Polygon To mint NFTs using your own smart contract, do the following: In the table located under this section, find the blockchain address of the Tatum NFT minter for your blockchain and network (mainnet or testnet). Add the minter address as an NFT minter to your smart contract. Use this API with the MintNftMinter schema of the request body. In the request body, enter the following information: chain is the blockchain that you use. to is the blockchain address where to send the minted NFT to. url is the URL of the NFT metadata. minter is the address of the NFT minter that you found in Step 1. contractAddress is the address of your NFT smart contract. tokenId is the the token ID of the NFT. For example:  {   \&quot;chain\&quot;: \&quot;CELO\&quot;,   \&quot;to\&quot;: \&quot;0x8ce4e40889a13971681391aad29e88efaf91f784\&quot;,   \&quot;url\&quot;: \&quot;ipfs://QmXJJ6UF5WkF4WTJvsdhiA1etGwBLfpva7Vr9AudGMe3pj\&quot;,   \&quot;contractAddress\&quot;: \&quot;0x687422eEA2cB73B5d3e242bA5456b782919AFc85\&quot;,   \&quot;tokenId\&quot;: \&quot;0123\&quot;,   \&quot;minter\&quot;: \&quot;0xBC2eBA680EE50d685cc4Fe65f102AA70AfB27D3F\&quot; } When you make an API call with this request body, the private key of the NFT minter will be added to the request body automatically:  {   \&quot;chain\&quot;: \&quot;CELO\&quot;,   \&quot;to\&quot;: \&quot;0x8ce4e40889a13971681391aad29e88efaf91f784\&quot;,   \&quot;url\&quot;: \&quot;ipfs://QmXJJ6UF5WkF4WTJvsdhiA1etGwBLfpva7Vr9AudGMe3pj\&quot;,   \&quot;contractAddress\&quot;: \&quot;0x687422eEA2cB73B5d3e242bA5456b782919AFc85\&quot;,   \&quot;tokenId\&quot;: \&quot;0123\&quot;,   \&quot;minter\&quot;: \&quot;0xBC2eBA680EE50d685cc4Fe65f102AA70AfB27D3F\&quot;,   \&quot;fromPrivateKey\&quot;: \&quot;0x05e150c73f1920ec14caa1e0b6aa09940899678051a78542840c2668ce5080c2\&quot; } The following table lists the blockchain addresses of the Tatum NFT minters for the testnet and mainnet of the supported blockchains: Blockchain Minter address - testnet* Minter address - mainnet BNB Smart Chain 0xc16ae5e8c985b906935a0cadf4e24f0400531883 0x49678AAB11E001eb3cB2cBD9aA96b36DC2461A94 Celo 0xBC2eBA680EE50d685cc4Fe65f102AA70AfB27D3F 0x49678AAB11E001eb3cB2cBD9aA96b36DC2461A94 Ethereum 0x53e8577C4347C365E4e0DA5B57A589cB6f2AB848 0x49678AAB11E001eb3cB2cBD9aA96b36DC2461A94 Harmony 0x8906f62d40293ddca77fdf6714c3f63265deddf0 0x49678AAB11E001eb3cB2cBD9aA96b36DC2461A94 Klaytn 0x80d8bac9a6901698b3749fe336bbd1385c1f98f2 0x49678AAB11E001eb3cB2cBD9aA96b36DC2461A94 Polygon 0x542b9ac4945a3836fd12ad98acbc76a0c8b743f5 0x49678AAB11E001eb3cB2cBD9aA96b36DC2461A94 *If a minter blockchain address on the testnet does not have sufficient funds to cover the transaction fee, add some amount to it using a crypto faucet of the blockchain. Minting NFTs natively on a blockchain When minting an NFT natively on a blockchain, you are charged a fee for the transaction, and you must sign the transaction with the private key of the blockchain address from which the fee will be deducted. Providing the private key in the API is not a secure way of signing transactions, because the private key can be stolen or exposed. Your private keys should never leave your security perimeter. You should use the private keys only for testing a solution you are building on the testnet of a blockchain. For signing transactions on the mainnet, we strongly recommend that you use the Tatum Key Management System (KMS) and provide the signature ID instead of the private key in the API. Alternatively, you can use the Tatum JavaScript client. You can mint NFTs natively on the following blockchains: Algorand BNB Smart Chain Celo Ethereum Flow Harmony Klaytn KuCoin Community Chain Polygon Solana TRON Depending on what blockchain you use, choose the request body schema to use in the API call. To mint NFTs natively on Algorand and: To sign the transaction with your private key, use this API with the MintNftAlgorand schema of the request body. To sign the transaction with your signature ID, use this API the MintNftAlgorandKMS schema of the request body. NOTE: To be able to burn the minted NFTs any time later, specify the address of the manager account in the manager parameter. An NFT minted on Algorand is automatically transferred to your blockchain address. After the NFT is minted, you have to transfer it to the recipient&#39;s address. The recipient has to agree in advance to receive your NFT because Algorand charges users for storing NFTs on their addresses, and an Algorand blockchain address by default does not receive NFTs unless explicitly agreed. For more information about how it works, see the section about minting NFTs on Algorand using the pre-built NFT smart contract provided by Tatum. To mint NFTs natively on BNB Smart Chain, Ethereum, Harmony, Klaytn, KuCoin Community Chain, or Polygon, and: To sign the transaction with your private key, use this API with the MintNft schema of the request body. To sign the transaction with your signature ID, use this API the MintNftKMS schema of the request body. To mint NFTs natively on Celo and: To sign the transaction with your private key, use this API with the MintNftCelo schema of the request body. To sign the transaction with your signature ID, use this API the MintNftKMSCelo schema of the request body. To mint NFTs natively on Flow and: To sign the transaction with your private key, use this API with the MintNftFlowPK schema of the request body. To sign the transaction with your signature ID, use this API the MintNftFlowMnemonic schema of the request body. To sign the transaction with your wallet mnemonic, use this API the MintNftFlowKMS schema of the request body. To mint NFTs natively on Solana and: To sign the transaction with your private key, use this API with the MintNftSolana schema of the request body. To sign the transaction with your signature ID, use this API the MintNftSolanaKMS schema of the request body. NOTE: When an NFT is minted on Solana, a new blockchain address is created to receive the NFT under the recipient&#39;s account address. After the NFT is minted, you have to transfer it to the recipient&#39;s address. For more information about how it works, see the section about minting NFTs on Solana using the pre-built NFT smart contract provided by Tatum. To mint NFTs natively on TRON and: To sign the transaction with your private key, use this API with the MintNftTron schema of the request body. To sign the transaction with your signature ID, use this API the MintNftKMSTron schema of the request body.
        /// </summary>
        /// <exception cref="Tatum.CSharp.Bsc.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="mintNftMinter"></param>
        /// <param name="xTestnetType">Type of Ethereum testnet. Defaults to Sepolia. Valid only for ETH invocations for testnet API Key. For mainnet API Key, this value is ignored. (optional, default to ethereum-sepolia)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (TransactionHash)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<TransactionHash>> NftMintErc721WithHttpInfoAsync(MintNftMinter mintNftMinter, string xTestnetType = default(string), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            // verify the required parameter 'mintNftMinter' is set
            if (mintNftMinter == null)
                throw new ApiException(400, "Missing required parameter 'mintNftMinter' when calling NFTBscApi->NftMintErc721_0");

            var localVarRequestOptions = new RequestOptions();

            var contentTypes = new string[]{
                "application/json"
            };

            // to determine the Accept header
            var accepts = new string[]{
                "application/json"
            };


            var localVarContentType = ClientUtils.SelectHeaderContentType(contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = ClientUtils.SelectHeaderAccept(accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            if (xTestnetType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("x-testnet-type", ClientUtils.ParameterToString(xTestnetType)); // header parameter
            }
            localVarRequestOptions.Data = mintNftMinter;

            // authentication (X-API-Key) required
            if (!string.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("x-api-key")))
            {
                localVarRequestOptions.HeaderParameters.Add("x-api-key", Configuration.GetApiKeyWithPrefix("x-api-key"));
            }

            // make the HTTP request

            var localVarResponse = await AsynchronousClient.PostAsync<TransactionHash>("/v3/nft/mint", localVarRequestOptions, Configuration, cancellationToken).ConfigureAwait(false);

            return localVarResponse;
        }

        /// <summary>
        /// Mint an NFT 100 credits per API call on Flow 2 credits per API call on the other blockchains You can mint NFTs using either of the following methods: Using NFT Express Natively on a blockchain Minting NFTs using NFT Express NFT Express is Tatum&#39;s feature that helps you mint NFTs easier than minting natively on a blockchain. You do not need to enter your private key or signature ID. NFT Express uses the private key provided by Tatum. You do not need to hold crypto or keep addresses topped up with crypto to pay for minting transactions. To use NFT Express on the mainnet, you have to have a paid pricing plan. Tatum covers your transaction fees for NFT minting and pays for them from its own blockchain address. Then, the fee amount paid by Tatum is converted to the number of credits, and these credits are deducted from the monthly credit allowance of your paid pricing plan. The transaction fees and the corresponding numbers of credits deducted from your allowance vary depending on what blockchain you mint NFTs on. On the testnet, no credits are deducted from the monthly credit allowance. You can mint NFTs with NFT Express regardless of your pricing plan. With NFT Express, you can choose whether to mint NFTs on the pre-built NFT smart contract provided by Tatum or on your own smart contract. Use the pre-built smart contract provided by Tatum to mint NFTs If you want to mint NFTs using the pre-built smart contract, you do not need to deploy your own NFT smart contract. You do not need to provide the address of the NFT smart contract and the token ID in the request body either. The address of the smart contract and the token ID are provided automatically by Tatum. The token ID is autogenerated. It starts with 0 and is increased by 1 for each new NFT. The token ID is calculated separately for each supported blockchain and its mainnet and testnet. For more information, see our user documentation. You can mint NFTs on the pre-built smart contract provided by Tatum on the following blockchains: Algorand BNB Smart Chain Celo Ethereum Harmony Klaytn Polygon Solana Depending on what blockchain you use, choose the request body schema to use in the API call. To mint NFTs on BNB Smart Chain, Celo, Ethereum, Harmony, Klaytn, or Polygon, use this API with the MintNftExpress schema of the request body. To mint NFTs on Algorand, use this API with the MintNftExpressAlgorand schema of the request body. To be able to burn the minted NFTs any time later, specify the address of the manager account in the manager parameter. An NFT minted on Algorand is automatically transferred to your blockchain address. After the NFT is minted, you have to transfer it to the recipient&#39;s address. The recipient has to agree in advance to receive your NFT because Algorand charges users for storing NFTs on their addresses, and an Algorand blockchain address by default does not receive NFTs unless explicitly agreed. This how it works: The recipient agrees to receive the NFT to their address. You transfer the NFT to the recipient&#39;s address (use the transferNftAlgoExpress schema of the request body). NOTE: On the mainnet, Tatum covers your transaction fees for the NFT transfer and pays for them from its own blockchain address. Then, the fee amount paid by Tatum is converted to the number of credits, and these credits are deducted from the monthly credit allowance of your paid pricing plan. On the testnet, no credits are deducted from the monthly credit allowance. To mint NFTs on Solana, use this API with the MintNftExpressSolana schema of the request body. Solana uses the Metaplex Protocol, a smart contract and metadata standard for creating and working with NFTs. When you mint an NFT on Solana with NFT Express, the pre-built smart contract based on the Metaplex Protocol is used. When an NFT is minted on Solana, a new blockchain address is created to receive the NFT under the recipient&#39;s account address (the one in the to parameter of the request body). This address is returned in the nftAccountAddress parameter in the response body, is owned by the recipient&#39;s address, and has the same private key. The response body also returns the address of the minted NFT itself, which is held in the nftAddress parameter. After the NFT is minted, you have to transfer it to the recipient&#39;s address (use the transferNftSolana or transferNftSolanaKMS schema of the request body). In the request body of the transfer call: Set the from parameter to the address that you used in the to parameter in the request body of the minting call. Set the to parameter to the recipient&#39;s address. Set the contractAddress parameter to the address from the nftAddress parameter returned in the response body of the minting call. Set the fromPrivateKey/signatureId parameter to the private key/signature ID of the blockchain address that you specified in the from parameter. Use your own smart contract to mint NFTs If you want to mint NFTs using your own smart contract, you are going to use an NTF minter, a special blockchain address provided by Tatum that will cover the minting fees. The number of credits equivalent to the fees will be then deducted from the monthly credit allowance of your paid pricing plan. IMPORTANT! Your smart contract must be deployed as a general NFT smart contract. You cannot use cashback and provenance smart contracts with NFT Express. For more information, see our user documentation and the article in the Tatum blog. You can mint NFTs on your own smart contract on the following blockchains: BNB Smart Chain Celo Ethereum Harmony Klaytn Polygon To mint NFTs using your own smart contract, do the following: In the table located under this section, find the blockchain address of the Tatum NFT minter for your blockchain and network (mainnet or testnet). Add the minter address as an NFT minter to your smart contract. Use this API with the MintNftMinter schema of the request body. In the request body, enter the following information: chain is the blockchain that you use. to is the blockchain address where to send the minted NFT to. url is the URL of the NFT metadata. minter is the address of the NFT minter that you found in Step 1. contractAddress is the address of your NFT smart contract. tokenId is the the token ID of the NFT. For example:  {   \&quot;chain\&quot;: \&quot;CELO\&quot;,   \&quot;to\&quot;: \&quot;0x8ce4e40889a13971681391aad29e88efaf91f784\&quot;,   \&quot;url\&quot;: \&quot;ipfs://QmXJJ6UF5WkF4WTJvsdhiA1etGwBLfpva7Vr9AudGMe3pj\&quot;,   \&quot;contractAddress\&quot;: \&quot;0x687422eEA2cB73B5d3e242bA5456b782919AFc85\&quot;,   \&quot;tokenId\&quot;: \&quot;0123\&quot;,   \&quot;minter\&quot;: \&quot;0xBC2eBA680EE50d685cc4Fe65f102AA70AfB27D3F\&quot; } When you make an API call with this request body, the private key of the NFT minter will be added to the request body automatically:  {   \&quot;chain\&quot;: \&quot;CELO\&quot;,   \&quot;to\&quot;: \&quot;0x8ce4e40889a13971681391aad29e88efaf91f784\&quot;,   \&quot;url\&quot;: \&quot;ipfs://QmXJJ6UF5WkF4WTJvsdhiA1etGwBLfpva7Vr9AudGMe3pj\&quot;,   \&quot;contractAddress\&quot;: \&quot;0x687422eEA2cB73B5d3e242bA5456b782919AFc85\&quot;,   \&quot;tokenId\&quot;: \&quot;0123\&quot;,   \&quot;minter\&quot;: \&quot;0xBC2eBA680EE50d685cc4Fe65f102AA70AfB27D3F\&quot;,   \&quot;fromPrivateKey\&quot;: \&quot;0x05e150c73f1920ec14caa1e0b6aa09940899678051a78542840c2668ce5080c2\&quot; } The following table lists the blockchain addresses of the Tatum NFT minters for the testnet and mainnet of the supported blockchains: Blockchain Minter address - testnet* Minter address - mainnet BNB Smart Chain 0xc16ae5e8c985b906935a0cadf4e24f0400531883 0x49678AAB11E001eb3cB2cBD9aA96b36DC2461A94 Celo 0xBC2eBA680EE50d685cc4Fe65f102AA70AfB27D3F 0x49678AAB11E001eb3cB2cBD9aA96b36DC2461A94 Ethereum 0x53e8577C4347C365E4e0DA5B57A589cB6f2AB848 0x49678AAB11E001eb3cB2cBD9aA96b36DC2461A94 Harmony 0x8906f62d40293ddca77fdf6714c3f63265deddf0 0x49678AAB11E001eb3cB2cBD9aA96b36DC2461A94 Klaytn 0x80d8bac9a6901698b3749fe336bbd1385c1f98f2 0x49678AAB11E001eb3cB2cBD9aA96b36DC2461A94 Polygon 0x542b9ac4945a3836fd12ad98acbc76a0c8b743f5 0x49678AAB11E001eb3cB2cBD9aA96b36DC2461A94 *If a minter blockchain address on the testnet does not have sufficient funds to cover the transaction fee, add some amount to it using a crypto faucet of the blockchain. Minting NFTs natively on a blockchain When minting an NFT natively on a blockchain, you are charged a fee for the transaction, and you must sign the transaction with the private key of the blockchain address from which the fee will be deducted. Providing the private key in the API is not a secure way of signing transactions, because the private key can be stolen or exposed. Your private keys should never leave your security perimeter. You should use the private keys only for testing a solution you are building on the testnet of a blockchain. For signing transactions on the mainnet, we strongly recommend that you use the Tatum Key Management System (KMS) and provide the signature ID instead of the private key in the API. Alternatively, you can use the Tatum JavaScript client. You can mint NFTs natively on the following blockchains: Algorand BNB Smart Chain Celo Ethereum Flow Harmony Klaytn KuCoin Community Chain Polygon Solana TRON Depending on what blockchain you use, choose the request body schema to use in the API call. To mint NFTs natively on Algorand and: To sign the transaction with your private key, use this API with the MintNftAlgorand schema of the request body. To sign the transaction with your signature ID, use this API the MintNftAlgorandKMS schema of the request body. NOTE: To be able to burn the minted NFTs any time later, specify the address of the manager account in the manager parameter. An NFT minted on Algorand is automatically transferred to your blockchain address. After the NFT is minted, you have to transfer it to the recipient&#39;s address. The recipient has to agree in advance to receive your NFT because Algorand charges users for storing NFTs on their addresses, and an Algorand blockchain address by default does not receive NFTs unless explicitly agreed. For more information about how it works, see the section about minting NFTs on Algorand using the pre-built NFT smart contract provided by Tatum. To mint NFTs natively on BNB Smart Chain, Ethereum, Harmony, Klaytn, KuCoin Community Chain, or Polygon, and: To sign the transaction with your private key, use this API with the MintNft schema of the request body. To sign the transaction with your signature ID, use this API the MintNftKMS schema of the request body. To mint NFTs natively on Celo and: To sign the transaction with your private key, use this API with the MintNftCelo schema of the request body. To sign the transaction with your signature ID, use this API the MintNftKMSCelo schema of the request body. To mint NFTs natively on Flow and: To sign the transaction with your private key, use this API with the MintNftFlowPK schema of the request body. To sign the transaction with your signature ID, use this API the MintNftFlowMnemonic schema of the request body. To sign the transaction with your wallet mnemonic, use this API the MintNftFlowKMS schema of the request body. To mint NFTs natively on Solana and: To sign the transaction with your private key, use this API with the MintNftSolana schema of the request body. To sign the transaction with your signature ID, use this API the MintNftSolanaKMS schema of the request body. NOTE: When an NFT is minted on Solana, a new blockchain address is created to receive the NFT under the recipient&#39;s account address. After the NFT is minted, you have to transfer it to the recipient&#39;s address. For more information about how it works, see the section about minting NFTs on Solana using the pre-built NFT smart contract provided by Tatum. To mint NFTs natively on TRON and: To sign the transaction with your private key, use this API with the MintNftTron schema of the request body. To sign the transaction with your signature ID, use this API the MintNftKMSTron schema of the request body.
        /// </summary>
        /// <exception cref="Tatum.CSharp.Bsc.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="mintNft"></param>
        /// <param name="xTestnetType">Type of Ethereum testnet. Defaults to Sepolia. Valid only for ETH invocations for testnet API Key. For mainnet API Key, this value is ignored. (optional, default to ethereum-sepolia)</param>
        /// <returns>TransactionHash</returns>
        public TransactionHash NftMintErc721(MintNft mintNft, string xTestnetType = default(string))
        {
            var localVarResponse = NftMintErc721WithHttpInfo(mintNft, xTestnetType);

            var exception = ExceptionFactory?.Invoke("NftMintErc721_1", localVarResponse);
            if (exception != null) throw exception;

            return localVarResponse.Data;
        }

        /// <summary>
        /// Mint an NFT 100 credits per API call on Flow 2 credits per API call on the other blockchains You can mint NFTs using either of the following methods: Using NFT Express Natively on a blockchain Minting NFTs using NFT Express NFT Express is Tatum&#39;s feature that helps you mint NFTs easier than minting natively on a blockchain. You do not need to enter your private key or signature ID. NFT Express uses the private key provided by Tatum. You do not need to hold crypto or keep addresses topped up with crypto to pay for minting transactions. To use NFT Express on the mainnet, you have to have a paid pricing plan. Tatum covers your transaction fees for NFT minting and pays for them from its own blockchain address. Then, the fee amount paid by Tatum is converted to the number of credits, and these credits are deducted from the monthly credit allowance of your paid pricing plan. The transaction fees and the corresponding numbers of credits deducted from your allowance vary depending on what blockchain you mint NFTs on. On the testnet, no credits are deducted from the monthly credit allowance. You can mint NFTs with NFT Express regardless of your pricing plan. With NFT Express, you can choose whether to mint NFTs on the pre-built NFT smart contract provided by Tatum or on your own smart contract. Use the pre-built smart contract provided by Tatum to mint NFTs If you want to mint NFTs using the pre-built smart contract, you do not need to deploy your own NFT smart contract. You do not need to provide the address of the NFT smart contract and the token ID in the request body either. The address of the smart contract and the token ID are provided automatically by Tatum. The token ID is autogenerated. It starts with 0 and is increased by 1 for each new NFT. The token ID is calculated separately for each supported blockchain and its mainnet and testnet. For more information, see our user documentation. You can mint NFTs on the pre-built smart contract provided by Tatum on the following blockchains: Algorand BNB Smart Chain Celo Ethereum Harmony Klaytn Polygon Solana Depending on what blockchain you use, choose the request body schema to use in the API call. To mint NFTs on BNB Smart Chain, Celo, Ethereum, Harmony, Klaytn, or Polygon, use this API with the MintNftExpress schema of the request body. To mint NFTs on Algorand, use this API with the MintNftExpressAlgorand schema of the request body. To be able to burn the minted NFTs any time later, specify the address of the manager account in the manager parameter. An NFT minted on Algorand is automatically transferred to your blockchain address. After the NFT is minted, you have to transfer it to the recipient&#39;s address. The recipient has to agree in advance to receive your NFT because Algorand charges users for storing NFTs on their addresses, and an Algorand blockchain address by default does not receive NFTs unless explicitly agreed. This how it works: The recipient agrees to receive the NFT to their address. You transfer the NFT to the recipient&#39;s address (use the transferNftAlgoExpress schema of the request body). NOTE: On the mainnet, Tatum covers your transaction fees for the NFT transfer and pays for them from its own blockchain address. Then, the fee amount paid by Tatum is converted to the number of credits, and these credits are deducted from the monthly credit allowance of your paid pricing plan. On the testnet, no credits are deducted from the monthly credit allowance. To mint NFTs on Solana, use this API with the MintNftExpressSolana schema of the request body. Solana uses the Metaplex Protocol, a smart contract and metadata standard for creating and working with NFTs. When you mint an NFT on Solana with NFT Express, the pre-built smart contract based on the Metaplex Protocol is used. When an NFT is minted on Solana, a new blockchain address is created to receive the NFT under the recipient&#39;s account address (the one in the to parameter of the request body). This address is returned in the nftAccountAddress parameter in the response body, is owned by the recipient&#39;s address, and has the same private key. The response body also returns the address of the minted NFT itself, which is held in the nftAddress parameter. After the NFT is minted, you have to transfer it to the recipient&#39;s address (use the transferNftSolana or transferNftSolanaKMS schema of the request body). In the request body of the transfer call: Set the from parameter to the address that you used in the to parameter in the request body of the minting call. Set the to parameter to the recipient&#39;s address. Set the contractAddress parameter to the address from the nftAddress parameter returned in the response body of the minting call. Set the fromPrivateKey/signatureId parameter to the private key/signature ID of the blockchain address that you specified in the from parameter. Use your own smart contract to mint NFTs If you want to mint NFTs using your own smart contract, you are going to use an NTF minter, a special blockchain address provided by Tatum that will cover the minting fees. The number of credits equivalent to the fees will be then deducted from the monthly credit allowance of your paid pricing plan. IMPORTANT! Your smart contract must be deployed as a general NFT smart contract. You cannot use cashback and provenance smart contracts with NFT Express. For more information, see our user documentation and the article in the Tatum blog. You can mint NFTs on your own smart contract on the following blockchains: BNB Smart Chain Celo Ethereum Harmony Klaytn Polygon To mint NFTs using your own smart contract, do the following: In the table located under this section, find the blockchain address of the Tatum NFT minter for your blockchain and network (mainnet or testnet). Add the minter address as an NFT minter to your smart contract. Use this API with the MintNftMinter schema of the request body. In the request body, enter the following information: chain is the blockchain that you use. to is the blockchain address where to send the minted NFT to. url is the URL of the NFT metadata. minter is the address of the NFT minter that you found in Step 1. contractAddress is the address of your NFT smart contract. tokenId is the the token ID of the NFT. For example:  {   \&quot;chain\&quot;: \&quot;CELO\&quot;,   \&quot;to\&quot;: \&quot;0x8ce4e40889a13971681391aad29e88efaf91f784\&quot;,   \&quot;url\&quot;: \&quot;ipfs://QmXJJ6UF5WkF4WTJvsdhiA1etGwBLfpva7Vr9AudGMe3pj\&quot;,   \&quot;contractAddress\&quot;: \&quot;0x687422eEA2cB73B5d3e242bA5456b782919AFc85\&quot;,   \&quot;tokenId\&quot;: \&quot;0123\&quot;,   \&quot;minter\&quot;: \&quot;0xBC2eBA680EE50d685cc4Fe65f102AA70AfB27D3F\&quot; } When you make an API call with this request body, the private key of the NFT minter will be added to the request body automatically:  {   \&quot;chain\&quot;: \&quot;CELO\&quot;,   \&quot;to\&quot;: \&quot;0x8ce4e40889a13971681391aad29e88efaf91f784\&quot;,   \&quot;url\&quot;: \&quot;ipfs://QmXJJ6UF5WkF4WTJvsdhiA1etGwBLfpva7Vr9AudGMe3pj\&quot;,   \&quot;contractAddress\&quot;: \&quot;0x687422eEA2cB73B5d3e242bA5456b782919AFc85\&quot;,   \&quot;tokenId\&quot;: \&quot;0123\&quot;,   \&quot;minter\&quot;: \&quot;0xBC2eBA680EE50d685cc4Fe65f102AA70AfB27D3F\&quot;,   \&quot;fromPrivateKey\&quot;: \&quot;0x05e150c73f1920ec14caa1e0b6aa09940899678051a78542840c2668ce5080c2\&quot; } The following table lists the blockchain addresses of the Tatum NFT minters for the testnet and mainnet of the supported blockchains: Blockchain Minter address - testnet* Minter address - mainnet BNB Smart Chain 0xc16ae5e8c985b906935a0cadf4e24f0400531883 0x49678AAB11E001eb3cB2cBD9aA96b36DC2461A94 Celo 0xBC2eBA680EE50d685cc4Fe65f102AA70AfB27D3F 0x49678AAB11E001eb3cB2cBD9aA96b36DC2461A94 Ethereum 0x53e8577C4347C365E4e0DA5B57A589cB6f2AB848 0x49678AAB11E001eb3cB2cBD9aA96b36DC2461A94 Harmony 0x8906f62d40293ddca77fdf6714c3f63265deddf0 0x49678AAB11E001eb3cB2cBD9aA96b36DC2461A94 Klaytn 0x80d8bac9a6901698b3749fe336bbd1385c1f98f2 0x49678AAB11E001eb3cB2cBD9aA96b36DC2461A94 Polygon 0x542b9ac4945a3836fd12ad98acbc76a0c8b743f5 0x49678AAB11E001eb3cB2cBD9aA96b36DC2461A94 *If a minter blockchain address on the testnet does not have sufficient funds to cover the transaction fee, add some amount to it using a crypto faucet of the blockchain. Minting NFTs natively on a blockchain When minting an NFT natively on a blockchain, you are charged a fee for the transaction, and you must sign the transaction with the private key of the blockchain address from which the fee will be deducted. Providing the private key in the API is not a secure way of signing transactions, because the private key can be stolen or exposed. Your private keys should never leave your security perimeter. You should use the private keys only for testing a solution you are building on the testnet of a blockchain. For signing transactions on the mainnet, we strongly recommend that you use the Tatum Key Management System (KMS) and provide the signature ID instead of the private key in the API. Alternatively, you can use the Tatum JavaScript client. You can mint NFTs natively on the following blockchains: Algorand BNB Smart Chain Celo Ethereum Flow Harmony Klaytn KuCoin Community Chain Polygon Solana TRON Depending on what blockchain you use, choose the request body schema to use in the API call. To mint NFTs natively on Algorand and: To sign the transaction with your private key, use this API with the MintNftAlgorand schema of the request body. To sign the transaction with your signature ID, use this API the MintNftAlgorandKMS schema of the request body. NOTE: To be able to burn the minted NFTs any time later, specify the address of the manager account in the manager parameter. An NFT minted on Algorand is automatically transferred to your blockchain address. After the NFT is minted, you have to transfer it to the recipient&#39;s address. The recipient has to agree in advance to receive your NFT because Algorand charges users for storing NFTs on their addresses, and an Algorand blockchain address by default does not receive NFTs unless explicitly agreed. For more information about how it works, see the section about minting NFTs on Algorand using the pre-built NFT smart contract provided by Tatum. To mint NFTs natively on BNB Smart Chain, Ethereum, Harmony, Klaytn, KuCoin Community Chain, or Polygon, and: To sign the transaction with your private key, use this API with the MintNft schema of the request body. To sign the transaction with your signature ID, use this API the MintNftKMS schema of the request body. To mint NFTs natively on Celo and: To sign the transaction with your private key, use this API with the MintNftCelo schema of the request body. To sign the transaction with your signature ID, use this API the MintNftKMSCelo schema of the request body. To mint NFTs natively on Flow and: To sign the transaction with your private key, use this API with the MintNftFlowPK schema of the request body. To sign the transaction with your signature ID, use this API the MintNftFlowMnemonic schema of the request body. To sign the transaction with your wallet mnemonic, use this API the MintNftFlowKMS schema of the request body. To mint NFTs natively on Solana and: To sign the transaction with your private key, use this API with the MintNftSolana schema of the request body. To sign the transaction with your signature ID, use this API the MintNftSolanaKMS schema of the request body. NOTE: When an NFT is minted on Solana, a new blockchain address is created to receive the NFT under the recipient&#39;s account address. After the NFT is minted, you have to transfer it to the recipient&#39;s address. For more information about how it works, see the section about minting NFTs on Solana using the pre-built NFT smart contract provided by Tatum. To mint NFTs natively on TRON and: To sign the transaction with your private key, use this API with the MintNftTron schema of the request body. To sign the transaction with your signature ID, use this API the MintNftKMSTron schema of the request body.
        /// </summary>
        /// <exception cref="Tatum.CSharp.Bsc.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="mintNft"></param>
        /// <param name="xTestnetType">Type of Ethereum testnet. Defaults to Sepolia. Valid only for ETH invocations for testnet API Key. For mainnet API Key, this value is ignored. (optional, default to ethereum-sepolia)</param>
        /// <returns>ApiResponse of TransactionHash</returns>
        public ApiResponse<TransactionHash> NftMintErc721WithHttpInfo(MintNft mintNft, string xTestnetType = default(string))
        {
            // verify the required parameter 'mintNft' is set
            if (mintNft == null)
                throw new ApiException(400, "Missing required parameter 'mintNft' when calling NFTBscApi->NftMintErc721_1");

            var localVarRequestOptions = new RequestOptions();

            var contentTypes = new string[]{
                "application/json"
            };

            // to determine the Accept header
            var accepts = new string[]{
                "application/json"
            };

            var localVarContentType = ClientUtils.SelectHeaderContentType(contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = ClientUtils.SelectHeaderAccept(accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            if (xTestnetType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("x-testnet-type", ClientUtils.ParameterToString(xTestnetType)); // header parameter
            }
            localVarRequestOptions.Data = mintNft;

            // authentication (X-API-Key) required
            if (!string.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("x-api-key")))
            {
                localVarRequestOptions.HeaderParameters.Add("x-api-key", Configuration.GetApiKeyWithPrefix("x-api-key"));
            }

            // make the HTTP request
            var localVarResponse = Client.Post<TransactionHash>("/v3/nft/mint", localVarRequestOptions, Configuration);

            return localVarResponse;
        }

        /// <summary>
        /// Mint an NFT 100 credits per API call on Flow 2 credits per API call on the other blockchains You can mint NFTs using either of the following methods: Using NFT Express Natively on a blockchain Minting NFTs using NFT Express NFT Express is Tatum&#39;s feature that helps you mint NFTs easier than minting natively on a blockchain. You do not need to enter your private key or signature ID. NFT Express uses the private key provided by Tatum. You do not need to hold crypto or keep addresses topped up with crypto to pay for minting transactions. To use NFT Express on the mainnet, you have to have a paid pricing plan. Tatum covers your transaction fees for NFT minting and pays for them from its own blockchain address. Then, the fee amount paid by Tatum is converted to the number of credits, and these credits are deducted from the monthly credit allowance of your paid pricing plan. The transaction fees and the corresponding numbers of credits deducted from your allowance vary depending on what blockchain you mint NFTs on. On the testnet, no credits are deducted from the monthly credit allowance. You can mint NFTs with NFT Express regardless of your pricing plan. With NFT Express, you can choose whether to mint NFTs on the pre-built NFT smart contract provided by Tatum or on your own smart contract. Use the pre-built smart contract provided by Tatum to mint NFTs If you want to mint NFTs using the pre-built smart contract, you do not need to deploy your own NFT smart contract. You do not need to provide the address of the NFT smart contract and the token ID in the request body either. The address of the smart contract and the token ID are provided automatically by Tatum. The token ID is autogenerated. It starts with 0 and is increased by 1 for each new NFT. The token ID is calculated separately for each supported blockchain and its mainnet and testnet. For more information, see our user documentation. You can mint NFTs on the pre-built smart contract provided by Tatum on the following blockchains: Algorand BNB Smart Chain Celo Ethereum Harmony Klaytn Polygon Solana Depending on what blockchain you use, choose the request body schema to use in the API call. To mint NFTs on BNB Smart Chain, Celo, Ethereum, Harmony, Klaytn, or Polygon, use this API with the MintNftExpress schema of the request body. To mint NFTs on Algorand, use this API with the MintNftExpressAlgorand schema of the request body. To be able to burn the minted NFTs any time later, specify the address of the manager account in the manager parameter. An NFT minted on Algorand is automatically transferred to your blockchain address. After the NFT is minted, you have to transfer it to the recipient&#39;s address. The recipient has to agree in advance to receive your NFT because Algorand charges users for storing NFTs on their addresses, and an Algorand blockchain address by default does not receive NFTs unless explicitly agreed. This how it works: The recipient agrees to receive the NFT to their address. You transfer the NFT to the recipient&#39;s address (use the transferNftAlgoExpress schema of the request body). NOTE: On the mainnet, Tatum covers your transaction fees for the NFT transfer and pays for them from its own blockchain address. Then, the fee amount paid by Tatum is converted to the number of credits, and these credits are deducted from the monthly credit allowance of your paid pricing plan. On the testnet, no credits are deducted from the monthly credit allowance. To mint NFTs on Solana, use this API with the MintNftExpressSolana schema of the request body. Solana uses the Metaplex Protocol, a smart contract and metadata standard for creating and working with NFTs. When you mint an NFT on Solana with NFT Express, the pre-built smart contract based on the Metaplex Protocol is used. When an NFT is minted on Solana, a new blockchain address is created to receive the NFT under the recipient&#39;s account address (the one in the to parameter of the request body). This address is returned in the nftAccountAddress parameter in the response body, is owned by the recipient&#39;s address, and has the same private key. The response body also returns the address of the minted NFT itself, which is held in the nftAddress parameter. After the NFT is minted, you have to transfer it to the recipient&#39;s address (use the transferNftSolana or transferNftSolanaKMS schema of the request body). In the request body of the transfer call: Set the from parameter to the address that you used in the to parameter in the request body of the minting call. Set the to parameter to the recipient&#39;s address. Set the contractAddress parameter to the address from the nftAddress parameter returned in the response body of the minting call. Set the fromPrivateKey/signatureId parameter to the private key/signature ID of the blockchain address that you specified in the from parameter. Use your own smart contract to mint NFTs If you want to mint NFTs using your own smart contract, you are going to use an NTF minter, a special blockchain address provided by Tatum that will cover the minting fees. The number of credits equivalent to the fees will be then deducted from the monthly credit allowance of your paid pricing plan. IMPORTANT! Your smart contract must be deployed as a general NFT smart contract. You cannot use cashback and provenance smart contracts with NFT Express. For more information, see our user documentation and the article in the Tatum blog. You can mint NFTs on your own smart contract on the following blockchains: BNB Smart Chain Celo Ethereum Harmony Klaytn Polygon To mint NFTs using your own smart contract, do the following: In the table located under this section, find the blockchain address of the Tatum NFT minter for your blockchain and network (mainnet or testnet). Add the minter address as an NFT minter to your smart contract. Use this API with the MintNftMinter schema of the request body. In the request body, enter the following information: chain is the blockchain that you use. to is the blockchain address where to send the minted NFT to. url is the URL of the NFT metadata. minter is the address of the NFT minter that you found in Step 1. contractAddress is the address of your NFT smart contract. tokenId is the the token ID of the NFT. For example:  {   \&quot;chain\&quot;: \&quot;CELO\&quot;,   \&quot;to\&quot;: \&quot;0x8ce4e40889a13971681391aad29e88efaf91f784\&quot;,   \&quot;url\&quot;: \&quot;ipfs://QmXJJ6UF5WkF4WTJvsdhiA1etGwBLfpva7Vr9AudGMe3pj\&quot;,   \&quot;contractAddress\&quot;: \&quot;0x687422eEA2cB73B5d3e242bA5456b782919AFc85\&quot;,   \&quot;tokenId\&quot;: \&quot;0123\&quot;,   \&quot;minter\&quot;: \&quot;0xBC2eBA680EE50d685cc4Fe65f102AA70AfB27D3F\&quot; } When you make an API call with this request body, the private key of the NFT minter will be added to the request body automatically:  {   \&quot;chain\&quot;: \&quot;CELO\&quot;,   \&quot;to\&quot;: \&quot;0x8ce4e40889a13971681391aad29e88efaf91f784\&quot;,   \&quot;url\&quot;: \&quot;ipfs://QmXJJ6UF5WkF4WTJvsdhiA1etGwBLfpva7Vr9AudGMe3pj\&quot;,   \&quot;contractAddress\&quot;: \&quot;0x687422eEA2cB73B5d3e242bA5456b782919AFc85\&quot;,   \&quot;tokenId\&quot;: \&quot;0123\&quot;,   \&quot;minter\&quot;: \&quot;0xBC2eBA680EE50d685cc4Fe65f102AA70AfB27D3F\&quot;,   \&quot;fromPrivateKey\&quot;: \&quot;0x05e150c73f1920ec14caa1e0b6aa09940899678051a78542840c2668ce5080c2\&quot; } The following table lists the blockchain addresses of the Tatum NFT minters for the testnet and mainnet of the supported blockchains: Blockchain Minter address - testnet* Minter address - mainnet BNB Smart Chain 0xc16ae5e8c985b906935a0cadf4e24f0400531883 0x49678AAB11E001eb3cB2cBD9aA96b36DC2461A94 Celo 0xBC2eBA680EE50d685cc4Fe65f102AA70AfB27D3F 0x49678AAB11E001eb3cB2cBD9aA96b36DC2461A94 Ethereum 0x53e8577C4347C365E4e0DA5B57A589cB6f2AB848 0x49678AAB11E001eb3cB2cBD9aA96b36DC2461A94 Harmony 0x8906f62d40293ddca77fdf6714c3f63265deddf0 0x49678AAB11E001eb3cB2cBD9aA96b36DC2461A94 Klaytn 0x80d8bac9a6901698b3749fe336bbd1385c1f98f2 0x49678AAB11E001eb3cB2cBD9aA96b36DC2461A94 Polygon 0x542b9ac4945a3836fd12ad98acbc76a0c8b743f5 0x49678AAB11E001eb3cB2cBD9aA96b36DC2461A94 *If a minter blockchain address on the testnet does not have sufficient funds to cover the transaction fee, add some amount to it using a crypto faucet of the blockchain. Minting NFTs natively on a blockchain When minting an NFT natively on a blockchain, you are charged a fee for the transaction, and you must sign the transaction with the private key of the blockchain address from which the fee will be deducted. Providing the private key in the API is not a secure way of signing transactions, because the private key can be stolen or exposed. Your private keys should never leave your security perimeter. You should use the private keys only for testing a solution you are building on the testnet of a blockchain. For signing transactions on the mainnet, we strongly recommend that you use the Tatum Key Management System (KMS) and provide the signature ID instead of the private key in the API. Alternatively, you can use the Tatum JavaScript client. You can mint NFTs natively on the following blockchains: Algorand BNB Smart Chain Celo Ethereum Flow Harmony Klaytn KuCoin Community Chain Polygon Solana TRON Depending on what blockchain you use, choose the request body schema to use in the API call. To mint NFTs natively on Algorand and: To sign the transaction with your private key, use this API with the MintNftAlgorand schema of the request body. To sign the transaction with your signature ID, use this API the MintNftAlgorandKMS schema of the request body. NOTE: To be able to burn the minted NFTs any time later, specify the address of the manager account in the manager parameter. An NFT minted on Algorand is automatically transferred to your blockchain address. After the NFT is minted, you have to transfer it to the recipient&#39;s address. The recipient has to agree in advance to receive your NFT because Algorand charges users for storing NFTs on their addresses, and an Algorand blockchain address by default does not receive NFTs unless explicitly agreed. For more information about how it works, see the section about minting NFTs on Algorand using the pre-built NFT smart contract provided by Tatum. To mint NFTs natively on BNB Smart Chain, Ethereum, Harmony, Klaytn, KuCoin Community Chain, or Polygon, and: To sign the transaction with your private key, use this API with the MintNft schema of the request body. To sign the transaction with your signature ID, use this API the MintNftKMS schema of the request body. To mint NFTs natively on Celo and: To sign the transaction with your private key, use this API with the MintNftCelo schema of the request body. To sign the transaction with your signature ID, use this API the MintNftKMSCelo schema of the request body. To mint NFTs natively on Flow and: To sign the transaction with your private key, use this API with the MintNftFlowPK schema of the request body. To sign the transaction with your signature ID, use this API the MintNftFlowMnemonic schema of the request body. To sign the transaction with your wallet mnemonic, use this API the MintNftFlowKMS schema of the request body. To mint NFTs natively on Solana and: To sign the transaction with your private key, use this API with the MintNftSolana schema of the request body. To sign the transaction with your signature ID, use this API the MintNftSolanaKMS schema of the request body. NOTE: When an NFT is minted on Solana, a new blockchain address is created to receive the NFT under the recipient&#39;s account address. After the NFT is minted, you have to transfer it to the recipient&#39;s address. For more information about how it works, see the section about minting NFTs on Solana using the pre-built NFT smart contract provided by Tatum. To mint NFTs natively on TRON and: To sign the transaction with your private key, use this API with the MintNftTron schema of the request body. To sign the transaction with your signature ID, use this API the MintNftKMSTron schema of the request body.
        /// </summary>
        /// <exception cref="Tatum.CSharp.Bsc.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="mintNft"></param>
        /// <param name="xTestnetType">Type of Ethereum testnet. Defaults to Sepolia. Valid only for ETH invocations for testnet API Key. For mainnet API Key, this value is ignored. (optional, default to ethereum-sepolia)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of TransactionHash</returns>
        public async System.Threading.Tasks.Task<TransactionHash> NftMintErc721Async(MintNft mintNft, string xTestnetType = default(string), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            var localVarResponse = await NftMintErc721WithHttpInfoAsync(mintNft, xTestnetType, cancellationToken).ConfigureAwait(false);
            
            var exception = ExceptionFactory?.Invoke("NftMintErc721_1", localVarResponse);
            if (exception != null) throw exception;

            return localVarResponse.Data;
        }

        /// <summary>
        /// Mint an NFT 100 credits per API call on Flow 2 credits per API call on the other blockchains You can mint NFTs using either of the following methods: Using NFT Express Natively on a blockchain Minting NFTs using NFT Express NFT Express is Tatum&#39;s feature that helps you mint NFTs easier than minting natively on a blockchain. You do not need to enter your private key or signature ID. NFT Express uses the private key provided by Tatum. You do not need to hold crypto or keep addresses topped up with crypto to pay for minting transactions. To use NFT Express on the mainnet, you have to have a paid pricing plan. Tatum covers your transaction fees for NFT minting and pays for them from its own blockchain address. Then, the fee amount paid by Tatum is converted to the number of credits, and these credits are deducted from the monthly credit allowance of your paid pricing plan. The transaction fees and the corresponding numbers of credits deducted from your allowance vary depending on what blockchain you mint NFTs on. On the testnet, no credits are deducted from the monthly credit allowance. You can mint NFTs with NFT Express regardless of your pricing plan. With NFT Express, you can choose whether to mint NFTs on the pre-built NFT smart contract provided by Tatum or on your own smart contract. Use the pre-built smart contract provided by Tatum to mint NFTs If you want to mint NFTs using the pre-built smart contract, you do not need to deploy your own NFT smart contract. You do not need to provide the address of the NFT smart contract and the token ID in the request body either. The address of the smart contract and the token ID are provided automatically by Tatum. The token ID is autogenerated. It starts with 0 and is increased by 1 for each new NFT. The token ID is calculated separately for each supported blockchain and its mainnet and testnet. For more information, see our user documentation. You can mint NFTs on the pre-built smart contract provided by Tatum on the following blockchains: Algorand BNB Smart Chain Celo Ethereum Harmony Klaytn Polygon Solana Depending on what blockchain you use, choose the request body schema to use in the API call. To mint NFTs on BNB Smart Chain, Celo, Ethereum, Harmony, Klaytn, or Polygon, use this API with the MintNftExpress schema of the request body. To mint NFTs on Algorand, use this API with the MintNftExpressAlgorand schema of the request body. To be able to burn the minted NFTs any time later, specify the address of the manager account in the manager parameter. An NFT minted on Algorand is automatically transferred to your blockchain address. After the NFT is minted, you have to transfer it to the recipient&#39;s address. The recipient has to agree in advance to receive your NFT because Algorand charges users for storing NFTs on their addresses, and an Algorand blockchain address by default does not receive NFTs unless explicitly agreed. This how it works: The recipient agrees to receive the NFT to their address. You transfer the NFT to the recipient&#39;s address (use the transferNftAlgoExpress schema of the request body). NOTE: On the mainnet, Tatum covers your transaction fees for the NFT transfer and pays for them from its own blockchain address. Then, the fee amount paid by Tatum is converted to the number of credits, and these credits are deducted from the monthly credit allowance of your paid pricing plan. On the testnet, no credits are deducted from the monthly credit allowance. To mint NFTs on Solana, use this API with the MintNftExpressSolana schema of the request body. Solana uses the Metaplex Protocol, a smart contract and metadata standard for creating and working with NFTs. When you mint an NFT on Solana with NFT Express, the pre-built smart contract based on the Metaplex Protocol is used. When an NFT is minted on Solana, a new blockchain address is created to receive the NFT under the recipient&#39;s account address (the one in the to parameter of the request body). This address is returned in the nftAccountAddress parameter in the response body, is owned by the recipient&#39;s address, and has the same private key. The response body also returns the address of the minted NFT itself, which is held in the nftAddress parameter. After the NFT is minted, you have to transfer it to the recipient&#39;s address (use the transferNftSolana or transferNftSolanaKMS schema of the request body). In the request body of the transfer call: Set the from parameter to the address that you used in the to parameter in the request body of the minting call. Set the to parameter to the recipient&#39;s address. Set the contractAddress parameter to the address from the nftAddress parameter returned in the response body of the minting call. Set the fromPrivateKey/signatureId parameter to the private key/signature ID of the blockchain address that you specified in the from parameter. Use your own smart contract to mint NFTs If you want to mint NFTs using your own smart contract, you are going to use an NTF minter, a special blockchain address provided by Tatum that will cover the minting fees. The number of credits equivalent to the fees will be then deducted from the monthly credit allowance of your paid pricing plan. IMPORTANT! Your smart contract must be deployed as a general NFT smart contract. You cannot use cashback and provenance smart contracts with NFT Express. For more information, see our user documentation and the article in the Tatum blog. You can mint NFTs on your own smart contract on the following blockchains: BNB Smart Chain Celo Ethereum Harmony Klaytn Polygon To mint NFTs using your own smart contract, do the following: In the table located under this section, find the blockchain address of the Tatum NFT minter for your blockchain and network (mainnet or testnet). Add the minter address as an NFT minter to your smart contract. Use this API with the MintNftMinter schema of the request body. In the request body, enter the following information: chain is the blockchain that you use. to is the blockchain address where to send the minted NFT to. url is the URL of the NFT metadata. minter is the address of the NFT minter that you found in Step 1. contractAddress is the address of your NFT smart contract. tokenId is the the token ID of the NFT. For example:  {   \&quot;chain\&quot;: \&quot;CELO\&quot;,   \&quot;to\&quot;: \&quot;0x8ce4e40889a13971681391aad29e88efaf91f784\&quot;,   \&quot;url\&quot;: \&quot;ipfs://QmXJJ6UF5WkF4WTJvsdhiA1etGwBLfpva7Vr9AudGMe3pj\&quot;,   \&quot;contractAddress\&quot;: \&quot;0x687422eEA2cB73B5d3e242bA5456b782919AFc85\&quot;,   \&quot;tokenId\&quot;: \&quot;0123\&quot;,   \&quot;minter\&quot;: \&quot;0xBC2eBA680EE50d685cc4Fe65f102AA70AfB27D3F\&quot; } When you make an API call with this request body, the private key of the NFT minter will be added to the request body automatically:  {   \&quot;chain\&quot;: \&quot;CELO\&quot;,   \&quot;to\&quot;: \&quot;0x8ce4e40889a13971681391aad29e88efaf91f784\&quot;,   \&quot;url\&quot;: \&quot;ipfs://QmXJJ6UF5WkF4WTJvsdhiA1etGwBLfpva7Vr9AudGMe3pj\&quot;,   \&quot;contractAddress\&quot;: \&quot;0x687422eEA2cB73B5d3e242bA5456b782919AFc85\&quot;,   \&quot;tokenId\&quot;: \&quot;0123\&quot;,   \&quot;minter\&quot;: \&quot;0xBC2eBA680EE50d685cc4Fe65f102AA70AfB27D3F\&quot;,   \&quot;fromPrivateKey\&quot;: \&quot;0x05e150c73f1920ec14caa1e0b6aa09940899678051a78542840c2668ce5080c2\&quot; } The following table lists the blockchain addresses of the Tatum NFT minters for the testnet and mainnet of the supported blockchains: Blockchain Minter address - testnet* Minter address - mainnet BNB Smart Chain 0xc16ae5e8c985b906935a0cadf4e24f0400531883 0x49678AAB11E001eb3cB2cBD9aA96b36DC2461A94 Celo 0xBC2eBA680EE50d685cc4Fe65f102AA70AfB27D3F 0x49678AAB11E001eb3cB2cBD9aA96b36DC2461A94 Ethereum 0x53e8577C4347C365E4e0DA5B57A589cB6f2AB848 0x49678AAB11E001eb3cB2cBD9aA96b36DC2461A94 Harmony 0x8906f62d40293ddca77fdf6714c3f63265deddf0 0x49678AAB11E001eb3cB2cBD9aA96b36DC2461A94 Klaytn 0x80d8bac9a6901698b3749fe336bbd1385c1f98f2 0x49678AAB11E001eb3cB2cBD9aA96b36DC2461A94 Polygon 0x542b9ac4945a3836fd12ad98acbc76a0c8b743f5 0x49678AAB11E001eb3cB2cBD9aA96b36DC2461A94 *If a minter blockchain address on the testnet does not have sufficient funds to cover the transaction fee, add some amount to it using a crypto faucet of the blockchain. Minting NFTs natively on a blockchain When minting an NFT natively on a blockchain, you are charged a fee for the transaction, and you must sign the transaction with the private key of the blockchain address from which the fee will be deducted. Providing the private key in the API is not a secure way of signing transactions, because the private key can be stolen or exposed. Your private keys should never leave your security perimeter. You should use the private keys only for testing a solution you are building on the testnet of a blockchain. For signing transactions on the mainnet, we strongly recommend that you use the Tatum Key Management System (KMS) and provide the signature ID instead of the private key in the API. Alternatively, you can use the Tatum JavaScript client. You can mint NFTs natively on the following blockchains: Algorand BNB Smart Chain Celo Ethereum Flow Harmony Klaytn KuCoin Community Chain Polygon Solana TRON Depending on what blockchain you use, choose the request body schema to use in the API call. To mint NFTs natively on Algorand and: To sign the transaction with your private key, use this API with the MintNftAlgorand schema of the request body. To sign the transaction with your signature ID, use this API the MintNftAlgorandKMS schema of the request body. NOTE: To be able to burn the minted NFTs any time later, specify the address of the manager account in the manager parameter. An NFT minted on Algorand is automatically transferred to your blockchain address. After the NFT is minted, you have to transfer it to the recipient&#39;s address. The recipient has to agree in advance to receive your NFT because Algorand charges users for storing NFTs on their addresses, and an Algorand blockchain address by default does not receive NFTs unless explicitly agreed. For more information about how it works, see the section about minting NFTs on Algorand using the pre-built NFT smart contract provided by Tatum. To mint NFTs natively on BNB Smart Chain, Ethereum, Harmony, Klaytn, KuCoin Community Chain, or Polygon, and: To sign the transaction with your private key, use this API with the MintNft schema of the request body. To sign the transaction with your signature ID, use this API the MintNftKMS schema of the request body. To mint NFTs natively on Celo and: To sign the transaction with your private key, use this API with the MintNftCelo schema of the request body. To sign the transaction with your signature ID, use this API the MintNftKMSCelo schema of the request body. To mint NFTs natively on Flow and: To sign the transaction with your private key, use this API with the MintNftFlowPK schema of the request body. To sign the transaction with your signature ID, use this API the MintNftFlowMnemonic schema of the request body. To sign the transaction with your wallet mnemonic, use this API the MintNftFlowKMS schema of the request body. To mint NFTs natively on Solana and: To sign the transaction with your private key, use this API with the MintNftSolana schema of the request body. To sign the transaction with your signature ID, use this API the MintNftSolanaKMS schema of the request body. NOTE: When an NFT is minted on Solana, a new blockchain address is created to receive the NFT under the recipient&#39;s account address. After the NFT is minted, you have to transfer it to the recipient&#39;s address. For more information about how it works, see the section about minting NFTs on Solana using the pre-built NFT smart contract provided by Tatum. To mint NFTs natively on TRON and: To sign the transaction with your private key, use this API with the MintNftTron schema of the request body. To sign the transaction with your signature ID, use this API the MintNftKMSTron schema of the request body.
        /// </summary>
        /// <exception cref="Tatum.CSharp.Bsc.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="mintNft"></param>
        /// <param name="xTestnetType">Type of Ethereum testnet. Defaults to Sepolia. Valid only for ETH invocations for testnet API Key. For mainnet API Key, this value is ignored. (optional, default to ethereum-sepolia)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (TransactionHash)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<TransactionHash>> NftMintErc721WithHttpInfoAsync(MintNft mintNft, string xTestnetType = default(string), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            // verify the required parameter 'mintNft' is set
            if (mintNft == null)
                throw new ApiException(400, "Missing required parameter 'mintNft' when calling NFTBscApi->NftMintErc721_1");

            var localVarRequestOptions = new RequestOptions();

            var contentTypes = new string[]{
                "application/json"
            };

            // to determine the Accept header
            var accepts = new string[]{
                "application/json"
            };


            var localVarContentType = ClientUtils.SelectHeaderContentType(contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = ClientUtils.SelectHeaderAccept(accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            if (xTestnetType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("x-testnet-type", ClientUtils.ParameterToString(xTestnetType)); // header parameter
            }
            localVarRequestOptions.Data = mintNft;

            // authentication (X-API-Key) required
            if (!string.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("x-api-key")))
            {
                localVarRequestOptions.HeaderParameters.Add("x-api-key", Configuration.GetApiKeyWithPrefix("x-api-key"));
            }

            // make the HTTP request

            var localVarResponse = await AsynchronousClient.PostAsync<TransactionHash>("/v3/nft/mint", localVarRequestOptions, Configuration, cancellationToken).ConfigureAwait(false);

            return localVarResponse;
        }

        /// <summary>
        /// Mint an NFT 100 credits per API call on Flow 2 credits per API call on the other blockchains You can mint NFTs using either of the following methods: Using NFT Express Natively on a blockchain Minting NFTs using NFT Express NFT Express is Tatum&#39;s feature that helps you mint NFTs easier than minting natively on a blockchain. You do not need to enter your private key or signature ID. NFT Express uses the private key provided by Tatum. You do not need to hold crypto or keep addresses topped up with crypto to pay for minting transactions. To use NFT Express on the mainnet, you have to have a paid pricing plan. Tatum covers your transaction fees for NFT minting and pays for them from its own blockchain address. Then, the fee amount paid by Tatum is converted to the number of credits, and these credits are deducted from the monthly credit allowance of your paid pricing plan. The transaction fees and the corresponding numbers of credits deducted from your allowance vary depending on what blockchain you mint NFTs on. On the testnet, no credits are deducted from the monthly credit allowance. You can mint NFTs with NFT Express regardless of your pricing plan. With NFT Express, you can choose whether to mint NFTs on the pre-built NFT smart contract provided by Tatum or on your own smart contract. Use the pre-built smart contract provided by Tatum to mint NFTs If you want to mint NFTs using the pre-built smart contract, you do not need to deploy your own NFT smart contract. You do not need to provide the address of the NFT smart contract and the token ID in the request body either. The address of the smart contract and the token ID are provided automatically by Tatum. The token ID is autogenerated. It starts with 0 and is increased by 1 for each new NFT. The token ID is calculated separately for each supported blockchain and its mainnet and testnet. For more information, see our user documentation. You can mint NFTs on the pre-built smart contract provided by Tatum on the following blockchains: Algorand BNB Smart Chain Celo Ethereum Harmony Klaytn Polygon Solana Depending on what blockchain you use, choose the request body schema to use in the API call. To mint NFTs on BNB Smart Chain, Celo, Ethereum, Harmony, Klaytn, or Polygon, use this API with the MintNftExpress schema of the request body. To mint NFTs on Algorand, use this API with the MintNftExpressAlgorand schema of the request body. To be able to burn the minted NFTs any time later, specify the address of the manager account in the manager parameter. An NFT minted on Algorand is automatically transferred to your blockchain address. After the NFT is minted, you have to transfer it to the recipient&#39;s address. The recipient has to agree in advance to receive your NFT because Algorand charges users for storing NFTs on their addresses, and an Algorand blockchain address by default does not receive NFTs unless explicitly agreed. This how it works: The recipient agrees to receive the NFT to their address. You transfer the NFT to the recipient&#39;s address (use the transferNftAlgoExpress schema of the request body). NOTE: On the mainnet, Tatum covers your transaction fees for the NFT transfer and pays for them from its own blockchain address. Then, the fee amount paid by Tatum is converted to the number of credits, and these credits are deducted from the monthly credit allowance of your paid pricing plan. On the testnet, no credits are deducted from the monthly credit allowance. To mint NFTs on Solana, use this API with the MintNftExpressSolana schema of the request body. Solana uses the Metaplex Protocol, a smart contract and metadata standard for creating and working with NFTs. When you mint an NFT on Solana with NFT Express, the pre-built smart contract based on the Metaplex Protocol is used. When an NFT is minted on Solana, a new blockchain address is created to receive the NFT under the recipient&#39;s account address (the one in the to parameter of the request body). This address is returned in the nftAccountAddress parameter in the response body, is owned by the recipient&#39;s address, and has the same private key. The response body also returns the address of the minted NFT itself, which is held in the nftAddress parameter. After the NFT is minted, you have to transfer it to the recipient&#39;s address (use the transferNftSolana or transferNftSolanaKMS schema of the request body). In the request body of the transfer call: Set the from parameter to the address that you used in the to parameter in the request body of the minting call. Set the to parameter to the recipient&#39;s address. Set the contractAddress parameter to the address from the nftAddress parameter returned in the response body of the minting call. Set the fromPrivateKey/signatureId parameter to the private key/signature ID of the blockchain address that you specified in the from parameter. Use your own smart contract to mint NFTs If you want to mint NFTs using your own smart contract, you are going to use an NTF minter, a special blockchain address provided by Tatum that will cover the minting fees. The number of credits equivalent to the fees will be then deducted from the monthly credit allowance of your paid pricing plan. IMPORTANT! Your smart contract must be deployed as a general NFT smart contract. You cannot use cashback and provenance smart contracts with NFT Express. For more information, see our user documentation and the article in the Tatum blog. You can mint NFTs on your own smart contract on the following blockchains: BNB Smart Chain Celo Ethereum Harmony Klaytn Polygon To mint NFTs using your own smart contract, do the following: In the table located under this section, find the blockchain address of the Tatum NFT minter for your blockchain and network (mainnet or testnet). Add the minter address as an NFT minter to your smart contract. Use this API with the MintNftMinter schema of the request body. In the request body, enter the following information: chain is the blockchain that you use. to is the blockchain address where to send the minted NFT to. url is the URL of the NFT metadata. minter is the address of the NFT minter that you found in Step 1. contractAddress is the address of your NFT smart contract. tokenId is the the token ID of the NFT. For example:  {   \&quot;chain\&quot;: \&quot;CELO\&quot;,   \&quot;to\&quot;: \&quot;0x8ce4e40889a13971681391aad29e88efaf91f784\&quot;,   \&quot;url\&quot;: \&quot;ipfs://QmXJJ6UF5WkF4WTJvsdhiA1etGwBLfpva7Vr9AudGMe3pj\&quot;,   \&quot;contractAddress\&quot;: \&quot;0x687422eEA2cB73B5d3e242bA5456b782919AFc85\&quot;,   \&quot;tokenId\&quot;: \&quot;0123\&quot;,   \&quot;minter\&quot;: \&quot;0xBC2eBA680EE50d685cc4Fe65f102AA70AfB27D3F\&quot; } When you make an API call with this request body, the private key of the NFT minter will be added to the request body automatically:  {   \&quot;chain\&quot;: \&quot;CELO\&quot;,   \&quot;to\&quot;: \&quot;0x8ce4e40889a13971681391aad29e88efaf91f784\&quot;,   \&quot;url\&quot;: \&quot;ipfs://QmXJJ6UF5WkF4WTJvsdhiA1etGwBLfpva7Vr9AudGMe3pj\&quot;,   \&quot;contractAddress\&quot;: \&quot;0x687422eEA2cB73B5d3e242bA5456b782919AFc85\&quot;,   \&quot;tokenId\&quot;: \&quot;0123\&quot;,   \&quot;minter\&quot;: \&quot;0xBC2eBA680EE50d685cc4Fe65f102AA70AfB27D3F\&quot;,   \&quot;fromPrivateKey\&quot;: \&quot;0x05e150c73f1920ec14caa1e0b6aa09940899678051a78542840c2668ce5080c2\&quot; } The following table lists the blockchain addresses of the Tatum NFT minters for the testnet and mainnet of the supported blockchains: Blockchain Minter address - testnet* Minter address - mainnet BNB Smart Chain 0xc16ae5e8c985b906935a0cadf4e24f0400531883 0x49678AAB11E001eb3cB2cBD9aA96b36DC2461A94 Celo 0xBC2eBA680EE50d685cc4Fe65f102AA70AfB27D3F 0x49678AAB11E001eb3cB2cBD9aA96b36DC2461A94 Ethereum 0x53e8577C4347C365E4e0DA5B57A589cB6f2AB848 0x49678AAB11E001eb3cB2cBD9aA96b36DC2461A94 Harmony 0x8906f62d40293ddca77fdf6714c3f63265deddf0 0x49678AAB11E001eb3cB2cBD9aA96b36DC2461A94 Klaytn 0x80d8bac9a6901698b3749fe336bbd1385c1f98f2 0x49678AAB11E001eb3cB2cBD9aA96b36DC2461A94 Polygon 0x542b9ac4945a3836fd12ad98acbc76a0c8b743f5 0x49678AAB11E001eb3cB2cBD9aA96b36DC2461A94 *If a minter blockchain address on the testnet does not have sufficient funds to cover the transaction fee, add some amount to it using a crypto faucet of the blockchain. Minting NFTs natively on a blockchain When minting an NFT natively on a blockchain, you are charged a fee for the transaction, and you must sign the transaction with the private key of the blockchain address from which the fee will be deducted. Providing the private key in the API is not a secure way of signing transactions, because the private key can be stolen or exposed. Your private keys should never leave your security perimeter. You should use the private keys only for testing a solution you are building on the testnet of a blockchain. For signing transactions on the mainnet, we strongly recommend that you use the Tatum Key Management System (KMS) and provide the signature ID instead of the private key in the API. Alternatively, you can use the Tatum JavaScript client. You can mint NFTs natively on the following blockchains: Algorand BNB Smart Chain Celo Ethereum Flow Harmony Klaytn KuCoin Community Chain Polygon Solana TRON Depending on what blockchain you use, choose the request body schema to use in the API call. To mint NFTs natively on Algorand and: To sign the transaction with your private key, use this API with the MintNftAlgorand schema of the request body. To sign the transaction with your signature ID, use this API the MintNftAlgorandKMS schema of the request body. NOTE: To be able to burn the minted NFTs any time later, specify the address of the manager account in the manager parameter. An NFT minted on Algorand is automatically transferred to your blockchain address. After the NFT is minted, you have to transfer it to the recipient&#39;s address. The recipient has to agree in advance to receive your NFT because Algorand charges users for storing NFTs on their addresses, and an Algorand blockchain address by default does not receive NFTs unless explicitly agreed. For more information about how it works, see the section about minting NFTs on Algorand using the pre-built NFT smart contract provided by Tatum. To mint NFTs natively on BNB Smart Chain, Ethereum, Harmony, Klaytn, KuCoin Community Chain, or Polygon, and: To sign the transaction with your private key, use this API with the MintNft schema of the request body. To sign the transaction with your signature ID, use this API the MintNftKMS schema of the request body. To mint NFTs natively on Celo and: To sign the transaction with your private key, use this API with the MintNftCelo schema of the request body. To sign the transaction with your signature ID, use this API the MintNftKMSCelo schema of the request body. To mint NFTs natively on Flow and: To sign the transaction with your private key, use this API with the MintNftFlowPK schema of the request body. To sign the transaction with your signature ID, use this API the MintNftFlowMnemonic schema of the request body. To sign the transaction with your wallet mnemonic, use this API the MintNftFlowKMS schema of the request body. To mint NFTs natively on Solana and: To sign the transaction with your private key, use this API with the MintNftSolana schema of the request body. To sign the transaction with your signature ID, use this API the MintNftSolanaKMS schema of the request body. NOTE: When an NFT is minted on Solana, a new blockchain address is created to receive the NFT under the recipient&#39;s account address. After the NFT is minted, you have to transfer it to the recipient&#39;s address. For more information about how it works, see the section about minting NFTs on Solana using the pre-built NFT smart contract provided by Tatum. To mint NFTs natively on TRON and: To sign the transaction with your private key, use this API with the MintNftTron schema of the request body. To sign the transaction with your signature ID, use this API the MintNftKMSTron schema of the request body.
        /// </summary>
        /// <exception cref="Tatum.CSharp.Bsc.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="mintNftKMS"></param>
        /// <param name="xTestnetType">Type of Ethereum testnet. Defaults to Sepolia. Valid only for ETH invocations for testnet API Key. For mainnet API Key, this value is ignored. (optional, default to ethereum-sepolia)</param>
        /// <returns>SignatureId</returns>
        public SignatureId NftMintErc721(MintNftKMS mintNftKMS, string xTestnetType = default(string))
        {
            var localVarResponse = NftMintErc721WithHttpInfo(mintNftKMS, xTestnetType);

            var exception = ExceptionFactory?.Invoke("NftMintErc721_2", localVarResponse);
            if (exception != null) throw exception;

            return localVarResponse.Data;
        }

        /// <summary>
        /// Mint an NFT 100 credits per API call on Flow 2 credits per API call on the other blockchains You can mint NFTs using either of the following methods: Using NFT Express Natively on a blockchain Minting NFTs using NFT Express NFT Express is Tatum&#39;s feature that helps you mint NFTs easier than minting natively on a blockchain. You do not need to enter your private key or signature ID. NFT Express uses the private key provided by Tatum. You do not need to hold crypto or keep addresses topped up with crypto to pay for minting transactions. To use NFT Express on the mainnet, you have to have a paid pricing plan. Tatum covers your transaction fees for NFT minting and pays for them from its own blockchain address. Then, the fee amount paid by Tatum is converted to the number of credits, and these credits are deducted from the monthly credit allowance of your paid pricing plan. The transaction fees and the corresponding numbers of credits deducted from your allowance vary depending on what blockchain you mint NFTs on. On the testnet, no credits are deducted from the monthly credit allowance. You can mint NFTs with NFT Express regardless of your pricing plan. With NFT Express, you can choose whether to mint NFTs on the pre-built NFT smart contract provided by Tatum or on your own smart contract. Use the pre-built smart contract provided by Tatum to mint NFTs If you want to mint NFTs using the pre-built smart contract, you do not need to deploy your own NFT smart contract. You do not need to provide the address of the NFT smart contract and the token ID in the request body either. The address of the smart contract and the token ID are provided automatically by Tatum. The token ID is autogenerated. It starts with 0 and is increased by 1 for each new NFT. The token ID is calculated separately for each supported blockchain and its mainnet and testnet. For more information, see our user documentation. You can mint NFTs on the pre-built smart contract provided by Tatum on the following blockchains: Algorand BNB Smart Chain Celo Ethereum Harmony Klaytn Polygon Solana Depending on what blockchain you use, choose the request body schema to use in the API call. To mint NFTs on BNB Smart Chain, Celo, Ethereum, Harmony, Klaytn, or Polygon, use this API with the MintNftExpress schema of the request body. To mint NFTs on Algorand, use this API with the MintNftExpressAlgorand schema of the request body. To be able to burn the minted NFTs any time later, specify the address of the manager account in the manager parameter. An NFT minted on Algorand is automatically transferred to your blockchain address. After the NFT is minted, you have to transfer it to the recipient&#39;s address. The recipient has to agree in advance to receive your NFT because Algorand charges users for storing NFTs on their addresses, and an Algorand blockchain address by default does not receive NFTs unless explicitly agreed. This how it works: The recipient agrees to receive the NFT to their address. You transfer the NFT to the recipient&#39;s address (use the transferNftAlgoExpress schema of the request body). NOTE: On the mainnet, Tatum covers your transaction fees for the NFT transfer and pays for them from its own blockchain address. Then, the fee amount paid by Tatum is converted to the number of credits, and these credits are deducted from the monthly credit allowance of your paid pricing plan. On the testnet, no credits are deducted from the monthly credit allowance. To mint NFTs on Solana, use this API with the MintNftExpressSolana schema of the request body. Solana uses the Metaplex Protocol, a smart contract and metadata standard for creating and working with NFTs. When you mint an NFT on Solana with NFT Express, the pre-built smart contract based on the Metaplex Protocol is used. When an NFT is minted on Solana, a new blockchain address is created to receive the NFT under the recipient&#39;s account address (the one in the to parameter of the request body). This address is returned in the nftAccountAddress parameter in the response body, is owned by the recipient&#39;s address, and has the same private key. The response body also returns the address of the minted NFT itself, which is held in the nftAddress parameter. After the NFT is minted, you have to transfer it to the recipient&#39;s address (use the transferNftSolana or transferNftSolanaKMS schema of the request body). In the request body of the transfer call: Set the from parameter to the address that you used in the to parameter in the request body of the minting call. Set the to parameter to the recipient&#39;s address. Set the contractAddress parameter to the address from the nftAddress parameter returned in the response body of the minting call. Set the fromPrivateKey/signatureId parameter to the private key/signature ID of the blockchain address that you specified in the from parameter. Use your own smart contract to mint NFTs If you want to mint NFTs using your own smart contract, you are going to use an NTF minter, a special blockchain address provided by Tatum that will cover the minting fees. The number of credits equivalent to the fees will be then deducted from the monthly credit allowance of your paid pricing plan. IMPORTANT! Your smart contract must be deployed as a general NFT smart contract. You cannot use cashback and provenance smart contracts with NFT Express. For more information, see our user documentation and the article in the Tatum blog. You can mint NFTs on your own smart contract on the following blockchains: BNB Smart Chain Celo Ethereum Harmony Klaytn Polygon To mint NFTs using your own smart contract, do the following: In the table located under this section, find the blockchain address of the Tatum NFT minter for your blockchain and network (mainnet or testnet). Add the minter address as an NFT minter to your smart contract. Use this API with the MintNftMinter schema of the request body. In the request body, enter the following information: chain is the blockchain that you use. to is the blockchain address where to send the minted NFT to. url is the URL of the NFT metadata. minter is the address of the NFT minter that you found in Step 1. contractAddress is the address of your NFT smart contract. tokenId is the the token ID of the NFT. For example:  {   \&quot;chain\&quot;: \&quot;CELO\&quot;,   \&quot;to\&quot;: \&quot;0x8ce4e40889a13971681391aad29e88efaf91f784\&quot;,   \&quot;url\&quot;: \&quot;ipfs://QmXJJ6UF5WkF4WTJvsdhiA1etGwBLfpva7Vr9AudGMe3pj\&quot;,   \&quot;contractAddress\&quot;: \&quot;0x687422eEA2cB73B5d3e242bA5456b782919AFc85\&quot;,   \&quot;tokenId\&quot;: \&quot;0123\&quot;,   \&quot;minter\&quot;: \&quot;0xBC2eBA680EE50d685cc4Fe65f102AA70AfB27D3F\&quot; } When you make an API call with this request body, the private key of the NFT minter will be added to the request body automatically:  {   \&quot;chain\&quot;: \&quot;CELO\&quot;,   \&quot;to\&quot;: \&quot;0x8ce4e40889a13971681391aad29e88efaf91f784\&quot;,   \&quot;url\&quot;: \&quot;ipfs://QmXJJ6UF5WkF4WTJvsdhiA1etGwBLfpva7Vr9AudGMe3pj\&quot;,   \&quot;contractAddress\&quot;: \&quot;0x687422eEA2cB73B5d3e242bA5456b782919AFc85\&quot;,   \&quot;tokenId\&quot;: \&quot;0123\&quot;,   \&quot;minter\&quot;: \&quot;0xBC2eBA680EE50d685cc4Fe65f102AA70AfB27D3F\&quot;,   \&quot;fromPrivateKey\&quot;: \&quot;0x05e150c73f1920ec14caa1e0b6aa09940899678051a78542840c2668ce5080c2\&quot; } The following table lists the blockchain addresses of the Tatum NFT minters for the testnet and mainnet of the supported blockchains: Blockchain Minter address - testnet* Minter address - mainnet BNB Smart Chain 0xc16ae5e8c985b906935a0cadf4e24f0400531883 0x49678AAB11E001eb3cB2cBD9aA96b36DC2461A94 Celo 0xBC2eBA680EE50d685cc4Fe65f102AA70AfB27D3F 0x49678AAB11E001eb3cB2cBD9aA96b36DC2461A94 Ethereum 0x53e8577C4347C365E4e0DA5B57A589cB6f2AB848 0x49678AAB11E001eb3cB2cBD9aA96b36DC2461A94 Harmony 0x8906f62d40293ddca77fdf6714c3f63265deddf0 0x49678AAB11E001eb3cB2cBD9aA96b36DC2461A94 Klaytn 0x80d8bac9a6901698b3749fe336bbd1385c1f98f2 0x49678AAB11E001eb3cB2cBD9aA96b36DC2461A94 Polygon 0x542b9ac4945a3836fd12ad98acbc76a0c8b743f5 0x49678AAB11E001eb3cB2cBD9aA96b36DC2461A94 *If a minter blockchain address on the testnet does not have sufficient funds to cover the transaction fee, add some amount to it using a crypto faucet of the blockchain. Minting NFTs natively on a blockchain When minting an NFT natively on a blockchain, you are charged a fee for the transaction, and you must sign the transaction with the private key of the blockchain address from which the fee will be deducted. Providing the private key in the API is not a secure way of signing transactions, because the private key can be stolen or exposed. Your private keys should never leave your security perimeter. You should use the private keys only for testing a solution you are building on the testnet of a blockchain. For signing transactions on the mainnet, we strongly recommend that you use the Tatum Key Management System (KMS) and provide the signature ID instead of the private key in the API. Alternatively, you can use the Tatum JavaScript client. You can mint NFTs natively on the following blockchains: Algorand BNB Smart Chain Celo Ethereum Flow Harmony Klaytn KuCoin Community Chain Polygon Solana TRON Depending on what blockchain you use, choose the request body schema to use in the API call. To mint NFTs natively on Algorand and: To sign the transaction with your private key, use this API with the MintNftAlgorand schema of the request body. To sign the transaction with your signature ID, use this API the MintNftAlgorandKMS schema of the request body. NOTE: To be able to burn the minted NFTs any time later, specify the address of the manager account in the manager parameter. An NFT minted on Algorand is automatically transferred to your blockchain address. After the NFT is minted, you have to transfer it to the recipient&#39;s address. The recipient has to agree in advance to receive your NFT because Algorand charges users for storing NFTs on their addresses, and an Algorand blockchain address by default does not receive NFTs unless explicitly agreed. For more information about how it works, see the section about minting NFTs on Algorand using the pre-built NFT smart contract provided by Tatum. To mint NFTs natively on BNB Smart Chain, Ethereum, Harmony, Klaytn, KuCoin Community Chain, or Polygon, and: To sign the transaction with your private key, use this API with the MintNft schema of the request body. To sign the transaction with your signature ID, use this API the MintNftKMS schema of the request body. To mint NFTs natively on Celo and: To sign the transaction with your private key, use this API with the MintNftCelo schema of the request body. To sign the transaction with your signature ID, use this API the MintNftKMSCelo schema of the request body. To mint NFTs natively on Flow and: To sign the transaction with your private key, use this API with the MintNftFlowPK schema of the request body. To sign the transaction with your signature ID, use this API the MintNftFlowMnemonic schema of the request body. To sign the transaction with your wallet mnemonic, use this API the MintNftFlowKMS schema of the request body. To mint NFTs natively on Solana and: To sign the transaction with your private key, use this API with the MintNftSolana schema of the request body. To sign the transaction with your signature ID, use this API the MintNftSolanaKMS schema of the request body. NOTE: When an NFT is minted on Solana, a new blockchain address is created to receive the NFT under the recipient&#39;s account address. After the NFT is minted, you have to transfer it to the recipient&#39;s address. For more information about how it works, see the section about minting NFTs on Solana using the pre-built NFT smart contract provided by Tatum. To mint NFTs natively on TRON and: To sign the transaction with your private key, use this API with the MintNftTron schema of the request body. To sign the transaction with your signature ID, use this API the MintNftKMSTron schema of the request body.
        /// </summary>
        /// <exception cref="Tatum.CSharp.Bsc.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="mintNftKMS"></param>
        /// <param name="xTestnetType">Type of Ethereum testnet. Defaults to Sepolia. Valid only for ETH invocations for testnet API Key. For mainnet API Key, this value is ignored. (optional, default to ethereum-sepolia)</param>
        /// <returns>ApiResponse of SignatureId</returns>
        public ApiResponse<SignatureId> NftMintErc721WithHttpInfo(MintNftKMS mintNftKMS, string xTestnetType = default(string))
        {
            // verify the required parameter 'mintNftKMS' is set
            if (mintNftKMS == null)
                throw new ApiException(400, "Missing required parameter 'mintNftKMS' when calling NFTBscApi->NftMintErc721_2");

            var localVarRequestOptions = new RequestOptions();

            var contentTypes = new string[]{
                "application/json"
            };

            // to determine the Accept header
            var accepts = new string[]{
                "application/json"
            };

            var localVarContentType = ClientUtils.SelectHeaderContentType(contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = ClientUtils.SelectHeaderAccept(accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            if (xTestnetType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("x-testnet-type", ClientUtils.ParameterToString(xTestnetType)); // header parameter
            }
            localVarRequestOptions.Data = mintNftKMS;

            // authentication (X-API-Key) required
            if (!string.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("x-api-key")))
            {
                localVarRequestOptions.HeaderParameters.Add("x-api-key", Configuration.GetApiKeyWithPrefix("x-api-key"));
            }

            // make the HTTP request
            var localVarResponse = Client.Post<SignatureId>("/v3/nft/mint", localVarRequestOptions, Configuration);

            return localVarResponse;
        }

        /// <summary>
        /// Mint an NFT 100 credits per API call on Flow 2 credits per API call on the other blockchains You can mint NFTs using either of the following methods: Using NFT Express Natively on a blockchain Minting NFTs using NFT Express NFT Express is Tatum&#39;s feature that helps you mint NFTs easier than minting natively on a blockchain. You do not need to enter your private key or signature ID. NFT Express uses the private key provided by Tatum. You do not need to hold crypto or keep addresses topped up with crypto to pay for minting transactions. To use NFT Express on the mainnet, you have to have a paid pricing plan. Tatum covers your transaction fees for NFT minting and pays for them from its own blockchain address. Then, the fee amount paid by Tatum is converted to the number of credits, and these credits are deducted from the monthly credit allowance of your paid pricing plan. The transaction fees and the corresponding numbers of credits deducted from your allowance vary depending on what blockchain you mint NFTs on. On the testnet, no credits are deducted from the monthly credit allowance. You can mint NFTs with NFT Express regardless of your pricing plan. With NFT Express, you can choose whether to mint NFTs on the pre-built NFT smart contract provided by Tatum or on your own smart contract. Use the pre-built smart contract provided by Tatum to mint NFTs If you want to mint NFTs using the pre-built smart contract, you do not need to deploy your own NFT smart contract. You do not need to provide the address of the NFT smart contract and the token ID in the request body either. The address of the smart contract and the token ID are provided automatically by Tatum. The token ID is autogenerated. It starts with 0 and is increased by 1 for each new NFT. The token ID is calculated separately for each supported blockchain and its mainnet and testnet. For more information, see our user documentation. You can mint NFTs on the pre-built smart contract provided by Tatum on the following blockchains: Algorand BNB Smart Chain Celo Ethereum Harmony Klaytn Polygon Solana Depending on what blockchain you use, choose the request body schema to use in the API call. To mint NFTs on BNB Smart Chain, Celo, Ethereum, Harmony, Klaytn, or Polygon, use this API with the MintNftExpress schema of the request body. To mint NFTs on Algorand, use this API with the MintNftExpressAlgorand schema of the request body. To be able to burn the minted NFTs any time later, specify the address of the manager account in the manager parameter. An NFT minted on Algorand is automatically transferred to your blockchain address. After the NFT is minted, you have to transfer it to the recipient&#39;s address. The recipient has to agree in advance to receive your NFT because Algorand charges users for storing NFTs on their addresses, and an Algorand blockchain address by default does not receive NFTs unless explicitly agreed. This how it works: The recipient agrees to receive the NFT to their address. You transfer the NFT to the recipient&#39;s address (use the transferNftAlgoExpress schema of the request body). NOTE: On the mainnet, Tatum covers your transaction fees for the NFT transfer and pays for them from its own blockchain address. Then, the fee amount paid by Tatum is converted to the number of credits, and these credits are deducted from the monthly credit allowance of your paid pricing plan. On the testnet, no credits are deducted from the monthly credit allowance. To mint NFTs on Solana, use this API with the MintNftExpressSolana schema of the request body. Solana uses the Metaplex Protocol, a smart contract and metadata standard for creating and working with NFTs. When you mint an NFT on Solana with NFT Express, the pre-built smart contract based on the Metaplex Protocol is used. When an NFT is minted on Solana, a new blockchain address is created to receive the NFT under the recipient&#39;s account address (the one in the to parameter of the request body). This address is returned in the nftAccountAddress parameter in the response body, is owned by the recipient&#39;s address, and has the same private key. The response body also returns the address of the minted NFT itself, which is held in the nftAddress parameter. After the NFT is minted, you have to transfer it to the recipient&#39;s address (use the transferNftSolana or transferNftSolanaKMS schema of the request body). In the request body of the transfer call: Set the from parameter to the address that you used in the to parameter in the request body of the minting call. Set the to parameter to the recipient&#39;s address. Set the contractAddress parameter to the address from the nftAddress parameter returned in the response body of the minting call. Set the fromPrivateKey/signatureId parameter to the private key/signature ID of the blockchain address that you specified in the from parameter. Use your own smart contract to mint NFTs If you want to mint NFTs using your own smart contract, you are going to use an NTF minter, a special blockchain address provided by Tatum that will cover the minting fees. The number of credits equivalent to the fees will be then deducted from the monthly credit allowance of your paid pricing plan. IMPORTANT! Your smart contract must be deployed as a general NFT smart contract. You cannot use cashback and provenance smart contracts with NFT Express. For more information, see our user documentation and the article in the Tatum blog. You can mint NFTs on your own smart contract on the following blockchains: BNB Smart Chain Celo Ethereum Harmony Klaytn Polygon To mint NFTs using your own smart contract, do the following: In the table located under this section, find the blockchain address of the Tatum NFT minter for your blockchain and network (mainnet or testnet). Add the minter address as an NFT minter to your smart contract. Use this API with the MintNftMinter schema of the request body. In the request body, enter the following information: chain is the blockchain that you use. to is the blockchain address where to send the minted NFT to. url is the URL of the NFT metadata. minter is the address of the NFT minter that you found in Step 1. contractAddress is the address of your NFT smart contract. tokenId is the the token ID of the NFT. For example:  {   \&quot;chain\&quot;: \&quot;CELO\&quot;,   \&quot;to\&quot;: \&quot;0x8ce4e40889a13971681391aad29e88efaf91f784\&quot;,   \&quot;url\&quot;: \&quot;ipfs://QmXJJ6UF5WkF4WTJvsdhiA1etGwBLfpva7Vr9AudGMe3pj\&quot;,   \&quot;contractAddress\&quot;: \&quot;0x687422eEA2cB73B5d3e242bA5456b782919AFc85\&quot;,   \&quot;tokenId\&quot;: \&quot;0123\&quot;,   \&quot;minter\&quot;: \&quot;0xBC2eBA680EE50d685cc4Fe65f102AA70AfB27D3F\&quot; } When you make an API call with this request body, the private key of the NFT minter will be added to the request body automatically:  {   \&quot;chain\&quot;: \&quot;CELO\&quot;,   \&quot;to\&quot;: \&quot;0x8ce4e40889a13971681391aad29e88efaf91f784\&quot;,   \&quot;url\&quot;: \&quot;ipfs://QmXJJ6UF5WkF4WTJvsdhiA1etGwBLfpva7Vr9AudGMe3pj\&quot;,   \&quot;contractAddress\&quot;: \&quot;0x687422eEA2cB73B5d3e242bA5456b782919AFc85\&quot;,   \&quot;tokenId\&quot;: \&quot;0123\&quot;,   \&quot;minter\&quot;: \&quot;0xBC2eBA680EE50d685cc4Fe65f102AA70AfB27D3F\&quot;,   \&quot;fromPrivateKey\&quot;: \&quot;0x05e150c73f1920ec14caa1e0b6aa09940899678051a78542840c2668ce5080c2\&quot; } The following table lists the blockchain addresses of the Tatum NFT minters for the testnet and mainnet of the supported blockchains: Blockchain Minter address - testnet* Minter address - mainnet BNB Smart Chain 0xc16ae5e8c985b906935a0cadf4e24f0400531883 0x49678AAB11E001eb3cB2cBD9aA96b36DC2461A94 Celo 0xBC2eBA680EE50d685cc4Fe65f102AA70AfB27D3F 0x49678AAB11E001eb3cB2cBD9aA96b36DC2461A94 Ethereum 0x53e8577C4347C365E4e0DA5B57A589cB6f2AB848 0x49678AAB11E001eb3cB2cBD9aA96b36DC2461A94 Harmony 0x8906f62d40293ddca77fdf6714c3f63265deddf0 0x49678AAB11E001eb3cB2cBD9aA96b36DC2461A94 Klaytn 0x80d8bac9a6901698b3749fe336bbd1385c1f98f2 0x49678AAB11E001eb3cB2cBD9aA96b36DC2461A94 Polygon 0x542b9ac4945a3836fd12ad98acbc76a0c8b743f5 0x49678AAB11E001eb3cB2cBD9aA96b36DC2461A94 *If a minter blockchain address on the testnet does not have sufficient funds to cover the transaction fee, add some amount to it using a crypto faucet of the blockchain. Minting NFTs natively on a blockchain When minting an NFT natively on a blockchain, you are charged a fee for the transaction, and you must sign the transaction with the private key of the blockchain address from which the fee will be deducted. Providing the private key in the API is not a secure way of signing transactions, because the private key can be stolen or exposed. Your private keys should never leave your security perimeter. You should use the private keys only for testing a solution you are building on the testnet of a blockchain. For signing transactions on the mainnet, we strongly recommend that you use the Tatum Key Management System (KMS) and provide the signature ID instead of the private key in the API. Alternatively, you can use the Tatum JavaScript client. You can mint NFTs natively on the following blockchains: Algorand BNB Smart Chain Celo Ethereum Flow Harmony Klaytn KuCoin Community Chain Polygon Solana TRON Depending on what blockchain you use, choose the request body schema to use in the API call. To mint NFTs natively on Algorand and: To sign the transaction with your private key, use this API with the MintNftAlgorand schema of the request body. To sign the transaction with your signature ID, use this API the MintNftAlgorandKMS schema of the request body. NOTE: To be able to burn the minted NFTs any time later, specify the address of the manager account in the manager parameter. An NFT minted on Algorand is automatically transferred to your blockchain address. After the NFT is minted, you have to transfer it to the recipient&#39;s address. The recipient has to agree in advance to receive your NFT because Algorand charges users for storing NFTs on their addresses, and an Algorand blockchain address by default does not receive NFTs unless explicitly agreed. For more information about how it works, see the section about minting NFTs on Algorand using the pre-built NFT smart contract provided by Tatum. To mint NFTs natively on BNB Smart Chain, Ethereum, Harmony, Klaytn, KuCoin Community Chain, or Polygon, and: To sign the transaction with your private key, use this API with the MintNft schema of the request body. To sign the transaction with your signature ID, use this API the MintNftKMS schema of the request body. To mint NFTs natively on Celo and: To sign the transaction with your private key, use this API with the MintNftCelo schema of the request body. To sign the transaction with your signature ID, use this API the MintNftKMSCelo schema of the request body. To mint NFTs natively on Flow and: To sign the transaction with your private key, use this API with the MintNftFlowPK schema of the request body. To sign the transaction with your signature ID, use this API the MintNftFlowMnemonic schema of the request body. To sign the transaction with your wallet mnemonic, use this API the MintNftFlowKMS schema of the request body. To mint NFTs natively on Solana and: To sign the transaction with your private key, use this API with the MintNftSolana schema of the request body. To sign the transaction with your signature ID, use this API the MintNftSolanaKMS schema of the request body. NOTE: When an NFT is minted on Solana, a new blockchain address is created to receive the NFT under the recipient&#39;s account address. After the NFT is minted, you have to transfer it to the recipient&#39;s address. For more information about how it works, see the section about minting NFTs on Solana using the pre-built NFT smart contract provided by Tatum. To mint NFTs natively on TRON and: To sign the transaction with your private key, use this API with the MintNftTron schema of the request body. To sign the transaction with your signature ID, use this API the MintNftKMSTron schema of the request body.
        /// </summary>
        /// <exception cref="Tatum.CSharp.Bsc.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="mintNftKMS"></param>
        /// <param name="xTestnetType">Type of Ethereum testnet. Defaults to Sepolia. Valid only for ETH invocations for testnet API Key. For mainnet API Key, this value is ignored. (optional, default to ethereum-sepolia)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of SignatureId</returns>
        public async System.Threading.Tasks.Task<SignatureId> NftMintErc721Async(MintNftKMS mintNftKMS, string xTestnetType = default(string), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            var localVarResponse = await NftMintErc721WithHttpInfoAsync(mintNftKMS, xTestnetType, cancellationToken).ConfigureAwait(false);
            
            var exception = ExceptionFactory?.Invoke("NftMintErc721_2", localVarResponse);
            if (exception != null) throw exception;

            return localVarResponse.Data;
        }

        /// <summary>
        /// Mint an NFT 100 credits per API call on Flow 2 credits per API call on the other blockchains You can mint NFTs using either of the following methods: Using NFT Express Natively on a blockchain Minting NFTs using NFT Express NFT Express is Tatum&#39;s feature that helps you mint NFTs easier than minting natively on a blockchain. You do not need to enter your private key or signature ID. NFT Express uses the private key provided by Tatum. You do not need to hold crypto or keep addresses topped up with crypto to pay for minting transactions. To use NFT Express on the mainnet, you have to have a paid pricing plan. Tatum covers your transaction fees for NFT minting and pays for them from its own blockchain address. Then, the fee amount paid by Tatum is converted to the number of credits, and these credits are deducted from the monthly credit allowance of your paid pricing plan. The transaction fees and the corresponding numbers of credits deducted from your allowance vary depending on what blockchain you mint NFTs on. On the testnet, no credits are deducted from the monthly credit allowance. You can mint NFTs with NFT Express regardless of your pricing plan. With NFT Express, you can choose whether to mint NFTs on the pre-built NFT smart contract provided by Tatum or on your own smart contract. Use the pre-built smart contract provided by Tatum to mint NFTs If you want to mint NFTs using the pre-built smart contract, you do not need to deploy your own NFT smart contract. You do not need to provide the address of the NFT smart contract and the token ID in the request body either. The address of the smart contract and the token ID are provided automatically by Tatum. The token ID is autogenerated. It starts with 0 and is increased by 1 for each new NFT. The token ID is calculated separately for each supported blockchain and its mainnet and testnet. For more information, see our user documentation. You can mint NFTs on the pre-built smart contract provided by Tatum on the following blockchains: Algorand BNB Smart Chain Celo Ethereum Harmony Klaytn Polygon Solana Depending on what blockchain you use, choose the request body schema to use in the API call. To mint NFTs on BNB Smart Chain, Celo, Ethereum, Harmony, Klaytn, or Polygon, use this API with the MintNftExpress schema of the request body. To mint NFTs on Algorand, use this API with the MintNftExpressAlgorand schema of the request body. To be able to burn the minted NFTs any time later, specify the address of the manager account in the manager parameter. An NFT minted on Algorand is automatically transferred to your blockchain address. After the NFT is minted, you have to transfer it to the recipient&#39;s address. The recipient has to agree in advance to receive your NFT because Algorand charges users for storing NFTs on their addresses, and an Algorand blockchain address by default does not receive NFTs unless explicitly agreed. This how it works: The recipient agrees to receive the NFT to their address. You transfer the NFT to the recipient&#39;s address (use the transferNftAlgoExpress schema of the request body). NOTE: On the mainnet, Tatum covers your transaction fees for the NFT transfer and pays for them from its own blockchain address. Then, the fee amount paid by Tatum is converted to the number of credits, and these credits are deducted from the monthly credit allowance of your paid pricing plan. On the testnet, no credits are deducted from the monthly credit allowance. To mint NFTs on Solana, use this API with the MintNftExpressSolana schema of the request body. Solana uses the Metaplex Protocol, a smart contract and metadata standard for creating and working with NFTs. When you mint an NFT on Solana with NFT Express, the pre-built smart contract based on the Metaplex Protocol is used. When an NFT is minted on Solana, a new blockchain address is created to receive the NFT under the recipient&#39;s account address (the one in the to parameter of the request body). This address is returned in the nftAccountAddress parameter in the response body, is owned by the recipient&#39;s address, and has the same private key. The response body also returns the address of the minted NFT itself, which is held in the nftAddress parameter. After the NFT is minted, you have to transfer it to the recipient&#39;s address (use the transferNftSolana or transferNftSolanaKMS schema of the request body). In the request body of the transfer call: Set the from parameter to the address that you used in the to parameter in the request body of the minting call. Set the to parameter to the recipient&#39;s address. Set the contractAddress parameter to the address from the nftAddress parameter returned in the response body of the minting call. Set the fromPrivateKey/signatureId parameter to the private key/signature ID of the blockchain address that you specified in the from parameter. Use your own smart contract to mint NFTs If you want to mint NFTs using your own smart contract, you are going to use an NTF minter, a special blockchain address provided by Tatum that will cover the minting fees. The number of credits equivalent to the fees will be then deducted from the monthly credit allowance of your paid pricing plan. IMPORTANT! Your smart contract must be deployed as a general NFT smart contract. You cannot use cashback and provenance smart contracts with NFT Express. For more information, see our user documentation and the article in the Tatum blog. You can mint NFTs on your own smart contract on the following blockchains: BNB Smart Chain Celo Ethereum Harmony Klaytn Polygon To mint NFTs using your own smart contract, do the following: In the table located under this section, find the blockchain address of the Tatum NFT minter for your blockchain and network (mainnet or testnet). Add the minter address as an NFT minter to your smart contract. Use this API with the MintNftMinter schema of the request body. In the request body, enter the following information: chain is the blockchain that you use. to is the blockchain address where to send the minted NFT to. url is the URL of the NFT metadata. minter is the address of the NFT minter that you found in Step 1. contractAddress is the address of your NFT smart contract. tokenId is the the token ID of the NFT. For example:  {   \&quot;chain\&quot;: \&quot;CELO\&quot;,   \&quot;to\&quot;: \&quot;0x8ce4e40889a13971681391aad29e88efaf91f784\&quot;,   \&quot;url\&quot;: \&quot;ipfs://QmXJJ6UF5WkF4WTJvsdhiA1etGwBLfpva7Vr9AudGMe3pj\&quot;,   \&quot;contractAddress\&quot;: \&quot;0x687422eEA2cB73B5d3e242bA5456b782919AFc85\&quot;,   \&quot;tokenId\&quot;: \&quot;0123\&quot;,   \&quot;minter\&quot;: \&quot;0xBC2eBA680EE50d685cc4Fe65f102AA70AfB27D3F\&quot; } When you make an API call with this request body, the private key of the NFT minter will be added to the request body automatically:  {   \&quot;chain\&quot;: \&quot;CELO\&quot;,   \&quot;to\&quot;: \&quot;0x8ce4e40889a13971681391aad29e88efaf91f784\&quot;,   \&quot;url\&quot;: \&quot;ipfs://QmXJJ6UF5WkF4WTJvsdhiA1etGwBLfpva7Vr9AudGMe3pj\&quot;,   \&quot;contractAddress\&quot;: \&quot;0x687422eEA2cB73B5d3e242bA5456b782919AFc85\&quot;,   \&quot;tokenId\&quot;: \&quot;0123\&quot;,   \&quot;minter\&quot;: \&quot;0xBC2eBA680EE50d685cc4Fe65f102AA70AfB27D3F\&quot;,   \&quot;fromPrivateKey\&quot;: \&quot;0x05e150c73f1920ec14caa1e0b6aa09940899678051a78542840c2668ce5080c2\&quot; } The following table lists the blockchain addresses of the Tatum NFT minters for the testnet and mainnet of the supported blockchains: Blockchain Minter address - testnet* Minter address - mainnet BNB Smart Chain 0xc16ae5e8c985b906935a0cadf4e24f0400531883 0x49678AAB11E001eb3cB2cBD9aA96b36DC2461A94 Celo 0xBC2eBA680EE50d685cc4Fe65f102AA70AfB27D3F 0x49678AAB11E001eb3cB2cBD9aA96b36DC2461A94 Ethereum 0x53e8577C4347C365E4e0DA5B57A589cB6f2AB848 0x49678AAB11E001eb3cB2cBD9aA96b36DC2461A94 Harmony 0x8906f62d40293ddca77fdf6714c3f63265deddf0 0x49678AAB11E001eb3cB2cBD9aA96b36DC2461A94 Klaytn 0x80d8bac9a6901698b3749fe336bbd1385c1f98f2 0x49678AAB11E001eb3cB2cBD9aA96b36DC2461A94 Polygon 0x542b9ac4945a3836fd12ad98acbc76a0c8b743f5 0x49678AAB11E001eb3cB2cBD9aA96b36DC2461A94 *If a minter blockchain address on the testnet does not have sufficient funds to cover the transaction fee, add some amount to it using a crypto faucet of the blockchain. Minting NFTs natively on a blockchain When minting an NFT natively on a blockchain, you are charged a fee for the transaction, and you must sign the transaction with the private key of the blockchain address from which the fee will be deducted. Providing the private key in the API is not a secure way of signing transactions, because the private key can be stolen or exposed. Your private keys should never leave your security perimeter. You should use the private keys only for testing a solution you are building on the testnet of a blockchain. For signing transactions on the mainnet, we strongly recommend that you use the Tatum Key Management System (KMS) and provide the signature ID instead of the private key in the API. Alternatively, you can use the Tatum JavaScript client. You can mint NFTs natively on the following blockchains: Algorand BNB Smart Chain Celo Ethereum Flow Harmony Klaytn KuCoin Community Chain Polygon Solana TRON Depending on what blockchain you use, choose the request body schema to use in the API call. To mint NFTs natively on Algorand and: To sign the transaction with your private key, use this API with the MintNftAlgorand schema of the request body. To sign the transaction with your signature ID, use this API the MintNftAlgorandKMS schema of the request body. NOTE: To be able to burn the minted NFTs any time later, specify the address of the manager account in the manager parameter. An NFT minted on Algorand is automatically transferred to your blockchain address. After the NFT is minted, you have to transfer it to the recipient&#39;s address. The recipient has to agree in advance to receive your NFT because Algorand charges users for storing NFTs on their addresses, and an Algorand blockchain address by default does not receive NFTs unless explicitly agreed. For more information about how it works, see the section about minting NFTs on Algorand using the pre-built NFT smart contract provided by Tatum. To mint NFTs natively on BNB Smart Chain, Ethereum, Harmony, Klaytn, KuCoin Community Chain, or Polygon, and: To sign the transaction with your private key, use this API with the MintNft schema of the request body. To sign the transaction with your signature ID, use this API the MintNftKMS schema of the request body. To mint NFTs natively on Celo and: To sign the transaction with your private key, use this API with the MintNftCelo schema of the request body. To sign the transaction with your signature ID, use this API the MintNftKMSCelo schema of the request body. To mint NFTs natively on Flow and: To sign the transaction with your private key, use this API with the MintNftFlowPK schema of the request body. To sign the transaction with your signature ID, use this API the MintNftFlowMnemonic schema of the request body. To sign the transaction with your wallet mnemonic, use this API the MintNftFlowKMS schema of the request body. To mint NFTs natively on Solana and: To sign the transaction with your private key, use this API with the MintNftSolana schema of the request body. To sign the transaction with your signature ID, use this API the MintNftSolanaKMS schema of the request body. NOTE: When an NFT is minted on Solana, a new blockchain address is created to receive the NFT under the recipient&#39;s account address. After the NFT is minted, you have to transfer it to the recipient&#39;s address. For more information about how it works, see the section about minting NFTs on Solana using the pre-built NFT smart contract provided by Tatum. To mint NFTs natively on TRON and: To sign the transaction with your private key, use this API with the MintNftTron schema of the request body. To sign the transaction with your signature ID, use this API the MintNftKMSTron schema of the request body.
        /// </summary>
        /// <exception cref="Tatum.CSharp.Bsc.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="mintNftKMS"></param>
        /// <param name="xTestnetType">Type of Ethereum testnet. Defaults to Sepolia. Valid only for ETH invocations for testnet API Key. For mainnet API Key, this value is ignored. (optional, default to ethereum-sepolia)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (SignatureId)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<SignatureId>> NftMintErc721WithHttpInfoAsync(MintNftKMS mintNftKMS, string xTestnetType = default(string), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            // verify the required parameter 'mintNftKMS' is set
            if (mintNftKMS == null)
                throw new ApiException(400, "Missing required parameter 'mintNftKMS' when calling NFTBscApi->NftMintErc721_2");

            var localVarRequestOptions = new RequestOptions();

            var contentTypes = new string[]{
                "application/json"
            };

            // to determine the Accept header
            var accepts = new string[]{
                "application/json"
            };


            var localVarContentType = ClientUtils.SelectHeaderContentType(contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = ClientUtils.SelectHeaderAccept(accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            if (xTestnetType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("x-testnet-type", ClientUtils.ParameterToString(xTestnetType)); // header parameter
            }
            localVarRequestOptions.Data = mintNftKMS;

            // authentication (X-API-Key) required
            if (!string.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("x-api-key")))
            {
                localVarRequestOptions.HeaderParameters.Add("x-api-key", Configuration.GetApiKeyWithPrefix("x-api-key"));
            }

            // make the HTTP request

            var localVarResponse = await AsynchronousClient.PostAsync<SignatureId>("/v3/nft/mint", localVarRequestOptions, Configuration, cancellationToken).ConfigureAwait(false);

            return localVarResponse;
        }

        /// <summary>
        /// Mint multiple NFTs 100 credits per API call on Flow 2 credits per API call on the other blockchains Create multiple NFT Tokens and transfer them to destination account. Create and transfer any NFT tokens from smart contract defined in contractAddress. This API is supported for the following blockchains: BNB Smart Chain Celo Ethereum Flow Harmony Klaytn KuCoin Community Chain Polygon TRON This operation works in two modes. First mode works just like other NFT endpoints. Every time the funds are transferred, the transaction must be signed with the corresponding private key. No one should ever send it&#39;s own private keys to the internet because there is a strong possibility of stealing keys and loss of funds. In this method, it is possible to enter privateKey or signatureId. PrivateKey should be used only for quick development on testnet versions of blockchain when there is no risk of losing funds. In production, Tatum KMS should be used for the highest security standards, and signatureId should be present in the request. Alternatively, using the Tatum client library for supported languages. Second mode enables you to mint on any custom NFT ERC-721 smart contract, on which specified minter address is approved as a minter. You don&#39;t specify private key or signatureId, only minter address, from which the NFT will be minted. It means you perform mint multiple NFT request with following body: {    \&quot;to\&quot;: [\&quot;0x80d8bac9a6901698b3749fe336bbd1385c1f98f2\&quot;],    \&quot;url\&quot;: [\&quot;ipfs://QmXJJ6UF5WkF4WTJvsdhiA1etGwBLfpva7Vr9AudGMe3pj\&quot;],    \&quot;tokenId\&quot;: [\&quot;9876541124516\&quot;],    \&quot;contractAddress\&quot;:\&quot;0xcd2ada00c48a27faa5cc67f9a1ed55b89ddf7f77\&quot;,    \&quot;minter\&quot;: \&quot;0x542b9ac4945a3836fd12ad98acbc76a0c8b743f5\&quot;,    \&quot;chain\&quot;: \&quot;MATIC\&quot; } The blockchain fee of the performed transaction is paid from the address connected with built-in private key and is debited in form of credits. The credits are debited only if NFT mint requests are performed with paid API key plan. We transform fee to the credits in accordance to the rates provided by the Tatum. If you want to batch mint on ERC-721 contract which is not deployed via Tatum API, your smart contract must contain this method: mintMultiple(address[] to, uint256[] tokenId, string[] uri): boolean You can use addresses specified in the bellow table to be used as a minter. Chain Testnet address Mainnet Address MATIC 0x542b9ac4945a3836fd12ad98acbc76a0c8b743f5 0xcf9e127455d28e7362380aec1b92ddee8200b295 BSC 0xc16ae5e8c985b906935a0cadf4e24f0400531883 0xcf9e127455d28e7362380aec1b92ddee8200b295 ONE 0x8906f62d40293ddca77fdf6714c3f63265deddf0 0xcf9e127455d28e7362380aec1b92ddee8200b295 ETH 0x53e8577C4347C365E4e0DA5B57A589cB6f2AB848 0xcf9e127455d28e7362380aec1b92ddee8200b295 CELO 0xBC2eBA680EE50d685cc4Fe65f102AA70AfB27D3F 0xcf9e127455d28e7362380aec1b92ddee8200b295 KLAY 0x80d8bac9a6901698b3749fe336bbd1385c1f98f2 0xcf9e127455d28e7362380aec1b92ddee8200b295 If there are not enough coins on any testnet address, feel free to send coins there.
        /// </summary>
        /// <exception cref="Tatum.CSharp.Bsc.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="mintMultipleNftMinter"></param>
        /// <param name="xTestnetType">Type of Ethereum testnet. Defaults to Sepolia. Valid only for ETH invocations for testnet API Key. For mainnet API Key, this value is ignored. (optional, default to ethereum-sepolia)</param>
        /// <returns>TransactionHash</returns>
        public TransactionHash NftMintMultipleErc721(MintMultipleNftMinter mintMultipleNftMinter, string xTestnetType = default(string))
        {
            var localVarResponse = NftMintMultipleErc721WithHttpInfo(mintMultipleNftMinter, xTestnetType);

            var exception = ExceptionFactory?.Invoke("NftMintMultipleErc721", localVarResponse);
            if (exception != null) throw exception;

            return localVarResponse.Data;
        }

        /// <summary>
        /// Mint multiple NFTs 100 credits per API call on Flow 2 credits per API call on the other blockchains Create multiple NFT Tokens and transfer them to destination account. Create and transfer any NFT tokens from smart contract defined in contractAddress. This API is supported for the following blockchains: BNB Smart Chain Celo Ethereum Flow Harmony Klaytn KuCoin Community Chain Polygon TRON This operation works in two modes. First mode works just like other NFT endpoints. Every time the funds are transferred, the transaction must be signed with the corresponding private key. No one should ever send it&#39;s own private keys to the internet because there is a strong possibility of stealing keys and loss of funds. In this method, it is possible to enter privateKey or signatureId. PrivateKey should be used only for quick development on testnet versions of blockchain when there is no risk of losing funds. In production, Tatum KMS should be used for the highest security standards, and signatureId should be present in the request. Alternatively, using the Tatum client library for supported languages. Second mode enables you to mint on any custom NFT ERC-721 smart contract, on which specified minter address is approved as a minter. You don&#39;t specify private key or signatureId, only minter address, from which the NFT will be minted. It means you perform mint multiple NFT request with following body: {    \&quot;to\&quot;: [\&quot;0x80d8bac9a6901698b3749fe336bbd1385c1f98f2\&quot;],    \&quot;url\&quot;: [\&quot;ipfs://QmXJJ6UF5WkF4WTJvsdhiA1etGwBLfpva7Vr9AudGMe3pj\&quot;],    \&quot;tokenId\&quot;: [\&quot;9876541124516\&quot;],    \&quot;contractAddress\&quot;:\&quot;0xcd2ada00c48a27faa5cc67f9a1ed55b89ddf7f77\&quot;,    \&quot;minter\&quot;: \&quot;0x542b9ac4945a3836fd12ad98acbc76a0c8b743f5\&quot;,    \&quot;chain\&quot;: \&quot;MATIC\&quot; } The blockchain fee of the performed transaction is paid from the address connected with built-in private key and is debited in form of credits. The credits are debited only if NFT mint requests are performed with paid API key plan. We transform fee to the credits in accordance to the rates provided by the Tatum. If you want to batch mint on ERC-721 contract which is not deployed via Tatum API, your smart contract must contain this method: mintMultiple(address[] to, uint256[] tokenId, string[] uri): boolean You can use addresses specified in the bellow table to be used as a minter. Chain Testnet address Mainnet Address MATIC 0x542b9ac4945a3836fd12ad98acbc76a0c8b743f5 0xcf9e127455d28e7362380aec1b92ddee8200b295 BSC 0xc16ae5e8c985b906935a0cadf4e24f0400531883 0xcf9e127455d28e7362380aec1b92ddee8200b295 ONE 0x8906f62d40293ddca77fdf6714c3f63265deddf0 0xcf9e127455d28e7362380aec1b92ddee8200b295 ETH 0x53e8577C4347C365E4e0DA5B57A589cB6f2AB848 0xcf9e127455d28e7362380aec1b92ddee8200b295 CELO 0xBC2eBA680EE50d685cc4Fe65f102AA70AfB27D3F 0xcf9e127455d28e7362380aec1b92ddee8200b295 KLAY 0x80d8bac9a6901698b3749fe336bbd1385c1f98f2 0xcf9e127455d28e7362380aec1b92ddee8200b295 If there are not enough coins on any testnet address, feel free to send coins there.
        /// </summary>
        /// <exception cref="Tatum.CSharp.Bsc.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="mintMultipleNftMinter"></param>
        /// <param name="xTestnetType">Type of Ethereum testnet. Defaults to Sepolia. Valid only for ETH invocations for testnet API Key. For mainnet API Key, this value is ignored. (optional, default to ethereum-sepolia)</param>
        /// <returns>ApiResponse of TransactionHash</returns>
        public ApiResponse<TransactionHash> NftMintMultipleErc721WithHttpInfo(MintMultipleNftMinter mintMultipleNftMinter, string xTestnetType = default(string))
        {
            // verify the required parameter 'mintMultipleNftMinter' is set
            if (mintMultipleNftMinter == null)
                throw new ApiException(400, "Missing required parameter 'mintMultipleNftMinter' when calling NFTBscApi->NftMintMultipleErc721");

            var localVarRequestOptions = new RequestOptions();

            var contentTypes = new string[]{
                "application/json"
            };

            // to determine the Accept header
            var accepts = new string[]{
                "application/json"
            };

            var localVarContentType = ClientUtils.SelectHeaderContentType(contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = ClientUtils.SelectHeaderAccept(accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            if (xTestnetType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("x-testnet-type", ClientUtils.ParameterToString(xTestnetType)); // header parameter
            }
            localVarRequestOptions.Data = mintMultipleNftMinter;

            // authentication (X-API-Key) required
            if (!string.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("x-api-key")))
            {
                localVarRequestOptions.HeaderParameters.Add("x-api-key", Configuration.GetApiKeyWithPrefix("x-api-key"));
            }

            // make the HTTP request
            var localVarResponse = Client.Post<TransactionHash>("/v3/nft/mint/batch", localVarRequestOptions, Configuration);

            return localVarResponse;
        }

        /// <summary>
        /// Mint multiple NFTs 100 credits per API call on Flow 2 credits per API call on the other blockchains Create multiple NFT Tokens and transfer them to destination account. Create and transfer any NFT tokens from smart contract defined in contractAddress. This API is supported for the following blockchains: BNB Smart Chain Celo Ethereum Flow Harmony Klaytn KuCoin Community Chain Polygon TRON This operation works in two modes. First mode works just like other NFT endpoints. Every time the funds are transferred, the transaction must be signed with the corresponding private key. No one should ever send it&#39;s own private keys to the internet because there is a strong possibility of stealing keys and loss of funds. In this method, it is possible to enter privateKey or signatureId. PrivateKey should be used only for quick development on testnet versions of blockchain when there is no risk of losing funds. In production, Tatum KMS should be used for the highest security standards, and signatureId should be present in the request. Alternatively, using the Tatum client library for supported languages. Second mode enables you to mint on any custom NFT ERC-721 smart contract, on which specified minter address is approved as a minter. You don&#39;t specify private key or signatureId, only minter address, from which the NFT will be minted. It means you perform mint multiple NFT request with following body: {    \&quot;to\&quot;: [\&quot;0x80d8bac9a6901698b3749fe336bbd1385c1f98f2\&quot;],    \&quot;url\&quot;: [\&quot;ipfs://QmXJJ6UF5WkF4WTJvsdhiA1etGwBLfpva7Vr9AudGMe3pj\&quot;],    \&quot;tokenId\&quot;: [\&quot;9876541124516\&quot;],    \&quot;contractAddress\&quot;:\&quot;0xcd2ada00c48a27faa5cc67f9a1ed55b89ddf7f77\&quot;,    \&quot;minter\&quot;: \&quot;0x542b9ac4945a3836fd12ad98acbc76a0c8b743f5\&quot;,    \&quot;chain\&quot;: \&quot;MATIC\&quot; } The blockchain fee of the performed transaction is paid from the address connected with built-in private key and is debited in form of credits. The credits are debited only if NFT mint requests are performed with paid API key plan. We transform fee to the credits in accordance to the rates provided by the Tatum. If you want to batch mint on ERC-721 contract which is not deployed via Tatum API, your smart contract must contain this method: mintMultiple(address[] to, uint256[] tokenId, string[] uri): boolean You can use addresses specified in the bellow table to be used as a minter. Chain Testnet address Mainnet Address MATIC 0x542b9ac4945a3836fd12ad98acbc76a0c8b743f5 0xcf9e127455d28e7362380aec1b92ddee8200b295 BSC 0xc16ae5e8c985b906935a0cadf4e24f0400531883 0xcf9e127455d28e7362380aec1b92ddee8200b295 ONE 0x8906f62d40293ddca77fdf6714c3f63265deddf0 0xcf9e127455d28e7362380aec1b92ddee8200b295 ETH 0x53e8577C4347C365E4e0DA5B57A589cB6f2AB848 0xcf9e127455d28e7362380aec1b92ddee8200b295 CELO 0xBC2eBA680EE50d685cc4Fe65f102AA70AfB27D3F 0xcf9e127455d28e7362380aec1b92ddee8200b295 KLAY 0x80d8bac9a6901698b3749fe336bbd1385c1f98f2 0xcf9e127455d28e7362380aec1b92ddee8200b295 If there are not enough coins on any testnet address, feel free to send coins there.
        /// </summary>
        /// <exception cref="Tatum.CSharp.Bsc.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="mintMultipleNftMinter"></param>
        /// <param name="xTestnetType">Type of Ethereum testnet. Defaults to Sepolia. Valid only for ETH invocations for testnet API Key. For mainnet API Key, this value is ignored. (optional, default to ethereum-sepolia)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of TransactionHash</returns>
        public async System.Threading.Tasks.Task<TransactionHash> NftMintMultipleErc721Async(MintMultipleNftMinter mintMultipleNftMinter, string xTestnetType = default(string), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            var localVarResponse = await NftMintMultipleErc721WithHttpInfoAsync(mintMultipleNftMinter, xTestnetType, cancellationToken).ConfigureAwait(false);
            
            var exception = ExceptionFactory?.Invoke("NftMintMultipleErc721", localVarResponse);
            if (exception != null) throw exception;

            return localVarResponse.Data;
        }

        /// <summary>
        /// Mint multiple NFTs 100 credits per API call on Flow 2 credits per API call on the other blockchains Create multiple NFT Tokens and transfer them to destination account. Create and transfer any NFT tokens from smart contract defined in contractAddress. This API is supported for the following blockchains: BNB Smart Chain Celo Ethereum Flow Harmony Klaytn KuCoin Community Chain Polygon TRON This operation works in two modes. First mode works just like other NFT endpoints. Every time the funds are transferred, the transaction must be signed with the corresponding private key. No one should ever send it&#39;s own private keys to the internet because there is a strong possibility of stealing keys and loss of funds. In this method, it is possible to enter privateKey or signatureId. PrivateKey should be used only for quick development on testnet versions of blockchain when there is no risk of losing funds. In production, Tatum KMS should be used for the highest security standards, and signatureId should be present in the request. Alternatively, using the Tatum client library for supported languages. Second mode enables you to mint on any custom NFT ERC-721 smart contract, on which specified minter address is approved as a minter. You don&#39;t specify private key or signatureId, only minter address, from which the NFT will be minted. It means you perform mint multiple NFT request with following body: {    \&quot;to\&quot;: [\&quot;0x80d8bac9a6901698b3749fe336bbd1385c1f98f2\&quot;],    \&quot;url\&quot;: [\&quot;ipfs://QmXJJ6UF5WkF4WTJvsdhiA1etGwBLfpva7Vr9AudGMe3pj\&quot;],    \&quot;tokenId\&quot;: [\&quot;9876541124516\&quot;],    \&quot;contractAddress\&quot;:\&quot;0xcd2ada00c48a27faa5cc67f9a1ed55b89ddf7f77\&quot;,    \&quot;minter\&quot;: \&quot;0x542b9ac4945a3836fd12ad98acbc76a0c8b743f5\&quot;,    \&quot;chain\&quot;: \&quot;MATIC\&quot; } The blockchain fee of the performed transaction is paid from the address connected with built-in private key and is debited in form of credits. The credits are debited only if NFT mint requests are performed with paid API key plan. We transform fee to the credits in accordance to the rates provided by the Tatum. If you want to batch mint on ERC-721 contract which is not deployed via Tatum API, your smart contract must contain this method: mintMultiple(address[] to, uint256[] tokenId, string[] uri): boolean You can use addresses specified in the bellow table to be used as a minter. Chain Testnet address Mainnet Address MATIC 0x542b9ac4945a3836fd12ad98acbc76a0c8b743f5 0xcf9e127455d28e7362380aec1b92ddee8200b295 BSC 0xc16ae5e8c985b906935a0cadf4e24f0400531883 0xcf9e127455d28e7362380aec1b92ddee8200b295 ONE 0x8906f62d40293ddca77fdf6714c3f63265deddf0 0xcf9e127455d28e7362380aec1b92ddee8200b295 ETH 0x53e8577C4347C365E4e0DA5B57A589cB6f2AB848 0xcf9e127455d28e7362380aec1b92ddee8200b295 CELO 0xBC2eBA680EE50d685cc4Fe65f102AA70AfB27D3F 0xcf9e127455d28e7362380aec1b92ddee8200b295 KLAY 0x80d8bac9a6901698b3749fe336bbd1385c1f98f2 0xcf9e127455d28e7362380aec1b92ddee8200b295 If there are not enough coins on any testnet address, feel free to send coins there.
        /// </summary>
        /// <exception cref="Tatum.CSharp.Bsc.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="mintMultipleNftMinter"></param>
        /// <param name="xTestnetType">Type of Ethereum testnet. Defaults to Sepolia. Valid only for ETH invocations for testnet API Key. For mainnet API Key, this value is ignored. (optional, default to ethereum-sepolia)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (TransactionHash)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<TransactionHash>> NftMintMultipleErc721WithHttpInfoAsync(MintMultipleNftMinter mintMultipleNftMinter, string xTestnetType = default(string), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            // verify the required parameter 'mintMultipleNftMinter' is set
            if (mintMultipleNftMinter == null)
                throw new ApiException(400, "Missing required parameter 'mintMultipleNftMinter' when calling NFTBscApi->NftMintMultipleErc721");

            var localVarRequestOptions = new RequestOptions();

            var contentTypes = new string[]{
                "application/json"
            };

            // to determine the Accept header
            var accepts = new string[]{
                "application/json"
            };


            var localVarContentType = ClientUtils.SelectHeaderContentType(contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = ClientUtils.SelectHeaderAccept(accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            if (xTestnetType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("x-testnet-type", ClientUtils.ParameterToString(xTestnetType)); // header parameter
            }
            localVarRequestOptions.Data = mintMultipleNftMinter;

            // authentication (X-API-Key) required
            if (!string.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("x-api-key")))
            {
                localVarRequestOptions.HeaderParameters.Add("x-api-key", Configuration.GetApiKeyWithPrefix("x-api-key"));
            }

            // make the HTTP request

            var localVarResponse = await AsynchronousClient.PostAsync<TransactionHash>("/v3/nft/mint/batch", localVarRequestOptions, Configuration, cancellationToken).ConfigureAwait(false);

            return localVarResponse;
        }

        /// <summary>
        /// Mint multiple NFTs 100 credits per API call on Flow 2 credits per API call on the other blockchains Create multiple NFT Tokens and transfer them to destination account. Create and transfer any NFT tokens from smart contract defined in contractAddress. This API is supported for the following blockchains: BNB Smart Chain Celo Ethereum Flow Harmony Klaytn KuCoin Community Chain Polygon TRON This operation works in two modes. First mode works just like other NFT endpoints. Every time the funds are transferred, the transaction must be signed with the corresponding private key. No one should ever send it&#39;s own private keys to the internet because there is a strong possibility of stealing keys and loss of funds. In this method, it is possible to enter privateKey or signatureId. PrivateKey should be used only for quick development on testnet versions of blockchain when there is no risk of losing funds. In production, Tatum KMS should be used for the highest security standards, and signatureId should be present in the request. Alternatively, using the Tatum client library for supported languages. Second mode enables you to mint on any custom NFT ERC-721 smart contract, on which specified minter address is approved as a minter. You don&#39;t specify private key or signatureId, only minter address, from which the NFT will be minted. It means you perform mint multiple NFT request with following body: {    \&quot;to\&quot;: [\&quot;0x80d8bac9a6901698b3749fe336bbd1385c1f98f2\&quot;],    \&quot;url\&quot;: [\&quot;ipfs://QmXJJ6UF5WkF4WTJvsdhiA1etGwBLfpva7Vr9AudGMe3pj\&quot;],    \&quot;tokenId\&quot;: [\&quot;9876541124516\&quot;],    \&quot;contractAddress\&quot;:\&quot;0xcd2ada00c48a27faa5cc67f9a1ed55b89ddf7f77\&quot;,    \&quot;minter\&quot;: \&quot;0x542b9ac4945a3836fd12ad98acbc76a0c8b743f5\&quot;,    \&quot;chain\&quot;: \&quot;MATIC\&quot; } The blockchain fee of the performed transaction is paid from the address connected with built-in private key and is debited in form of credits. The credits are debited only if NFT mint requests are performed with paid API key plan. We transform fee to the credits in accordance to the rates provided by the Tatum. If you want to batch mint on ERC-721 contract which is not deployed via Tatum API, your smart contract must contain this method: mintMultiple(address[] to, uint256[] tokenId, string[] uri): boolean You can use addresses specified in the bellow table to be used as a minter. Chain Testnet address Mainnet Address MATIC 0x542b9ac4945a3836fd12ad98acbc76a0c8b743f5 0xcf9e127455d28e7362380aec1b92ddee8200b295 BSC 0xc16ae5e8c985b906935a0cadf4e24f0400531883 0xcf9e127455d28e7362380aec1b92ddee8200b295 ONE 0x8906f62d40293ddca77fdf6714c3f63265deddf0 0xcf9e127455d28e7362380aec1b92ddee8200b295 ETH 0x53e8577C4347C365E4e0DA5B57A589cB6f2AB848 0xcf9e127455d28e7362380aec1b92ddee8200b295 CELO 0xBC2eBA680EE50d685cc4Fe65f102AA70AfB27D3F 0xcf9e127455d28e7362380aec1b92ddee8200b295 KLAY 0x80d8bac9a6901698b3749fe336bbd1385c1f98f2 0xcf9e127455d28e7362380aec1b92ddee8200b295 If there are not enough coins on any testnet address, feel free to send coins there.
        /// </summary>
        /// <exception cref="Tatum.CSharp.Bsc.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="mintMultipleNft"></param>
        /// <param name="xTestnetType">Type of Ethereum testnet. Defaults to Sepolia. Valid only for ETH invocations for testnet API Key. For mainnet API Key, this value is ignored. (optional, default to ethereum-sepolia)</param>
        /// <returns>TransactionHash</returns>
        public TransactionHash NftMintMultipleErc721(MintMultipleNft mintMultipleNft, string xTestnetType = default(string))
        {
            var localVarResponse = NftMintMultipleErc721WithHttpInfo(mintMultipleNft, xTestnetType);

            var exception = ExceptionFactory?.Invoke("NftMintMultipleErc721_0", localVarResponse);
            if (exception != null) throw exception;

            return localVarResponse.Data;
        }

        /// <summary>
        /// Mint multiple NFTs 100 credits per API call on Flow 2 credits per API call on the other blockchains Create multiple NFT Tokens and transfer them to destination account. Create and transfer any NFT tokens from smart contract defined in contractAddress. This API is supported for the following blockchains: BNB Smart Chain Celo Ethereum Flow Harmony Klaytn KuCoin Community Chain Polygon TRON This operation works in two modes. First mode works just like other NFT endpoints. Every time the funds are transferred, the transaction must be signed with the corresponding private key. No one should ever send it&#39;s own private keys to the internet because there is a strong possibility of stealing keys and loss of funds. In this method, it is possible to enter privateKey or signatureId. PrivateKey should be used only for quick development on testnet versions of blockchain when there is no risk of losing funds. In production, Tatum KMS should be used for the highest security standards, and signatureId should be present in the request. Alternatively, using the Tatum client library for supported languages. Second mode enables you to mint on any custom NFT ERC-721 smart contract, on which specified minter address is approved as a minter. You don&#39;t specify private key or signatureId, only minter address, from which the NFT will be minted. It means you perform mint multiple NFT request with following body: {    \&quot;to\&quot;: [\&quot;0x80d8bac9a6901698b3749fe336bbd1385c1f98f2\&quot;],    \&quot;url\&quot;: [\&quot;ipfs://QmXJJ6UF5WkF4WTJvsdhiA1etGwBLfpva7Vr9AudGMe3pj\&quot;],    \&quot;tokenId\&quot;: [\&quot;9876541124516\&quot;],    \&quot;contractAddress\&quot;:\&quot;0xcd2ada00c48a27faa5cc67f9a1ed55b89ddf7f77\&quot;,    \&quot;minter\&quot;: \&quot;0x542b9ac4945a3836fd12ad98acbc76a0c8b743f5\&quot;,    \&quot;chain\&quot;: \&quot;MATIC\&quot; } The blockchain fee of the performed transaction is paid from the address connected with built-in private key and is debited in form of credits. The credits are debited only if NFT mint requests are performed with paid API key plan. We transform fee to the credits in accordance to the rates provided by the Tatum. If you want to batch mint on ERC-721 contract which is not deployed via Tatum API, your smart contract must contain this method: mintMultiple(address[] to, uint256[] tokenId, string[] uri): boolean You can use addresses specified in the bellow table to be used as a minter. Chain Testnet address Mainnet Address MATIC 0x542b9ac4945a3836fd12ad98acbc76a0c8b743f5 0xcf9e127455d28e7362380aec1b92ddee8200b295 BSC 0xc16ae5e8c985b906935a0cadf4e24f0400531883 0xcf9e127455d28e7362380aec1b92ddee8200b295 ONE 0x8906f62d40293ddca77fdf6714c3f63265deddf0 0xcf9e127455d28e7362380aec1b92ddee8200b295 ETH 0x53e8577C4347C365E4e0DA5B57A589cB6f2AB848 0xcf9e127455d28e7362380aec1b92ddee8200b295 CELO 0xBC2eBA680EE50d685cc4Fe65f102AA70AfB27D3F 0xcf9e127455d28e7362380aec1b92ddee8200b295 KLAY 0x80d8bac9a6901698b3749fe336bbd1385c1f98f2 0xcf9e127455d28e7362380aec1b92ddee8200b295 If there are not enough coins on any testnet address, feel free to send coins there.
        /// </summary>
        /// <exception cref="Tatum.CSharp.Bsc.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="mintMultipleNft"></param>
        /// <param name="xTestnetType">Type of Ethereum testnet. Defaults to Sepolia. Valid only for ETH invocations for testnet API Key. For mainnet API Key, this value is ignored. (optional, default to ethereum-sepolia)</param>
        /// <returns>ApiResponse of TransactionHash</returns>
        public ApiResponse<TransactionHash> NftMintMultipleErc721WithHttpInfo(MintMultipleNft mintMultipleNft, string xTestnetType = default(string))
        {
            // verify the required parameter 'mintMultipleNft' is set
            if (mintMultipleNft == null)
                throw new ApiException(400, "Missing required parameter 'mintMultipleNft' when calling NFTBscApi->NftMintMultipleErc721_0");

            var localVarRequestOptions = new RequestOptions();

            var contentTypes = new string[]{
                "application/json"
            };

            // to determine the Accept header
            var accepts = new string[]{
                "application/json"
            };

            var localVarContentType = ClientUtils.SelectHeaderContentType(contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = ClientUtils.SelectHeaderAccept(accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            if (xTestnetType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("x-testnet-type", ClientUtils.ParameterToString(xTestnetType)); // header parameter
            }
            localVarRequestOptions.Data = mintMultipleNft;

            // authentication (X-API-Key) required
            if (!string.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("x-api-key")))
            {
                localVarRequestOptions.HeaderParameters.Add("x-api-key", Configuration.GetApiKeyWithPrefix("x-api-key"));
            }

            // make the HTTP request
            var localVarResponse = Client.Post<TransactionHash>("/v3/nft/mint/batch", localVarRequestOptions, Configuration);

            return localVarResponse;
        }

        /// <summary>
        /// Mint multiple NFTs 100 credits per API call on Flow 2 credits per API call on the other blockchains Create multiple NFT Tokens and transfer them to destination account. Create and transfer any NFT tokens from smart contract defined in contractAddress. This API is supported for the following blockchains: BNB Smart Chain Celo Ethereum Flow Harmony Klaytn KuCoin Community Chain Polygon TRON This operation works in two modes. First mode works just like other NFT endpoints. Every time the funds are transferred, the transaction must be signed with the corresponding private key. No one should ever send it&#39;s own private keys to the internet because there is a strong possibility of stealing keys and loss of funds. In this method, it is possible to enter privateKey or signatureId. PrivateKey should be used only for quick development on testnet versions of blockchain when there is no risk of losing funds. In production, Tatum KMS should be used for the highest security standards, and signatureId should be present in the request. Alternatively, using the Tatum client library for supported languages. Second mode enables you to mint on any custom NFT ERC-721 smart contract, on which specified minter address is approved as a minter. You don&#39;t specify private key or signatureId, only minter address, from which the NFT will be minted. It means you perform mint multiple NFT request with following body: {    \&quot;to\&quot;: [\&quot;0x80d8bac9a6901698b3749fe336bbd1385c1f98f2\&quot;],    \&quot;url\&quot;: [\&quot;ipfs://QmXJJ6UF5WkF4WTJvsdhiA1etGwBLfpva7Vr9AudGMe3pj\&quot;],    \&quot;tokenId\&quot;: [\&quot;9876541124516\&quot;],    \&quot;contractAddress\&quot;:\&quot;0xcd2ada00c48a27faa5cc67f9a1ed55b89ddf7f77\&quot;,    \&quot;minter\&quot;: \&quot;0x542b9ac4945a3836fd12ad98acbc76a0c8b743f5\&quot;,    \&quot;chain\&quot;: \&quot;MATIC\&quot; } The blockchain fee of the performed transaction is paid from the address connected with built-in private key and is debited in form of credits. The credits are debited only if NFT mint requests are performed with paid API key plan. We transform fee to the credits in accordance to the rates provided by the Tatum. If you want to batch mint on ERC-721 contract which is not deployed via Tatum API, your smart contract must contain this method: mintMultiple(address[] to, uint256[] tokenId, string[] uri): boolean You can use addresses specified in the bellow table to be used as a minter. Chain Testnet address Mainnet Address MATIC 0x542b9ac4945a3836fd12ad98acbc76a0c8b743f5 0xcf9e127455d28e7362380aec1b92ddee8200b295 BSC 0xc16ae5e8c985b906935a0cadf4e24f0400531883 0xcf9e127455d28e7362380aec1b92ddee8200b295 ONE 0x8906f62d40293ddca77fdf6714c3f63265deddf0 0xcf9e127455d28e7362380aec1b92ddee8200b295 ETH 0x53e8577C4347C365E4e0DA5B57A589cB6f2AB848 0xcf9e127455d28e7362380aec1b92ddee8200b295 CELO 0xBC2eBA680EE50d685cc4Fe65f102AA70AfB27D3F 0xcf9e127455d28e7362380aec1b92ddee8200b295 KLAY 0x80d8bac9a6901698b3749fe336bbd1385c1f98f2 0xcf9e127455d28e7362380aec1b92ddee8200b295 If there are not enough coins on any testnet address, feel free to send coins there.
        /// </summary>
        /// <exception cref="Tatum.CSharp.Bsc.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="mintMultipleNft"></param>
        /// <param name="xTestnetType">Type of Ethereum testnet. Defaults to Sepolia. Valid only for ETH invocations for testnet API Key. For mainnet API Key, this value is ignored. (optional, default to ethereum-sepolia)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of TransactionHash</returns>
        public async System.Threading.Tasks.Task<TransactionHash> NftMintMultipleErc721Async(MintMultipleNft mintMultipleNft, string xTestnetType = default(string), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            var localVarResponse = await NftMintMultipleErc721WithHttpInfoAsync(mintMultipleNft, xTestnetType, cancellationToken).ConfigureAwait(false);
            
            var exception = ExceptionFactory?.Invoke("NftMintMultipleErc721_0", localVarResponse);
            if (exception != null) throw exception;

            return localVarResponse.Data;
        }

        /// <summary>
        /// Mint multiple NFTs 100 credits per API call on Flow 2 credits per API call on the other blockchains Create multiple NFT Tokens and transfer them to destination account. Create and transfer any NFT tokens from smart contract defined in contractAddress. This API is supported for the following blockchains: BNB Smart Chain Celo Ethereum Flow Harmony Klaytn KuCoin Community Chain Polygon TRON This operation works in two modes. First mode works just like other NFT endpoints. Every time the funds are transferred, the transaction must be signed with the corresponding private key. No one should ever send it&#39;s own private keys to the internet because there is a strong possibility of stealing keys and loss of funds. In this method, it is possible to enter privateKey or signatureId. PrivateKey should be used only for quick development on testnet versions of blockchain when there is no risk of losing funds. In production, Tatum KMS should be used for the highest security standards, and signatureId should be present in the request. Alternatively, using the Tatum client library for supported languages. Second mode enables you to mint on any custom NFT ERC-721 smart contract, on which specified minter address is approved as a minter. You don&#39;t specify private key or signatureId, only minter address, from which the NFT will be minted. It means you perform mint multiple NFT request with following body: {    \&quot;to\&quot;: [\&quot;0x80d8bac9a6901698b3749fe336bbd1385c1f98f2\&quot;],    \&quot;url\&quot;: [\&quot;ipfs://QmXJJ6UF5WkF4WTJvsdhiA1etGwBLfpva7Vr9AudGMe3pj\&quot;],    \&quot;tokenId\&quot;: [\&quot;9876541124516\&quot;],    \&quot;contractAddress\&quot;:\&quot;0xcd2ada00c48a27faa5cc67f9a1ed55b89ddf7f77\&quot;,    \&quot;minter\&quot;: \&quot;0x542b9ac4945a3836fd12ad98acbc76a0c8b743f5\&quot;,    \&quot;chain\&quot;: \&quot;MATIC\&quot; } The blockchain fee of the performed transaction is paid from the address connected with built-in private key and is debited in form of credits. The credits are debited only if NFT mint requests are performed with paid API key plan. We transform fee to the credits in accordance to the rates provided by the Tatum. If you want to batch mint on ERC-721 contract which is not deployed via Tatum API, your smart contract must contain this method: mintMultiple(address[] to, uint256[] tokenId, string[] uri): boolean You can use addresses specified in the bellow table to be used as a minter. Chain Testnet address Mainnet Address MATIC 0x542b9ac4945a3836fd12ad98acbc76a0c8b743f5 0xcf9e127455d28e7362380aec1b92ddee8200b295 BSC 0xc16ae5e8c985b906935a0cadf4e24f0400531883 0xcf9e127455d28e7362380aec1b92ddee8200b295 ONE 0x8906f62d40293ddca77fdf6714c3f63265deddf0 0xcf9e127455d28e7362380aec1b92ddee8200b295 ETH 0x53e8577C4347C365E4e0DA5B57A589cB6f2AB848 0xcf9e127455d28e7362380aec1b92ddee8200b295 CELO 0xBC2eBA680EE50d685cc4Fe65f102AA70AfB27D3F 0xcf9e127455d28e7362380aec1b92ddee8200b295 KLAY 0x80d8bac9a6901698b3749fe336bbd1385c1f98f2 0xcf9e127455d28e7362380aec1b92ddee8200b295 If there are not enough coins on any testnet address, feel free to send coins there.
        /// </summary>
        /// <exception cref="Tatum.CSharp.Bsc.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="mintMultipleNft"></param>
        /// <param name="xTestnetType">Type of Ethereum testnet. Defaults to Sepolia. Valid only for ETH invocations for testnet API Key. For mainnet API Key, this value is ignored. (optional, default to ethereum-sepolia)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (TransactionHash)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<TransactionHash>> NftMintMultipleErc721WithHttpInfoAsync(MintMultipleNft mintMultipleNft, string xTestnetType = default(string), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            // verify the required parameter 'mintMultipleNft' is set
            if (mintMultipleNft == null)
                throw new ApiException(400, "Missing required parameter 'mintMultipleNft' when calling NFTBscApi->NftMintMultipleErc721_0");

            var localVarRequestOptions = new RequestOptions();

            var contentTypes = new string[]{
                "application/json"
            };

            // to determine the Accept header
            var accepts = new string[]{
                "application/json"
            };


            var localVarContentType = ClientUtils.SelectHeaderContentType(contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = ClientUtils.SelectHeaderAccept(accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            if (xTestnetType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("x-testnet-type", ClientUtils.ParameterToString(xTestnetType)); // header parameter
            }
            localVarRequestOptions.Data = mintMultipleNft;

            // authentication (X-API-Key) required
            if (!string.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("x-api-key")))
            {
                localVarRequestOptions.HeaderParameters.Add("x-api-key", Configuration.GetApiKeyWithPrefix("x-api-key"));
            }

            // make the HTTP request

            var localVarResponse = await AsynchronousClient.PostAsync<TransactionHash>("/v3/nft/mint/batch", localVarRequestOptions, Configuration, cancellationToken).ConfigureAwait(false);

            return localVarResponse;
        }

        /// <summary>
        /// Mint multiple NFTs 100 credits per API call on Flow 2 credits per API call on the other blockchains Create multiple NFT Tokens and transfer them to destination account. Create and transfer any NFT tokens from smart contract defined in contractAddress. This API is supported for the following blockchains: BNB Smart Chain Celo Ethereum Flow Harmony Klaytn KuCoin Community Chain Polygon TRON This operation works in two modes. First mode works just like other NFT endpoints. Every time the funds are transferred, the transaction must be signed with the corresponding private key. No one should ever send it&#39;s own private keys to the internet because there is a strong possibility of stealing keys and loss of funds. In this method, it is possible to enter privateKey or signatureId. PrivateKey should be used only for quick development on testnet versions of blockchain when there is no risk of losing funds. In production, Tatum KMS should be used for the highest security standards, and signatureId should be present in the request. Alternatively, using the Tatum client library for supported languages. Second mode enables you to mint on any custom NFT ERC-721 smart contract, on which specified minter address is approved as a minter. You don&#39;t specify private key or signatureId, only minter address, from which the NFT will be minted. It means you perform mint multiple NFT request with following body: {    \&quot;to\&quot;: [\&quot;0x80d8bac9a6901698b3749fe336bbd1385c1f98f2\&quot;],    \&quot;url\&quot;: [\&quot;ipfs://QmXJJ6UF5WkF4WTJvsdhiA1etGwBLfpva7Vr9AudGMe3pj\&quot;],    \&quot;tokenId\&quot;: [\&quot;9876541124516\&quot;],    \&quot;contractAddress\&quot;:\&quot;0xcd2ada00c48a27faa5cc67f9a1ed55b89ddf7f77\&quot;,    \&quot;minter\&quot;: \&quot;0x542b9ac4945a3836fd12ad98acbc76a0c8b743f5\&quot;,    \&quot;chain\&quot;: \&quot;MATIC\&quot; } The blockchain fee of the performed transaction is paid from the address connected with built-in private key and is debited in form of credits. The credits are debited only if NFT mint requests are performed with paid API key plan. We transform fee to the credits in accordance to the rates provided by the Tatum. If you want to batch mint on ERC-721 contract which is not deployed via Tatum API, your smart contract must contain this method: mintMultiple(address[] to, uint256[] tokenId, string[] uri): boolean You can use addresses specified in the bellow table to be used as a minter. Chain Testnet address Mainnet Address MATIC 0x542b9ac4945a3836fd12ad98acbc76a0c8b743f5 0xcf9e127455d28e7362380aec1b92ddee8200b295 BSC 0xc16ae5e8c985b906935a0cadf4e24f0400531883 0xcf9e127455d28e7362380aec1b92ddee8200b295 ONE 0x8906f62d40293ddca77fdf6714c3f63265deddf0 0xcf9e127455d28e7362380aec1b92ddee8200b295 ETH 0x53e8577C4347C365E4e0DA5B57A589cB6f2AB848 0xcf9e127455d28e7362380aec1b92ddee8200b295 CELO 0xBC2eBA680EE50d685cc4Fe65f102AA70AfB27D3F 0xcf9e127455d28e7362380aec1b92ddee8200b295 KLAY 0x80d8bac9a6901698b3749fe336bbd1385c1f98f2 0xcf9e127455d28e7362380aec1b92ddee8200b295 If there are not enough coins on any testnet address, feel free to send coins there.
        /// </summary>
        /// <exception cref="Tatum.CSharp.Bsc.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="mintMultipleNftKMS"></param>
        /// <param name="xTestnetType">Type of Ethereum testnet. Defaults to Sepolia. Valid only for ETH invocations for testnet API Key. For mainnet API Key, this value is ignored. (optional, default to ethereum-sepolia)</param>
        /// <returns>SignatureId</returns>
        public SignatureId NftMintMultipleErc721(MintMultipleNftKMS mintMultipleNftKMS, string xTestnetType = default(string))
        {
            var localVarResponse = NftMintMultipleErc721WithHttpInfo(mintMultipleNftKMS, xTestnetType);

            var exception = ExceptionFactory?.Invoke("NftMintMultipleErc721_1", localVarResponse);
            if (exception != null) throw exception;

            return localVarResponse.Data;
        }

        /// <summary>
        /// Mint multiple NFTs 100 credits per API call on Flow 2 credits per API call on the other blockchains Create multiple NFT Tokens and transfer them to destination account. Create and transfer any NFT tokens from smart contract defined in contractAddress. This API is supported for the following blockchains: BNB Smart Chain Celo Ethereum Flow Harmony Klaytn KuCoin Community Chain Polygon TRON This operation works in two modes. First mode works just like other NFT endpoints. Every time the funds are transferred, the transaction must be signed with the corresponding private key. No one should ever send it&#39;s own private keys to the internet because there is a strong possibility of stealing keys and loss of funds. In this method, it is possible to enter privateKey or signatureId. PrivateKey should be used only for quick development on testnet versions of blockchain when there is no risk of losing funds. In production, Tatum KMS should be used for the highest security standards, and signatureId should be present in the request. Alternatively, using the Tatum client library for supported languages. Second mode enables you to mint on any custom NFT ERC-721 smart contract, on which specified minter address is approved as a minter. You don&#39;t specify private key or signatureId, only minter address, from which the NFT will be minted. It means you perform mint multiple NFT request with following body: {    \&quot;to\&quot;: [\&quot;0x80d8bac9a6901698b3749fe336bbd1385c1f98f2\&quot;],    \&quot;url\&quot;: [\&quot;ipfs://QmXJJ6UF5WkF4WTJvsdhiA1etGwBLfpva7Vr9AudGMe3pj\&quot;],    \&quot;tokenId\&quot;: [\&quot;9876541124516\&quot;],    \&quot;contractAddress\&quot;:\&quot;0xcd2ada00c48a27faa5cc67f9a1ed55b89ddf7f77\&quot;,    \&quot;minter\&quot;: \&quot;0x542b9ac4945a3836fd12ad98acbc76a0c8b743f5\&quot;,    \&quot;chain\&quot;: \&quot;MATIC\&quot; } The blockchain fee of the performed transaction is paid from the address connected with built-in private key and is debited in form of credits. The credits are debited only if NFT mint requests are performed with paid API key plan. We transform fee to the credits in accordance to the rates provided by the Tatum. If you want to batch mint on ERC-721 contract which is not deployed via Tatum API, your smart contract must contain this method: mintMultiple(address[] to, uint256[] tokenId, string[] uri): boolean You can use addresses specified in the bellow table to be used as a minter. Chain Testnet address Mainnet Address MATIC 0x542b9ac4945a3836fd12ad98acbc76a0c8b743f5 0xcf9e127455d28e7362380aec1b92ddee8200b295 BSC 0xc16ae5e8c985b906935a0cadf4e24f0400531883 0xcf9e127455d28e7362380aec1b92ddee8200b295 ONE 0x8906f62d40293ddca77fdf6714c3f63265deddf0 0xcf9e127455d28e7362380aec1b92ddee8200b295 ETH 0x53e8577C4347C365E4e0DA5B57A589cB6f2AB848 0xcf9e127455d28e7362380aec1b92ddee8200b295 CELO 0xBC2eBA680EE50d685cc4Fe65f102AA70AfB27D3F 0xcf9e127455d28e7362380aec1b92ddee8200b295 KLAY 0x80d8bac9a6901698b3749fe336bbd1385c1f98f2 0xcf9e127455d28e7362380aec1b92ddee8200b295 If there are not enough coins on any testnet address, feel free to send coins there.
        /// </summary>
        /// <exception cref="Tatum.CSharp.Bsc.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="mintMultipleNftKMS"></param>
        /// <param name="xTestnetType">Type of Ethereum testnet. Defaults to Sepolia. Valid only for ETH invocations for testnet API Key. For mainnet API Key, this value is ignored. (optional, default to ethereum-sepolia)</param>
        /// <returns>ApiResponse of SignatureId</returns>
        public ApiResponse<SignatureId> NftMintMultipleErc721WithHttpInfo(MintMultipleNftKMS mintMultipleNftKMS, string xTestnetType = default(string))
        {
            // verify the required parameter 'mintMultipleNftKMS' is set
            if (mintMultipleNftKMS == null)
                throw new ApiException(400, "Missing required parameter 'mintMultipleNftKMS' when calling NFTBscApi->NftMintMultipleErc721_1");

            var localVarRequestOptions = new RequestOptions();

            var contentTypes = new string[]{
                "application/json"
            };

            // to determine the Accept header
            var accepts = new string[]{
                "application/json"
            };

            var localVarContentType = ClientUtils.SelectHeaderContentType(contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = ClientUtils.SelectHeaderAccept(accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            if (xTestnetType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("x-testnet-type", ClientUtils.ParameterToString(xTestnetType)); // header parameter
            }
            localVarRequestOptions.Data = mintMultipleNftKMS;

            // authentication (X-API-Key) required
            if (!string.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("x-api-key")))
            {
                localVarRequestOptions.HeaderParameters.Add("x-api-key", Configuration.GetApiKeyWithPrefix("x-api-key"));
            }

            // make the HTTP request
            var localVarResponse = Client.Post<SignatureId>("/v3/nft/mint/batch", localVarRequestOptions, Configuration);

            return localVarResponse;
        }

        /// <summary>
        /// Mint multiple NFTs 100 credits per API call on Flow 2 credits per API call on the other blockchains Create multiple NFT Tokens and transfer them to destination account. Create and transfer any NFT tokens from smart contract defined in contractAddress. This API is supported for the following blockchains: BNB Smart Chain Celo Ethereum Flow Harmony Klaytn KuCoin Community Chain Polygon TRON This operation works in two modes. First mode works just like other NFT endpoints. Every time the funds are transferred, the transaction must be signed with the corresponding private key. No one should ever send it&#39;s own private keys to the internet because there is a strong possibility of stealing keys and loss of funds. In this method, it is possible to enter privateKey or signatureId. PrivateKey should be used only for quick development on testnet versions of blockchain when there is no risk of losing funds. In production, Tatum KMS should be used for the highest security standards, and signatureId should be present in the request. Alternatively, using the Tatum client library for supported languages. Second mode enables you to mint on any custom NFT ERC-721 smart contract, on which specified minter address is approved as a minter. You don&#39;t specify private key or signatureId, only minter address, from which the NFT will be minted. It means you perform mint multiple NFT request with following body: {    \&quot;to\&quot;: [\&quot;0x80d8bac9a6901698b3749fe336bbd1385c1f98f2\&quot;],    \&quot;url\&quot;: [\&quot;ipfs://QmXJJ6UF5WkF4WTJvsdhiA1etGwBLfpva7Vr9AudGMe3pj\&quot;],    \&quot;tokenId\&quot;: [\&quot;9876541124516\&quot;],    \&quot;contractAddress\&quot;:\&quot;0xcd2ada00c48a27faa5cc67f9a1ed55b89ddf7f77\&quot;,    \&quot;minter\&quot;: \&quot;0x542b9ac4945a3836fd12ad98acbc76a0c8b743f5\&quot;,    \&quot;chain\&quot;: \&quot;MATIC\&quot; } The blockchain fee of the performed transaction is paid from the address connected with built-in private key and is debited in form of credits. The credits are debited only if NFT mint requests are performed with paid API key plan. We transform fee to the credits in accordance to the rates provided by the Tatum. If you want to batch mint on ERC-721 contract which is not deployed via Tatum API, your smart contract must contain this method: mintMultiple(address[] to, uint256[] tokenId, string[] uri): boolean You can use addresses specified in the bellow table to be used as a minter. Chain Testnet address Mainnet Address MATIC 0x542b9ac4945a3836fd12ad98acbc76a0c8b743f5 0xcf9e127455d28e7362380aec1b92ddee8200b295 BSC 0xc16ae5e8c985b906935a0cadf4e24f0400531883 0xcf9e127455d28e7362380aec1b92ddee8200b295 ONE 0x8906f62d40293ddca77fdf6714c3f63265deddf0 0xcf9e127455d28e7362380aec1b92ddee8200b295 ETH 0x53e8577C4347C365E4e0DA5B57A589cB6f2AB848 0xcf9e127455d28e7362380aec1b92ddee8200b295 CELO 0xBC2eBA680EE50d685cc4Fe65f102AA70AfB27D3F 0xcf9e127455d28e7362380aec1b92ddee8200b295 KLAY 0x80d8bac9a6901698b3749fe336bbd1385c1f98f2 0xcf9e127455d28e7362380aec1b92ddee8200b295 If there are not enough coins on any testnet address, feel free to send coins there.
        /// </summary>
        /// <exception cref="Tatum.CSharp.Bsc.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="mintMultipleNftKMS"></param>
        /// <param name="xTestnetType">Type of Ethereum testnet. Defaults to Sepolia. Valid only for ETH invocations for testnet API Key. For mainnet API Key, this value is ignored. (optional, default to ethereum-sepolia)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of SignatureId</returns>
        public async System.Threading.Tasks.Task<SignatureId> NftMintMultipleErc721Async(MintMultipleNftKMS mintMultipleNftKMS, string xTestnetType = default(string), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            var localVarResponse = await NftMintMultipleErc721WithHttpInfoAsync(mintMultipleNftKMS, xTestnetType, cancellationToken).ConfigureAwait(false);
            
            var exception = ExceptionFactory?.Invoke("NftMintMultipleErc721_1", localVarResponse);
            if (exception != null) throw exception;

            return localVarResponse.Data;
        }

        /// <summary>
        /// Mint multiple NFTs 100 credits per API call on Flow 2 credits per API call on the other blockchains Create multiple NFT Tokens and transfer them to destination account. Create and transfer any NFT tokens from smart contract defined in contractAddress. This API is supported for the following blockchains: BNB Smart Chain Celo Ethereum Flow Harmony Klaytn KuCoin Community Chain Polygon TRON This operation works in two modes. First mode works just like other NFT endpoints. Every time the funds are transferred, the transaction must be signed with the corresponding private key. No one should ever send it&#39;s own private keys to the internet because there is a strong possibility of stealing keys and loss of funds. In this method, it is possible to enter privateKey or signatureId. PrivateKey should be used only for quick development on testnet versions of blockchain when there is no risk of losing funds. In production, Tatum KMS should be used for the highest security standards, and signatureId should be present in the request. Alternatively, using the Tatum client library for supported languages. Second mode enables you to mint on any custom NFT ERC-721 smart contract, on which specified minter address is approved as a minter. You don&#39;t specify private key or signatureId, only minter address, from which the NFT will be minted. It means you perform mint multiple NFT request with following body: {    \&quot;to\&quot;: [\&quot;0x80d8bac9a6901698b3749fe336bbd1385c1f98f2\&quot;],    \&quot;url\&quot;: [\&quot;ipfs://QmXJJ6UF5WkF4WTJvsdhiA1etGwBLfpva7Vr9AudGMe3pj\&quot;],    \&quot;tokenId\&quot;: [\&quot;9876541124516\&quot;],    \&quot;contractAddress\&quot;:\&quot;0xcd2ada00c48a27faa5cc67f9a1ed55b89ddf7f77\&quot;,    \&quot;minter\&quot;: \&quot;0x542b9ac4945a3836fd12ad98acbc76a0c8b743f5\&quot;,    \&quot;chain\&quot;: \&quot;MATIC\&quot; } The blockchain fee of the performed transaction is paid from the address connected with built-in private key and is debited in form of credits. The credits are debited only if NFT mint requests are performed with paid API key plan. We transform fee to the credits in accordance to the rates provided by the Tatum. If you want to batch mint on ERC-721 contract which is not deployed via Tatum API, your smart contract must contain this method: mintMultiple(address[] to, uint256[] tokenId, string[] uri): boolean You can use addresses specified in the bellow table to be used as a minter. Chain Testnet address Mainnet Address MATIC 0x542b9ac4945a3836fd12ad98acbc76a0c8b743f5 0xcf9e127455d28e7362380aec1b92ddee8200b295 BSC 0xc16ae5e8c985b906935a0cadf4e24f0400531883 0xcf9e127455d28e7362380aec1b92ddee8200b295 ONE 0x8906f62d40293ddca77fdf6714c3f63265deddf0 0xcf9e127455d28e7362380aec1b92ddee8200b295 ETH 0x53e8577C4347C365E4e0DA5B57A589cB6f2AB848 0xcf9e127455d28e7362380aec1b92ddee8200b295 CELO 0xBC2eBA680EE50d685cc4Fe65f102AA70AfB27D3F 0xcf9e127455d28e7362380aec1b92ddee8200b295 KLAY 0x80d8bac9a6901698b3749fe336bbd1385c1f98f2 0xcf9e127455d28e7362380aec1b92ddee8200b295 If there are not enough coins on any testnet address, feel free to send coins there.
        /// </summary>
        /// <exception cref="Tatum.CSharp.Bsc.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="mintMultipleNftKMS"></param>
        /// <param name="xTestnetType">Type of Ethereum testnet. Defaults to Sepolia. Valid only for ETH invocations for testnet API Key. For mainnet API Key, this value is ignored. (optional, default to ethereum-sepolia)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (SignatureId)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<SignatureId>> NftMintMultipleErc721WithHttpInfoAsync(MintMultipleNftKMS mintMultipleNftKMS, string xTestnetType = default(string), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            // verify the required parameter 'mintMultipleNftKMS' is set
            if (mintMultipleNftKMS == null)
                throw new ApiException(400, "Missing required parameter 'mintMultipleNftKMS' when calling NFTBscApi->NftMintMultipleErc721_1");

            var localVarRequestOptions = new RequestOptions();

            var contentTypes = new string[]{
                "application/json"
            };

            // to determine the Accept header
            var accepts = new string[]{
                "application/json"
            };


            var localVarContentType = ClientUtils.SelectHeaderContentType(contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = ClientUtils.SelectHeaderAccept(accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            if (xTestnetType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("x-testnet-type", ClientUtils.ParameterToString(xTestnetType)); // header parameter
            }
            localVarRequestOptions.Data = mintMultipleNftKMS;

            // authentication (X-API-Key) required
            if (!string.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("x-api-key")))
            {
                localVarRequestOptions.HeaderParameters.Add("x-api-key", Configuration.GetApiKeyWithPrefix("x-api-key"));
            }

            // make the HTTP request

            var localVarResponse = await AsynchronousClient.PostAsync<SignatureId>("/v3/nft/mint/batch", localVarRequestOptions, Configuration, cancellationToken).ConfigureAwait(false);

            return localVarResponse;
        }

        /// <summary>
        /// Transfer an NFT 100 credits per API call on Flow 2 credits per API call on the other blockchains Transfer an NFT from the smart contract (the contractAddress parameter in the request body) to the specified blockchain address (the to parameter in the request body). In one API call, you can transfer only one NFT. This API is supported for the following blockchains: Algorand BNB Smart Chain Celo Ethereum Flow Harmony Klaytn KuCoin Community Chain Polygon Solana TRON For Ethereum, Celo, and BNB Smart Chain, transferring NFTs invokes the safeTransfer() method. Transferring NFTs on Algorand On Algorand, the recipient has to agree in advance to receive your NFT because Algorand charges users for storing NFTs on their addresses, and an Algorand blockchain address by default does not receive NFTs unless explicitly agreed. Before transferring an NFT, make sure that the recipient has agreed to receive the NFT to their address. If you want to transfer an NFT that was minted using NFT Express, use the transferNftAlgoExpress schema of the request body. NOTE: On the mainnet, Tatum covers your transaction fees for the NFT transfer and pays for them from its own blockchain address. Then, the fee amount paid by Tatum is converted to the number of credits, and these credits are deducted from the monthly credit allowance of your paid pricing plan. On the testnet, no credits are deducted from the monthly credit allowance. Transferring NFTs on Solana If you want to transfer an NFT that was minted using NFT Express, see the section about minting NFTs on Solana using the pre-built NFT smart contract provided by Tatum for the information about how to set up the parameters in the request body. Signing a transaction When transferring an NFT, you are charged a fee for the transaction, and you must sign the transaction with the private key of the blockchain address from which the fee will be deducted. Providing the private key in the API is not a secure way of signing transactions, because the private key can be stolen or exposed. Your private keys should never leave your security perimeter. You should use the private keys only for testing a solution you are building on the testnet of a blockchain. For signing transactions on the mainnet, we strongly recommend that you use the Tatum Key Management System (KMS) and provide the signature ID instead of the private key in the API. Alternatively, you can use the Tatum JavaScript client. NOTE: This does not apply to transferring NFTs that were minted on Algorand using NFT Express (see earlier in this section).
        /// </summary>
        /// <exception cref="Tatum.CSharp.Bsc.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="transferNft"></param>
        /// <param name="xTestnetType">Type of Ethereum testnet. Defaults to Sepolia. Valid only for ETH invocations for testnet API Key. For mainnet API Key, this value is ignored. (optional, default to ethereum-sepolia)</param>
        /// <returns>TransactionHash</returns>
        public TransactionHash NftTransferErc721(TransferNft transferNft, string xTestnetType = default(string))
        {
            var localVarResponse = NftTransferErc721WithHttpInfo(transferNft, xTestnetType);

            var exception = ExceptionFactory?.Invoke("NftTransferErc721", localVarResponse);
            if (exception != null) throw exception;

            return localVarResponse.Data;
        }

        /// <summary>
        /// Transfer an NFT 100 credits per API call on Flow 2 credits per API call on the other blockchains Transfer an NFT from the smart contract (the contractAddress parameter in the request body) to the specified blockchain address (the to parameter in the request body). In one API call, you can transfer only one NFT. This API is supported for the following blockchains: Algorand BNB Smart Chain Celo Ethereum Flow Harmony Klaytn KuCoin Community Chain Polygon Solana TRON For Ethereum, Celo, and BNB Smart Chain, transferring NFTs invokes the safeTransfer() method. Transferring NFTs on Algorand On Algorand, the recipient has to agree in advance to receive your NFT because Algorand charges users for storing NFTs on their addresses, and an Algorand blockchain address by default does not receive NFTs unless explicitly agreed. Before transferring an NFT, make sure that the recipient has agreed to receive the NFT to their address. If you want to transfer an NFT that was minted using NFT Express, use the transferNftAlgoExpress schema of the request body. NOTE: On the mainnet, Tatum covers your transaction fees for the NFT transfer and pays for them from its own blockchain address. Then, the fee amount paid by Tatum is converted to the number of credits, and these credits are deducted from the monthly credit allowance of your paid pricing plan. On the testnet, no credits are deducted from the monthly credit allowance. Transferring NFTs on Solana If you want to transfer an NFT that was minted using NFT Express, see the section about minting NFTs on Solana using the pre-built NFT smart contract provided by Tatum for the information about how to set up the parameters in the request body. Signing a transaction When transferring an NFT, you are charged a fee for the transaction, and you must sign the transaction with the private key of the blockchain address from which the fee will be deducted. Providing the private key in the API is not a secure way of signing transactions, because the private key can be stolen or exposed. Your private keys should never leave your security perimeter. You should use the private keys only for testing a solution you are building on the testnet of a blockchain. For signing transactions on the mainnet, we strongly recommend that you use the Tatum Key Management System (KMS) and provide the signature ID instead of the private key in the API. Alternatively, you can use the Tatum JavaScript client. NOTE: This does not apply to transferring NFTs that were minted on Algorand using NFT Express (see earlier in this section).
        /// </summary>
        /// <exception cref="Tatum.CSharp.Bsc.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="transferNft"></param>
        /// <param name="xTestnetType">Type of Ethereum testnet. Defaults to Sepolia. Valid only for ETH invocations for testnet API Key. For mainnet API Key, this value is ignored. (optional, default to ethereum-sepolia)</param>
        /// <returns>ApiResponse of TransactionHash</returns>
        public ApiResponse<TransactionHash> NftTransferErc721WithHttpInfo(TransferNft transferNft, string xTestnetType = default(string))
        {
            // verify the required parameter 'transferNft' is set
            if (transferNft == null)
                throw new ApiException(400, "Missing required parameter 'transferNft' when calling NFTBscApi->NftTransferErc721");

            var localVarRequestOptions = new RequestOptions();

            var contentTypes = new string[]{
                "application/json"
            };

            // to determine the Accept header
            var accepts = new string[]{
                "application/json"
            };

            var localVarContentType = ClientUtils.SelectHeaderContentType(contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = ClientUtils.SelectHeaderAccept(accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            if (xTestnetType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("x-testnet-type", ClientUtils.ParameterToString(xTestnetType)); // header parameter
            }
            localVarRequestOptions.Data = transferNft;

            // authentication (X-API-Key) required
            if (!string.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("x-api-key")))
            {
                localVarRequestOptions.HeaderParameters.Add("x-api-key", Configuration.GetApiKeyWithPrefix("x-api-key"));
            }

            // make the HTTP request
            var localVarResponse = Client.Post<TransactionHash>("/v3/nft/transaction", localVarRequestOptions, Configuration);

            return localVarResponse;
        }

        /// <summary>
        /// Transfer an NFT 100 credits per API call on Flow 2 credits per API call on the other blockchains Transfer an NFT from the smart contract (the contractAddress parameter in the request body) to the specified blockchain address (the to parameter in the request body). In one API call, you can transfer only one NFT. This API is supported for the following blockchains: Algorand BNB Smart Chain Celo Ethereum Flow Harmony Klaytn KuCoin Community Chain Polygon Solana TRON For Ethereum, Celo, and BNB Smart Chain, transferring NFTs invokes the safeTransfer() method. Transferring NFTs on Algorand On Algorand, the recipient has to agree in advance to receive your NFT because Algorand charges users for storing NFTs on their addresses, and an Algorand blockchain address by default does not receive NFTs unless explicitly agreed. Before transferring an NFT, make sure that the recipient has agreed to receive the NFT to their address. If you want to transfer an NFT that was minted using NFT Express, use the transferNftAlgoExpress schema of the request body. NOTE: On the mainnet, Tatum covers your transaction fees for the NFT transfer and pays for them from its own blockchain address. Then, the fee amount paid by Tatum is converted to the number of credits, and these credits are deducted from the monthly credit allowance of your paid pricing plan. On the testnet, no credits are deducted from the monthly credit allowance. Transferring NFTs on Solana If you want to transfer an NFT that was minted using NFT Express, see the section about minting NFTs on Solana using the pre-built NFT smart contract provided by Tatum for the information about how to set up the parameters in the request body. Signing a transaction When transferring an NFT, you are charged a fee for the transaction, and you must sign the transaction with the private key of the blockchain address from which the fee will be deducted. Providing the private key in the API is not a secure way of signing transactions, because the private key can be stolen or exposed. Your private keys should never leave your security perimeter. You should use the private keys only for testing a solution you are building on the testnet of a blockchain. For signing transactions on the mainnet, we strongly recommend that you use the Tatum Key Management System (KMS) and provide the signature ID instead of the private key in the API. Alternatively, you can use the Tatum JavaScript client. NOTE: This does not apply to transferring NFTs that were minted on Algorand using NFT Express (see earlier in this section).
        /// </summary>
        /// <exception cref="Tatum.CSharp.Bsc.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="transferNft"></param>
        /// <param name="xTestnetType">Type of Ethereum testnet. Defaults to Sepolia. Valid only for ETH invocations for testnet API Key. For mainnet API Key, this value is ignored. (optional, default to ethereum-sepolia)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of TransactionHash</returns>
        public async System.Threading.Tasks.Task<TransactionHash> NftTransferErc721Async(TransferNft transferNft, string xTestnetType = default(string), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            var localVarResponse = await NftTransferErc721WithHttpInfoAsync(transferNft, xTestnetType, cancellationToken).ConfigureAwait(false);
            
            var exception = ExceptionFactory?.Invoke("NftTransferErc721", localVarResponse);
            if (exception != null) throw exception;

            return localVarResponse.Data;
        }

        /// <summary>
        /// Transfer an NFT 100 credits per API call on Flow 2 credits per API call on the other blockchains Transfer an NFT from the smart contract (the contractAddress parameter in the request body) to the specified blockchain address (the to parameter in the request body). In one API call, you can transfer only one NFT. This API is supported for the following blockchains: Algorand BNB Smart Chain Celo Ethereum Flow Harmony Klaytn KuCoin Community Chain Polygon Solana TRON For Ethereum, Celo, and BNB Smart Chain, transferring NFTs invokes the safeTransfer() method. Transferring NFTs on Algorand On Algorand, the recipient has to agree in advance to receive your NFT because Algorand charges users for storing NFTs on their addresses, and an Algorand blockchain address by default does not receive NFTs unless explicitly agreed. Before transferring an NFT, make sure that the recipient has agreed to receive the NFT to their address. If you want to transfer an NFT that was minted using NFT Express, use the transferNftAlgoExpress schema of the request body. NOTE: On the mainnet, Tatum covers your transaction fees for the NFT transfer and pays for them from its own blockchain address. Then, the fee amount paid by Tatum is converted to the number of credits, and these credits are deducted from the monthly credit allowance of your paid pricing plan. On the testnet, no credits are deducted from the monthly credit allowance. Transferring NFTs on Solana If you want to transfer an NFT that was minted using NFT Express, see the section about minting NFTs on Solana using the pre-built NFT smart contract provided by Tatum for the information about how to set up the parameters in the request body. Signing a transaction When transferring an NFT, you are charged a fee for the transaction, and you must sign the transaction with the private key of the blockchain address from which the fee will be deducted. Providing the private key in the API is not a secure way of signing transactions, because the private key can be stolen or exposed. Your private keys should never leave your security perimeter. You should use the private keys only for testing a solution you are building on the testnet of a blockchain. For signing transactions on the mainnet, we strongly recommend that you use the Tatum Key Management System (KMS) and provide the signature ID instead of the private key in the API. Alternatively, you can use the Tatum JavaScript client. NOTE: This does not apply to transferring NFTs that were minted on Algorand using NFT Express (see earlier in this section).
        /// </summary>
        /// <exception cref="Tatum.CSharp.Bsc.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="transferNft"></param>
        /// <param name="xTestnetType">Type of Ethereum testnet. Defaults to Sepolia. Valid only for ETH invocations for testnet API Key. For mainnet API Key, this value is ignored. (optional, default to ethereum-sepolia)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (TransactionHash)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<TransactionHash>> NftTransferErc721WithHttpInfoAsync(TransferNft transferNft, string xTestnetType = default(string), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            // verify the required parameter 'transferNft' is set
            if (transferNft == null)
                throw new ApiException(400, "Missing required parameter 'transferNft' when calling NFTBscApi->NftTransferErc721");

            var localVarRequestOptions = new RequestOptions();

            var contentTypes = new string[]{
                "application/json"
            };

            // to determine the Accept header
            var accepts = new string[]{
                "application/json"
            };


            var localVarContentType = ClientUtils.SelectHeaderContentType(contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = ClientUtils.SelectHeaderAccept(accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            if (xTestnetType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("x-testnet-type", ClientUtils.ParameterToString(xTestnetType)); // header parameter
            }
            localVarRequestOptions.Data = transferNft;

            // authentication (X-API-Key) required
            if (!string.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("x-api-key")))
            {
                localVarRequestOptions.HeaderParameters.Add("x-api-key", Configuration.GetApiKeyWithPrefix("x-api-key"));
            }

            // make the HTTP request

            var localVarResponse = await AsynchronousClient.PostAsync<TransactionHash>("/v3/nft/transaction", localVarRequestOptions, Configuration, cancellationToken).ConfigureAwait(false);

            return localVarResponse;
        }

        /// <summary>
        /// Transfer an NFT 100 credits per API call on Flow 2 credits per API call on the other blockchains Transfer an NFT from the smart contract (the contractAddress parameter in the request body) to the specified blockchain address (the to parameter in the request body). In one API call, you can transfer only one NFT. This API is supported for the following blockchains: Algorand BNB Smart Chain Celo Ethereum Flow Harmony Klaytn KuCoin Community Chain Polygon Solana TRON For Ethereum, Celo, and BNB Smart Chain, transferring NFTs invokes the safeTransfer() method. Transferring NFTs on Algorand On Algorand, the recipient has to agree in advance to receive your NFT because Algorand charges users for storing NFTs on their addresses, and an Algorand blockchain address by default does not receive NFTs unless explicitly agreed. Before transferring an NFT, make sure that the recipient has agreed to receive the NFT to their address. If you want to transfer an NFT that was minted using NFT Express, use the transferNftAlgoExpress schema of the request body. NOTE: On the mainnet, Tatum covers your transaction fees for the NFT transfer and pays for them from its own blockchain address. Then, the fee amount paid by Tatum is converted to the number of credits, and these credits are deducted from the monthly credit allowance of your paid pricing plan. On the testnet, no credits are deducted from the monthly credit allowance. Transferring NFTs on Solana If you want to transfer an NFT that was minted using NFT Express, see the section about minting NFTs on Solana using the pre-built NFT smart contract provided by Tatum for the information about how to set up the parameters in the request body. Signing a transaction When transferring an NFT, you are charged a fee for the transaction, and you must sign the transaction with the private key of the blockchain address from which the fee will be deducted. Providing the private key in the API is not a secure way of signing transactions, because the private key can be stolen or exposed. Your private keys should never leave your security perimeter. You should use the private keys only for testing a solution you are building on the testnet of a blockchain. For signing transactions on the mainnet, we strongly recommend that you use the Tatum Key Management System (KMS) and provide the signature ID instead of the private key in the API. Alternatively, you can use the Tatum JavaScript client. NOTE: This does not apply to transferring NFTs that were minted on Algorand using NFT Express (see earlier in this section).
        /// </summary>
        /// <exception cref="Tatum.CSharp.Bsc.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="transferNftKMS"></param>
        /// <param name="xTestnetType">Type of Ethereum testnet. Defaults to Sepolia. Valid only for ETH invocations for testnet API Key. For mainnet API Key, this value is ignored. (optional, default to ethereum-sepolia)</param>
        /// <returns>SignatureId</returns>
        public SignatureId NftTransferErc721(TransferNftKMS transferNftKMS, string xTestnetType = default(string))
        {
            var localVarResponse = NftTransferErc721WithHttpInfo(transferNftKMS, xTestnetType);

            var exception = ExceptionFactory?.Invoke("NftTransferErc721_0", localVarResponse);
            if (exception != null) throw exception;

            return localVarResponse.Data;
        }

        /// <summary>
        /// Transfer an NFT 100 credits per API call on Flow 2 credits per API call on the other blockchains Transfer an NFT from the smart contract (the contractAddress parameter in the request body) to the specified blockchain address (the to parameter in the request body). In one API call, you can transfer only one NFT. This API is supported for the following blockchains: Algorand BNB Smart Chain Celo Ethereum Flow Harmony Klaytn KuCoin Community Chain Polygon Solana TRON For Ethereum, Celo, and BNB Smart Chain, transferring NFTs invokes the safeTransfer() method. Transferring NFTs on Algorand On Algorand, the recipient has to agree in advance to receive your NFT because Algorand charges users for storing NFTs on their addresses, and an Algorand blockchain address by default does not receive NFTs unless explicitly agreed. Before transferring an NFT, make sure that the recipient has agreed to receive the NFT to their address. If you want to transfer an NFT that was minted using NFT Express, use the transferNftAlgoExpress schema of the request body. NOTE: On the mainnet, Tatum covers your transaction fees for the NFT transfer and pays for them from its own blockchain address. Then, the fee amount paid by Tatum is converted to the number of credits, and these credits are deducted from the monthly credit allowance of your paid pricing plan. On the testnet, no credits are deducted from the monthly credit allowance. Transferring NFTs on Solana If you want to transfer an NFT that was minted using NFT Express, see the section about minting NFTs on Solana using the pre-built NFT smart contract provided by Tatum for the information about how to set up the parameters in the request body. Signing a transaction When transferring an NFT, you are charged a fee for the transaction, and you must sign the transaction with the private key of the blockchain address from which the fee will be deducted. Providing the private key in the API is not a secure way of signing transactions, because the private key can be stolen or exposed. Your private keys should never leave your security perimeter. You should use the private keys only for testing a solution you are building on the testnet of a blockchain. For signing transactions on the mainnet, we strongly recommend that you use the Tatum Key Management System (KMS) and provide the signature ID instead of the private key in the API. Alternatively, you can use the Tatum JavaScript client. NOTE: This does not apply to transferring NFTs that were minted on Algorand using NFT Express (see earlier in this section).
        /// </summary>
        /// <exception cref="Tatum.CSharp.Bsc.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="transferNftKMS"></param>
        /// <param name="xTestnetType">Type of Ethereum testnet. Defaults to Sepolia. Valid only for ETH invocations for testnet API Key. For mainnet API Key, this value is ignored. (optional, default to ethereum-sepolia)</param>
        /// <returns>ApiResponse of SignatureId</returns>
        public ApiResponse<SignatureId> NftTransferErc721WithHttpInfo(TransferNftKMS transferNftKMS, string xTestnetType = default(string))
        {
            // verify the required parameter 'transferNftKMS' is set
            if (transferNftKMS == null)
                throw new ApiException(400, "Missing required parameter 'transferNftKMS' when calling NFTBscApi->NftTransferErc721_0");

            var localVarRequestOptions = new RequestOptions();

            var contentTypes = new string[]{
                "application/json"
            };

            // to determine the Accept header
            var accepts = new string[]{
                "application/json"
            };

            var localVarContentType = ClientUtils.SelectHeaderContentType(contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = ClientUtils.SelectHeaderAccept(accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            if (xTestnetType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("x-testnet-type", ClientUtils.ParameterToString(xTestnetType)); // header parameter
            }
            localVarRequestOptions.Data = transferNftKMS;

            // authentication (X-API-Key) required
            if (!string.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("x-api-key")))
            {
                localVarRequestOptions.HeaderParameters.Add("x-api-key", Configuration.GetApiKeyWithPrefix("x-api-key"));
            }

            // make the HTTP request
            var localVarResponse = Client.Post<SignatureId>("/v3/nft/transaction", localVarRequestOptions, Configuration);

            return localVarResponse;
        }

        /// <summary>
        /// Transfer an NFT 100 credits per API call on Flow 2 credits per API call on the other blockchains Transfer an NFT from the smart contract (the contractAddress parameter in the request body) to the specified blockchain address (the to parameter in the request body). In one API call, you can transfer only one NFT. This API is supported for the following blockchains: Algorand BNB Smart Chain Celo Ethereum Flow Harmony Klaytn KuCoin Community Chain Polygon Solana TRON For Ethereum, Celo, and BNB Smart Chain, transferring NFTs invokes the safeTransfer() method. Transferring NFTs on Algorand On Algorand, the recipient has to agree in advance to receive your NFT because Algorand charges users for storing NFTs on their addresses, and an Algorand blockchain address by default does not receive NFTs unless explicitly agreed. Before transferring an NFT, make sure that the recipient has agreed to receive the NFT to their address. If you want to transfer an NFT that was minted using NFT Express, use the transferNftAlgoExpress schema of the request body. NOTE: On the mainnet, Tatum covers your transaction fees for the NFT transfer and pays for them from its own blockchain address. Then, the fee amount paid by Tatum is converted to the number of credits, and these credits are deducted from the monthly credit allowance of your paid pricing plan. On the testnet, no credits are deducted from the monthly credit allowance. Transferring NFTs on Solana If you want to transfer an NFT that was minted using NFT Express, see the section about minting NFTs on Solana using the pre-built NFT smart contract provided by Tatum for the information about how to set up the parameters in the request body. Signing a transaction When transferring an NFT, you are charged a fee for the transaction, and you must sign the transaction with the private key of the blockchain address from which the fee will be deducted. Providing the private key in the API is not a secure way of signing transactions, because the private key can be stolen or exposed. Your private keys should never leave your security perimeter. You should use the private keys only for testing a solution you are building on the testnet of a blockchain. For signing transactions on the mainnet, we strongly recommend that you use the Tatum Key Management System (KMS) and provide the signature ID instead of the private key in the API. Alternatively, you can use the Tatum JavaScript client. NOTE: This does not apply to transferring NFTs that were minted on Algorand using NFT Express (see earlier in this section).
        /// </summary>
        /// <exception cref="Tatum.CSharp.Bsc.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="transferNftKMS"></param>
        /// <param name="xTestnetType">Type of Ethereum testnet. Defaults to Sepolia. Valid only for ETH invocations for testnet API Key. For mainnet API Key, this value is ignored. (optional, default to ethereum-sepolia)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of SignatureId</returns>
        public async System.Threading.Tasks.Task<SignatureId> NftTransferErc721Async(TransferNftKMS transferNftKMS, string xTestnetType = default(string), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            var localVarResponse = await NftTransferErc721WithHttpInfoAsync(transferNftKMS, xTestnetType, cancellationToken).ConfigureAwait(false);
            
            var exception = ExceptionFactory?.Invoke("NftTransferErc721_0", localVarResponse);
            if (exception != null) throw exception;

            return localVarResponse.Data;
        }

        /// <summary>
        /// Transfer an NFT 100 credits per API call on Flow 2 credits per API call on the other blockchains Transfer an NFT from the smart contract (the contractAddress parameter in the request body) to the specified blockchain address (the to parameter in the request body). In one API call, you can transfer only one NFT. This API is supported for the following blockchains: Algorand BNB Smart Chain Celo Ethereum Flow Harmony Klaytn KuCoin Community Chain Polygon Solana TRON For Ethereum, Celo, and BNB Smart Chain, transferring NFTs invokes the safeTransfer() method. Transferring NFTs on Algorand On Algorand, the recipient has to agree in advance to receive your NFT because Algorand charges users for storing NFTs on their addresses, and an Algorand blockchain address by default does not receive NFTs unless explicitly agreed. Before transferring an NFT, make sure that the recipient has agreed to receive the NFT to their address. If you want to transfer an NFT that was minted using NFT Express, use the transferNftAlgoExpress schema of the request body. NOTE: On the mainnet, Tatum covers your transaction fees for the NFT transfer and pays for them from its own blockchain address. Then, the fee amount paid by Tatum is converted to the number of credits, and these credits are deducted from the monthly credit allowance of your paid pricing plan. On the testnet, no credits are deducted from the monthly credit allowance. Transferring NFTs on Solana If you want to transfer an NFT that was minted using NFT Express, see the section about minting NFTs on Solana using the pre-built NFT smart contract provided by Tatum for the information about how to set up the parameters in the request body. Signing a transaction When transferring an NFT, you are charged a fee for the transaction, and you must sign the transaction with the private key of the blockchain address from which the fee will be deducted. Providing the private key in the API is not a secure way of signing transactions, because the private key can be stolen or exposed. Your private keys should never leave your security perimeter. You should use the private keys only for testing a solution you are building on the testnet of a blockchain. For signing transactions on the mainnet, we strongly recommend that you use the Tatum Key Management System (KMS) and provide the signature ID instead of the private key in the API. Alternatively, you can use the Tatum JavaScript client. NOTE: This does not apply to transferring NFTs that were minted on Algorand using NFT Express (see earlier in this section).
        /// </summary>
        /// <exception cref="Tatum.CSharp.Bsc.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="transferNftKMS"></param>
        /// <param name="xTestnetType">Type of Ethereum testnet. Defaults to Sepolia. Valid only for ETH invocations for testnet API Key. For mainnet API Key, this value is ignored. (optional, default to ethereum-sepolia)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (SignatureId)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<SignatureId>> NftTransferErc721WithHttpInfoAsync(TransferNftKMS transferNftKMS, string xTestnetType = default(string), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            // verify the required parameter 'transferNftKMS' is set
            if (transferNftKMS == null)
                throw new ApiException(400, "Missing required parameter 'transferNftKMS' when calling NFTBscApi->NftTransferErc721_0");

            var localVarRequestOptions = new RequestOptions();

            var contentTypes = new string[]{
                "application/json"
            };

            // to determine the Accept header
            var accepts = new string[]{
                "application/json"
            };


            var localVarContentType = ClientUtils.SelectHeaderContentType(contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = ClientUtils.SelectHeaderAccept(accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            if (xTestnetType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("x-testnet-type", ClientUtils.ParameterToString(xTestnetType)); // header parameter
            }
            localVarRequestOptions.Data = transferNftKMS;

            // authentication (X-API-Key) required
            if (!string.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("x-api-key")))
            {
                localVarRequestOptions.HeaderParameters.Add("x-api-key", Configuration.GetApiKeyWithPrefix("x-api-key"));
            }

            // make the HTTP request

            var localVarResponse = await AsynchronousClient.PostAsync<SignatureId>("/v3/nft/transaction", localVarRequestOptions, Configuration, cancellationToken).ConfigureAwait(false);

            return localVarResponse;
        }

        /// <summary>
        /// Update NFT royalty information 2 credits per API call Update the value of the royalty cashback set for an NFT. The royalty cashback value can be updated only from the address of the NFT author (the address that is listed as a royalty cashback receiver in the NFT royalty information). The royalty cashback value cannot be updated from the address of the NFT owner. In one API call, you can update the first value of the royalty cashback for the NFT author for one NFT. To disable the royalties for the NFT completely, set it to 0. This API is supported for the following blockchains: BNB Smart Chain Celo Ethereum Harmony Klaytn KuCoin Community Chain Polygon TRON Signing a transaction When updating NFT royalty, you are charged a fee for the transaction, and you must sign the transaction with the private key of the blockchain address from which the fee will be deducted. Providing the private key in the API is not a secure way of signing transactions, because the private key can be stolen or exposed. Your private keys should never leave your security perimeter. You should use the private keys only for testing a solution you are building on the testnet of a blockchain. For signing transactions on the mainnet, we strongly recommend that you use the Tatum Key Management System (KMS) and provide the signature ID instead of the private key in the API. Alternatively, you can use the Tatum JavaScript client.
        /// </summary>
        /// <exception cref="Tatum.CSharp.Bsc.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="updateCashbackValueForAuthorNft"></param>
        /// <param name="xTestnetType">Type of Ethereum testnet. Defaults to Sepolia. Valid only for ETH invocations for testnet API Key. For mainnet API Key, this value is ignored. (optional, default to ethereum-sepolia)</param>
        /// <returns>TransactionHash</returns>
        public TransactionHash NftUpdateCashbackErc721(UpdateCashbackValueForAuthorNft updateCashbackValueForAuthorNft, string xTestnetType = default(string))
        {
            var localVarResponse = NftUpdateCashbackErc721WithHttpInfo(updateCashbackValueForAuthorNft, xTestnetType);

            var exception = ExceptionFactory?.Invoke("NftUpdateCashbackErc721", localVarResponse);
            if (exception != null) throw exception;

            return localVarResponse.Data;
        }

        /// <summary>
        /// Update NFT royalty information 2 credits per API call Update the value of the royalty cashback set for an NFT. The royalty cashback value can be updated only from the address of the NFT author (the address that is listed as a royalty cashback receiver in the NFT royalty information). The royalty cashback value cannot be updated from the address of the NFT owner. In one API call, you can update the first value of the royalty cashback for the NFT author for one NFT. To disable the royalties for the NFT completely, set it to 0. This API is supported for the following blockchains: BNB Smart Chain Celo Ethereum Harmony Klaytn KuCoin Community Chain Polygon TRON Signing a transaction When updating NFT royalty, you are charged a fee for the transaction, and you must sign the transaction with the private key of the blockchain address from which the fee will be deducted. Providing the private key in the API is not a secure way of signing transactions, because the private key can be stolen or exposed. Your private keys should never leave your security perimeter. You should use the private keys only for testing a solution you are building on the testnet of a blockchain. For signing transactions on the mainnet, we strongly recommend that you use the Tatum Key Management System (KMS) and provide the signature ID instead of the private key in the API. Alternatively, you can use the Tatum JavaScript client.
        /// </summary>
        /// <exception cref="Tatum.CSharp.Bsc.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="updateCashbackValueForAuthorNft"></param>
        /// <param name="xTestnetType">Type of Ethereum testnet. Defaults to Sepolia. Valid only for ETH invocations for testnet API Key. For mainnet API Key, this value is ignored. (optional, default to ethereum-sepolia)</param>
        /// <returns>ApiResponse of TransactionHash</returns>
        public ApiResponse<TransactionHash> NftUpdateCashbackErc721WithHttpInfo(UpdateCashbackValueForAuthorNft updateCashbackValueForAuthorNft, string xTestnetType = default(string))
        {
            // verify the required parameter 'updateCashbackValueForAuthorNft' is set
            if (updateCashbackValueForAuthorNft == null)
                throw new ApiException(400, "Missing required parameter 'updateCashbackValueForAuthorNft' when calling NFTBscApi->NftUpdateCashbackErc721");

            var localVarRequestOptions = new RequestOptions();

            var contentTypes = new string[]{
                "application/json"
            };

            // to determine the Accept header
            var accepts = new string[]{
                "application/json"
            };

            var localVarContentType = ClientUtils.SelectHeaderContentType(contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = ClientUtils.SelectHeaderAccept(accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            if (xTestnetType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("x-testnet-type", ClientUtils.ParameterToString(xTestnetType)); // header parameter
            }
            localVarRequestOptions.Data = updateCashbackValueForAuthorNft;

            // authentication (X-API-Key) required
            if (!string.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("x-api-key")))
            {
                localVarRequestOptions.HeaderParameters.Add("x-api-key", Configuration.GetApiKeyWithPrefix("x-api-key"));
            }

            // make the HTTP request
            var localVarResponse = Client.Put<TransactionHash>("/v3/nft/royalty", localVarRequestOptions, Configuration);

            return localVarResponse;
        }

        /// <summary>
        /// Update NFT royalty information 2 credits per API call Update the value of the royalty cashback set for an NFT. The royalty cashback value can be updated only from the address of the NFT author (the address that is listed as a royalty cashback receiver in the NFT royalty information). The royalty cashback value cannot be updated from the address of the NFT owner. In one API call, you can update the first value of the royalty cashback for the NFT author for one NFT. To disable the royalties for the NFT completely, set it to 0. This API is supported for the following blockchains: BNB Smart Chain Celo Ethereum Harmony Klaytn KuCoin Community Chain Polygon TRON Signing a transaction When updating NFT royalty, you are charged a fee for the transaction, and you must sign the transaction with the private key of the blockchain address from which the fee will be deducted. Providing the private key in the API is not a secure way of signing transactions, because the private key can be stolen or exposed. Your private keys should never leave your security perimeter. You should use the private keys only for testing a solution you are building on the testnet of a blockchain. For signing transactions on the mainnet, we strongly recommend that you use the Tatum Key Management System (KMS) and provide the signature ID instead of the private key in the API. Alternatively, you can use the Tatum JavaScript client.
        /// </summary>
        /// <exception cref="Tatum.CSharp.Bsc.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="updateCashbackValueForAuthorNft"></param>
        /// <param name="xTestnetType">Type of Ethereum testnet. Defaults to Sepolia. Valid only for ETH invocations for testnet API Key. For mainnet API Key, this value is ignored. (optional, default to ethereum-sepolia)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of TransactionHash</returns>
        public async System.Threading.Tasks.Task<TransactionHash> NftUpdateCashbackErc721Async(UpdateCashbackValueForAuthorNft updateCashbackValueForAuthorNft, string xTestnetType = default(string), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            var localVarResponse = await NftUpdateCashbackErc721WithHttpInfoAsync(updateCashbackValueForAuthorNft, xTestnetType, cancellationToken).ConfigureAwait(false);
            
            var exception = ExceptionFactory?.Invoke("NftUpdateCashbackErc721", localVarResponse);
            if (exception != null) throw exception;

            return localVarResponse.Data;
        }

        /// <summary>
        /// Update NFT royalty information 2 credits per API call Update the value of the royalty cashback set for an NFT. The royalty cashback value can be updated only from the address of the NFT author (the address that is listed as a royalty cashback receiver in the NFT royalty information). The royalty cashback value cannot be updated from the address of the NFT owner. In one API call, you can update the first value of the royalty cashback for the NFT author for one NFT. To disable the royalties for the NFT completely, set it to 0. This API is supported for the following blockchains: BNB Smart Chain Celo Ethereum Harmony Klaytn KuCoin Community Chain Polygon TRON Signing a transaction When updating NFT royalty, you are charged a fee for the transaction, and you must sign the transaction with the private key of the blockchain address from which the fee will be deducted. Providing the private key in the API is not a secure way of signing transactions, because the private key can be stolen or exposed. Your private keys should never leave your security perimeter. You should use the private keys only for testing a solution you are building on the testnet of a blockchain. For signing transactions on the mainnet, we strongly recommend that you use the Tatum Key Management System (KMS) and provide the signature ID instead of the private key in the API. Alternatively, you can use the Tatum JavaScript client.
        /// </summary>
        /// <exception cref="Tatum.CSharp.Bsc.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="updateCashbackValueForAuthorNft"></param>
        /// <param name="xTestnetType">Type of Ethereum testnet. Defaults to Sepolia. Valid only for ETH invocations for testnet API Key. For mainnet API Key, this value is ignored. (optional, default to ethereum-sepolia)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (TransactionHash)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<TransactionHash>> NftUpdateCashbackErc721WithHttpInfoAsync(UpdateCashbackValueForAuthorNft updateCashbackValueForAuthorNft, string xTestnetType = default(string), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            // verify the required parameter 'updateCashbackValueForAuthorNft' is set
            if (updateCashbackValueForAuthorNft == null)
                throw new ApiException(400, "Missing required parameter 'updateCashbackValueForAuthorNft' when calling NFTBscApi->NftUpdateCashbackErc721");

            var localVarRequestOptions = new RequestOptions();

            var contentTypes = new string[]{
                "application/json"
            };

            // to determine the Accept header
            var accepts = new string[]{
                "application/json"
            };


            var localVarContentType = ClientUtils.SelectHeaderContentType(contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = ClientUtils.SelectHeaderAccept(accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            if (xTestnetType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("x-testnet-type", ClientUtils.ParameterToString(xTestnetType)); // header parameter
            }
            localVarRequestOptions.Data = updateCashbackValueForAuthorNft;

            // authentication (X-API-Key) required
            if (!string.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("x-api-key")))
            {
                localVarRequestOptions.HeaderParameters.Add("x-api-key", Configuration.GetApiKeyWithPrefix("x-api-key"));
            }

            // make the HTTP request

            var localVarResponse = await AsynchronousClient.PutAsync<TransactionHash>("/v3/nft/royalty", localVarRequestOptions, Configuration, cancellationToken).ConfigureAwait(false);

            return localVarResponse;
        }

        /// <summary>
        /// Update NFT royalty information 2 credits per API call Update the value of the royalty cashback set for an NFT. The royalty cashback value can be updated only from the address of the NFT author (the address that is listed as a royalty cashback receiver in the NFT royalty information). The royalty cashback value cannot be updated from the address of the NFT owner. In one API call, you can update the first value of the royalty cashback for the NFT author for one NFT. To disable the royalties for the NFT completely, set it to 0. This API is supported for the following blockchains: BNB Smart Chain Celo Ethereum Harmony Klaytn KuCoin Community Chain Polygon TRON Signing a transaction When updating NFT royalty, you are charged a fee for the transaction, and you must sign the transaction with the private key of the blockchain address from which the fee will be deducted. Providing the private key in the API is not a secure way of signing transactions, because the private key can be stolen or exposed. Your private keys should never leave your security perimeter. You should use the private keys only for testing a solution you are building on the testnet of a blockchain. For signing transactions on the mainnet, we strongly recommend that you use the Tatum Key Management System (KMS) and provide the signature ID instead of the private key in the API. Alternatively, you can use the Tatum JavaScript client.
        /// </summary>
        /// <exception cref="Tatum.CSharp.Bsc.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="updateCashbackValueForAuthorNftKMS"></param>
        /// <param name="xTestnetType">Type of Ethereum testnet. Defaults to Sepolia. Valid only for ETH invocations for testnet API Key. For mainnet API Key, this value is ignored. (optional, default to ethereum-sepolia)</param>
        /// <returns>SignatureId</returns>
        public SignatureId NftUpdateCashbackErc721(UpdateCashbackValueForAuthorNftKMS updateCashbackValueForAuthorNftKMS, string xTestnetType = default(string))
        {
            var localVarResponse = NftUpdateCashbackErc721WithHttpInfo(updateCashbackValueForAuthorNftKMS, xTestnetType);

            var exception = ExceptionFactory?.Invoke("NftUpdateCashbackErc721_0", localVarResponse);
            if (exception != null) throw exception;

            return localVarResponse.Data;
        }

        /// <summary>
        /// Update NFT royalty information 2 credits per API call Update the value of the royalty cashback set for an NFT. The royalty cashback value can be updated only from the address of the NFT author (the address that is listed as a royalty cashback receiver in the NFT royalty information). The royalty cashback value cannot be updated from the address of the NFT owner. In one API call, you can update the first value of the royalty cashback for the NFT author for one NFT. To disable the royalties for the NFT completely, set it to 0. This API is supported for the following blockchains: BNB Smart Chain Celo Ethereum Harmony Klaytn KuCoin Community Chain Polygon TRON Signing a transaction When updating NFT royalty, you are charged a fee for the transaction, and you must sign the transaction with the private key of the blockchain address from which the fee will be deducted. Providing the private key in the API is not a secure way of signing transactions, because the private key can be stolen or exposed. Your private keys should never leave your security perimeter. You should use the private keys only for testing a solution you are building on the testnet of a blockchain. For signing transactions on the mainnet, we strongly recommend that you use the Tatum Key Management System (KMS) and provide the signature ID instead of the private key in the API. Alternatively, you can use the Tatum JavaScript client.
        /// </summary>
        /// <exception cref="Tatum.CSharp.Bsc.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="updateCashbackValueForAuthorNftKMS"></param>
        /// <param name="xTestnetType">Type of Ethereum testnet. Defaults to Sepolia. Valid only for ETH invocations for testnet API Key. For mainnet API Key, this value is ignored. (optional, default to ethereum-sepolia)</param>
        /// <returns>ApiResponse of SignatureId</returns>
        public ApiResponse<SignatureId> NftUpdateCashbackErc721WithHttpInfo(UpdateCashbackValueForAuthorNftKMS updateCashbackValueForAuthorNftKMS, string xTestnetType = default(string))
        {
            // verify the required parameter 'updateCashbackValueForAuthorNftKMS' is set
            if (updateCashbackValueForAuthorNftKMS == null)
                throw new ApiException(400, "Missing required parameter 'updateCashbackValueForAuthorNftKMS' when calling NFTBscApi->NftUpdateCashbackErc721_0");

            var localVarRequestOptions = new RequestOptions();

            var contentTypes = new string[]{
                "application/json"
            };

            // to determine the Accept header
            var accepts = new string[]{
                "application/json"
            };

            var localVarContentType = ClientUtils.SelectHeaderContentType(contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = ClientUtils.SelectHeaderAccept(accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            if (xTestnetType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("x-testnet-type", ClientUtils.ParameterToString(xTestnetType)); // header parameter
            }
            localVarRequestOptions.Data = updateCashbackValueForAuthorNftKMS;

            // authentication (X-API-Key) required
            if (!string.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("x-api-key")))
            {
                localVarRequestOptions.HeaderParameters.Add("x-api-key", Configuration.GetApiKeyWithPrefix("x-api-key"));
            }

            // make the HTTP request
            var localVarResponse = Client.Put<SignatureId>("/v3/nft/royalty", localVarRequestOptions, Configuration);

            return localVarResponse;
        }

        /// <summary>
        /// Update NFT royalty information 2 credits per API call Update the value of the royalty cashback set for an NFT. The royalty cashback value can be updated only from the address of the NFT author (the address that is listed as a royalty cashback receiver in the NFT royalty information). The royalty cashback value cannot be updated from the address of the NFT owner. In one API call, you can update the first value of the royalty cashback for the NFT author for one NFT. To disable the royalties for the NFT completely, set it to 0. This API is supported for the following blockchains: BNB Smart Chain Celo Ethereum Harmony Klaytn KuCoin Community Chain Polygon TRON Signing a transaction When updating NFT royalty, you are charged a fee for the transaction, and you must sign the transaction with the private key of the blockchain address from which the fee will be deducted. Providing the private key in the API is not a secure way of signing transactions, because the private key can be stolen or exposed. Your private keys should never leave your security perimeter. You should use the private keys only for testing a solution you are building on the testnet of a blockchain. For signing transactions on the mainnet, we strongly recommend that you use the Tatum Key Management System (KMS) and provide the signature ID instead of the private key in the API. Alternatively, you can use the Tatum JavaScript client.
        /// </summary>
        /// <exception cref="Tatum.CSharp.Bsc.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="updateCashbackValueForAuthorNftKMS"></param>
        /// <param name="xTestnetType">Type of Ethereum testnet. Defaults to Sepolia. Valid only for ETH invocations for testnet API Key. For mainnet API Key, this value is ignored. (optional, default to ethereum-sepolia)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of SignatureId</returns>
        public async System.Threading.Tasks.Task<SignatureId> NftUpdateCashbackErc721Async(UpdateCashbackValueForAuthorNftKMS updateCashbackValueForAuthorNftKMS, string xTestnetType = default(string), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            var localVarResponse = await NftUpdateCashbackErc721WithHttpInfoAsync(updateCashbackValueForAuthorNftKMS, xTestnetType, cancellationToken).ConfigureAwait(false);
            
            var exception = ExceptionFactory?.Invoke("NftUpdateCashbackErc721_0", localVarResponse);
            if (exception != null) throw exception;

            return localVarResponse.Data;
        }

        /// <summary>
        /// Update NFT royalty information 2 credits per API call Update the value of the royalty cashback set for an NFT. The royalty cashback value can be updated only from the address of the NFT author (the address that is listed as a royalty cashback receiver in the NFT royalty information). The royalty cashback value cannot be updated from the address of the NFT owner. In one API call, you can update the first value of the royalty cashback for the NFT author for one NFT. To disable the royalties for the NFT completely, set it to 0. This API is supported for the following blockchains: BNB Smart Chain Celo Ethereum Harmony Klaytn KuCoin Community Chain Polygon TRON Signing a transaction When updating NFT royalty, you are charged a fee for the transaction, and you must sign the transaction with the private key of the blockchain address from which the fee will be deducted. Providing the private key in the API is not a secure way of signing transactions, because the private key can be stolen or exposed. Your private keys should never leave your security perimeter. You should use the private keys only for testing a solution you are building on the testnet of a blockchain. For signing transactions on the mainnet, we strongly recommend that you use the Tatum Key Management System (KMS) and provide the signature ID instead of the private key in the API. Alternatively, you can use the Tatum JavaScript client.
        /// </summary>
        /// <exception cref="Tatum.CSharp.Bsc.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="updateCashbackValueForAuthorNftKMS"></param>
        /// <param name="xTestnetType">Type of Ethereum testnet. Defaults to Sepolia. Valid only for ETH invocations for testnet API Key. For mainnet API Key, this value is ignored. (optional, default to ethereum-sepolia)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (SignatureId)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<SignatureId>> NftUpdateCashbackErc721WithHttpInfoAsync(UpdateCashbackValueForAuthorNftKMS updateCashbackValueForAuthorNftKMS, string xTestnetType = default(string), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            // verify the required parameter 'updateCashbackValueForAuthorNftKMS' is set
            if (updateCashbackValueForAuthorNftKMS == null)
                throw new ApiException(400, "Missing required parameter 'updateCashbackValueForAuthorNftKMS' when calling NFTBscApi->NftUpdateCashbackErc721_0");

            var localVarRequestOptions = new RequestOptions();

            var contentTypes = new string[]{
                "application/json"
            };

            // to determine the Accept header
            var accepts = new string[]{
                "application/json"
            };


            var localVarContentType = ClientUtils.SelectHeaderContentType(contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = ClientUtils.SelectHeaderAccept(accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            if (xTestnetType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("x-testnet-type", ClientUtils.ParameterToString(xTestnetType)); // header parameter
            }
            localVarRequestOptions.Data = updateCashbackValueForAuthorNftKMS;

            // authentication (X-API-Key) required
            if (!string.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("x-api-key")))
            {
                localVarRequestOptions.HeaderParameters.Add("x-api-key", Configuration.GetApiKeyWithPrefix("x-api-key"));
            }

            // make the HTTP request

            var localVarResponse = await AsynchronousClient.PutAsync<SignatureId>("/v3/nft/royalty", localVarRequestOptions, Configuration, cancellationToken).ConfigureAwait(false);

            return localVarResponse;
        }

    }
}
