/*
 * Tatum API Reference
 *
 * # Welcome to the Tatum API Reference!  ## What is Tatum?  Tatum offers a flexible framework to build, run, and scale blockchain apps fast. To learn more about the Tatum blockchain development framework, visit [our website](https://tatum.io/framework).  The Tatum API features powerful endpoints that simplify a complex blockchain into single API requests. Code for all supported blockchains using unified API calls.  ## Need help?  To chat with other developers, get help from the Support team, and engage with the thriving Tatum community, join  our [Discord server](https://discord.com/invite/tatum). For more information about how to work with Tatum, review the [online documentation](https://docs.tatum.io/).  ## About this API Reference  The Tatum API Reference is based on OpenAPI Specification v3.1.0 with a few [vendor extensions](https://github.com/Redocly/redoc/blob/master/docs/redoc-vendor-extensions.md) applied.  # Authentication  When using the Tatum API, you authenticate yourself with an **API key**. <SecurityDefinitions /> 
 *
 * The version of the OpenAPI document: 3.17.1
 * Generated by: https://github.com/openapitools/openapi-generator.git
 */


using System;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.Linq;
using System.Net;
using System.Net.Http;
using System.Net.Mime;
using Tatum.CSharp.Polygon.Core.Client;
using Tatum.CSharp.Polygon.Core.Model;

namespace Tatum.CSharp.Polygon.Core.Api
{

    /// <summary>
    /// Represents a collection of functions to interact with the API endpoints
    /// </summary>
    public interface IPolygonApiSync : IApiAccessor
    {
        #region Synchronous Operations
        /// <summary>
        /// Invoke a method in a smart contract on Polygon
        /// </summary>
        /// <remarks>
        /// 2 credits per API call Invoke a method in an existing smart contract on Polygon. You can call a read-only or write method. For read-only methods, the output of the invoked method is returned. For write methods, the ID of the associated transaction is returned. Troubleshooting a failed transaction Tatum ensures that this API works against the blockchain (accesses the blockchain, finds the specified smart contract, and executes the specified ABI method with the provided parameters). However, because this API can be run against any smart contract on the blockchain, Tatum cannot in any way guarantee that the method itself will be executed successfully. If you have issues with invoking the method, refer to the user documentation for this method, or contact the author of the smart contract. For more information about invoking methods in smart contracts, see this article on our Support Portal. Signing a transaction When invoking a method in a smart contract, you are charged a fee for the transaction, and you must sign the transaction with the private key of the blockchain address from which the fee will be deducted. If caller field is present instead of the private key, Tatum will sign the transaction with the managed private key connected to the caller address. This is applicable only for paid mainnet plans and all testnet plans. Keep in mind that the caller address must have enough access right to perform the action in the smart contract method. Providing the private key in the API is not a secure way of signing transactions, because the private key can be stolen or exposed. Your private keys should never leave your security perimeter. You should use the private keys only for testing a solution you are building on the testnet of a blockchain. For signing transactions on the mainnet, we strongly recommend that you use the Tatum Key Management System (KMS) and provide the signature ID instead of the private key in the API. Alternatively, you can use the Tatum JavaScript client.
        /// </remarks>
        /// <exception cref="Tatum.CSharp.Polygon.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="callPolygonSmartContractReadMethod"></param>
        /// <returns>Data</returns>
        Data PolygonBlockchainSmartContractInvocation(CallPolygonSmartContractReadMethod callPolygonSmartContractReadMethod);
        /// <summary>
        /// Invoke a method in a smart contract on Polygon
        /// </summary>
        /// <remarks>
        /// 2 credits per API call Invoke a method in an existing smart contract on Polygon. You can call a read-only or write method. For read-only methods, the output of the invoked method is returned. For write methods, the ID of the associated transaction is returned. Troubleshooting a failed transaction Tatum ensures that this API works against the blockchain (accesses the blockchain, finds the specified smart contract, and executes the specified ABI method with the provided parameters). However, because this API can be run against any smart contract on the blockchain, Tatum cannot in any way guarantee that the method itself will be executed successfully. If you have issues with invoking the method, refer to the user documentation for this method, or contact the author of the smart contract. For more information about invoking methods in smart contracts, see this article on our Support Portal. Signing a transaction When invoking a method in a smart contract, you are charged a fee for the transaction, and you must sign the transaction with the private key of the blockchain address from which the fee will be deducted. If caller field is present instead of the private key, Tatum will sign the transaction with the managed private key connected to the caller address. This is applicable only for paid mainnet plans and all testnet plans. Keep in mind that the caller address must have enough access right to perform the action in the smart contract method. Providing the private key in the API is not a secure way of signing transactions, because the private key can be stolen or exposed. Your private keys should never leave your security perimeter. You should use the private keys only for testing a solution you are building on the testnet of a blockchain. For signing transactions on the mainnet, we strongly recommend that you use the Tatum Key Management System (KMS) and provide the signature ID instead of the private key in the API. Alternatively, you can use the Tatum JavaScript client.
        /// </remarks>
        /// <exception cref="Tatum.CSharp.Polygon.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="callPolygonSmartContractMethod"></param>
        /// <returns>TransactionHash</returns>
        TransactionHash PolygonBlockchainSmartContractInvocation(CallPolygonSmartContractMethod callPolygonSmartContractMethod);
        /// <summary>
        /// Invoke a method in a smart contract on Polygon
        /// </summary>
        /// <remarks>
        /// 2 credits per API call Invoke a method in an existing smart contract on Polygon. You can call a read-only or write method. For read-only methods, the output of the invoked method is returned. For write methods, the ID of the associated transaction is returned. Troubleshooting a failed transaction Tatum ensures that this API works against the blockchain (accesses the blockchain, finds the specified smart contract, and executes the specified ABI method with the provided parameters). However, because this API can be run against any smart contract on the blockchain, Tatum cannot in any way guarantee that the method itself will be executed successfully. If you have issues with invoking the method, refer to the user documentation for this method, or contact the author of the smart contract. For more information about invoking methods in smart contracts, see this article on our Support Portal. Signing a transaction When invoking a method in a smart contract, you are charged a fee for the transaction, and you must sign the transaction with the private key of the blockchain address from which the fee will be deducted. If caller field is present instead of the private key, Tatum will sign the transaction with the managed private key connected to the caller address. This is applicable only for paid mainnet plans and all testnet plans. Keep in mind that the caller address must have enough access right to perform the action in the smart contract method. Providing the private key in the API is not a secure way of signing transactions, because the private key can be stolen or exposed. Your private keys should never leave your security perimeter. You should use the private keys only for testing a solution you are building on the testnet of a blockchain. For signing transactions on the mainnet, we strongly recommend that you use the Tatum Key Management System (KMS) and provide the signature ID instead of the private key in the API. Alternatively, you can use the Tatum JavaScript client.
        /// </remarks>
        /// <exception cref="Tatum.CSharp.Polygon.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="callPolygonSmartContractMethodCaller"></param>
        /// <returns>TransactionHash</returns>
        TransactionHash PolygonBlockchainSmartContractInvocation(CallPolygonSmartContractMethodCaller callPolygonSmartContractMethodCaller);
        /// <summary>
        /// Invoke a method in a smart contract on Polygon
        /// </summary>
        /// <remarks>
        /// 2 credits per API call Invoke a method in an existing smart contract on Polygon. You can call a read-only or write method. For read-only methods, the output of the invoked method is returned. For write methods, the ID of the associated transaction is returned. Troubleshooting a failed transaction Tatum ensures that this API works against the blockchain (accesses the blockchain, finds the specified smart contract, and executes the specified ABI method with the provided parameters). However, because this API can be run against any smart contract on the blockchain, Tatum cannot in any way guarantee that the method itself will be executed successfully. If you have issues with invoking the method, refer to the user documentation for this method, or contact the author of the smart contract. For more information about invoking methods in smart contracts, see this article on our Support Portal. Signing a transaction When invoking a method in a smart contract, you are charged a fee for the transaction, and you must sign the transaction with the private key of the blockchain address from which the fee will be deducted. If caller field is present instead of the private key, Tatum will sign the transaction with the managed private key connected to the caller address. This is applicable only for paid mainnet plans and all testnet plans. Keep in mind that the caller address must have enough access right to perform the action in the smart contract method. Providing the private key in the API is not a secure way of signing transactions, because the private key can be stolen or exposed. Your private keys should never leave your security perimeter. You should use the private keys only for testing a solution you are building on the testnet of a blockchain. For signing transactions on the mainnet, we strongly recommend that you use the Tatum Key Management System (KMS) and provide the signature ID instead of the private key in the API. Alternatively, you can use the Tatum JavaScript client.
        /// </remarks>
        /// <exception cref="Tatum.CSharp.Polygon.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="callPolygonSmartContractMethodKMS"></param>
        /// <returns>SignatureId</returns>
        SignatureId PolygonBlockchainSmartContractInvocation(CallPolygonSmartContractMethodKMS callPolygonSmartContractMethodKMS);
        /// <summary>
        /// Send MATIC from account to account
        /// </summary>
        /// <remarks>
        /// 2 credits per API call Send MATIC from account to account. Signing a transaction When sending MATIC, you are charged a fee for the transaction, and you must sign the transaction with the private key of the blockchain address from which the fee will be deducted. Providing the private key in the API is not a secure way of signing transactions, because the private key can be stolen or exposed. Your private keys should never leave your security perimeter. You should use the private keys only for testing a solution you are building on the testnet of a blockchain. For signing transactions on the mainnet, we strongly recommend that you use the Tatum Key Management System (KMS) and provide the signature ID instead of the private key in the API. Alternatively, you can use the Tatum JavaScript client.
        /// </remarks>
        /// <exception cref="Tatum.CSharp.Polygon.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="transferPolygonBlockchain"></param>
        /// <returns>TransactionHash</returns>
        TransactionHash PolygonBlockchainTransfer(TransferPolygonBlockchain transferPolygonBlockchain);
        /// <summary>
        /// Send MATIC from account to account
        /// </summary>
        /// <remarks>
        /// 2 credits per API call Send MATIC from account to account. Signing a transaction When sending MATIC, you are charged a fee for the transaction, and you must sign the transaction with the private key of the blockchain address from which the fee will be deducted. Providing the private key in the API is not a secure way of signing transactions, because the private key can be stolen or exposed. Your private keys should never leave your security perimeter. You should use the private keys only for testing a solution you are building on the testnet of a blockchain. For signing transactions on the mainnet, we strongly recommend that you use the Tatum Key Management System (KMS) and provide the signature ID instead of the private key in the API. Alternatively, you can use the Tatum JavaScript client.
        /// </remarks>
        /// <exception cref="Tatum.CSharp.Polygon.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="transferPolygonBlockchainKMS"></param>
        /// <returns>SignatureId</returns>
        SignatureId PolygonBlockchainTransfer(TransferPolygonBlockchainKMS transferPolygonBlockchainKMS);
        /// <summary>
        /// Broadcast signed Polygon transaction
        /// </summary>
        /// <remarks>
        /// 2 credits per API call Broadcast signed transaction to Polygon blockchain. This method is used internally from Tatum KMS or Tatum client libraries. It is possible to create custom signing mechanism and use this method only for broadcasting data to the blockchain.
        /// </remarks>
        /// <exception cref="Tatum.CSharp.Polygon.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="broadcastKMS"></param>
        /// <returns>TransactionHash</returns>
        TransactionHash PolygonBroadcast(BroadcastKMS broadcastKMS);
        /// <summary>
        /// Generate Polygon account address from Extended public key
        /// </summary>
        /// <remarks>
        /// 1 credit per API call Generate Polygon account deposit address from Extended public key. Deposit address is generated for the specific index - each extended public key can generate up to 2^31 addresses starting from index 0 until 2^31.
        /// </remarks>
        /// <exception cref="Tatum.CSharp.Polygon.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="xpub">Extended public key of wallet.</param>
        /// <param name="index">Derivation index of desired address to be generated.</param>
        /// <returns>GeneratedAddressMatic</returns>
        GeneratedAddressMatic PolygonGenerateAddress(string xpub, decimal index);
        /// <summary>
        /// Generate Polygon private key
        /// </summary>
        /// <remarks>
        /// 1 credit per API call Generate private key of address from mnemonic for given derivation path index. Private key is generated for the specific index - each mnemonic can generate up to 2^31 private keys starting from index 0 until 2^31.
        /// </remarks>
        /// <exception cref="Tatum.CSharp.Polygon.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="privKeyRequest"></param>
        /// <returns>PrivKey</returns>
        PrivKey PolygonGenerateAddressPrivateKey(PrivKeyRequest privKeyRequest);
        /// <summary>
        /// Generate Polygon wallet
        /// </summary>
        /// <remarks>
        /// 1 credit per API call Tatum supports BIP44 HD wallets. It is very convenient and secure, since it can generate 2^31 addresses from 1 mnemonic phrase. Mnemonic phrase consists of 24 special words in defined order and can restore access to all generated addresses and private keys. Each address is identified by 3 main values: Private Key - your secret value, which should never be revealed Public Key - public address to be published Derivation index - index of generated address Tatum follows BIP44 specification and generates for Polygon wallet with derivation path m&#39;/44&#39;/966&#39;/0&#39;/0. More about BIP44 HD wallets can be found here - https://github.com/bitcoin/bips/blob/master/bip-0044.mediawiki. Generate BIP44 compatible Polygon wallet.
        /// </remarks>
        /// <exception cref="Tatum.CSharp.Polygon.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="mnemonic">Mnemonic to use for generation of extended public and private keys. (optional)</param>
        /// <returns>Wallet</returns>
        Wallet PolygonGenerateWallet(string mnemonic = default(string));
        /// <summary>
        /// Get Polygon Account balance
        /// </summary>
        /// <remarks>
        /// 1 credit per API call Get Polygon account balance in MATIC. This method does not prints any balance of the ERC20 or ERC721 tokens on the account.
        /// </remarks>
        /// <exception cref="Tatum.CSharp.Polygon.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="address">Account address you want to get balance of</param>
        /// <returns>MaticBalance</returns>
        MaticBalance PolygonGetBalance(string address);
        /// <summary>
        /// Get Polygon block by hash
        /// </summary>
        /// <remarks>
        /// 1 credit per API call Get Polygon block by block hash or block number.
        /// </remarks>
        /// <exception cref="Tatum.CSharp.Polygon.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="hash">Block hash or block number</param>
        /// <returns>EthBlock</returns>
        EthBlock PolygonGetBlock(string hash);
        /// <summary>
        /// Get current block number
        /// </summary>
        /// <remarks>
        /// 1 credit per API call Get Polygon current block number. This is the number of the latest block in the blockchain.
        /// </remarks>
        /// <exception cref="Tatum.CSharp.Polygon.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <returns>decimal</returns>
        decimal PolygonGetCurrentBlock();
        /// <summary>
        /// Get Polygon Transaction
        /// </summary>
        /// <remarks>
        /// 2 credits per API call Get Polygon transaction by transaction hash.
        /// </remarks>
        /// <exception cref="Tatum.CSharp.Polygon.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="hash">Transaction hash</param>
        /// <returns>PolygonTx</returns>
        PolygonTx PolygonGetTransaction(string hash);
        /// <summary>
        /// Get Polygon transactions by address
        /// </summary>
        /// <remarks>
        /// 1 credit per API call Get Polygon transactions by address. This includes incoming and outgoing transactions for the address.
        /// </remarks>
        /// <exception cref="Tatum.CSharp.Polygon.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="address">Account address you want to get balance of</param>
        /// <param name="pageSize">Max number of items per page is 50.</param>
        /// <param name="offset">Offset to obtain next page of the data. (optional)</param>
        /// <param name="from">Transactions from this block onwards will be included. (optional)</param>
        /// <param name="to">Transactions up to this block will be included. (optional)</param>
        /// <param name="sort">Sorting of the data. ASC - oldest first, DESC - newest first. (optional, default to DESC)</param>
        /// <returns>List&lt;PolygonTx&gt;</returns>
        List<PolygonTx> PolygonGetTransactionByAddress(string address, decimal pageSize, decimal? offset = default(decimal?), decimal? from = default(decimal?), decimal? to = default(decimal?), string sort = default(string));
        /// <summary>
        /// Get count of outgoing Polygon transactions
        /// </summary>
        /// <remarks>
        /// 1 credit per API call Get a number of outgoing Polygon transactions for the address. When a transaction is sent, there can be multiple outgoing transactions, which are not yet processed by the blockchain. To distinguish between them, there is a counter called a nonce, which represents the order of the transaction in the list of outgoing transactions.
        /// </remarks>
        /// <exception cref="Tatum.CSharp.Polygon.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="address">address</param>
        /// <returns>decimal</returns>
        decimal PolygonGetTransactionCount(string address);
        #endregion Synchronous Operations
    }

    /// <summary>
    /// Represents a collection of functions to interact with the API endpoints
    /// </summary>
    public interface IPolygonApiWithHttpInfoSync : IApiAccessor
    {
        #region Synchronous Operations With Http Info
        /// <summary>
        /// Invoke a method in a smart contract on Polygon
        /// </summary>
        /// <remarks>
        /// 2 credits per API call Invoke a method in an existing smart contract on Polygon. You can call a read-only or write method. For read-only methods, the output of the invoked method is returned. For write methods, the ID of the associated transaction is returned. Troubleshooting a failed transaction Tatum ensures that this API works against the blockchain (accesses the blockchain, finds the specified smart contract, and executes the specified ABI method with the provided parameters). However, because this API can be run against any smart contract on the blockchain, Tatum cannot in any way guarantee that the method itself will be executed successfully. If you have issues with invoking the method, refer to the user documentation for this method, or contact the author of the smart contract. For more information about invoking methods in smart contracts, see this article on our Support Portal. Signing a transaction When invoking a method in a smart contract, you are charged a fee for the transaction, and you must sign the transaction with the private key of the blockchain address from which the fee will be deducted. If caller field is present instead of the private key, Tatum will sign the transaction with the managed private key connected to the caller address. This is applicable only for paid mainnet plans and all testnet plans. Keep in mind that the caller address must have enough access right to perform the action in the smart contract method. Providing the private key in the API is not a secure way of signing transactions, because the private key can be stolen or exposed. Your private keys should never leave your security perimeter. You should use the private keys only for testing a solution you are building on the testnet of a blockchain. For signing transactions on the mainnet, we strongly recommend that you use the Tatum Key Management System (KMS) and provide the signature ID instead of the private key in the API. Alternatively, you can use the Tatum JavaScript client.
        /// </remarks>
        /// <exception cref="Tatum.CSharp.Polygon.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="callPolygonSmartContractReadMethod"></param>
        /// <returns>ApiResponse of Data</returns>
        ApiResponse<Data> PolygonBlockchainSmartContractInvocationWithHttpInfo(CallPolygonSmartContractReadMethod callPolygonSmartContractReadMethod);
        /// <summary>
        /// Invoke a method in a smart contract on Polygon
        /// </summary>
        /// <remarks>
        /// 2 credits per API call Invoke a method in an existing smart contract on Polygon. You can call a read-only or write method. For read-only methods, the output of the invoked method is returned. For write methods, the ID of the associated transaction is returned. Troubleshooting a failed transaction Tatum ensures that this API works against the blockchain (accesses the blockchain, finds the specified smart contract, and executes the specified ABI method with the provided parameters). However, because this API can be run against any smart contract on the blockchain, Tatum cannot in any way guarantee that the method itself will be executed successfully. If you have issues with invoking the method, refer to the user documentation for this method, or contact the author of the smart contract. For more information about invoking methods in smart contracts, see this article on our Support Portal. Signing a transaction When invoking a method in a smart contract, you are charged a fee for the transaction, and you must sign the transaction with the private key of the blockchain address from which the fee will be deducted. If caller field is present instead of the private key, Tatum will sign the transaction with the managed private key connected to the caller address. This is applicable only for paid mainnet plans and all testnet plans. Keep in mind that the caller address must have enough access right to perform the action in the smart contract method. Providing the private key in the API is not a secure way of signing transactions, because the private key can be stolen or exposed. Your private keys should never leave your security perimeter. You should use the private keys only for testing a solution you are building on the testnet of a blockchain. For signing transactions on the mainnet, we strongly recommend that you use the Tatum Key Management System (KMS) and provide the signature ID instead of the private key in the API. Alternatively, you can use the Tatum JavaScript client.
        /// </remarks>
        /// <exception cref="Tatum.CSharp.Polygon.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="callPolygonSmartContractMethod"></param>
        /// <returns>ApiResponse of TransactionHash</returns>
        ApiResponse<TransactionHash> PolygonBlockchainSmartContractInvocationWithHttpInfo(CallPolygonSmartContractMethod callPolygonSmartContractMethod);
        /// <summary>
        /// Invoke a method in a smart contract on Polygon
        /// </summary>
        /// <remarks>
        /// 2 credits per API call Invoke a method in an existing smart contract on Polygon. You can call a read-only or write method. For read-only methods, the output of the invoked method is returned. For write methods, the ID of the associated transaction is returned. Troubleshooting a failed transaction Tatum ensures that this API works against the blockchain (accesses the blockchain, finds the specified smart contract, and executes the specified ABI method with the provided parameters). However, because this API can be run against any smart contract on the blockchain, Tatum cannot in any way guarantee that the method itself will be executed successfully. If you have issues with invoking the method, refer to the user documentation for this method, or contact the author of the smart contract. For more information about invoking methods in smart contracts, see this article on our Support Portal. Signing a transaction When invoking a method in a smart contract, you are charged a fee for the transaction, and you must sign the transaction with the private key of the blockchain address from which the fee will be deducted. If caller field is present instead of the private key, Tatum will sign the transaction with the managed private key connected to the caller address. This is applicable only for paid mainnet plans and all testnet plans. Keep in mind that the caller address must have enough access right to perform the action in the smart contract method. Providing the private key in the API is not a secure way of signing transactions, because the private key can be stolen or exposed. Your private keys should never leave your security perimeter. You should use the private keys only for testing a solution you are building on the testnet of a blockchain. For signing transactions on the mainnet, we strongly recommend that you use the Tatum Key Management System (KMS) and provide the signature ID instead of the private key in the API. Alternatively, you can use the Tatum JavaScript client.
        /// </remarks>
        /// <exception cref="Tatum.CSharp.Polygon.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="callPolygonSmartContractMethodCaller"></param>
        /// <returns>ApiResponse of TransactionHash</returns>
        ApiResponse<TransactionHash> PolygonBlockchainSmartContractInvocationWithHttpInfo(CallPolygonSmartContractMethodCaller callPolygonSmartContractMethodCaller);
        /// <summary>
        /// Invoke a method in a smart contract on Polygon
        /// </summary>
        /// <remarks>
        /// 2 credits per API call Invoke a method in an existing smart contract on Polygon. You can call a read-only or write method. For read-only methods, the output of the invoked method is returned. For write methods, the ID of the associated transaction is returned. Troubleshooting a failed transaction Tatum ensures that this API works against the blockchain (accesses the blockchain, finds the specified smart contract, and executes the specified ABI method with the provided parameters). However, because this API can be run against any smart contract on the blockchain, Tatum cannot in any way guarantee that the method itself will be executed successfully. If you have issues with invoking the method, refer to the user documentation for this method, or contact the author of the smart contract. For more information about invoking methods in smart contracts, see this article on our Support Portal. Signing a transaction When invoking a method in a smart contract, you are charged a fee for the transaction, and you must sign the transaction with the private key of the blockchain address from which the fee will be deducted. If caller field is present instead of the private key, Tatum will sign the transaction with the managed private key connected to the caller address. This is applicable only for paid mainnet plans and all testnet plans. Keep in mind that the caller address must have enough access right to perform the action in the smart contract method. Providing the private key in the API is not a secure way of signing transactions, because the private key can be stolen or exposed. Your private keys should never leave your security perimeter. You should use the private keys only for testing a solution you are building on the testnet of a blockchain. For signing transactions on the mainnet, we strongly recommend that you use the Tatum Key Management System (KMS) and provide the signature ID instead of the private key in the API. Alternatively, you can use the Tatum JavaScript client.
        /// </remarks>
        /// <exception cref="Tatum.CSharp.Polygon.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="callPolygonSmartContractMethodKMS"></param>
        /// <returns>ApiResponse of SignatureId</returns>
        ApiResponse<SignatureId> PolygonBlockchainSmartContractInvocationWithHttpInfo(CallPolygonSmartContractMethodKMS callPolygonSmartContractMethodKMS);
        /// <summary>
        /// Send MATIC from account to account
        /// </summary>
        /// <remarks>
        /// 2 credits per API call Send MATIC from account to account. Signing a transaction When sending MATIC, you are charged a fee for the transaction, and you must sign the transaction with the private key of the blockchain address from which the fee will be deducted. Providing the private key in the API is not a secure way of signing transactions, because the private key can be stolen or exposed. Your private keys should never leave your security perimeter. You should use the private keys only for testing a solution you are building on the testnet of a blockchain. For signing transactions on the mainnet, we strongly recommend that you use the Tatum Key Management System (KMS) and provide the signature ID instead of the private key in the API. Alternatively, you can use the Tatum JavaScript client.
        /// </remarks>
        /// <exception cref="Tatum.CSharp.Polygon.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="transferPolygonBlockchain"></param>
        /// <returns>ApiResponse of TransactionHash</returns>
        ApiResponse<TransactionHash> PolygonBlockchainTransferWithHttpInfo(TransferPolygonBlockchain transferPolygonBlockchain);
        /// <summary>
        /// Send MATIC from account to account
        /// </summary>
        /// <remarks>
        /// 2 credits per API call Send MATIC from account to account. Signing a transaction When sending MATIC, you are charged a fee for the transaction, and you must sign the transaction with the private key of the blockchain address from which the fee will be deducted. Providing the private key in the API is not a secure way of signing transactions, because the private key can be stolen or exposed. Your private keys should never leave your security perimeter. You should use the private keys only for testing a solution you are building on the testnet of a blockchain. For signing transactions on the mainnet, we strongly recommend that you use the Tatum Key Management System (KMS) and provide the signature ID instead of the private key in the API. Alternatively, you can use the Tatum JavaScript client.
        /// </remarks>
        /// <exception cref="Tatum.CSharp.Polygon.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="transferPolygonBlockchainKMS"></param>
        /// <returns>ApiResponse of SignatureId</returns>
        ApiResponse<SignatureId> PolygonBlockchainTransferWithHttpInfo(TransferPolygonBlockchainKMS transferPolygonBlockchainKMS);
        /// <summary>
        /// Broadcast signed Polygon transaction
        /// </summary>
        /// <remarks>
        /// 2 credits per API call Broadcast signed transaction to Polygon blockchain. This method is used internally from Tatum KMS or Tatum client libraries. It is possible to create custom signing mechanism and use this method only for broadcasting data to the blockchain.
        /// </remarks>
        /// <exception cref="Tatum.CSharp.Polygon.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="broadcastKMS"></param>
        /// <returns>ApiResponse of TransactionHash</returns>
        ApiResponse<TransactionHash> PolygonBroadcastWithHttpInfo(BroadcastKMS broadcastKMS);
        /// <summary>
        /// Generate Polygon account address from Extended public key
        /// </summary>
        /// <remarks>
        /// 1 credit per API call Generate Polygon account deposit address from Extended public key. Deposit address is generated for the specific index - each extended public key can generate up to 2^31 addresses starting from index 0 until 2^31.
        /// </remarks>
        /// <exception cref="Tatum.CSharp.Polygon.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="xpub">Extended public key of wallet.</param>
        /// <param name="index">Derivation index of desired address to be generated.</param>
        /// <returns>ApiResponse of GeneratedAddressMatic</returns>
        ApiResponse<GeneratedAddressMatic> PolygonGenerateAddressWithHttpInfo(string xpub, decimal index);
        /// <summary>
        /// Generate Polygon private key
        /// </summary>
        /// <remarks>
        /// 1 credit per API call Generate private key of address from mnemonic for given derivation path index. Private key is generated for the specific index - each mnemonic can generate up to 2^31 private keys starting from index 0 until 2^31.
        /// </remarks>
        /// <exception cref="Tatum.CSharp.Polygon.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="privKeyRequest"></param>
        /// <returns>ApiResponse of PrivKey</returns>
        ApiResponse<PrivKey> PolygonGenerateAddressPrivateKeyWithHttpInfo(PrivKeyRequest privKeyRequest);
        /// <summary>
        /// Generate Polygon wallet
        /// </summary>
        /// <remarks>
        /// 1 credit per API call Tatum supports BIP44 HD wallets. It is very convenient and secure, since it can generate 2^31 addresses from 1 mnemonic phrase. Mnemonic phrase consists of 24 special words in defined order and can restore access to all generated addresses and private keys. Each address is identified by 3 main values: Private Key - your secret value, which should never be revealed Public Key - public address to be published Derivation index - index of generated address Tatum follows BIP44 specification and generates for Polygon wallet with derivation path m&#39;/44&#39;/966&#39;/0&#39;/0. More about BIP44 HD wallets can be found here - https://github.com/bitcoin/bips/blob/master/bip-0044.mediawiki. Generate BIP44 compatible Polygon wallet.
        /// </remarks>
        /// <exception cref="Tatum.CSharp.Polygon.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="mnemonic">Mnemonic to use for generation of extended public and private keys. (optional)</param>
        /// <returns>ApiResponse of Wallet</returns>
        ApiResponse<Wallet> PolygonGenerateWalletWithHttpInfo(string mnemonic = default(string));
        /// <summary>
        /// Get Polygon Account balance
        /// </summary>
        /// <remarks>
        /// 1 credit per API call Get Polygon account balance in MATIC. This method does not prints any balance of the ERC20 or ERC721 tokens on the account.
        /// </remarks>
        /// <exception cref="Tatum.CSharp.Polygon.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="address">Account address you want to get balance of</param>
        /// <returns>ApiResponse of MaticBalance</returns>
        ApiResponse<MaticBalance> PolygonGetBalanceWithHttpInfo(string address);
        /// <summary>
        /// Get Polygon block by hash
        /// </summary>
        /// <remarks>
        /// 1 credit per API call Get Polygon block by block hash or block number.
        /// </remarks>
        /// <exception cref="Tatum.CSharp.Polygon.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="hash">Block hash or block number</param>
        /// <returns>ApiResponse of EthBlock</returns>
        ApiResponse<EthBlock> PolygonGetBlockWithHttpInfo(string hash);
        /// <summary>
        /// Get current block number
        /// </summary>
        /// <remarks>
        /// 1 credit per API call Get Polygon current block number. This is the number of the latest block in the blockchain.
        /// </remarks>
        /// <exception cref="Tatum.CSharp.Polygon.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <returns>ApiResponse of decimal</returns>
        ApiResponse<decimal> PolygonGetCurrentBlockWithHttpInfo();
        /// <summary>
        /// Get Polygon Transaction
        /// </summary>
        /// <remarks>
        /// 2 credits per API call Get Polygon transaction by transaction hash.
        /// </remarks>
        /// <exception cref="Tatum.CSharp.Polygon.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="hash">Transaction hash</param>
        /// <returns>ApiResponse of PolygonTx</returns>
        ApiResponse<PolygonTx> PolygonGetTransactionWithHttpInfo(string hash);
        /// <summary>
        /// Get Polygon transactions by address
        /// </summary>
        /// <remarks>
        /// 1 credit per API call Get Polygon transactions by address. This includes incoming and outgoing transactions for the address.
        /// </remarks>
        /// <exception cref="Tatum.CSharp.Polygon.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="address">Account address you want to get balance of</param>
        /// <param name="pageSize">Max number of items per page is 50.</param>
        /// <param name="offset">Offset to obtain next page of the data. (optional)</param>
        /// <param name="from">Transactions from this block onwards will be included. (optional)</param>
        /// <param name="to">Transactions up to this block will be included. (optional)</param>
        /// <param name="sort">Sorting of the data. ASC - oldest first, DESC - newest first. (optional, default to DESC)</param>
        /// <returns>ApiResponse of List&lt;PolygonTx&gt;</returns>
        ApiResponse<List<PolygonTx>> PolygonGetTransactionByAddressWithHttpInfo(string address, decimal pageSize, decimal? offset = default(decimal?), decimal? from = default(decimal?), decimal? to = default(decimal?), string sort = default(string));
        /// <summary>
        /// Get count of outgoing Polygon transactions
        /// </summary>
        /// <remarks>
        /// 1 credit per API call Get a number of outgoing Polygon transactions for the address. When a transaction is sent, there can be multiple outgoing transactions, which are not yet processed by the blockchain. To distinguish between them, there is a counter called a nonce, which represents the order of the transaction in the list of outgoing transactions.
        /// </remarks>
        /// <exception cref="Tatum.CSharp.Polygon.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="address">address</param>
        /// <returns>ApiResponse of decimal</returns>
        ApiResponse<decimal> PolygonGetTransactionCountWithHttpInfo(string address);
        #endregion Synchronous Operations With Http Info
    }

    /// <summary>
    /// Represents a collection of functions to interact with the API endpoints
    /// </summary>
    public interface IPolygonApiAsync : IApiAccessor
    {
        #region Asynchronous Operations
        /// <summary>
        /// Invoke a method in a smart contract on Polygon
        /// </summary>
        /// <remarks>
        /// 2 credits per API call Invoke a method in an existing smart contract on Polygon. You can call a read-only or write method. For read-only methods, the output of the invoked method is returned. For write methods, the ID of the associated transaction is returned. Troubleshooting a failed transaction Tatum ensures that this API works against the blockchain (accesses the blockchain, finds the specified smart contract, and executes the specified ABI method with the provided parameters). However, because this API can be run against any smart contract on the blockchain, Tatum cannot in any way guarantee that the method itself will be executed successfully. If you have issues with invoking the method, refer to the user documentation for this method, or contact the author of the smart contract. For more information about invoking methods in smart contracts, see this article on our Support Portal. Signing a transaction When invoking a method in a smart contract, you are charged a fee for the transaction, and you must sign the transaction with the private key of the blockchain address from which the fee will be deducted. If caller field is present instead of the private key, Tatum will sign the transaction with the managed private key connected to the caller address. This is applicable only for paid mainnet plans and all testnet plans. Keep in mind that the caller address must have enough access right to perform the action in the smart contract method. Providing the private key in the API is not a secure way of signing transactions, because the private key can be stolen or exposed. Your private keys should never leave your security perimeter. You should use the private keys only for testing a solution you are building on the testnet of a blockchain. For signing transactions on the mainnet, we strongly recommend that you use the Tatum Key Management System (KMS) and provide the signature ID instead of the private key in the API. Alternatively, you can use the Tatum JavaScript client.
        /// </remarks>
        /// <exception cref="Tatum.CSharp.Polygon.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="callPolygonSmartContractReadMethod"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of Data</returns>
        System.Threading.Tasks.Task<Data> PolygonBlockchainSmartContractInvocationAsync(CallPolygonSmartContractReadMethod callPolygonSmartContractReadMethod, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        /// <summary>
        /// Invoke a method in a smart contract on Polygon
        /// </summary>
        /// <remarks>
        /// 2 credits per API call Invoke a method in an existing smart contract on Polygon. You can call a read-only or write method. For read-only methods, the output of the invoked method is returned. For write methods, the ID of the associated transaction is returned. Troubleshooting a failed transaction Tatum ensures that this API works against the blockchain (accesses the blockchain, finds the specified smart contract, and executes the specified ABI method with the provided parameters). However, because this API can be run against any smart contract on the blockchain, Tatum cannot in any way guarantee that the method itself will be executed successfully. If you have issues with invoking the method, refer to the user documentation for this method, or contact the author of the smart contract. For more information about invoking methods in smart contracts, see this article on our Support Portal. Signing a transaction When invoking a method in a smart contract, you are charged a fee for the transaction, and you must sign the transaction with the private key of the blockchain address from which the fee will be deducted. If caller field is present instead of the private key, Tatum will sign the transaction with the managed private key connected to the caller address. This is applicable only for paid mainnet plans and all testnet plans. Keep in mind that the caller address must have enough access right to perform the action in the smart contract method. Providing the private key in the API is not a secure way of signing transactions, because the private key can be stolen or exposed. Your private keys should never leave your security perimeter. You should use the private keys only for testing a solution you are building on the testnet of a blockchain. For signing transactions on the mainnet, we strongly recommend that you use the Tatum Key Management System (KMS) and provide the signature ID instead of the private key in the API. Alternatively, you can use the Tatum JavaScript client.
        /// </remarks>
        /// <exception cref="Tatum.CSharp.Polygon.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="callPolygonSmartContractMethod"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of TransactionHash</returns>
        System.Threading.Tasks.Task<TransactionHash> PolygonBlockchainSmartContractInvocationAsync(CallPolygonSmartContractMethod callPolygonSmartContractMethod, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        /// <summary>
        /// Invoke a method in a smart contract on Polygon
        /// </summary>
        /// <remarks>
        /// 2 credits per API call Invoke a method in an existing smart contract on Polygon. You can call a read-only or write method. For read-only methods, the output of the invoked method is returned. For write methods, the ID of the associated transaction is returned. Troubleshooting a failed transaction Tatum ensures that this API works against the blockchain (accesses the blockchain, finds the specified smart contract, and executes the specified ABI method with the provided parameters). However, because this API can be run against any smart contract on the blockchain, Tatum cannot in any way guarantee that the method itself will be executed successfully. If you have issues with invoking the method, refer to the user documentation for this method, or contact the author of the smart contract. For more information about invoking methods in smart contracts, see this article on our Support Portal. Signing a transaction When invoking a method in a smart contract, you are charged a fee for the transaction, and you must sign the transaction with the private key of the blockchain address from which the fee will be deducted. If caller field is present instead of the private key, Tatum will sign the transaction with the managed private key connected to the caller address. This is applicable only for paid mainnet plans and all testnet plans. Keep in mind that the caller address must have enough access right to perform the action in the smart contract method. Providing the private key in the API is not a secure way of signing transactions, because the private key can be stolen or exposed. Your private keys should never leave your security perimeter. You should use the private keys only for testing a solution you are building on the testnet of a blockchain. For signing transactions on the mainnet, we strongly recommend that you use the Tatum Key Management System (KMS) and provide the signature ID instead of the private key in the API. Alternatively, you can use the Tatum JavaScript client.
        /// </remarks>
        /// <exception cref="Tatum.CSharp.Polygon.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="callPolygonSmartContractMethodCaller"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of TransactionHash</returns>
        System.Threading.Tasks.Task<TransactionHash> PolygonBlockchainSmartContractInvocationAsync(CallPolygonSmartContractMethodCaller callPolygonSmartContractMethodCaller, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        /// <summary>
        /// Invoke a method in a smart contract on Polygon
        /// </summary>
        /// <remarks>
        /// 2 credits per API call Invoke a method in an existing smart contract on Polygon. You can call a read-only or write method. For read-only methods, the output of the invoked method is returned. For write methods, the ID of the associated transaction is returned. Troubleshooting a failed transaction Tatum ensures that this API works against the blockchain (accesses the blockchain, finds the specified smart contract, and executes the specified ABI method with the provided parameters). However, because this API can be run against any smart contract on the blockchain, Tatum cannot in any way guarantee that the method itself will be executed successfully. If you have issues with invoking the method, refer to the user documentation for this method, or contact the author of the smart contract. For more information about invoking methods in smart contracts, see this article on our Support Portal. Signing a transaction When invoking a method in a smart contract, you are charged a fee for the transaction, and you must sign the transaction with the private key of the blockchain address from which the fee will be deducted. If caller field is present instead of the private key, Tatum will sign the transaction with the managed private key connected to the caller address. This is applicable only for paid mainnet plans and all testnet plans. Keep in mind that the caller address must have enough access right to perform the action in the smart contract method. Providing the private key in the API is not a secure way of signing transactions, because the private key can be stolen or exposed. Your private keys should never leave your security perimeter. You should use the private keys only for testing a solution you are building on the testnet of a blockchain. For signing transactions on the mainnet, we strongly recommend that you use the Tatum Key Management System (KMS) and provide the signature ID instead of the private key in the API. Alternatively, you can use the Tatum JavaScript client.
        /// </remarks>
        /// <exception cref="Tatum.CSharp.Polygon.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="callPolygonSmartContractMethodKMS"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of SignatureId</returns>
        System.Threading.Tasks.Task<SignatureId> PolygonBlockchainSmartContractInvocationAsync(CallPolygonSmartContractMethodKMS callPolygonSmartContractMethodKMS, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        /// <summary>
        /// Send MATIC from account to account
        /// </summary>
        /// <remarks>
        /// 2 credits per API call Send MATIC from account to account. Signing a transaction When sending MATIC, you are charged a fee for the transaction, and you must sign the transaction with the private key of the blockchain address from which the fee will be deducted. Providing the private key in the API is not a secure way of signing transactions, because the private key can be stolen or exposed. Your private keys should never leave your security perimeter. You should use the private keys only for testing a solution you are building on the testnet of a blockchain. For signing transactions on the mainnet, we strongly recommend that you use the Tatum Key Management System (KMS) and provide the signature ID instead of the private key in the API. Alternatively, you can use the Tatum JavaScript client.
        /// </remarks>
        /// <exception cref="Tatum.CSharp.Polygon.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="transferPolygonBlockchain"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of TransactionHash</returns>
        System.Threading.Tasks.Task<TransactionHash> PolygonBlockchainTransferAsync(TransferPolygonBlockchain transferPolygonBlockchain, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        /// <summary>
        /// Send MATIC from account to account
        /// </summary>
        /// <remarks>
        /// 2 credits per API call Send MATIC from account to account. Signing a transaction When sending MATIC, you are charged a fee for the transaction, and you must sign the transaction with the private key of the blockchain address from which the fee will be deducted. Providing the private key in the API is not a secure way of signing transactions, because the private key can be stolen or exposed. Your private keys should never leave your security perimeter. You should use the private keys only for testing a solution you are building on the testnet of a blockchain. For signing transactions on the mainnet, we strongly recommend that you use the Tatum Key Management System (KMS) and provide the signature ID instead of the private key in the API. Alternatively, you can use the Tatum JavaScript client.
        /// </remarks>
        /// <exception cref="Tatum.CSharp.Polygon.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="transferPolygonBlockchainKMS"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of SignatureId</returns>
        System.Threading.Tasks.Task<SignatureId> PolygonBlockchainTransferAsync(TransferPolygonBlockchainKMS transferPolygonBlockchainKMS, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        /// <summary>
        /// Broadcast signed Polygon transaction
        /// </summary>
        /// <remarks>
        /// 2 credits per API call Broadcast signed transaction to Polygon blockchain. This method is used internally from Tatum KMS or Tatum client libraries. It is possible to create custom signing mechanism and use this method only for broadcasting data to the blockchain.
        /// </remarks>
        /// <exception cref="Tatum.CSharp.Polygon.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="broadcastKMS"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of TransactionHash</returns>
        System.Threading.Tasks.Task<TransactionHash> PolygonBroadcastAsync(BroadcastKMS broadcastKMS, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        /// <summary>
        /// Generate Polygon account address from Extended public key
        /// </summary>
        /// <remarks>
        /// 1 credit per API call Generate Polygon account deposit address from Extended public key. Deposit address is generated for the specific index - each extended public key can generate up to 2^31 addresses starting from index 0 until 2^31.
        /// </remarks>
        /// <exception cref="Tatum.CSharp.Polygon.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="xpub">Extended public key of wallet.</param>
        /// <param name="index">Derivation index of desired address to be generated.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of GeneratedAddressMatic</returns>
        System.Threading.Tasks.Task<GeneratedAddressMatic> PolygonGenerateAddressAsync(string xpub, decimal index, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        /// <summary>
        /// Generate Polygon private key
        /// </summary>
        /// <remarks>
        /// 1 credit per API call Generate private key of address from mnemonic for given derivation path index. Private key is generated for the specific index - each mnemonic can generate up to 2^31 private keys starting from index 0 until 2^31.
        /// </remarks>
        /// <exception cref="Tatum.CSharp.Polygon.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="privKeyRequest"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of PrivKey</returns>
        System.Threading.Tasks.Task<PrivKey> PolygonGenerateAddressPrivateKeyAsync(PrivKeyRequest privKeyRequest, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        /// <summary>
        /// Generate Polygon wallet
        /// </summary>
        /// <remarks>
        /// 1 credit per API call Tatum supports BIP44 HD wallets. It is very convenient and secure, since it can generate 2^31 addresses from 1 mnemonic phrase. Mnemonic phrase consists of 24 special words in defined order and can restore access to all generated addresses and private keys. Each address is identified by 3 main values: Private Key - your secret value, which should never be revealed Public Key - public address to be published Derivation index - index of generated address Tatum follows BIP44 specification and generates for Polygon wallet with derivation path m&#39;/44&#39;/966&#39;/0&#39;/0. More about BIP44 HD wallets can be found here - https://github.com/bitcoin/bips/blob/master/bip-0044.mediawiki. Generate BIP44 compatible Polygon wallet.
        /// </remarks>
        /// <exception cref="Tatum.CSharp.Polygon.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="mnemonic">Mnemonic to use for generation of extended public and private keys. (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of Wallet</returns>
        System.Threading.Tasks.Task<Wallet> PolygonGenerateWalletAsync(string mnemonic = default(string), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        /// <summary>
        /// Get Polygon Account balance
        /// </summary>
        /// <remarks>
        /// 1 credit per API call Get Polygon account balance in MATIC. This method does not prints any balance of the ERC20 or ERC721 tokens on the account.
        /// </remarks>
        /// <exception cref="Tatum.CSharp.Polygon.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="address">Account address you want to get balance of</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of MaticBalance</returns>
        System.Threading.Tasks.Task<MaticBalance> PolygonGetBalanceAsync(string address, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        /// <summary>
        /// Get Polygon block by hash
        /// </summary>
        /// <remarks>
        /// 1 credit per API call Get Polygon block by block hash or block number.
        /// </remarks>
        /// <exception cref="Tatum.CSharp.Polygon.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="hash">Block hash or block number</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of EthBlock</returns>
        System.Threading.Tasks.Task<EthBlock> PolygonGetBlockAsync(string hash, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        /// <summary>
        /// Get current block number
        /// </summary>
        /// <remarks>
        /// 1 credit per API call Get Polygon current block number. This is the number of the latest block in the blockchain.
        /// </remarks>
        /// <exception cref="Tatum.CSharp.Polygon.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of decimal</returns>
        System.Threading.Tasks.Task<decimal> PolygonGetCurrentBlockAsync(System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        /// <summary>
        /// Get Polygon Transaction
        /// </summary>
        /// <remarks>
        /// 2 credits per API call Get Polygon transaction by transaction hash.
        /// </remarks>
        /// <exception cref="Tatum.CSharp.Polygon.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="hash">Transaction hash</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of PolygonTx</returns>
        System.Threading.Tasks.Task<PolygonTx> PolygonGetTransactionAsync(string hash, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        /// <summary>
        /// Get Polygon transactions by address
        /// </summary>
        /// <remarks>
        /// 1 credit per API call Get Polygon transactions by address. This includes incoming and outgoing transactions for the address.
        /// </remarks>
        /// <exception cref="Tatum.CSharp.Polygon.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="address">Account address you want to get balance of</param>
        /// <param name="pageSize">Max number of items per page is 50.</param>
        /// <param name="offset">Offset to obtain next page of the data. (optional)</param>
        /// <param name="from">Transactions from this block onwards will be included. (optional)</param>
        /// <param name="to">Transactions up to this block will be included. (optional)</param>
        /// <param name="sort">Sorting of the data. ASC - oldest first, DESC - newest first. (optional, default to DESC)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of List&lt;PolygonTx&gt;</returns>
        System.Threading.Tasks.Task<List<PolygonTx>> PolygonGetTransactionByAddressAsync(string address, decimal pageSize, decimal? offset = default(decimal?), decimal? from = default(decimal?), decimal? to = default(decimal?), string sort = default(string), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        /// <summary>
        /// Get count of outgoing Polygon transactions
        /// </summary>
        /// <remarks>
        /// 1 credit per API call Get a number of outgoing Polygon transactions for the address. When a transaction is sent, there can be multiple outgoing transactions, which are not yet processed by the blockchain. To distinguish between them, there is a counter called a nonce, which represents the order of the transaction in the list of outgoing transactions.
        /// </remarks>
        /// <exception cref="Tatum.CSharp.Polygon.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="address">address</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of decimal</returns>
        System.Threading.Tasks.Task<decimal> PolygonGetTransactionCountAsync(string address, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        #endregion Asynchronous Operations
    }

    /// <summary>
    /// Represents a collection of functions to interact with the API endpoints
    /// </summary>
    public interface IPolygonApiWithHttpInfoAsync : IApiAccessor
    {
        #region Asynchronous Operations With Http Info
        /// <summary>
        /// Invoke a method in a smart contract on Polygon
        /// </summary>
        /// <remarks>
        /// 2 credits per API call Invoke a method in an existing smart contract on Polygon. You can call a read-only or write method. For read-only methods, the output of the invoked method is returned. For write methods, the ID of the associated transaction is returned. Troubleshooting a failed transaction Tatum ensures that this API works against the blockchain (accesses the blockchain, finds the specified smart contract, and executes the specified ABI method with the provided parameters). However, because this API can be run against any smart contract on the blockchain, Tatum cannot in any way guarantee that the method itself will be executed successfully. If you have issues with invoking the method, refer to the user documentation for this method, or contact the author of the smart contract. For more information about invoking methods in smart contracts, see this article on our Support Portal. Signing a transaction When invoking a method in a smart contract, you are charged a fee for the transaction, and you must sign the transaction with the private key of the blockchain address from which the fee will be deducted. If caller field is present instead of the private key, Tatum will sign the transaction with the managed private key connected to the caller address. This is applicable only for paid mainnet plans and all testnet plans. Keep in mind that the caller address must have enough access right to perform the action in the smart contract method. Providing the private key in the API is not a secure way of signing transactions, because the private key can be stolen or exposed. Your private keys should never leave your security perimeter. You should use the private keys only for testing a solution you are building on the testnet of a blockchain. For signing transactions on the mainnet, we strongly recommend that you use the Tatum Key Management System (KMS) and provide the signature ID instead of the private key in the API. Alternatively, you can use the Tatum JavaScript client.
        /// </remarks>
        /// <exception cref="Tatum.CSharp.Polygon.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="callPolygonSmartContractReadMethod"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (Data)</returns>
        System.Threading.Tasks.Task<ApiResponse<Data>> PolygonBlockchainSmartContractInvocationWithHttpInfoAsync(CallPolygonSmartContractReadMethod callPolygonSmartContractReadMethod, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        /// <summary>
        /// Invoke a method in a smart contract on Polygon
        /// </summary>
        /// <remarks>
        /// 2 credits per API call Invoke a method in an existing smart contract on Polygon. You can call a read-only or write method. For read-only methods, the output of the invoked method is returned. For write methods, the ID of the associated transaction is returned. Troubleshooting a failed transaction Tatum ensures that this API works against the blockchain (accesses the blockchain, finds the specified smart contract, and executes the specified ABI method with the provided parameters). However, because this API can be run against any smart contract on the blockchain, Tatum cannot in any way guarantee that the method itself will be executed successfully. If you have issues with invoking the method, refer to the user documentation for this method, or contact the author of the smart contract. For more information about invoking methods in smart contracts, see this article on our Support Portal. Signing a transaction When invoking a method in a smart contract, you are charged a fee for the transaction, and you must sign the transaction with the private key of the blockchain address from which the fee will be deducted. If caller field is present instead of the private key, Tatum will sign the transaction with the managed private key connected to the caller address. This is applicable only for paid mainnet plans and all testnet plans. Keep in mind that the caller address must have enough access right to perform the action in the smart contract method. Providing the private key in the API is not a secure way of signing transactions, because the private key can be stolen or exposed. Your private keys should never leave your security perimeter. You should use the private keys only for testing a solution you are building on the testnet of a blockchain. For signing transactions on the mainnet, we strongly recommend that you use the Tatum Key Management System (KMS) and provide the signature ID instead of the private key in the API. Alternatively, you can use the Tatum JavaScript client.
        /// </remarks>
        /// <exception cref="Tatum.CSharp.Polygon.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="callPolygonSmartContractMethod"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (TransactionHash)</returns>
        System.Threading.Tasks.Task<ApiResponse<TransactionHash>> PolygonBlockchainSmartContractInvocationWithHttpInfoAsync(CallPolygonSmartContractMethod callPolygonSmartContractMethod, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        /// <summary>
        /// Invoke a method in a smart contract on Polygon
        /// </summary>
        /// <remarks>
        /// 2 credits per API call Invoke a method in an existing smart contract on Polygon. You can call a read-only or write method. For read-only methods, the output of the invoked method is returned. For write methods, the ID of the associated transaction is returned. Troubleshooting a failed transaction Tatum ensures that this API works against the blockchain (accesses the blockchain, finds the specified smart contract, and executes the specified ABI method with the provided parameters). However, because this API can be run against any smart contract on the blockchain, Tatum cannot in any way guarantee that the method itself will be executed successfully. If you have issues with invoking the method, refer to the user documentation for this method, or contact the author of the smart contract. For more information about invoking methods in smart contracts, see this article on our Support Portal. Signing a transaction When invoking a method in a smart contract, you are charged a fee for the transaction, and you must sign the transaction with the private key of the blockchain address from which the fee will be deducted. If caller field is present instead of the private key, Tatum will sign the transaction with the managed private key connected to the caller address. This is applicable only for paid mainnet plans and all testnet plans. Keep in mind that the caller address must have enough access right to perform the action in the smart contract method. Providing the private key in the API is not a secure way of signing transactions, because the private key can be stolen or exposed. Your private keys should never leave your security perimeter. You should use the private keys only for testing a solution you are building on the testnet of a blockchain. For signing transactions on the mainnet, we strongly recommend that you use the Tatum Key Management System (KMS) and provide the signature ID instead of the private key in the API. Alternatively, you can use the Tatum JavaScript client.
        /// </remarks>
        /// <exception cref="Tatum.CSharp.Polygon.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="callPolygonSmartContractMethodCaller"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (TransactionHash)</returns>
        System.Threading.Tasks.Task<ApiResponse<TransactionHash>> PolygonBlockchainSmartContractInvocationWithHttpInfoAsync(CallPolygonSmartContractMethodCaller callPolygonSmartContractMethodCaller, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        /// <summary>
        /// Invoke a method in a smart contract on Polygon
        /// </summary>
        /// <remarks>
        /// 2 credits per API call Invoke a method in an existing smart contract on Polygon. You can call a read-only or write method. For read-only methods, the output of the invoked method is returned. For write methods, the ID of the associated transaction is returned. Troubleshooting a failed transaction Tatum ensures that this API works against the blockchain (accesses the blockchain, finds the specified smart contract, and executes the specified ABI method with the provided parameters). However, because this API can be run against any smart contract on the blockchain, Tatum cannot in any way guarantee that the method itself will be executed successfully. If you have issues with invoking the method, refer to the user documentation for this method, or contact the author of the smart contract. For more information about invoking methods in smart contracts, see this article on our Support Portal. Signing a transaction When invoking a method in a smart contract, you are charged a fee for the transaction, and you must sign the transaction with the private key of the blockchain address from which the fee will be deducted. If caller field is present instead of the private key, Tatum will sign the transaction with the managed private key connected to the caller address. This is applicable only for paid mainnet plans and all testnet plans. Keep in mind that the caller address must have enough access right to perform the action in the smart contract method. Providing the private key in the API is not a secure way of signing transactions, because the private key can be stolen or exposed. Your private keys should never leave your security perimeter. You should use the private keys only for testing a solution you are building on the testnet of a blockchain. For signing transactions on the mainnet, we strongly recommend that you use the Tatum Key Management System (KMS) and provide the signature ID instead of the private key in the API. Alternatively, you can use the Tatum JavaScript client.
        /// </remarks>
        /// <exception cref="Tatum.CSharp.Polygon.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="callPolygonSmartContractMethodKMS"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (SignatureId)</returns>
        System.Threading.Tasks.Task<ApiResponse<SignatureId>> PolygonBlockchainSmartContractInvocationWithHttpInfoAsync(CallPolygonSmartContractMethodKMS callPolygonSmartContractMethodKMS, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        /// <summary>
        /// Send MATIC from account to account
        /// </summary>
        /// <remarks>
        /// 2 credits per API call Send MATIC from account to account. Signing a transaction When sending MATIC, you are charged a fee for the transaction, and you must sign the transaction with the private key of the blockchain address from which the fee will be deducted. Providing the private key in the API is not a secure way of signing transactions, because the private key can be stolen or exposed. Your private keys should never leave your security perimeter. You should use the private keys only for testing a solution you are building on the testnet of a blockchain. For signing transactions on the mainnet, we strongly recommend that you use the Tatum Key Management System (KMS) and provide the signature ID instead of the private key in the API. Alternatively, you can use the Tatum JavaScript client.
        /// </remarks>
        /// <exception cref="Tatum.CSharp.Polygon.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="transferPolygonBlockchain"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (TransactionHash)</returns>
        System.Threading.Tasks.Task<ApiResponse<TransactionHash>> PolygonBlockchainTransferWithHttpInfoAsync(TransferPolygonBlockchain transferPolygonBlockchain, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        /// <summary>
        /// Send MATIC from account to account
        /// </summary>
        /// <remarks>
        /// 2 credits per API call Send MATIC from account to account. Signing a transaction When sending MATIC, you are charged a fee for the transaction, and you must sign the transaction with the private key of the blockchain address from which the fee will be deducted. Providing the private key in the API is not a secure way of signing transactions, because the private key can be stolen or exposed. Your private keys should never leave your security perimeter. You should use the private keys only for testing a solution you are building on the testnet of a blockchain. For signing transactions on the mainnet, we strongly recommend that you use the Tatum Key Management System (KMS) and provide the signature ID instead of the private key in the API. Alternatively, you can use the Tatum JavaScript client.
        /// </remarks>
        /// <exception cref="Tatum.CSharp.Polygon.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="transferPolygonBlockchainKMS"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (SignatureId)</returns>
        System.Threading.Tasks.Task<ApiResponse<SignatureId>> PolygonBlockchainTransferWithHttpInfoAsync(TransferPolygonBlockchainKMS transferPolygonBlockchainKMS, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        /// <summary>
        /// Broadcast signed Polygon transaction
        /// </summary>
        /// <remarks>
        /// 2 credits per API call Broadcast signed transaction to Polygon blockchain. This method is used internally from Tatum KMS or Tatum client libraries. It is possible to create custom signing mechanism and use this method only for broadcasting data to the blockchain.
        /// </remarks>
        /// <exception cref="Tatum.CSharp.Polygon.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="broadcastKMS"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (TransactionHash)</returns>
        System.Threading.Tasks.Task<ApiResponse<TransactionHash>> PolygonBroadcastWithHttpInfoAsync(BroadcastKMS broadcastKMS, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        /// <summary>
        /// Generate Polygon account address from Extended public key
        /// </summary>
        /// <remarks>
        /// 1 credit per API call Generate Polygon account deposit address from Extended public key. Deposit address is generated for the specific index - each extended public key can generate up to 2^31 addresses starting from index 0 until 2^31.
        /// </remarks>
        /// <exception cref="Tatum.CSharp.Polygon.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="xpub">Extended public key of wallet.</param>
        /// <param name="index">Derivation index of desired address to be generated.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (GeneratedAddressMatic)</returns>
        System.Threading.Tasks.Task<ApiResponse<GeneratedAddressMatic>> PolygonGenerateAddressWithHttpInfoAsync(string xpub, decimal index, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        /// <summary>
        /// Generate Polygon private key
        /// </summary>
        /// <remarks>
        /// 1 credit per API call Generate private key of address from mnemonic for given derivation path index. Private key is generated for the specific index - each mnemonic can generate up to 2^31 private keys starting from index 0 until 2^31.
        /// </remarks>
        /// <exception cref="Tatum.CSharp.Polygon.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="privKeyRequest"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (PrivKey)</returns>
        System.Threading.Tasks.Task<ApiResponse<PrivKey>> PolygonGenerateAddressPrivateKeyWithHttpInfoAsync(PrivKeyRequest privKeyRequest, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        /// <summary>
        /// Generate Polygon wallet
        /// </summary>
        /// <remarks>
        /// 1 credit per API call Tatum supports BIP44 HD wallets. It is very convenient and secure, since it can generate 2^31 addresses from 1 mnemonic phrase. Mnemonic phrase consists of 24 special words in defined order and can restore access to all generated addresses and private keys. Each address is identified by 3 main values: Private Key - your secret value, which should never be revealed Public Key - public address to be published Derivation index - index of generated address Tatum follows BIP44 specification and generates for Polygon wallet with derivation path m&#39;/44&#39;/966&#39;/0&#39;/0. More about BIP44 HD wallets can be found here - https://github.com/bitcoin/bips/blob/master/bip-0044.mediawiki. Generate BIP44 compatible Polygon wallet.
        /// </remarks>
        /// <exception cref="Tatum.CSharp.Polygon.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="mnemonic">Mnemonic to use for generation of extended public and private keys. (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (Wallet)</returns>
        System.Threading.Tasks.Task<ApiResponse<Wallet>> PolygonGenerateWalletWithHttpInfoAsync(string mnemonic = default(string), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        /// <summary>
        /// Get Polygon Account balance
        /// </summary>
        /// <remarks>
        /// 1 credit per API call Get Polygon account balance in MATIC. This method does not prints any balance of the ERC20 or ERC721 tokens on the account.
        /// </remarks>
        /// <exception cref="Tatum.CSharp.Polygon.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="address">Account address you want to get balance of</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (MaticBalance)</returns>
        System.Threading.Tasks.Task<ApiResponse<MaticBalance>> PolygonGetBalanceWithHttpInfoAsync(string address, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        /// <summary>
        /// Get Polygon block by hash
        /// </summary>
        /// <remarks>
        /// 1 credit per API call Get Polygon block by block hash or block number.
        /// </remarks>
        /// <exception cref="Tatum.CSharp.Polygon.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="hash">Block hash or block number</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (EthBlock)</returns>
        System.Threading.Tasks.Task<ApiResponse<EthBlock>> PolygonGetBlockWithHttpInfoAsync(string hash, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        /// <summary>
        /// Get current block number
        /// </summary>
        /// <remarks>
        /// 1 credit per API call Get Polygon current block number. This is the number of the latest block in the blockchain.
        /// </remarks>
        /// <exception cref="Tatum.CSharp.Polygon.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (decimal)</returns>
        System.Threading.Tasks.Task<ApiResponse<decimal>> PolygonGetCurrentBlockWithHttpInfoAsync(System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        /// <summary>
        /// Get Polygon Transaction
        /// </summary>
        /// <remarks>
        /// 2 credits per API call Get Polygon transaction by transaction hash.
        /// </remarks>
        /// <exception cref="Tatum.CSharp.Polygon.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="hash">Transaction hash</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (PolygonTx)</returns>
        System.Threading.Tasks.Task<ApiResponse<PolygonTx>> PolygonGetTransactionWithHttpInfoAsync(string hash, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        /// <summary>
        /// Get Polygon transactions by address
        /// </summary>
        /// <remarks>
        /// 1 credit per API call Get Polygon transactions by address. This includes incoming and outgoing transactions for the address.
        /// </remarks>
        /// <exception cref="Tatum.CSharp.Polygon.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="address">Account address you want to get balance of</param>
        /// <param name="pageSize">Max number of items per page is 50.</param>
        /// <param name="offset">Offset to obtain next page of the data. (optional)</param>
        /// <param name="from">Transactions from this block onwards will be included. (optional)</param>
        /// <param name="to">Transactions up to this block will be included. (optional)</param>
        /// <param name="sort">Sorting of the data. ASC - oldest first, DESC - newest first. (optional, default to DESC)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (List&lt;PolygonTx&gt;)</returns>
        System.Threading.Tasks.Task<ApiResponse<List<PolygonTx>>> PolygonGetTransactionByAddressWithHttpInfoAsync(string address, decimal pageSize, decimal? offset = default(decimal?), decimal? from = default(decimal?), decimal? to = default(decimal?), string sort = default(string), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        /// <summary>
        /// Get count of outgoing Polygon transactions
        /// </summary>
        /// <remarks>
        /// 1 credit per API call Get a number of outgoing Polygon transactions for the address. When a transaction is sent, there can be multiple outgoing transactions, which are not yet processed by the blockchain. To distinguish between them, there is a counter called a nonce, which represents the order of the transaction in the list of outgoing transactions.
        /// </remarks>
        /// <exception cref="Tatum.CSharp.Polygon.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="address">address</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (decimal)</returns>
        System.Threading.Tasks.Task<ApiResponse<decimal>> PolygonGetTransactionCountWithHttpInfoAsync(string address, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        #endregion Asynchronous Operations With Http Info
    }


    /// <summary>
    /// Represents a collection of functions to interact with the API endpoints
    /// </summary>
    public interface IPolygonApi : IPolygonApiSync, IPolygonApiWithHttpInfoSync, IPolygonApiAsync, IPolygonApiWithHttpInfoAsync
    {

    }

    /// <summary>
    /// Represents a collection of functions to interact with the API endpoints
    /// </summary>
    public partial class PolygonApi : IPolygonApi
    {
        private ExceptionFactory _exceptionFactory = (name, response) => null;

        /// <summary>
        /// Initializes a new instance of the <see cref="PolygonApi"/> class.
        /// </summary>
        /// <param name="client">An instance of HttpClient.</param>
        /// <param name="handler">An optional instance of HttpClientHandler that is used by HttpClient.</param>
        /// <exception cref="ArgumentNullException"></exception>
        /// <returns></returns>
        /// <remarks>
        /// Some configuration settings will not be applied without passing an HttpClientHandler.
        /// The features affected are: Setting and Retrieving Cookies, Client Certificates, Proxy settings.
        /// </remarks>
        public PolygonApi(HttpClient client, HttpClientHandler handler = null) : this(client, (string)null, handler)
        {
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="PolygonApi"/> class.
        /// </summary>
        /// <param name="client">An instance of HttpClient.</param>
        /// <param name="basePath">The target service's base path in URL format.</param>
        /// <param name="handler">An optional instance of HttpClientHandler that is used by HttpClient.</param>
        /// <exception cref="ArgumentNullException"></exception>
        /// <exception cref="ArgumentException"></exception>
        /// <returns></returns>
        /// <remarks>
        /// Some configuration settings will not be applied without passing an HttpClientHandler.
        /// The features affected are: Setting and Retrieving Cookies, Client Certificates, Proxy settings.
        /// </remarks>
        public PolygonApi(HttpClient client, string basePath, HttpClientHandler handler = null)
        {
            if (client == null) throw new ArgumentNullException(nameof(client));

            Configuration = Tatum.CSharp.Polygon.Core.Client.Configuration.MergeConfigurations(
                GlobalConfiguration.Instance,
                new Configuration { BasePath = basePath }
            );
            ApiClient = new ApiClient(client, Configuration.BasePath, handler);
            Client =  ApiClient;
            AsynchronousClient = ApiClient;
            ExceptionFactory = Tatum.CSharp.Polygon.Core.Client.Configuration.DefaultExceptionFactory;
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="PolygonApi"/> class using Configuration object.
        /// </summary>
        /// <param name="client">An instance of HttpClient.</param>
        /// <param name="configuration">An instance of Configuration.</param>
        /// <param name="handler">An optional instance of HttpClientHandler that is used by HttpClient.</param>
        /// <exception cref="ArgumentNullException"></exception>
        /// <returns></returns>
        /// <remarks>
        /// Some configuration settings will not be applied without passing an HttpClientHandler.
        /// The features affected are: Setting and Retrieving Cookies, Client Certificates, Proxy settings.
        /// </remarks>
        public PolygonApi(HttpClient client, Configuration configuration, HttpClientHandler handler = null)
        {
            if (configuration == null) throw new ArgumentNullException(nameof(configuration));
            if (client == null) throw new ArgumentNullException(nameof(client));

            Configuration = Tatum.CSharp.Polygon.Core.Client.Configuration.MergeConfigurations(
                GlobalConfiguration.Instance,
                configuration
            );
            ApiClient = new ApiClient(client, Configuration.BasePath, handler);
            Client = ApiClient;
            AsynchronousClient = ApiClient;
            ExceptionFactory = Tatum.CSharp.Polygon.Core.Client.Configuration.DefaultExceptionFactory;
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="PolygonApi"/> class
        /// using a Configuration object and client instance.
        /// </summary>
        /// <param name="client">The client interface for synchronous API access.</param>
        /// <param name="asyncClient">The client interface for asynchronous API access.</param>
        /// <param name="configuration">The configuration object.</param>
        /// <exception cref="ArgumentNullException"></exception>
        public PolygonApi(ISynchronousClient client, IAsynchronousClient asyncClient, IReadableConfiguration configuration)
        {
            Client = client ?? throw new ArgumentNullException(nameof(client));
            AsynchronousClient = asyncClient ?? throw new ArgumentNullException(nameof(asyncClient));
            Configuration = configuration ?? throw new ArgumentNullException(nameof(configuration));
            ExceptionFactory = Tatum.CSharp.Polygon.Core.Client.Configuration.DefaultExceptionFactory;
        }

        /// <summary>
        /// Holds the ApiClient if created
        /// </summary>
        public ApiClient ApiClient { get; set; }

        /// <summary>
        /// The client for accessing this underlying API asynchronously.
        /// </summary>
        public IAsynchronousClient AsynchronousClient { get; set; }

        /// <summary>
        /// The client for accessing this underlying API synchronously.
        /// </summary>
        public ISynchronousClient Client { get; set; }

        /// <summary>
        /// Gets the base path of the API client.
        /// </summary>
        /// <value>The base path</value>
        public string GetBasePath()
        {
            return Configuration.BasePath;
        }

        /// <summary>
        /// Gets or sets the configuration object
        /// </summary>
        /// <value>An instance of the Configuration</value>
        public IReadableConfiguration Configuration { get; set; }

        /// <summary>
        /// Provides a factory method hook for the creation of exceptions.
        /// </summary>
        public ExceptionFactory ExceptionFactory
        {
            get
            {
                if (_exceptionFactory != null && _exceptionFactory.GetInvocationList().Length > 1)
                {
                    throw new InvalidOperationException("Multicast delegate for ExceptionFactory is unsupported.");
                }
                return _exceptionFactory;
            }
            set => _exceptionFactory = value;
        }

        /// <summary>
        /// Invoke a method in a smart contract on Polygon 2 credits per API call Invoke a method in an existing smart contract on Polygon. You can call a read-only or write method. For read-only methods, the output of the invoked method is returned. For write methods, the ID of the associated transaction is returned. Troubleshooting a failed transaction Tatum ensures that this API works against the blockchain (accesses the blockchain, finds the specified smart contract, and executes the specified ABI method with the provided parameters). However, because this API can be run against any smart contract on the blockchain, Tatum cannot in any way guarantee that the method itself will be executed successfully. If you have issues with invoking the method, refer to the user documentation for this method, or contact the author of the smart contract. For more information about invoking methods in smart contracts, see this article on our Support Portal. Signing a transaction When invoking a method in a smart contract, you are charged a fee for the transaction, and you must sign the transaction with the private key of the blockchain address from which the fee will be deducted. If caller field is present instead of the private key, Tatum will sign the transaction with the managed private key connected to the caller address. This is applicable only for paid mainnet plans and all testnet plans. Keep in mind that the caller address must have enough access right to perform the action in the smart contract method. Providing the private key in the API is not a secure way of signing transactions, because the private key can be stolen or exposed. Your private keys should never leave your security perimeter. You should use the private keys only for testing a solution you are building on the testnet of a blockchain. For signing transactions on the mainnet, we strongly recommend that you use the Tatum Key Management System (KMS) and provide the signature ID instead of the private key in the API. Alternatively, you can use the Tatum JavaScript client.
        /// </summary>
        /// <exception cref="Tatum.CSharp.Polygon.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="callPolygonSmartContractReadMethod"></param>
        /// <returns>Data</returns>
        public Data PolygonBlockchainSmartContractInvocation(CallPolygonSmartContractReadMethod callPolygonSmartContractReadMethod)
        {
            var localVarResponse = PolygonBlockchainSmartContractInvocationWithHttpInfo(callPolygonSmartContractReadMethod);

            var exception = ExceptionFactory?.Invoke("PolygonBlockchainSmartContractInvocation", localVarResponse);
            if (exception != null) throw exception;

            return localVarResponse.Data;
        }

        /// <summary>
        /// Invoke a method in a smart contract on Polygon 2 credits per API call Invoke a method in an existing smart contract on Polygon. You can call a read-only or write method. For read-only methods, the output of the invoked method is returned. For write methods, the ID of the associated transaction is returned. Troubleshooting a failed transaction Tatum ensures that this API works against the blockchain (accesses the blockchain, finds the specified smart contract, and executes the specified ABI method with the provided parameters). However, because this API can be run against any smart contract on the blockchain, Tatum cannot in any way guarantee that the method itself will be executed successfully. If you have issues with invoking the method, refer to the user documentation for this method, or contact the author of the smart contract. For more information about invoking methods in smart contracts, see this article on our Support Portal. Signing a transaction When invoking a method in a smart contract, you are charged a fee for the transaction, and you must sign the transaction with the private key of the blockchain address from which the fee will be deducted. If caller field is present instead of the private key, Tatum will sign the transaction with the managed private key connected to the caller address. This is applicable only for paid mainnet plans and all testnet plans. Keep in mind that the caller address must have enough access right to perform the action in the smart contract method. Providing the private key in the API is not a secure way of signing transactions, because the private key can be stolen or exposed. Your private keys should never leave your security perimeter. You should use the private keys only for testing a solution you are building on the testnet of a blockchain. For signing transactions on the mainnet, we strongly recommend that you use the Tatum Key Management System (KMS) and provide the signature ID instead of the private key in the API. Alternatively, you can use the Tatum JavaScript client.
        /// </summary>
        /// <exception cref="Tatum.CSharp.Polygon.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="callPolygonSmartContractReadMethod"></param>
        /// <returns>ApiResponse of Data</returns>
        public ApiResponse<Data> PolygonBlockchainSmartContractInvocationWithHttpInfo(CallPolygonSmartContractReadMethod callPolygonSmartContractReadMethod)
        {
            // verify the required parameter 'callPolygonSmartContractReadMethod' is set
            if (callPolygonSmartContractReadMethod == null)
                throw new ApiException(400, "Missing required parameter 'callPolygonSmartContractReadMethod' when calling PolygonApi->PolygonBlockchainSmartContractInvocation");

            var localVarRequestOptions = new RequestOptions();

            var contentTypes = new string[]{
                "application/json"
            };

            // to determine the Accept header
            var accepts = new string[]{
                "application/json"
            };

            var localVarContentType = ClientUtils.SelectHeaderContentType(contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = ClientUtils.SelectHeaderAccept(accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.Data = callPolygonSmartContractReadMethod;

            // authentication (X-API-Key) required
            if (!string.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("x-api-key")))
            {
                localVarRequestOptions.HeaderParameters.Add("x-api-key", Configuration.GetApiKeyWithPrefix("x-api-key"));
            }

            // make the HTTP request
            var localVarResponse = Client.Post<Data>("/v3/polygon/smartcontract", localVarRequestOptions, Configuration);

            return localVarResponse;
        }

        /// <summary>
        /// Invoke a method in a smart contract on Polygon 2 credits per API call Invoke a method in an existing smart contract on Polygon. You can call a read-only or write method. For read-only methods, the output of the invoked method is returned. For write methods, the ID of the associated transaction is returned. Troubleshooting a failed transaction Tatum ensures that this API works against the blockchain (accesses the blockchain, finds the specified smart contract, and executes the specified ABI method with the provided parameters). However, because this API can be run against any smart contract on the blockchain, Tatum cannot in any way guarantee that the method itself will be executed successfully. If you have issues with invoking the method, refer to the user documentation for this method, or contact the author of the smart contract. For more information about invoking methods in smart contracts, see this article on our Support Portal. Signing a transaction When invoking a method in a smart contract, you are charged a fee for the transaction, and you must sign the transaction with the private key of the blockchain address from which the fee will be deducted. If caller field is present instead of the private key, Tatum will sign the transaction with the managed private key connected to the caller address. This is applicable only for paid mainnet plans and all testnet plans. Keep in mind that the caller address must have enough access right to perform the action in the smart contract method. Providing the private key in the API is not a secure way of signing transactions, because the private key can be stolen or exposed. Your private keys should never leave your security perimeter. You should use the private keys only for testing a solution you are building on the testnet of a blockchain. For signing transactions on the mainnet, we strongly recommend that you use the Tatum Key Management System (KMS) and provide the signature ID instead of the private key in the API. Alternatively, you can use the Tatum JavaScript client.
        /// </summary>
        /// <exception cref="Tatum.CSharp.Polygon.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="callPolygonSmartContractReadMethod"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of Data</returns>
        public async System.Threading.Tasks.Task<Data> PolygonBlockchainSmartContractInvocationAsync(CallPolygonSmartContractReadMethod callPolygonSmartContractReadMethod, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            var localVarResponse = await PolygonBlockchainSmartContractInvocationWithHttpInfoAsync(callPolygonSmartContractReadMethod, cancellationToken).ConfigureAwait(false);
            
            var exception = ExceptionFactory?.Invoke("PolygonBlockchainSmartContractInvocation", localVarResponse);
            if (exception != null) throw exception;

            return localVarResponse.Data;
        }

        /// <summary>
        /// Invoke a method in a smart contract on Polygon 2 credits per API call Invoke a method in an existing smart contract on Polygon. You can call a read-only or write method. For read-only methods, the output of the invoked method is returned. For write methods, the ID of the associated transaction is returned. Troubleshooting a failed transaction Tatum ensures that this API works against the blockchain (accesses the blockchain, finds the specified smart contract, and executes the specified ABI method with the provided parameters). However, because this API can be run against any smart contract on the blockchain, Tatum cannot in any way guarantee that the method itself will be executed successfully. If you have issues with invoking the method, refer to the user documentation for this method, or contact the author of the smart contract. For more information about invoking methods in smart contracts, see this article on our Support Portal. Signing a transaction When invoking a method in a smart contract, you are charged a fee for the transaction, and you must sign the transaction with the private key of the blockchain address from which the fee will be deducted. If caller field is present instead of the private key, Tatum will sign the transaction with the managed private key connected to the caller address. This is applicable only for paid mainnet plans and all testnet plans. Keep in mind that the caller address must have enough access right to perform the action in the smart contract method. Providing the private key in the API is not a secure way of signing transactions, because the private key can be stolen or exposed. Your private keys should never leave your security perimeter. You should use the private keys only for testing a solution you are building on the testnet of a blockchain. For signing transactions on the mainnet, we strongly recommend that you use the Tatum Key Management System (KMS) and provide the signature ID instead of the private key in the API. Alternatively, you can use the Tatum JavaScript client.
        /// </summary>
        /// <exception cref="Tatum.CSharp.Polygon.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="callPolygonSmartContractReadMethod"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (Data)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<Data>> PolygonBlockchainSmartContractInvocationWithHttpInfoAsync(CallPolygonSmartContractReadMethod callPolygonSmartContractReadMethod, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            // verify the required parameter 'callPolygonSmartContractReadMethod' is set
            if (callPolygonSmartContractReadMethod == null)
                throw new ApiException(400, "Missing required parameter 'callPolygonSmartContractReadMethod' when calling PolygonApi->PolygonBlockchainSmartContractInvocation");

            var localVarRequestOptions = new RequestOptions();

            var contentTypes = new string[]{
                "application/json"
            };

            // to determine the Accept header
            var accepts = new string[]{
                "application/json"
            };


            var localVarContentType = ClientUtils.SelectHeaderContentType(contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = ClientUtils.SelectHeaderAccept(accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.Data = callPolygonSmartContractReadMethod;

            // authentication (X-API-Key) required
            if (!string.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("x-api-key")))
            {
                localVarRequestOptions.HeaderParameters.Add("x-api-key", Configuration.GetApiKeyWithPrefix("x-api-key"));
            }

            // make the HTTP request

            var localVarResponse = await AsynchronousClient.PostAsync<Data>("/v3/polygon/smartcontract", localVarRequestOptions, Configuration, cancellationToken).ConfigureAwait(false);

            return localVarResponse;
        }

        /// <summary>
        /// Invoke a method in a smart contract on Polygon 2 credits per API call Invoke a method in an existing smart contract on Polygon. You can call a read-only or write method. For read-only methods, the output of the invoked method is returned. For write methods, the ID of the associated transaction is returned. Troubleshooting a failed transaction Tatum ensures that this API works against the blockchain (accesses the blockchain, finds the specified smart contract, and executes the specified ABI method with the provided parameters). However, because this API can be run against any smart contract on the blockchain, Tatum cannot in any way guarantee that the method itself will be executed successfully. If you have issues with invoking the method, refer to the user documentation for this method, or contact the author of the smart contract. For more information about invoking methods in smart contracts, see this article on our Support Portal. Signing a transaction When invoking a method in a smart contract, you are charged a fee for the transaction, and you must sign the transaction with the private key of the blockchain address from which the fee will be deducted. If caller field is present instead of the private key, Tatum will sign the transaction with the managed private key connected to the caller address. This is applicable only for paid mainnet plans and all testnet plans. Keep in mind that the caller address must have enough access right to perform the action in the smart contract method. Providing the private key in the API is not a secure way of signing transactions, because the private key can be stolen or exposed. Your private keys should never leave your security perimeter. You should use the private keys only for testing a solution you are building on the testnet of a blockchain. For signing transactions on the mainnet, we strongly recommend that you use the Tatum Key Management System (KMS) and provide the signature ID instead of the private key in the API. Alternatively, you can use the Tatum JavaScript client.
        /// </summary>
        /// <exception cref="Tatum.CSharp.Polygon.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="callPolygonSmartContractMethod"></param>
        /// <returns>TransactionHash</returns>
        public TransactionHash PolygonBlockchainSmartContractInvocation(CallPolygonSmartContractMethod callPolygonSmartContractMethod)
        {
            var localVarResponse = PolygonBlockchainSmartContractInvocationWithHttpInfo(callPolygonSmartContractMethod);

            var exception = ExceptionFactory?.Invoke("PolygonBlockchainSmartContractInvocation_0", localVarResponse);
            if (exception != null) throw exception;

            return localVarResponse.Data;
        }

        /// <summary>
        /// Invoke a method in a smart contract on Polygon 2 credits per API call Invoke a method in an existing smart contract on Polygon. You can call a read-only or write method. For read-only methods, the output of the invoked method is returned. For write methods, the ID of the associated transaction is returned. Troubleshooting a failed transaction Tatum ensures that this API works against the blockchain (accesses the blockchain, finds the specified smart contract, and executes the specified ABI method with the provided parameters). However, because this API can be run against any smart contract on the blockchain, Tatum cannot in any way guarantee that the method itself will be executed successfully. If you have issues with invoking the method, refer to the user documentation for this method, or contact the author of the smart contract. For more information about invoking methods in smart contracts, see this article on our Support Portal. Signing a transaction When invoking a method in a smart contract, you are charged a fee for the transaction, and you must sign the transaction with the private key of the blockchain address from which the fee will be deducted. If caller field is present instead of the private key, Tatum will sign the transaction with the managed private key connected to the caller address. This is applicable only for paid mainnet plans and all testnet plans. Keep in mind that the caller address must have enough access right to perform the action in the smart contract method. Providing the private key in the API is not a secure way of signing transactions, because the private key can be stolen or exposed. Your private keys should never leave your security perimeter. You should use the private keys only for testing a solution you are building on the testnet of a blockchain. For signing transactions on the mainnet, we strongly recommend that you use the Tatum Key Management System (KMS) and provide the signature ID instead of the private key in the API. Alternatively, you can use the Tatum JavaScript client.
        /// </summary>
        /// <exception cref="Tatum.CSharp.Polygon.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="callPolygonSmartContractMethod"></param>
        /// <returns>ApiResponse of TransactionHash</returns>
        public ApiResponse<TransactionHash> PolygonBlockchainSmartContractInvocationWithHttpInfo(CallPolygonSmartContractMethod callPolygonSmartContractMethod)
        {
            // verify the required parameter 'callPolygonSmartContractMethod' is set
            if (callPolygonSmartContractMethod == null)
                throw new ApiException(400, "Missing required parameter 'callPolygonSmartContractMethod' when calling PolygonApi->PolygonBlockchainSmartContractInvocation_0");

            var localVarRequestOptions = new RequestOptions();

            var contentTypes = new string[]{
                "application/json"
            };

            // to determine the Accept header
            var accepts = new string[]{
                "application/json"
            };

            var localVarContentType = ClientUtils.SelectHeaderContentType(contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = ClientUtils.SelectHeaderAccept(accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.Data = callPolygonSmartContractMethod;

            // authentication (X-API-Key) required
            if (!string.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("x-api-key")))
            {
                localVarRequestOptions.HeaderParameters.Add("x-api-key", Configuration.GetApiKeyWithPrefix("x-api-key"));
            }

            // make the HTTP request
            var localVarResponse = Client.Post<TransactionHash>("/v3/polygon/smartcontract", localVarRequestOptions, Configuration);

            return localVarResponse;
        }

        /// <summary>
        /// Invoke a method in a smart contract on Polygon 2 credits per API call Invoke a method in an existing smart contract on Polygon. You can call a read-only or write method. For read-only methods, the output of the invoked method is returned. For write methods, the ID of the associated transaction is returned. Troubleshooting a failed transaction Tatum ensures that this API works against the blockchain (accesses the blockchain, finds the specified smart contract, and executes the specified ABI method with the provided parameters). However, because this API can be run against any smart contract on the blockchain, Tatum cannot in any way guarantee that the method itself will be executed successfully. If you have issues with invoking the method, refer to the user documentation for this method, or contact the author of the smart contract. For more information about invoking methods in smart contracts, see this article on our Support Portal. Signing a transaction When invoking a method in a smart contract, you are charged a fee for the transaction, and you must sign the transaction with the private key of the blockchain address from which the fee will be deducted. If caller field is present instead of the private key, Tatum will sign the transaction with the managed private key connected to the caller address. This is applicable only for paid mainnet plans and all testnet plans. Keep in mind that the caller address must have enough access right to perform the action in the smart contract method. Providing the private key in the API is not a secure way of signing transactions, because the private key can be stolen or exposed. Your private keys should never leave your security perimeter. You should use the private keys only for testing a solution you are building on the testnet of a blockchain. For signing transactions on the mainnet, we strongly recommend that you use the Tatum Key Management System (KMS) and provide the signature ID instead of the private key in the API. Alternatively, you can use the Tatum JavaScript client.
        /// </summary>
        /// <exception cref="Tatum.CSharp.Polygon.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="callPolygonSmartContractMethod"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of TransactionHash</returns>
        public async System.Threading.Tasks.Task<TransactionHash> PolygonBlockchainSmartContractInvocationAsync(CallPolygonSmartContractMethod callPolygonSmartContractMethod, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            var localVarResponse = await PolygonBlockchainSmartContractInvocationWithHttpInfoAsync(callPolygonSmartContractMethod, cancellationToken).ConfigureAwait(false);
            
            var exception = ExceptionFactory?.Invoke("PolygonBlockchainSmartContractInvocation_0", localVarResponse);
            if (exception != null) throw exception;

            return localVarResponse.Data;
        }

        /// <summary>
        /// Invoke a method in a smart contract on Polygon 2 credits per API call Invoke a method in an existing smart contract on Polygon. You can call a read-only or write method. For read-only methods, the output of the invoked method is returned. For write methods, the ID of the associated transaction is returned. Troubleshooting a failed transaction Tatum ensures that this API works against the blockchain (accesses the blockchain, finds the specified smart contract, and executes the specified ABI method with the provided parameters). However, because this API can be run against any smart contract on the blockchain, Tatum cannot in any way guarantee that the method itself will be executed successfully. If you have issues with invoking the method, refer to the user documentation for this method, or contact the author of the smart contract. For more information about invoking methods in smart contracts, see this article on our Support Portal. Signing a transaction When invoking a method in a smart contract, you are charged a fee for the transaction, and you must sign the transaction with the private key of the blockchain address from which the fee will be deducted. If caller field is present instead of the private key, Tatum will sign the transaction with the managed private key connected to the caller address. This is applicable only for paid mainnet plans and all testnet plans. Keep in mind that the caller address must have enough access right to perform the action in the smart contract method. Providing the private key in the API is not a secure way of signing transactions, because the private key can be stolen or exposed. Your private keys should never leave your security perimeter. You should use the private keys only for testing a solution you are building on the testnet of a blockchain. For signing transactions on the mainnet, we strongly recommend that you use the Tatum Key Management System (KMS) and provide the signature ID instead of the private key in the API. Alternatively, you can use the Tatum JavaScript client.
        /// </summary>
        /// <exception cref="Tatum.CSharp.Polygon.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="callPolygonSmartContractMethod"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (TransactionHash)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<TransactionHash>> PolygonBlockchainSmartContractInvocationWithHttpInfoAsync(CallPolygonSmartContractMethod callPolygonSmartContractMethod, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            // verify the required parameter 'callPolygonSmartContractMethod' is set
            if (callPolygonSmartContractMethod == null)
                throw new ApiException(400, "Missing required parameter 'callPolygonSmartContractMethod' when calling PolygonApi->PolygonBlockchainSmartContractInvocation_0");

            var localVarRequestOptions = new RequestOptions();

            var contentTypes = new string[]{
                "application/json"
            };

            // to determine the Accept header
            var accepts = new string[]{
                "application/json"
            };


            var localVarContentType = ClientUtils.SelectHeaderContentType(contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = ClientUtils.SelectHeaderAccept(accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.Data = callPolygonSmartContractMethod;

            // authentication (X-API-Key) required
            if (!string.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("x-api-key")))
            {
                localVarRequestOptions.HeaderParameters.Add("x-api-key", Configuration.GetApiKeyWithPrefix("x-api-key"));
            }

            // make the HTTP request

            var localVarResponse = await AsynchronousClient.PostAsync<TransactionHash>("/v3/polygon/smartcontract", localVarRequestOptions, Configuration, cancellationToken).ConfigureAwait(false);

            return localVarResponse;
        }

        /// <summary>
        /// Invoke a method in a smart contract on Polygon 2 credits per API call Invoke a method in an existing smart contract on Polygon. You can call a read-only or write method. For read-only methods, the output of the invoked method is returned. For write methods, the ID of the associated transaction is returned. Troubleshooting a failed transaction Tatum ensures that this API works against the blockchain (accesses the blockchain, finds the specified smart contract, and executes the specified ABI method with the provided parameters). However, because this API can be run against any smart contract on the blockchain, Tatum cannot in any way guarantee that the method itself will be executed successfully. If you have issues with invoking the method, refer to the user documentation for this method, or contact the author of the smart contract. For more information about invoking methods in smart contracts, see this article on our Support Portal. Signing a transaction When invoking a method in a smart contract, you are charged a fee for the transaction, and you must sign the transaction with the private key of the blockchain address from which the fee will be deducted. If caller field is present instead of the private key, Tatum will sign the transaction with the managed private key connected to the caller address. This is applicable only for paid mainnet plans and all testnet plans. Keep in mind that the caller address must have enough access right to perform the action in the smart contract method. Providing the private key in the API is not a secure way of signing transactions, because the private key can be stolen or exposed. Your private keys should never leave your security perimeter. You should use the private keys only for testing a solution you are building on the testnet of a blockchain. For signing transactions on the mainnet, we strongly recommend that you use the Tatum Key Management System (KMS) and provide the signature ID instead of the private key in the API. Alternatively, you can use the Tatum JavaScript client.
        /// </summary>
        /// <exception cref="Tatum.CSharp.Polygon.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="callPolygonSmartContractMethodCaller"></param>
        /// <returns>TransactionHash</returns>
        public TransactionHash PolygonBlockchainSmartContractInvocation(CallPolygonSmartContractMethodCaller callPolygonSmartContractMethodCaller)
        {
            var localVarResponse = PolygonBlockchainSmartContractInvocationWithHttpInfo(callPolygonSmartContractMethodCaller);

            var exception = ExceptionFactory?.Invoke("PolygonBlockchainSmartContractInvocation_1", localVarResponse);
            if (exception != null) throw exception;

            return localVarResponse.Data;
        }

        /// <summary>
        /// Invoke a method in a smart contract on Polygon 2 credits per API call Invoke a method in an existing smart contract on Polygon. You can call a read-only or write method. For read-only methods, the output of the invoked method is returned. For write methods, the ID of the associated transaction is returned. Troubleshooting a failed transaction Tatum ensures that this API works against the blockchain (accesses the blockchain, finds the specified smart contract, and executes the specified ABI method with the provided parameters). However, because this API can be run against any smart contract on the blockchain, Tatum cannot in any way guarantee that the method itself will be executed successfully. If you have issues with invoking the method, refer to the user documentation for this method, or contact the author of the smart contract. For more information about invoking methods in smart contracts, see this article on our Support Portal. Signing a transaction When invoking a method in a smart contract, you are charged a fee for the transaction, and you must sign the transaction with the private key of the blockchain address from which the fee will be deducted. If caller field is present instead of the private key, Tatum will sign the transaction with the managed private key connected to the caller address. This is applicable only for paid mainnet plans and all testnet plans. Keep in mind that the caller address must have enough access right to perform the action in the smart contract method. Providing the private key in the API is not a secure way of signing transactions, because the private key can be stolen or exposed. Your private keys should never leave your security perimeter. You should use the private keys only for testing a solution you are building on the testnet of a blockchain. For signing transactions on the mainnet, we strongly recommend that you use the Tatum Key Management System (KMS) and provide the signature ID instead of the private key in the API. Alternatively, you can use the Tatum JavaScript client.
        /// </summary>
        /// <exception cref="Tatum.CSharp.Polygon.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="callPolygonSmartContractMethodCaller"></param>
        /// <returns>ApiResponse of TransactionHash</returns>
        public ApiResponse<TransactionHash> PolygonBlockchainSmartContractInvocationWithHttpInfo(CallPolygonSmartContractMethodCaller callPolygonSmartContractMethodCaller)
        {
            // verify the required parameter 'callPolygonSmartContractMethodCaller' is set
            if (callPolygonSmartContractMethodCaller == null)
                throw new ApiException(400, "Missing required parameter 'callPolygonSmartContractMethodCaller' when calling PolygonApi->PolygonBlockchainSmartContractInvocation_1");

            var localVarRequestOptions = new RequestOptions();

            var contentTypes = new string[]{
                "application/json"
            };

            // to determine the Accept header
            var accepts = new string[]{
                "application/json"
            };

            var localVarContentType = ClientUtils.SelectHeaderContentType(contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = ClientUtils.SelectHeaderAccept(accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.Data = callPolygonSmartContractMethodCaller;

            // authentication (X-API-Key) required
            if (!string.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("x-api-key")))
            {
                localVarRequestOptions.HeaderParameters.Add("x-api-key", Configuration.GetApiKeyWithPrefix("x-api-key"));
            }

            // make the HTTP request
            var localVarResponse = Client.Post<TransactionHash>("/v3/polygon/smartcontract", localVarRequestOptions, Configuration);

            return localVarResponse;
        }

        /// <summary>
        /// Invoke a method in a smart contract on Polygon 2 credits per API call Invoke a method in an existing smart contract on Polygon. You can call a read-only or write method. For read-only methods, the output of the invoked method is returned. For write methods, the ID of the associated transaction is returned. Troubleshooting a failed transaction Tatum ensures that this API works against the blockchain (accesses the blockchain, finds the specified smart contract, and executes the specified ABI method with the provided parameters). However, because this API can be run against any smart contract on the blockchain, Tatum cannot in any way guarantee that the method itself will be executed successfully. If you have issues with invoking the method, refer to the user documentation for this method, or contact the author of the smart contract. For more information about invoking methods in smart contracts, see this article on our Support Portal. Signing a transaction When invoking a method in a smart contract, you are charged a fee for the transaction, and you must sign the transaction with the private key of the blockchain address from which the fee will be deducted. If caller field is present instead of the private key, Tatum will sign the transaction with the managed private key connected to the caller address. This is applicable only for paid mainnet plans and all testnet plans. Keep in mind that the caller address must have enough access right to perform the action in the smart contract method. Providing the private key in the API is not a secure way of signing transactions, because the private key can be stolen or exposed. Your private keys should never leave your security perimeter. You should use the private keys only for testing a solution you are building on the testnet of a blockchain. For signing transactions on the mainnet, we strongly recommend that you use the Tatum Key Management System (KMS) and provide the signature ID instead of the private key in the API. Alternatively, you can use the Tatum JavaScript client.
        /// </summary>
        /// <exception cref="Tatum.CSharp.Polygon.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="callPolygonSmartContractMethodCaller"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of TransactionHash</returns>
        public async System.Threading.Tasks.Task<TransactionHash> PolygonBlockchainSmartContractInvocationAsync(CallPolygonSmartContractMethodCaller callPolygonSmartContractMethodCaller, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            var localVarResponse = await PolygonBlockchainSmartContractInvocationWithHttpInfoAsync(callPolygonSmartContractMethodCaller, cancellationToken).ConfigureAwait(false);
            
            var exception = ExceptionFactory?.Invoke("PolygonBlockchainSmartContractInvocation_1", localVarResponse);
            if (exception != null) throw exception;

            return localVarResponse.Data;
        }

        /// <summary>
        /// Invoke a method in a smart contract on Polygon 2 credits per API call Invoke a method in an existing smart contract on Polygon. You can call a read-only or write method. For read-only methods, the output of the invoked method is returned. For write methods, the ID of the associated transaction is returned. Troubleshooting a failed transaction Tatum ensures that this API works against the blockchain (accesses the blockchain, finds the specified smart contract, and executes the specified ABI method with the provided parameters). However, because this API can be run against any smart contract on the blockchain, Tatum cannot in any way guarantee that the method itself will be executed successfully. If you have issues with invoking the method, refer to the user documentation for this method, or contact the author of the smart contract. For more information about invoking methods in smart contracts, see this article on our Support Portal. Signing a transaction When invoking a method in a smart contract, you are charged a fee for the transaction, and you must sign the transaction with the private key of the blockchain address from which the fee will be deducted. If caller field is present instead of the private key, Tatum will sign the transaction with the managed private key connected to the caller address. This is applicable only for paid mainnet plans and all testnet plans. Keep in mind that the caller address must have enough access right to perform the action in the smart contract method. Providing the private key in the API is not a secure way of signing transactions, because the private key can be stolen or exposed. Your private keys should never leave your security perimeter. You should use the private keys only for testing a solution you are building on the testnet of a blockchain. For signing transactions on the mainnet, we strongly recommend that you use the Tatum Key Management System (KMS) and provide the signature ID instead of the private key in the API. Alternatively, you can use the Tatum JavaScript client.
        /// </summary>
        /// <exception cref="Tatum.CSharp.Polygon.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="callPolygonSmartContractMethodCaller"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (TransactionHash)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<TransactionHash>> PolygonBlockchainSmartContractInvocationWithHttpInfoAsync(CallPolygonSmartContractMethodCaller callPolygonSmartContractMethodCaller, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            // verify the required parameter 'callPolygonSmartContractMethodCaller' is set
            if (callPolygonSmartContractMethodCaller == null)
                throw new ApiException(400, "Missing required parameter 'callPolygonSmartContractMethodCaller' when calling PolygonApi->PolygonBlockchainSmartContractInvocation_1");

            var localVarRequestOptions = new RequestOptions();

            var contentTypes = new string[]{
                "application/json"
            };

            // to determine the Accept header
            var accepts = new string[]{
                "application/json"
            };


            var localVarContentType = ClientUtils.SelectHeaderContentType(contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = ClientUtils.SelectHeaderAccept(accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.Data = callPolygonSmartContractMethodCaller;

            // authentication (X-API-Key) required
            if (!string.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("x-api-key")))
            {
                localVarRequestOptions.HeaderParameters.Add("x-api-key", Configuration.GetApiKeyWithPrefix("x-api-key"));
            }

            // make the HTTP request

            var localVarResponse = await AsynchronousClient.PostAsync<TransactionHash>("/v3/polygon/smartcontract", localVarRequestOptions, Configuration, cancellationToken).ConfigureAwait(false);

            return localVarResponse;
        }

        /// <summary>
        /// Invoke a method in a smart contract on Polygon 2 credits per API call Invoke a method in an existing smart contract on Polygon. You can call a read-only or write method. For read-only methods, the output of the invoked method is returned. For write methods, the ID of the associated transaction is returned. Troubleshooting a failed transaction Tatum ensures that this API works against the blockchain (accesses the blockchain, finds the specified smart contract, and executes the specified ABI method with the provided parameters). However, because this API can be run against any smart contract on the blockchain, Tatum cannot in any way guarantee that the method itself will be executed successfully. If you have issues with invoking the method, refer to the user documentation for this method, or contact the author of the smart contract. For more information about invoking methods in smart contracts, see this article on our Support Portal. Signing a transaction When invoking a method in a smart contract, you are charged a fee for the transaction, and you must sign the transaction with the private key of the blockchain address from which the fee will be deducted. If caller field is present instead of the private key, Tatum will sign the transaction with the managed private key connected to the caller address. This is applicable only for paid mainnet plans and all testnet plans. Keep in mind that the caller address must have enough access right to perform the action in the smart contract method. Providing the private key in the API is not a secure way of signing transactions, because the private key can be stolen or exposed. Your private keys should never leave your security perimeter. You should use the private keys only for testing a solution you are building on the testnet of a blockchain. For signing transactions on the mainnet, we strongly recommend that you use the Tatum Key Management System (KMS) and provide the signature ID instead of the private key in the API. Alternatively, you can use the Tatum JavaScript client.
        /// </summary>
        /// <exception cref="Tatum.CSharp.Polygon.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="callPolygonSmartContractMethodKMS"></param>
        /// <returns>SignatureId</returns>
        public SignatureId PolygonBlockchainSmartContractInvocation(CallPolygonSmartContractMethodKMS callPolygonSmartContractMethodKMS)
        {
            var localVarResponse = PolygonBlockchainSmartContractInvocationWithHttpInfo(callPolygonSmartContractMethodKMS);

            var exception = ExceptionFactory?.Invoke("PolygonBlockchainSmartContractInvocation_2", localVarResponse);
            if (exception != null) throw exception;

            return localVarResponse.Data;
        }

        /// <summary>
        /// Invoke a method in a smart contract on Polygon 2 credits per API call Invoke a method in an existing smart contract on Polygon. You can call a read-only or write method. For read-only methods, the output of the invoked method is returned. For write methods, the ID of the associated transaction is returned. Troubleshooting a failed transaction Tatum ensures that this API works against the blockchain (accesses the blockchain, finds the specified smart contract, and executes the specified ABI method with the provided parameters). However, because this API can be run against any smart contract on the blockchain, Tatum cannot in any way guarantee that the method itself will be executed successfully. If you have issues with invoking the method, refer to the user documentation for this method, or contact the author of the smart contract. For more information about invoking methods in smart contracts, see this article on our Support Portal. Signing a transaction When invoking a method in a smart contract, you are charged a fee for the transaction, and you must sign the transaction with the private key of the blockchain address from which the fee will be deducted. If caller field is present instead of the private key, Tatum will sign the transaction with the managed private key connected to the caller address. This is applicable only for paid mainnet plans and all testnet plans. Keep in mind that the caller address must have enough access right to perform the action in the smart contract method. Providing the private key in the API is not a secure way of signing transactions, because the private key can be stolen or exposed. Your private keys should never leave your security perimeter. You should use the private keys only for testing a solution you are building on the testnet of a blockchain. For signing transactions on the mainnet, we strongly recommend that you use the Tatum Key Management System (KMS) and provide the signature ID instead of the private key in the API. Alternatively, you can use the Tatum JavaScript client.
        /// </summary>
        /// <exception cref="Tatum.CSharp.Polygon.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="callPolygonSmartContractMethodKMS"></param>
        /// <returns>ApiResponse of SignatureId</returns>
        public ApiResponse<SignatureId> PolygonBlockchainSmartContractInvocationWithHttpInfo(CallPolygonSmartContractMethodKMS callPolygonSmartContractMethodKMS)
        {
            // verify the required parameter 'callPolygonSmartContractMethodKMS' is set
            if (callPolygonSmartContractMethodKMS == null)
                throw new ApiException(400, "Missing required parameter 'callPolygonSmartContractMethodKMS' when calling PolygonApi->PolygonBlockchainSmartContractInvocation_2");

            var localVarRequestOptions = new RequestOptions();

            var contentTypes = new string[]{
                "application/json"
            };

            // to determine the Accept header
            var accepts = new string[]{
                "application/json"
            };

            var localVarContentType = ClientUtils.SelectHeaderContentType(contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = ClientUtils.SelectHeaderAccept(accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.Data = callPolygonSmartContractMethodKMS;

            // authentication (X-API-Key) required
            if (!string.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("x-api-key")))
            {
                localVarRequestOptions.HeaderParameters.Add("x-api-key", Configuration.GetApiKeyWithPrefix("x-api-key"));
            }

            // make the HTTP request
            var localVarResponse = Client.Post<SignatureId>("/v3/polygon/smartcontract", localVarRequestOptions, Configuration);

            return localVarResponse;
        }

        /// <summary>
        /// Invoke a method in a smart contract on Polygon 2 credits per API call Invoke a method in an existing smart contract on Polygon. You can call a read-only or write method. For read-only methods, the output of the invoked method is returned. For write methods, the ID of the associated transaction is returned. Troubleshooting a failed transaction Tatum ensures that this API works against the blockchain (accesses the blockchain, finds the specified smart contract, and executes the specified ABI method with the provided parameters). However, because this API can be run against any smart contract on the blockchain, Tatum cannot in any way guarantee that the method itself will be executed successfully. If you have issues with invoking the method, refer to the user documentation for this method, or contact the author of the smart contract. For more information about invoking methods in smart contracts, see this article on our Support Portal. Signing a transaction When invoking a method in a smart contract, you are charged a fee for the transaction, and you must sign the transaction with the private key of the blockchain address from which the fee will be deducted. If caller field is present instead of the private key, Tatum will sign the transaction with the managed private key connected to the caller address. This is applicable only for paid mainnet plans and all testnet plans. Keep in mind that the caller address must have enough access right to perform the action in the smart contract method. Providing the private key in the API is not a secure way of signing transactions, because the private key can be stolen or exposed. Your private keys should never leave your security perimeter. You should use the private keys only for testing a solution you are building on the testnet of a blockchain. For signing transactions on the mainnet, we strongly recommend that you use the Tatum Key Management System (KMS) and provide the signature ID instead of the private key in the API. Alternatively, you can use the Tatum JavaScript client.
        /// </summary>
        /// <exception cref="Tatum.CSharp.Polygon.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="callPolygonSmartContractMethodKMS"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of SignatureId</returns>
        public async System.Threading.Tasks.Task<SignatureId> PolygonBlockchainSmartContractInvocationAsync(CallPolygonSmartContractMethodKMS callPolygonSmartContractMethodKMS, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            var localVarResponse = await PolygonBlockchainSmartContractInvocationWithHttpInfoAsync(callPolygonSmartContractMethodKMS, cancellationToken).ConfigureAwait(false);
            
            var exception = ExceptionFactory?.Invoke("PolygonBlockchainSmartContractInvocation_2", localVarResponse);
            if (exception != null) throw exception;

            return localVarResponse.Data;
        }

        /// <summary>
        /// Invoke a method in a smart contract on Polygon 2 credits per API call Invoke a method in an existing smart contract on Polygon. You can call a read-only or write method. For read-only methods, the output of the invoked method is returned. For write methods, the ID of the associated transaction is returned. Troubleshooting a failed transaction Tatum ensures that this API works against the blockchain (accesses the blockchain, finds the specified smart contract, and executes the specified ABI method with the provided parameters). However, because this API can be run against any smart contract on the blockchain, Tatum cannot in any way guarantee that the method itself will be executed successfully. If you have issues with invoking the method, refer to the user documentation for this method, or contact the author of the smart contract. For more information about invoking methods in smart contracts, see this article on our Support Portal. Signing a transaction When invoking a method in a smart contract, you are charged a fee for the transaction, and you must sign the transaction with the private key of the blockchain address from which the fee will be deducted. If caller field is present instead of the private key, Tatum will sign the transaction with the managed private key connected to the caller address. This is applicable only for paid mainnet plans and all testnet plans. Keep in mind that the caller address must have enough access right to perform the action in the smart contract method. Providing the private key in the API is not a secure way of signing transactions, because the private key can be stolen or exposed. Your private keys should never leave your security perimeter. You should use the private keys only for testing a solution you are building on the testnet of a blockchain. For signing transactions on the mainnet, we strongly recommend that you use the Tatum Key Management System (KMS) and provide the signature ID instead of the private key in the API. Alternatively, you can use the Tatum JavaScript client.
        /// </summary>
        /// <exception cref="Tatum.CSharp.Polygon.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="callPolygonSmartContractMethodKMS"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (SignatureId)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<SignatureId>> PolygonBlockchainSmartContractInvocationWithHttpInfoAsync(CallPolygonSmartContractMethodKMS callPolygonSmartContractMethodKMS, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            // verify the required parameter 'callPolygonSmartContractMethodKMS' is set
            if (callPolygonSmartContractMethodKMS == null)
                throw new ApiException(400, "Missing required parameter 'callPolygonSmartContractMethodKMS' when calling PolygonApi->PolygonBlockchainSmartContractInvocation_2");

            var localVarRequestOptions = new RequestOptions();

            var contentTypes = new string[]{
                "application/json"
            };

            // to determine the Accept header
            var accepts = new string[]{
                "application/json"
            };


            var localVarContentType = ClientUtils.SelectHeaderContentType(contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = ClientUtils.SelectHeaderAccept(accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.Data = callPolygonSmartContractMethodKMS;

            // authentication (X-API-Key) required
            if (!string.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("x-api-key")))
            {
                localVarRequestOptions.HeaderParameters.Add("x-api-key", Configuration.GetApiKeyWithPrefix("x-api-key"));
            }

            // make the HTTP request

            var localVarResponse = await AsynchronousClient.PostAsync<SignatureId>("/v3/polygon/smartcontract", localVarRequestOptions, Configuration, cancellationToken).ConfigureAwait(false);

            return localVarResponse;
        }

        /// <summary>
        /// Send MATIC from account to account 2 credits per API call Send MATIC from account to account. Signing a transaction When sending MATIC, you are charged a fee for the transaction, and you must sign the transaction with the private key of the blockchain address from which the fee will be deducted. Providing the private key in the API is not a secure way of signing transactions, because the private key can be stolen or exposed. Your private keys should never leave your security perimeter. You should use the private keys only for testing a solution you are building on the testnet of a blockchain. For signing transactions on the mainnet, we strongly recommend that you use the Tatum Key Management System (KMS) and provide the signature ID instead of the private key in the API. Alternatively, you can use the Tatum JavaScript client.
        /// </summary>
        /// <exception cref="Tatum.CSharp.Polygon.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="transferPolygonBlockchain"></param>
        /// <returns>TransactionHash</returns>
        public TransactionHash PolygonBlockchainTransfer(TransferPolygonBlockchain transferPolygonBlockchain)
        {
            var localVarResponse = PolygonBlockchainTransferWithHttpInfo(transferPolygonBlockchain);

            var exception = ExceptionFactory?.Invoke("PolygonBlockchainTransfer", localVarResponse);
            if (exception != null) throw exception;

            return localVarResponse.Data;
        }

        /// <summary>
        /// Send MATIC from account to account 2 credits per API call Send MATIC from account to account. Signing a transaction When sending MATIC, you are charged a fee for the transaction, and you must sign the transaction with the private key of the blockchain address from which the fee will be deducted. Providing the private key in the API is not a secure way of signing transactions, because the private key can be stolen or exposed. Your private keys should never leave your security perimeter. You should use the private keys only for testing a solution you are building on the testnet of a blockchain. For signing transactions on the mainnet, we strongly recommend that you use the Tatum Key Management System (KMS) and provide the signature ID instead of the private key in the API. Alternatively, you can use the Tatum JavaScript client.
        /// </summary>
        /// <exception cref="Tatum.CSharp.Polygon.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="transferPolygonBlockchain"></param>
        /// <returns>ApiResponse of TransactionHash</returns>
        public ApiResponse<TransactionHash> PolygonBlockchainTransferWithHttpInfo(TransferPolygonBlockchain transferPolygonBlockchain)
        {
            // verify the required parameter 'transferPolygonBlockchain' is set
            if (transferPolygonBlockchain == null)
                throw new ApiException(400, "Missing required parameter 'transferPolygonBlockchain' when calling PolygonApi->PolygonBlockchainTransfer");

            var localVarRequestOptions = new RequestOptions();

            var contentTypes = new string[]{
                "application/json"
            };

            // to determine the Accept header
            var accepts = new string[]{
                "application/json"
            };

            var localVarContentType = ClientUtils.SelectHeaderContentType(contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = ClientUtils.SelectHeaderAccept(accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.Data = transferPolygonBlockchain;

            // authentication (X-API-Key) required
            if (!string.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("x-api-key")))
            {
                localVarRequestOptions.HeaderParameters.Add("x-api-key", Configuration.GetApiKeyWithPrefix("x-api-key"));
            }

            // make the HTTP request
            var localVarResponse = Client.Post<TransactionHash>("/v3/polygon/transaction", localVarRequestOptions, Configuration);

            return localVarResponse;
        }

        /// <summary>
        /// Send MATIC from account to account 2 credits per API call Send MATIC from account to account. Signing a transaction When sending MATIC, you are charged a fee for the transaction, and you must sign the transaction with the private key of the blockchain address from which the fee will be deducted. Providing the private key in the API is not a secure way of signing transactions, because the private key can be stolen or exposed. Your private keys should never leave your security perimeter. You should use the private keys only for testing a solution you are building on the testnet of a blockchain. For signing transactions on the mainnet, we strongly recommend that you use the Tatum Key Management System (KMS) and provide the signature ID instead of the private key in the API. Alternatively, you can use the Tatum JavaScript client.
        /// </summary>
        /// <exception cref="Tatum.CSharp.Polygon.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="transferPolygonBlockchain"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of TransactionHash</returns>
        public async System.Threading.Tasks.Task<TransactionHash> PolygonBlockchainTransferAsync(TransferPolygonBlockchain transferPolygonBlockchain, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            var localVarResponse = await PolygonBlockchainTransferWithHttpInfoAsync(transferPolygonBlockchain, cancellationToken).ConfigureAwait(false);
            
            var exception = ExceptionFactory?.Invoke("PolygonBlockchainTransfer", localVarResponse);
            if (exception != null) throw exception;

            return localVarResponse.Data;
        }

        /// <summary>
        /// Send MATIC from account to account 2 credits per API call Send MATIC from account to account. Signing a transaction When sending MATIC, you are charged a fee for the transaction, and you must sign the transaction with the private key of the blockchain address from which the fee will be deducted. Providing the private key in the API is not a secure way of signing transactions, because the private key can be stolen or exposed. Your private keys should never leave your security perimeter. You should use the private keys only for testing a solution you are building on the testnet of a blockchain. For signing transactions on the mainnet, we strongly recommend that you use the Tatum Key Management System (KMS) and provide the signature ID instead of the private key in the API. Alternatively, you can use the Tatum JavaScript client.
        /// </summary>
        /// <exception cref="Tatum.CSharp.Polygon.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="transferPolygonBlockchain"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (TransactionHash)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<TransactionHash>> PolygonBlockchainTransferWithHttpInfoAsync(TransferPolygonBlockchain transferPolygonBlockchain, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            // verify the required parameter 'transferPolygonBlockchain' is set
            if (transferPolygonBlockchain == null)
                throw new ApiException(400, "Missing required parameter 'transferPolygonBlockchain' when calling PolygonApi->PolygonBlockchainTransfer");

            var localVarRequestOptions = new RequestOptions();

            var contentTypes = new string[]{
                "application/json"
            };

            // to determine the Accept header
            var accepts = new string[]{
                "application/json"
            };


            var localVarContentType = ClientUtils.SelectHeaderContentType(contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = ClientUtils.SelectHeaderAccept(accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.Data = transferPolygonBlockchain;

            // authentication (X-API-Key) required
            if (!string.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("x-api-key")))
            {
                localVarRequestOptions.HeaderParameters.Add("x-api-key", Configuration.GetApiKeyWithPrefix("x-api-key"));
            }

            // make the HTTP request

            var localVarResponse = await AsynchronousClient.PostAsync<TransactionHash>("/v3/polygon/transaction", localVarRequestOptions, Configuration, cancellationToken).ConfigureAwait(false);

            return localVarResponse;
        }

        /// <summary>
        /// Send MATIC from account to account 2 credits per API call Send MATIC from account to account. Signing a transaction When sending MATIC, you are charged a fee for the transaction, and you must sign the transaction with the private key of the blockchain address from which the fee will be deducted. Providing the private key in the API is not a secure way of signing transactions, because the private key can be stolen or exposed. Your private keys should never leave your security perimeter. You should use the private keys only for testing a solution you are building on the testnet of a blockchain. For signing transactions on the mainnet, we strongly recommend that you use the Tatum Key Management System (KMS) and provide the signature ID instead of the private key in the API. Alternatively, you can use the Tatum JavaScript client.
        /// </summary>
        /// <exception cref="Tatum.CSharp.Polygon.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="transferPolygonBlockchainKMS"></param>
        /// <returns>SignatureId</returns>
        public SignatureId PolygonBlockchainTransfer(TransferPolygonBlockchainKMS transferPolygonBlockchainKMS)
        {
            var localVarResponse = PolygonBlockchainTransferWithHttpInfo(transferPolygonBlockchainKMS);

            var exception = ExceptionFactory?.Invoke("PolygonBlockchainTransfer_0", localVarResponse);
            if (exception != null) throw exception;

            return localVarResponse.Data;
        }

        /// <summary>
        /// Send MATIC from account to account 2 credits per API call Send MATIC from account to account. Signing a transaction When sending MATIC, you are charged a fee for the transaction, and you must sign the transaction with the private key of the blockchain address from which the fee will be deducted. Providing the private key in the API is not a secure way of signing transactions, because the private key can be stolen or exposed. Your private keys should never leave your security perimeter. You should use the private keys only for testing a solution you are building on the testnet of a blockchain. For signing transactions on the mainnet, we strongly recommend that you use the Tatum Key Management System (KMS) and provide the signature ID instead of the private key in the API. Alternatively, you can use the Tatum JavaScript client.
        /// </summary>
        /// <exception cref="Tatum.CSharp.Polygon.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="transferPolygonBlockchainKMS"></param>
        /// <returns>ApiResponse of SignatureId</returns>
        public ApiResponse<SignatureId> PolygonBlockchainTransferWithHttpInfo(TransferPolygonBlockchainKMS transferPolygonBlockchainKMS)
        {
            // verify the required parameter 'transferPolygonBlockchainKMS' is set
            if (transferPolygonBlockchainKMS == null)
                throw new ApiException(400, "Missing required parameter 'transferPolygonBlockchainKMS' when calling PolygonApi->PolygonBlockchainTransfer_0");

            var localVarRequestOptions = new RequestOptions();

            var contentTypes = new string[]{
                "application/json"
            };

            // to determine the Accept header
            var accepts = new string[]{
                "application/json"
            };

            var localVarContentType = ClientUtils.SelectHeaderContentType(contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = ClientUtils.SelectHeaderAccept(accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.Data = transferPolygonBlockchainKMS;

            // authentication (X-API-Key) required
            if (!string.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("x-api-key")))
            {
                localVarRequestOptions.HeaderParameters.Add("x-api-key", Configuration.GetApiKeyWithPrefix("x-api-key"));
            }

            // make the HTTP request
            var localVarResponse = Client.Post<SignatureId>("/v3/polygon/transaction", localVarRequestOptions, Configuration);

            return localVarResponse;
        }

        /// <summary>
        /// Send MATIC from account to account 2 credits per API call Send MATIC from account to account. Signing a transaction When sending MATIC, you are charged a fee for the transaction, and you must sign the transaction with the private key of the blockchain address from which the fee will be deducted. Providing the private key in the API is not a secure way of signing transactions, because the private key can be stolen or exposed. Your private keys should never leave your security perimeter. You should use the private keys only for testing a solution you are building on the testnet of a blockchain. For signing transactions on the mainnet, we strongly recommend that you use the Tatum Key Management System (KMS) and provide the signature ID instead of the private key in the API. Alternatively, you can use the Tatum JavaScript client.
        /// </summary>
        /// <exception cref="Tatum.CSharp.Polygon.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="transferPolygonBlockchainKMS"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of SignatureId</returns>
        public async System.Threading.Tasks.Task<SignatureId> PolygonBlockchainTransferAsync(TransferPolygonBlockchainKMS transferPolygonBlockchainKMS, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            var localVarResponse = await PolygonBlockchainTransferWithHttpInfoAsync(transferPolygonBlockchainKMS, cancellationToken).ConfigureAwait(false);
            
            var exception = ExceptionFactory?.Invoke("PolygonBlockchainTransfer_0", localVarResponse);
            if (exception != null) throw exception;

            return localVarResponse.Data;
        }

        /// <summary>
        /// Send MATIC from account to account 2 credits per API call Send MATIC from account to account. Signing a transaction When sending MATIC, you are charged a fee for the transaction, and you must sign the transaction with the private key of the blockchain address from which the fee will be deducted. Providing the private key in the API is not a secure way of signing transactions, because the private key can be stolen or exposed. Your private keys should never leave your security perimeter. You should use the private keys only for testing a solution you are building on the testnet of a blockchain. For signing transactions on the mainnet, we strongly recommend that you use the Tatum Key Management System (KMS) and provide the signature ID instead of the private key in the API. Alternatively, you can use the Tatum JavaScript client.
        /// </summary>
        /// <exception cref="Tatum.CSharp.Polygon.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="transferPolygonBlockchainKMS"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (SignatureId)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<SignatureId>> PolygonBlockchainTransferWithHttpInfoAsync(TransferPolygonBlockchainKMS transferPolygonBlockchainKMS, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            // verify the required parameter 'transferPolygonBlockchainKMS' is set
            if (transferPolygonBlockchainKMS == null)
                throw new ApiException(400, "Missing required parameter 'transferPolygonBlockchainKMS' when calling PolygonApi->PolygonBlockchainTransfer_0");

            var localVarRequestOptions = new RequestOptions();

            var contentTypes = new string[]{
                "application/json"
            };

            // to determine the Accept header
            var accepts = new string[]{
                "application/json"
            };


            var localVarContentType = ClientUtils.SelectHeaderContentType(contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = ClientUtils.SelectHeaderAccept(accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.Data = transferPolygonBlockchainKMS;

            // authentication (X-API-Key) required
            if (!string.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("x-api-key")))
            {
                localVarRequestOptions.HeaderParameters.Add("x-api-key", Configuration.GetApiKeyWithPrefix("x-api-key"));
            }

            // make the HTTP request

            var localVarResponse = await AsynchronousClient.PostAsync<SignatureId>("/v3/polygon/transaction", localVarRequestOptions, Configuration, cancellationToken).ConfigureAwait(false);

            return localVarResponse;
        }

        /// <summary>
        /// Broadcast signed Polygon transaction 2 credits per API call Broadcast signed transaction to Polygon blockchain. This method is used internally from Tatum KMS or Tatum client libraries. It is possible to create custom signing mechanism and use this method only for broadcasting data to the blockchain.
        /// </summary>
        /// <exception cref="Tatum.CSharp.Polygon.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="broadcastKMS"></param>
        /// <returns>TransactionHash</returns>
        public TransactionHash PolygonBroadcast(BroadcastKMS broadcastKMS)
        {
            var localVarResponse = PolygonBroadcastWithHttpInfo(broadcastKMS);

            var exception = ExceptionFactory?.Invoke("PolygonBroadcast", localVarResponse);
            if (exception != null) throw exception;

            return localVarResponse.Data;
        }

        /// <summary>
        /// Broadcast signed Polygon transaction 2 credits per API call Broadcast signed transaction to Polygon blockchain. This method is used internally from Tatum KMS or Tatum client libraries. It is possible to create custom signing mechanism and use this method only for broadcasting data to the blockchain.
        /// </summary>
        /// <exception cref="Tatum.CSharp.Polygon.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="broadcastKMS"></param>
        /// <returns>ApiResponse of TransactionHash</returns>
        public ApiResponse<TransactionHash> PolygonBroadcastWithHttpInfo(BroadcastKMS broadcastKMS)
        {
            // verify the required parameter 'broadcastKMS' is set
            if (broadcastKMS == null)
                throw new ApiException(400, "Missing required parameter 'broadcastKMS' when calling PolygonApi->PolygonBroadcast");

            var localVarRequestOptions = new RequestOptions();

            var contentTypes = new string[]{
                "application/json"
            };

            // to determine the Accept header
            var accepts = new string[]{
                "application/json"
            };

            var localVarContentType = ClientUtils.SelectHeaderContentType(contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = ClientUtils.SelectHeaderAccept(accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.Data = broadcastKMS;

            // authentication (X-API-Key) required
            if (!string.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("x-api-key")))
            {
                localVarRequestOptions.HeaderParameters.Add("x-api-key", Configuration.GetApiKeyWithPrefix("x-api-key"));
            }

            // make the HTTP request
            var localVarResponse = Client.Post<TransactionHash>("/v3/polygon/broadcast", localVarRequestOptions, Configuration);

            return localVarResponse;
        }

        /// <summary>
        /// Broadcast signed Polygon transaction 2 credits per API call Broadcast signed transaction to Polygon blockchain. This method is used internally from Tatum KMS or Tatum client libraries. It is possible to create custom signing mechanism and use this method only for broadcasting data to the blockchain.
        /// </summary>
        /// <exception cref="Tatum.CSharp.Polygon.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="broadcastKMS"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of TransactionHash</returns>
        public async System.Threading.Tasks.Task<TransactionHash> PolygonBroadcastAsync(BroadcastKMS broadcastKMS, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            var localVarResponse = await PolygonBroadcastWithHttpInfoAsync(broadcastKMS, cancellationToken).ConfigureAwait(false);
            
            var exception = ExceptionFactory?.Invoke("PolygonBroadcast", localVarResponse);
            if (exception != null) throw exception;

            return localVarResponse.Data;
        }

        /// <summary>
        /// Broadcast signed Polygon transaction 2 credits per API call Broadcast signed transaction to Polygon blockchain. This method is used internally from Tatum KMS or Tatum client libraries. It is possible to create custom signing mechanism and use this method only for broadcasting data to the blockchain.
        /// </summary>
        /// <exception cref="Tatum.CSharp.Polygon.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="broadcastKMS"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (TransactionHash)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<TransactionHash>> PolygonBroadcastWithHttpInfoAsync(BroadcastKMS broadcastKMS, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            // verify the required parameter 'broadcastKMS' is set
            if (broadcastKMS == null)
                throw new ApiException(400, "Missing required parameter 'broadcastKMS' when calling PolygonApi->PolygonBroadcast");

            var localVarRequestOptions = new RequestOptions();

            var contentTypes = new string[]{
                "application/json"
            };

            // to determine the Accept header
            var accepts = new string[]{
                "application/json"
            };


            var localVarContentType = ClientUtils.SelectHeaderContentType(contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = ClientUtils.SelectHeaderAccept(accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.Data = broadcastKMS;

            // authentication (X-API-Key) required
            if (!string.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("x-api-key")))
            {
                localVarRequestOptions.HeaderParameters.Add("x-api-key", Configuration.GetApiKeyWithPrefix("x-api-key"));
            }

            // make the HTTP request

            var localVarResponse = await AsynchronousClient.PostAsync<TransactionHash>("/v3/polygon/broadcast", localVarRequestOptions, Configuration, cancellationToken).ConfigureAwait(false);

            return localVarResponse;
        }

        /// <summary>
        /// Generate Polygon account address from Extended public key 1 credit per API call Generate Polygon account deposit address from Extended public key. Deposit address is generated for the specific index - each extended public key can generate up to 2^31 addresses starting from index 0 until 2^31.
        /// </summary>
        /// <exception cref="Tatum.CSharp.Polygon.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="xpub">Extended public key of wallet.</param>
        /// <param name="index">Derivation index of desired address to be generated.</param>
        /// <returns>GeneratedAddressMatic</returns>
        public GeneratedAddressMatic PolygonGenerateAddress(string xpub, decimal index)
        {
            var localVarResponse = PolygonGenerateAddressWithHttpInfo(xpub, index);

            var exception = ExceptionFactory?.Invoke("PolygonGenerateAddress", localVarResponse);
            if (exception != null) throw exception;

            return localVarResponse.Data;
        }

        /// <summary>
        /// Generate Polygon account address from Extended public key 1 credit per API call Generate Polygon account deposit address from Extended public key. Deposit address is generated for the specific index - each extended public key can generate up to 2^31 addresses starting from index 0 until 2^31.
        /// </summary>
        /// <exception cref="Tatum.CSharp.Polygon.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="xpub">Extended public key of wallet.</param>
        /// <param name="index">Derivation index of desired address to be generated.</param>
        /// <returns>ApiResponse of GeneratedAddressMatic</returns>
        public ApiResponse<GeneratedAddressMatic> PolygonGenerateAddressWithHttpInfo(string xpub, decimal index)
        {
            // verify the required parameter 'xpub' is set
            if (xpub == null)
                throw new ApiException(400, "Missing required parameter 'xpub' when calling PolygonApi->PolygonGenerateAddress");

            var localVarRequestOptions = new RequestOptions();

            var contentTypes = new string[]{
            };

            // to determine the Accept header
            var accepts = new string[]{
                "application/json"
            };

            var localVarContentType = ClientUtils.SelectHeaderContentType(contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = ClientUtils.SelectHeaderAccept(accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.PathParameters.Add("xpub", ClientUtils.ParameterToString(xpub)); // path parameter
            localVarRequestOptions.PathParameters.Add("index", ClientUtils.ParameterToString(index)); // path parameter

            // authentication (X-API-Key) required
            if (!string.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("x-api-key")))
            {
                localVarRequestOptions.HeaderParameters.Add("x-api-key", Configuration.GetApiKeyWithPrefix("x-api-key"));
            }

            // make the HTTP request
            var localVarResponse = Client.Get<GeneratedAddressMatic>("/v3/polygon/address/{xpub}/{index}", localVarRequestOptions, Configuration);

            return localVarResponse;
        }

        /// <summary>
        /// Generate Polygon account address from Extended public key 1 credit per API call Generate Polygon account deposit address from Extended public key. Deposit address is generated for the specific index - each extended public key can generate up to 2^31 addresses starting from index 0 until 2^31.
        /// </summary>
        /// <exception cref="Tatum.CSharp.Polygon.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="xpub">Extended public key of wallet.</param>
        /// <param name="index">Derivation index of desired address to be generated.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of GeneratedAddressMatic</returns>
        public async System.Threading.Tasks.Task<GeneratedAddressMatic> PolygonGenerateAddressAsync(string xpub, decimal index, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            var localVarResponse = await PolygonGenerateAddressWithHttpInfoAsync(xpub, index, cancellationToken).ConfigureAwait(false);
            
            var exception = ExceptionFactory?.Invoke("PolygonGenerateAddress", localVarResponse);
            if (exception != null) throw exception;

            return localVarResponse.Data;
        }

        /// <summary>
        /// Generate Polygon account address from Extended public key 1 credit per API call Generate Polygon account deposit address from Extended public key. Deposit address is generated for the specific index - each extended public key can generate up to 2^31 addresses starting from index 0 until 2^31.
        /// </summary>
        /// <exception cref="Tatum.CSharp.Polygon.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="xpub">Extended public key of wallet.</param>
        /// <param name="index">Derivation index of desired address to be generated.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (GeneratedAddressMatic)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<GeneratedAddressMatic>> PolygonGenerateAddressWithHttpInfoAsync(string xpub, decimal index, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            // verify the required parameter 'xpub' is set
            if (xpub == null)
                throw new ApiException(400, "Missing required parameter 'xpub' when calling PolygonApi->PolygonGenerateAddress");

            var localVarRequestOptions = new RequestOptions();

            var contentTypes = new string[]{
            };

            // to determine the Accept header
            var accepts = new string[]{
                "application/json"
            };


            var localVarContentType = ClientUtils.SelectHeaderContentType(contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = ClientUtils.SelectHeaderAccept(accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.PathParameters.Add("xpub", ClientUtils.ParameterToString(xpub)); // path parameter
            localVarRequestOptions.PathParameters.Add("index", ClientUtils.ParameterToString(index)); // path parameter

            // authentication (X-API-Key) required
            if (!string.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("x-api-key")))
            {
                localVarRequestOptions.HeaderParameters.Add("x-api-key", Configuration.GetApiKeyWithPrefix("x-api-key"));
            }

            // make the HTTP request

            var localVarResponse = await AsynchronousClient.GetAsync<GeneratedAddressMatic>("/v3/polygon/address/{xpub}/{index}", localVarRequestOptions, Configuration, cancellationToken).ConfigureAwait(false);

            return localVarResponse;
        }

        /// <summary>
        /// Generate Polygon private key 1 credit per API call Generate private key of address from mnemonic for given derivation path index. Private key is generated for the specific index - each mnemonic can generate up to 2^31 private keys starting from index 0 until 2^31.
        /// </summary>
        /// <exception cref="Tatum.CSharp.Polygon.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="privKeyRequest"></param>
        /// <returns>PrivKey</returns>
        public PrivKey PolygonGenerateAddressPrivateKey(PrivKeyRequest privKeyRequest)
        {
            var localVarResponse = PolygonGenerateAddressPrivateKeyWithHttpInfo(privKeyRequest);

            var exception = ExceptionFactory?.Invoke("PolygonGenerateAddressPrivateKey", localVarResponse);
            if (exception != null) throw exception;

            return localVarResponse.Data;
        }

        /// <summary>
        /// Generate Polygon private key 1 credit per API call Generate private key of address from mnemonic for given derivation path index. Private key is generated for the specific index - each mnemonic can generate up to 2^31 private keys starting from index 0 until 2^31.
        /// </summary>
        /// <exception cref="Tatum.CSharp.Polygon.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="privKeyRequest"></param>
        /// <returns>ApiResponse of PrivKey</returns>
        public ApiResponse<PrivKey> PolygonGenerateAddressPrivateKeyWithHttpInfo(PrivKeyRequest privKeyRequest)
        {
            // verify the required parameter 'privKeyRequest' is set
            if (privKeyRequest == null)
                throw new ApiException(400, "Missing required parameter 'privKeyRequest' when calling PolygonApi->PolygonGenerateAddressPrivateKey");

            var localVarRequestOptions = new RequestOptions();

            var contentTypes = new string[]{
                "application/json"
            };

            // to determine the Accept header
            var accepts = new string[]{
                "application/json"
            };

            var localVarContentType = ClientUtils.SelectHeaderContentType(contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = ClientUtils.SelectHeaderAccept(accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.Data = privKeyRequest;

            // authentication (X-API-Key) required
            if (!string.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("x-api-key")))
            {
                localVarRequestOptions.HeaderParameters.Add("x-api-key", Configuration.GetApiKeyWithPrefix("x-api-key"));
            }

            // make the HTTP request
            var localVarResponse = Client.Post<PrivKey>("/v3/polygon/wallet/priv", localVarRequestOptions, Configuration);

            return localVarResponse;
        }

        /// <summary>
        /// Generate Polygon private key 1 credit per API call Generate private key of address from mnemonic for given derivation path index. Private key is generated for the specific index - each mnemonic can generate up to 2^31 private keys starting from index 0 until 2^31.
        /// </summary>
        /// <exception cref="Tatum.CSharp.Polygon.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="privKeyRequest"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of PrivKey</returns>
        public async System.Threading.Tasks.Task<PrivKey> PolygonGenerateAddressPrivateKeyAsync(PrivKeyRequest privKeyRequest, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            var localVarResponse = await PolygonGenerateAddressPrivateKeyWithHttpInfoAsync(privKeyRequest, cancellationToken).ConfigureAwait(false);
            
            var exception = ExceptionFactory?.Invoke("PolygonGenerateAddressPrivateKey", localVarResponse);
            if (exception != null) throw exception;

            return localVarResponse.Data;
        }

        /// <summary>
        /// Generate Polygon private key 1 credit per API call Generate private key of address from mnemonic for given derivation path index. Private key is generated for the specific index - each mnemonic can generate up to 2^31 private keys starting from index 0 until 2^31.
        /// </summary>
        /// <exception cref="Tatum.CSharp.Polygon.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="privKeyRequest"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (PrivKey)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<PrivKey>> PolygonGenerateAddressPrivateKeyWithHttpInfoAsync(PrivKeyRequest privKeyRequest, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            // verify the required parameter 'privKeyRequest' is set
            if (privKeyRequest == null)
                throw new ApiException(400, "Missing required parameter 'privKeyRequest' when calling PolygonApi->PolygonGenerateAddressPrivateKey");

            var localVarRequestOptions = new RequestOptions();

            var contentTypes = new string[]{
                "application/json"
            };

            // to determine the Accept header
            var accepts = new string[]{
                "application/json"
            };


            var localVarContentType = ClientUtils.SelectHeaderContentType(contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = ClientUtils.SelectHeaderAccept(accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.Data = privKeyRequest;

            // authentication (X-API-Key) required
            if (!string.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("x-api-key")))
            {
                localVarRequestOptions.HeaderParameters.Add("x-api-key", Configuration.GetApiKeyWithPrefix("x-api-key"));
            }

            // make the HTTP request

            var localVarResponse = await AsynchronousClient.PostAsync<PrivKey>("/v3/polygon/wallet/priv", localVarRequestOptions, Configuration, cancellationToken).ConfigureAwait(false);

            return localVarResponse;
        }

        /// <summary>
        /// Generate Polygon wallet 1 credit per API call Tatum supports BIP44 HD wallets. It is very convenient and secure, since it can generate 2^31 addresses from 1 mnemonic phrase. Mnemonic phrase consists of 24 special words in defined order and can restore access to all generated addresses and private keys. Each address is identified by 3 main values: Private Key - your secret value, which should never be revealed Public Key - public address to be published Derivation index - index of generated address Tatum follows BIP44 specification and generates for Polygon wallet with derivation path m&#39;/44&#39;/966&#39;/0&#39;/0. More about BIP44 HD wallets can be found here - https://github.com/bitcoin/bips/blob/master/bip-0044.mediawiki. Generate BIP44 compatible Polygon wallet.
        /// </summary>
        /// <exception cref="Tatum.CSharp.Polygon.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="mnemonic">Mnemonic to use for generation of extended public and private keys. (optional)</param>
        /// <returns>Wallet</returns>
        public Wallet PolygonGenerateWallet(string mnemonic = default(string))
        {
            var localVarResponse = PolygonGenerateWalletWithHttpInfo(mnemonic);

            var exception = ExceptionFactory?.Invoke("PolygonGenerateWallet", localVarResponse);
            if (exception != null) throw exception;

            return localVarResponse.Data;
        }

        /// <summary>
        /// Generate Polygon wallet 1 credit per API call Tatum supports BIP44 HD wallets. It is very convenient and secure, since it can generate 2^31 addresses from 1 mnemonic phrase. Mnemonic phrase consists of 24 special words in defined order and can restore access to all generated addresses and private keys. Each address is identified by 3 main values: Private Key - your secret value, which should never be revealed Public Key - public address to be published Derivation index - index of generated address Tatum follows BIP44 specification and generates for Polygon wallet with derivation path m&#39;/44&#39;/966&#39;/0&#39;/0. More about BIP44 HD wallets can be found here - https://github.com/bitcoin/bips/blob/master/bip-0044.mediawiki. Generate BIP44 compatible Polygon wallet.
        /// </summary>
        /// <exception cref="Tatum.CSharp.Polygon.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="mnemonic">Mnemonic to use for generation of extended public and private keys. (optional)</param>
        /// <returns>ApiResponse of Wallet</returns>
        public ApiResponse<Wallet> PolygonGenerateWalletWithHttpInfo(string mnemonic = default(string))
        {
            var localVarRequestOptions = new RequestOptions();

            var contentTypes = new string[]{
            };

            // to determine the Accept header
            var accepts = new string[]{
                "application/json"
            };

            var localVarContentType = ClientUtils.SelectHeaderContentType(contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = ClientUtils.SelectHeaderAccept(accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            if (mnemonic != null)
            {
                localVarRequestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "mnemonic", mnemonic));
            }

            // authentication (X-API-Key) required
            if (!string.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("x-api-key")))
            {
                localVarRequestOptions.HeaderParameters.Add("x-api-key", Configuration.GetApiKeyWithPrefix("x-api-key"));
            }

            // make the HTTP request
            var localVarResponse = Client.Get<Wallet>("/v3/polygon/wallet", localVarRequestOptions, Configuration);

            return localVarResponse;
        }

        /// <summary>
        /// Generate Polygon wallet 1 credit per API call Tatum supports BIP44 HD wallets. It is very convenient and secure, since it can generate 2^31 addresses from 1 mnemonic phrase. Mnemonic phrase consists of 24 special words in defined order and can restore access to all generated addresses and private keys. Each address is identified by 3 main values: Private Key - your secret value, which should never be revealed Public Key - public address to be published Derivation index - index of generated address Tatum follows BIP44 specification and generates for Polygon wallet with derivation path m&#39;/44&#39;/966&#39;/0&#39;/0. More about BIP44 HD wallets can be found here - https://github.com/bitcoin/bips/blob/master/bip-0044.mediawiki. Generate BIP44 compatible Polygon wallet.
        /// </summary>
        /// <exception cref="Tatum.CSharp.Polygon.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="mnemonic">Mnemonic to use for generation of extended public and private keys. (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of Wallet</returns>
        public async System.Threading.Tasks.Task<Wallet> PolygonGenerateWalletAsync(string mnemonic = default(string), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            var localVarResponse = await PolygonGenerateWalletWithHttpInfoAsync(mnemonic, cancellationToken).ConfigureAwait(false);
            
            var exception = ExceptionFactory?.Invoke("PolygonGenerateWallet", localVarResponse);
            if (exception != null) throw exception;

            return localVarResponse.Data;
        }

        /// <summary>
        /// Generate Polygon wallet 1 credit per API call Tatum supports BIP44 HD wallets. It is very convenient and secure, since it can generate 2^31 addresses from 1 mnemonic phrase. Mnemonic phrase consists of 24 special words in defined order and can restore access to all generated addresses and private keys. Each address is identified by 3 main values: Private Key - your secret value, which should never be revealed Public Key - public address to be published Derivation index - index of generated address Tatum follows BIP44 specification and generates for Polygon wallet with derivation path m&#39;/44&#39;/966&#39;/0&#39;/0. More about BIP44 HD wallets can be found here - https://github.com/bitcoin/bips/blob/master/bip-0044.mediawiki. Generate BIP44 compatible Polygon wallet.
        /// </summary>
        /// <exception cref="Tatum.CSharp.Polygon.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="mnemonic">Mnemonic to use for generation of extended public and private keys. (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (Wallet)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<Wallet>> PolygonGenerateWalletWithHttpInfoAsync(string mnemonic = default(string), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            var localVarRequestOptions = new RequestOptions();

            var contentTypes = new string[]{
            };

            // to determine the Accept header
            var accepts = new string[]{
                "application/json"
            };


            var localVarContentType = ClientUtils.SelectHeaderContentType(contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = ClientUtils.SelectHeaderAccept(accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            if (mnemonic != null)
            {
                localVarRequestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "mnemonic", mnemonic));
            }

            // authentication (X-API-Key) required
            if (!string.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("x-api-key")))
            {
                localVarRequestOptions.HeaderParameters.Add("x-api-key", Configuration.GetApiKeyWithPrefix("x-api-key"));
            }

            // make the HTTP request

            var localVarResponse = await AsynchronousClient.GetAsync<Wallet>("/v3/polygon/wallet", localVarRequestOptions, Configuration, cancellationToken).ConfigureAwait(false);

            return localVarResponse;
        }

        /// <summary>
        /// Get Polygon Account balance 1 credit per API call Get Polygon account balance in MATIC. This method does not prints any balance of the ERC20 or ERC721 tokens on the account.
        /// </summary>
        /// <exception cref="Tatum.CSharp.Polygon.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="address">Account address you want to get balance of</param>
        /// <returns>MaticBalance</returns>
        public MaticBalance PolygonGetBalance(string address)
        {
            var localVarResponse = PolygonGetBalanceWithHttpInfo(address);

            var exception = ExceptionFactory?.Invoke("PolygonGetBalance", localVarResponse);
            if (exception != null) throw exception;

            return localVarResponse.Data;
        }

        /// <summary>
        /// Get Polygon Account balance 1 credit per API call Get Polygon account balance in MATIC. This method does not prints any balance of the ERC20 or ERC721 tokens on the account.
        /// </summary>
        /// <exception cref="Tatum.CSharp.Polygon.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="address">Account address you want to get balance of</param>
        /// <returns>ApiResponse of MaticBalance</returns>
        public ApiResponse<MaticBalance> PolygonGetBalanceWithHttpInfo(string address)
        {
            // verify the required parameter 'address' is set
            if (address == null)
                throw new ApiException(400, "Missing required parameter 'address' when calling PolygonApi->PolygonGetBalance");

            var localVarRequestOptions = new RequestOptions();

            var contentTypes = new string[]{
            };

            // to determine the Accept header
            var accepts = new string[]{
                "application/json"
            };

            var localVarContentType = ClientUtils.SelectHeaderContentType(contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = ClientUtils.SelectHeaderAccept(accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.PathParameters.Add("address", ClientUtils.ParameterToString(address)); // path parameter

            // authentication (X-API-Key) required
            if (!string.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("x-api-key")))
            {
                localVarRequestOptions.HeaderParameters.Add("x-api-key", Configuration.GetApiKeyWithPrefix("x-api-key"));
            }

            // make the HTTP request
            var localVarResponse = Client.Get<MaticBalance>("/v3/polygon/account/balance/{address}", localVarRequestOptions, Configuration);

            return localVarResponse;
        }

        /// <summary>
        /// Get Polygon Account balance 1 credit per API call Get Polygon account balance in MATIC. This method does not prints any balance of the ERC20 or ERC721 tokens on the account.
        /// </summary>
        /// <exception cref="Tatum.CSharp.Polygon.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="address">Account address you want to get balance of</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of MaticBalance</returns>
        public async System.Threading.Tasks.Task<MaticBalance> PolygonGetBalanceAsync(string address, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            var localVarResponse = await PolygonGetBalanceWithHttpInfoAsync(address, cancellationToken).ConfigureAwait(false);
            
            var exception = ExceptionFactory?.Invoke("PolygonGetBalance", localVarResponse);
            if (exception != null) throw exception;

            return localVarResponse.Data;
        }

        /// <summary>
        /// Get Polygon Account balance 1 credit per API call Get Polygon account balance in MATIC. This method does not prints any balance of the ERC20 or ERC721 tokens on the account.
        /// </summary>
        /// <exception cref="Tatum.CSharp.Polygon.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="address">Account address you want to get balance of</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (MaticBalance)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<MaticBalance>> PolygonGetBalanceWithHttpInfoAsync(string address, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            // verify the required parameter 'address' is set
            if (address == null)
                throw new ApiException(400, "Missing required parameter 'address' when calling PolygonApi->PolygonGetBalance");

            var localVarRequestOptions = new RequestOptions();

            var contentTypes = new string[]{
            };

            // to determine the Accept header
            var accepts = new string[]{
                "application/json"
            };


            var localVarContentType = ClientUtils.SelectHeaderContentType(contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = ClientUtils.SelectHeaderAccept(accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.PathParameters.Add("address", ClientUtils.ParameterToString(address)); // path parameter

            // authentication (X-API-Key) required
            if (!string.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("x-api-key")))
            {
                localVarRequestOptions.HeaderParameters.Add("x-api-key", Configuration.GetApiKeyWithPrefix("x-api-key"));
            }

            // make the HTTP request

            var localVarResponse = await AsynchronousClient.GetAsync<MaticBalance>("/v3/polygon/account/balance/{address}", localVarRequestOptions, Configuration, cancellationToken).ConfigureAwait(false);

            return localVarResponse;
        }

        /// <summary>
        /// Get Polygon block by hash 1 credit per API call Get Polygon block by block hash or block number.
        /// </summary>
        /// <exception cref="Tatum.CSharp.Polygon.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="hash">Block hash or block number</param>
        /// <returns>EthBlock</returns>
        public EthBlock PolygonGetBlock(string hash)
        {
            var localVarResponse = PolygonGetBlockWithHttpInfo(hash);

            var exception = ExceptionFactory?.Invoke("PolygonGetBlock", localVarResponse);
            if (exception != null) throw exception;

            return localVarResponse.Data;
        }

        /// <summary>
        /// Get Polygon block by hash 1 credit per API call Get Polygon block by block hash or block number.
        /// </summary>
        /// <exception cref="Tatum.CSharp.Polygon.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="hash">Block hash or block number</param>
        /// <returns>ApiResponse of EthBlock</returns>
        public ApiResponse<EthBlock> PolygonGetBlockWithHttpInfo(string hash)
        {
            // verify the required parameter 'hash' is set
            if (hash == null)
                throw new ApiException(400, "Missing required parameter 'hash' when calling PolygonApi->PolygonGetBlock");

            var localVarRequestOptions = new RequestOptions();

            var contentTypes = new string[]{
            };

            // to determine the Accept header
            var accepts = new string[]{
                "application/json"
            };

            var localVarContentType = ClientUtils.SelectHeaderContentType(contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = ClientUtils.SelectHeaderAccept(accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.PathParameters.Add("hash", ClientUtils.ParameterToString(hash)); // path parameter

            // authentication (X-API-Key) required
            if (!string.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("x-api-key")))
            {
                localVarRequestOptions.HeaderParameters.Add("x-api-key", Configuration.GetApiKeyWithPrefix("x-api-key"));
            }

            // make the HTTP request
            var localVarResponse = Client.Get<EthBlock>("/v3/polygon/block/{hash}", localVarRequestOptions, Configuration);

            return localVarResponse;
        }

        /// <summary>
        /// Get Polygon block by hash 1 credit per API call Get Polygon block by block hash or block number.
        /// </summary>
        /// <exception cref="Tatum.CSharp.Polygon.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="hash">Block hash or block number</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of EthBlock</returns>
        public async System.Threading.Tasks.Task<EthBlock> PolygonGetBlockAsync(string hash, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            var localVarResponse = await PolygonGetBlockWithHttpInfoAsync(hash, cancellationToken).ConfigureAwait(false);
            
            var exception = ExceptionFactory?.Invoke("PolygonGetBlock", localVarResponse);
            if (exception != null) throw exception;

            return localVarResponse.Data;
        }

        /// <summary>
        /// Get Polygon block by hash 1 credit per API call Get Polygon block by block hash or block number.
        /// </summary>
        /// <exception cref="Tatum.CSharp.Polygon.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="hash">Block hash or block number</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (EthBlock)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<EthBlock>> PolygonGetBlockWithHttpInfoAsync(string hash, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            // verify the required parameter 'hash' is set
            if (hash == null)
                throw new ApiException(400, "Missing required parameter 'hash' when calling PolygonApi->PolygonGetBlock");

            var localVarRequestOptions = new RequestOptions();

            var contentTypes = new string[]{
            };

            // to determine the Accept header
            var accepts = new string[]{
                "application/json"
            };


            var localVarContentType = ClientUtils.SelectHeaderContentType(contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = ClientUtils.SelectHeaderAccept(accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.PathParameters.Add("hash", ClientUtils.ParameterToString(hash)); // path parameter

            // authentication (X-API-Key) required
            if (!string.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("x-api-key")))
            {
                localVarRequestOptions.HeaderParameters.Add("x-api-key", Configuration.GetApiKeyWithPrefix("x-api-key"));
            }

            // make the HTTP request

            var localVarResponse = await AsynchronousClient.GetAsync<EthBlock>("/v3/polygon/block/{hash}", localVarRequestOptions, Configuration, cancellationToken).ConfigureAwait(false);

            return localVarResponse;
        }

        /// <summary>
        /// Get current block number 1 credit per API call Get Polygon current block number. This is the number of the latest block in the blockchain.
        /// </summary>
        /// <exception cref="Tatum.CSharp.Polygon.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <returns>decimal</returns>
        public decimal PolygonGetCurrentBlock()
        {
            var localVarResponse = PolygonGetCurrentBlockWithHttpInfo();

            var exception = ExceptionFactory?.Invoke("PolygonGetCurrentBlock", localVarResponse);
            if (exception != null) throw exception;

            return localVarResponse.Data;
        }

        /// <summary>
        /// Get current block number 1 credit per API call Get Polygon current block number. This is the number of the latest block in the blockchain.
        /// </summary>
        /// <exception cref="Tatum.CSharp.Polygon.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <returns>ApiResponse of decimal</returns>
        public ApiResponse<decimal> PolygonGetCurrentBlockWithHttpInfo()
        {
            var localVarRequestOptions = new RequestOptions();

            var contentTypes = new string[]{
            };

            // to determine the Accept header
            var accepts = new string[]{
                "application/json"
            };

            var localVarContentType = ClientUtils.SelectHeaderContentType(contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = ClientUtils.SelectHeaderAccept(accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);


            // authentication (X-API-Key) required
            if (!string.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("x-api-key")))
            {
                localVarRequestOptions.HeaderParameters.Add("x-api-key", Configuration.GetApiKeyWithPrefix("x-api-key"));
            }

            // make the HTTP request
            var localVarResponse = Client.Get<decimal>("/v3/polygon/block/current", localVarRequestOptions, Configuration);

            return localVarResponse;
        }

        /// <summary>
        /// Get current block number 1 credit per API call Get Polygon current block number. This is the number of the latest block in the blockchain.
        /// </summary>
        /// <exception cref="Tatum.CSharp.Polygon.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of decimal</returns>
        public async System.Threading.Tasks.Task<decimal> PolygonGetCurrentBlockAsync(System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            var localVarResponse = await PolygonGetCurrentBlockWithHttpInfoAsync(cancellationToken).ConfigureAwait(false);
            
            var exception = ExceptionFactory?.Invoke("PolygonGetCurrentBlock", localVarResponse);
            if (exception != null) throw exception;

            return localVarResponse.Data;
        }

        /// <summary>
        /// Get current block number 1 credit per API call Get Polygon current block number. This is the number of the latest block in the blockchain.
        /// </summary>
        /// <exception cref="Tatum.CSharp.Polygon.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (decimal)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<decimal>> PolygonGetCurrentBlockWithHttpInfoAsync(System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            var localVarRequestOptions = new RequestOptions();

            var contentTypes = new string[]{
            };

            // to determine the Accept header
            var accepts = new string[]{
                "application/json"
            };


            var localVarContentType = ClientUtils.SelectHeaderContentType(contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = ClientUtils.SelectHeaderAccept(accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);


            // authentication (X-API-Key) required
            if (!string.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("x-api-key")))
            {
                localVarRequestOptions.HeaderParameters.Add("x-api-key", Configuration.GetApiKeyWithPrefix("x-api-key"));
            }

            // make the HTTP request

            var localVarResponse = await AsynchronousClient.GetAsync<decimal>("/v3/polygon/block/current", localVarRequestOptions, Configuration, cancellationToken).ConfigureAwait(false);

            return localVarResponse;
        }

        /// <summary>
        /// Get Polygon Transaction 2 credits per API call Get Polygon transaction by transaction hash.
        /// </summary>
        /// <exception cref="Tatum.CSharp.Polygon.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="hash">Transaction hash</param>
        /// <returns>PolygonTx</returns>
        public PolygonTx PolygonGetTransaction(string hash)
        {
            var localVarResponse = PolygonGetTransactionWithHttpInfo(hash);

            var exception = ExceptionFactory?.Invoke("PolygonGetTransaction", localVarResponse);
            if (exception != null) throw exception;

            return localVarResponse.Data;
        }

        /// <summary>
        /// Get Polygon Transaction 2 credits per API call Get Polygon transaction by transaction hash.
        /// </summary>
        /// <exception cref="Tatum.CSharp.Polygon.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="hash">Transaction hash</param>
        /// <returns>ApiResponse of PolygonTx</returns>
        public ApiResponse<PolygonTx> PolygonGetTransactionWithHttpInfo(string hash)
        {
            // verify the required parameter 'hash' is set
            if (hash == null)
                throw new ApiException(400, "Missing required parameter 'hash' when calling PolygonApi->PolygonGetTransaction");

            var localVarRequestOptions = new RequestOptions();

            var contentTypes = new string[]{
            };

            // to determine the Accept header
            var accepts = new string[]{
                "application/json"
            };

            var localVarContentType = ClientUtils.SelectHeaderContentType(contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = ClientUtils.SelectHeaderAccept(accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.PathParameters.Add("hash", ClientUtils.ParameterToString(hash)); // path parameter

            // authentication (X-API-Key) required
            if (!string.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("x-api-key")))
            {
                localVarRequestOptions.HeaderParameters.Add("x-api-key", Configuration.GetApiKeyWithPrefix("x-api-key"));
            }

            // make the HTTP request
            var localVarResponse = Client.Get<PolygonTx>("/v3/polygon/transaction/{hash}", localVarRequestOptions, Configuration);

            return localVarResponse;
        }

        /// <summary>
        /// Get Polygon Transaction 2 credits per API call Get Polygon transaction by transaction hash.
        /// </summary>
        /// <exception cref="Tatum.CSharp.Polygon.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="hash">Transaction hash</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of PolygonTx</returns>
        public async System.Threading.Tasks.Task<PolygonTx> PolygonGetTransactionAsync(string hash, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            var localVarResponse = await PolygonGetTransactionWithHttpInfoAsync(hash, cancellationToken).ConfigureAwait(false);
            
            var exception = ExceptionFactory?.Invoke("PolygonGetTransaction", localVarResponse);
            if (exception != null) throw exception;

            return localVarResponse.Data;
        }

        /// <summary>
        /// Get Polygon Transaction 2 credits per API call Get Polygon transaction by transaction hash.
        /// </summary>
        /// <exception cref="Tatum.CSharp.Polygon.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="hash">Transaction hash</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (PolygonTx)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<PolygonTx>> PolygonGetTransactionWithHttpInfoAsync(string hash, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            // verify the required parameter 'hash' is set
            if (hash == null)
                throw new ApiException(400, "Missing required parameter 'hash' when calling PolygonApi->PolygonGetTransaction");

            var localVarRequestOptions = new RequestOptions();

            var contentTypes = new string[]{
            };

            // to determine the Accept header
            var accepts = new string[]{
                "application/json"
            };


            var localVarContentType = ClientUtils.SelectHeaderContentType(contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = ClientUtils.SelectHeaderAccept(accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.PathParameters.Add("hash", ClientUtils.ParameterToString(hash)); // path parameter

            // authentication (X-API-Key) required
            if (!string.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("x-api-key")))
            {
                localVarRequestOptions.HeaderParameters.Add("x-api-key", Configuration.GetApiKeyWithPrefix("x-api-key"));
            }

            // make the HTTP request

            var localVarResponse = await AsynchronousClient.GetAsync<PolygonTx>("/v3/polygon/transaction/{hash}", localVarRequestOptions, Configuration, cancellationToken).ConfigureAwait(false);

            return localVarResponse;
        }

        /// <summary>
        /// Get Polygon transactions by address 1 credit per API call Get Polygon transactions by address. This includes incoming and outgoing transactions for the address.
        /// </summary>
        /// <exception cref="Tatum.CSharp.Polygon.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="address">Account address you want to get balance of</param>
        /// <param name="pageSize">Max number of items per page is 50.</param>
        /// <param name="offset">Offset to obtain next page of the data. (optional)</param>
        /// <param name="from">Transactions from this block onwards will be included. (optional)</param>
        /// <param name="to">Transactions up to this block will be included. (optional)</param>
        /// <param name="sort">Sorting of the data. ASC - oldest first, DESC - newest first. (optional, default to DESC)</param>
        /// <returns>List&lt;PolygonTx&gt;</returns>
        public List<PolygonTx> PolygonGetTransactionByAddress(string address, decimal pageSize, decimal? offset = default(decimal?), decimal? from = default(decimal?), decimal? to = default(decimal?), string sort = default(string))
        {
            var localVarResponse = PolygonGetTransactionByAddressWithHttpInfo(address, pageSize, offset, from, to, sort);

            var exception = ExceptionFactory?.Invoke("PolygonGetTransactionByAddress", localVarResponse);
            if (exception != null) throw exception;

            return localVarResponse.Data;
        }

        /// <summary>
        /// Get Polygon transactions by address 1 credit per API call Get Polygon transactions by address. This includes incoming and outgoing transactions for the address.
        /// </summary>
        /// <exception cref="Tatum.CSharp.Polygon.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="address">Account address you want to get balance of</param>
        /// <param name="pageSize">Max number of items per page is 50.</param>
        /// <param name="offset">Offset to obtain next page of the data. (optional)</param>
        /// <param name="from">Transactions from this block onwards will be included. (optional)</param>
        /// <param name="to">Transactions up to this block will be included. (optional)</param>
        /// <param name="sort">Sorting of the data. ASC - oldest first, DESC - newest first. (optional, default to DESC)</param>
        /// <returns>ApiResponse of List&lt;PolygonTx&gt;</returns>
        public ApiResponse<List<PolygonTx>> PolygonGetTransactionByAddressWithHttpInfo(string address, decimal pageSize, decimal? offset = default(decimal?), decimal? from = default(decimal?), decimal? to = default(decimal?), string sort = default(string))
        {
            // verify the required parameter 'address' is set
            if (address == null)
                throw new ApiException(400, "Missing required parameter 'address' when calling PolygonApi->PolygonGetTransactionByAddress");

            var localVarRequestOptions = new RequestOptions();

            var contentTypes = new string[]{
            };

            // to determine the Accept header
            var accepts = new string[]{
                "application/json"
            };

            var localVarContentType = ClientUtils.SelectHeaderContentType(contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = ClientUtils.SelectHeaderAccept(accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.PathParameters.Add("address", ClientUtils.ParameterToString(address)); // path parameter
            localVarRequestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "pageSize", pageSize));
            if (offset != null)
            {
                localVarRequestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "offset", offset));
            }
            if (from != null)
            {
                localVarRequestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "from", from));
            }
            if (to != null)
            {
                localVarRequestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "to", to));
            }
            if (sort != null)
            {
                localVarRequestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "sort", sort));
            }

            // authentication (X-API-Key) required
            if (!string.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("x-api-key")))
            {
                localVarRequestOptions.HeaderParameters.Add("x-api-key", Configuration.GetApiKeyWithPrefix("x-api-key"));
            }

            // make the HTTP request
            var localVarResponse = Client.Get<List<PolygonTx>>("/v3/polygon/account/transaction/{address}", localVarRequestOptions, Configuration);

            return localVarResponse;
        }

        /// <summary>
        /// Get Polygon transactions by address 1 credit per API call Get Polygon transactions by address. This includes incoming and outgoing transactions for the address.
        /// </summary>
        /// <exception cref="Tatum.CSharp.Polygon.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="address">Account address you want to get balance of</param>
        /// <param name="pageSize">Max number of items per page is 50.</param>
        /// <param name="offset">Offset to obtain next page of the data. (optional)</param>
        /// <param name="from">Transactions from this block onwards will be included. (optional)</param>
        /// <param name="to">Transactions up to this block will be included. (optional)</param>
        /// <param name="sort">Sorting of the data. ASC - oldest first, DESC - newest first. (optional, default to DESC)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of List&lt;PolygonTx&gt;</returns>
        public async System.Threading.Tasks.Task<List<PolygonTx>> PolygonGetTransactionByAddressAsync(string address, decimal pageSize, decimal? offset = default(decimal?), decimal? from = default(decimal?), decimal? to = default(decimal?), string sort = default(string), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            var localVarResponse = await PolygonGetTransactionByAddressWithHttpInfoAsync(address, pageSize, offset, from, to, sort, cancellationToken).ConfigureAwait(false);
            
            var exception = ExceptionFactory?.Invoke("PolygonGetTransactionByAddress", localVarResponse);
            if (exception != null) throw exception;

            return localVarResponse.Data;
        }

        /// <summary>
        /// Get Polygon transactions by address 1 credit per API call Get Polygon transactions by address. This includes incoming and outgoing transactions for the address.
        /// </summary>
        /// <exception cref="Tatum.CSharp.Polygon.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="address">Account address you want to get balance of</param>
        /// <param name="pageSize">Max number of items per page is 50.</param>
        /// <param name="offset">Offset to obtain next page of the data. (optional)</param>
        /// <param name="from">Transactions from this block onwards will be included. (optional)</param>
        /// <param name="to">Transactions up to this block will be included. (optional)</param>
        /// <param name="sort">Sorting of the data. ASC - oldest first, DESC - newest first. (optional, default to DESC)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (List&lt;PolygonTx&gt;)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<List<PolygonTx>>> PolygonGetTransactionByAddressWithHttpInfoAsync(string address, decimal pageSize, decimal? offset = default(decimal?), decimal? from = default(decimal?), decimal? to = default(decimal?), string sort = default(string), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            // verify the required parameter 'address' is set
            if (address == null)
                throw new ApiException(400, "Missing required parameter 'address' when calling PolygonApi->PolygonGetTransactionByAddress");

            var localVarRequestOptions = new RequestOptions();

            var contentTypes = new string[]{
            };

            // to determine the Accept header
            var accepts = new string[]{
                "application/json"
            };


            var localVarContentType = ClientUtils.SelectHeaderContentType(contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = ClientUtils.SelectHeaderAccept(accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.PathParameters.Add("address", ClientUtils.ParameterToString(address)); // path parameter
            localVarRequestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "pageSize", pageSize));
            if (offset != null)
            {
                localVarRequestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "offset", offset));
            }
            if (from != null)
            {
                localVarRequestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "from", from));
            }
            if (to != null)
            {
                localVarRequestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "to", to));
            }
            if (sort != null)
            {
                localVarRequestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "sort", sort));
            }

            // authentication (X-API-Key) required
            if (!string.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("x-api-key")))
            {
                localVarRequestOptions.HeaderParameters.Add("x-api-key", Configuration.GetApiKeyWithPrefix("x-api-key"));
            }

            // make the HTTP request

            var localVarResponse = await AsynchronousClient.GetAsync<List<PolygonTx>>("/v3/polygon/account/transaction/{address}", localVarRequestOptions, Configuration, cancellationToken).ConfigureAwait(false);

            return localVarResponse;
        }

        /// <summary>
        /// Get count of outgoing Polygon transactions 1 credit per API call Get a number of outgoing Polygon transactions for the address. When a transaction is sent, there can be multiple outgoing transactions, which are not yet processed by the blockchain. To distinguish between them, there is a counter called a nonce, which represents the order of the transaction in the list of outgoing transactions.
        /// </summary>
        /// <exception cref="Tatum.CSharp.Polygon.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="address">address</param>
        /// <returns>decimal</returns>
        public decimal PolygonGetTransactionCount(string address)
        {
            var localVarResponse = PolygonGetTransactionCountWithHttpInfo(address);

            var exception = ExceptionFactory?.Invoke("PolygonGetTransactionCount", localVarResponse);
            if (exception != null) throw exception;

            return localVarResponse.Data;
        }

        /// <summary>
        /// Get count of outgoing Polygon transactions 1 credit per API call Get a number of outgoing Polygon transactions for the address. When a transaction is sent, there can be multiple outgoing transactions, which are not yet processed by the blockchain. To distinguish between them, there is a counter called a nonce, which represents the order of the transaction in the list of outgoing transactions.
        /// </summary>
        /// <exception cref="Tatum.CSharp.Polygon.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="address">address</param>
        /// <returns>ApiResponse of decimal</returns>
        public ApiResponse<decimal> PolygonGetTransactionCountWithHttpInfo(string address)
        {
            // verify the required parameter 'address' is set
            if (address == null)
                throw new ApiException(400, "Missing required parameter 'address' when calling PolygonApi->PolygonGetTransactionCount");

            var localVarRequestOptions = new RequestOptions();

            var contentTypes = new string[]{
            };

            // to determine the Accept header
            var accepts = new string[]{
                "application/json"
            };

            var localVarContentType = ClientUtils.SelectHeaderContentType(contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = ClientUtils.SelectHeaderAccept(accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.PathParameters.Add("address", ClientUtils.ParameterToString(address)); // path parameter

            // authentication (X-API-Key) required
            if (!string.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("x-api-key")))
            {
                localVarRequestOptions.HeaderParameters.Add("x-api-key", Configuration.GetApiKeyWithPrefix("x-api-key"));
            }

            // make the HTTP request
            var localVarResponse = Client.Get<decimal>("/v3/polygon/transaction/count/{address}", localVarRequestOptions, Configuration);

            return localVarResponse;
        }

        /// <summary>
        /// Get count of outgoing Polygon transactions 1 credit per API call Get a number of outgoing Polygon transactions for the address. When a transaction is sent, there can be multiple outgoing transactions, which are not yet processed by the blockchain. To distinguish between them, there is a counter called a nonce, which represents the order of the transaction in the list of outgoing transactions.
        /// </summary>
        /// <exception cref="Tatum.CSharp.Polygon.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="address">address</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of decimal</returns>
        public async System.Threading.Tasks.Task<decimal> PolygonGetTransactionCountAsync(string address, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            var localVarResponse = await PolygonGetTransactionCountWithHttpInfoAsync(address, cancellationToken).ConfigureAwait(false);
            
            var exception = ExceptionFactory?.Invoke("PolygonGetTransactionCount", localVarResponse);
            if (exception != null) throw exception;

            return localVarResponse.Data;
        }

        /// <summary>
        /// Get count of outgoing Polygon transactions 1 credit per API call Get a number of outgoing Polygon transactions for the address. When a transaction is sent, there can be multiple outgoing transactions, which are not yet processed by the blockchain. To distinguish between them, there is a counter called a nonce, which represents the order of the transaction in the list of outgoing transactions.
        /// </summary>
        /// <exception cref="Tatum.CSharp.Polygon.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="address">address</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (decimal)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<decimal>> PolygonGetTransactionCountWithHttpInfoAsync(string address, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            // verify the required parameter 'address' is set
            if (address == null)
                throw new ApiException(400, "Missing required parameter 'address' when calling PolygonApi->PolygonGetTransactionCount");

            var localVarRequestOptions = new RequestOptions();

            var contentTypes = new string[]{
            };

            // to determine the Accept header
            var accepts = new string[]{
                "application/json"
            };


            var localVarContentType = ClientUtils.SelectHeaderContentType(contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = ClientUtils.SelectHeaderAccept(accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.PathParameters.Add("address", ClientUtils.ParameterToString(address)); // path parameter

            // authentication (X-API-Key) required
            if (!string.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("x-api-key")))
            {
                localVarRequestOptions.HeaderParameters.Add("x-api-key", Configuration.GetApiKeyWithPrefix("x-api-key"));
            }

            // make the HTTP request

            var localVarResponse = await AsynchronousClient.GetAsync<decimal>("/v3/polygon/transaction/count/{address}", localVarRequestOptions, Configuration, cancellationToken).ConfigureAwait(false);

            return localVarResponse;
        }

    }
}
