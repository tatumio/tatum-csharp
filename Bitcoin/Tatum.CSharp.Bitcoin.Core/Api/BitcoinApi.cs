/*
 * Tatum API Reference
 *
 * # Welcome to the Tatum API Reference!  ## What is Tatum?  Tatum offers a flexible framework to build, run, and scale blockchain apps fast. To learn more about the Tatum blockchain development framework, visit [our website](https://tatum.io/framework).  The Tatum API features powerful endpoints that simplify a complex blockchain into single API requests. Code for all supported blockchains using unified API calls.  ## Need help?  To chat with other developers, get help from the Support team, and engage with the thriving Tatum community, join  our [Discord server](https://discord.com/invite/tatum). For more information about how to work with Tatum, review the [online documentation](https://docs.tatum.io/).  ## About this API Reference  The Tatum API Reference is based on OpenAPI Specification v3.1.0 with a few [vendor extensions](https://github.com/Redocly/redoc/blob/master/docs/redoc-vendor-extensions.md) applied.  # Authentication  When using the Tatum API, you authenticate yourself with an **API key**. <SecurityDefinitions /> 
 *
 * The version of the OpenAPI document: 3.17.0
 * Generated by: https://github.com/openapitools/openapi-generator.git
 */


using System;
using System.Collections.Generic;
using System.Net.Http;
using Tatum.CSharp.Bitcoin.Core.Client;
using Tatum.CSharp.Bitcoin.Core.Model;

namespace Tatum.CSharp.Bitcoin.Core.Api
{

    /// <summary>
    /// Represents a collection of functions to interact with the API endpoints
    /// </summary>
    public interface IBitcoinApiSync : IApiAccessor
    {
        #region Synchronous Operations
        /// <summary>
        /// Broadcast a signed Bitcoin transaction
        /// </summary>
        /// <remarks>
        /// 2 credits per API call Broadcasts a signed transaction to the Bitcoin blockchain. This method is used internally from Tatum KMS or Tatum Client Libraries. It is possible to create a custom signing mechanism and only use this method for broadcasting data to the blockchain.
        /// </remarks>
        /// <exception cref="Tatum.CSharp.Bitcoin.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="broadcastKMS"></param>
        /// <returns>TransactionHash</returns>
        TransactionHash BtcBroadcast(BroadcastKMS broadcastKMS);
        /// <summary>
        /// Generate a Bitcoin address from the wallet&#39;s extended public key
        /// </summary>
        /// <remarks>
        /// 1 credit per API call Generate a Bitcoin address from the extended public key of the wallet. The address is generated for the specific index - each extended public key can generate up to 2^32 addresses with the index starting from 0 up to 2^31 - 1.
        /// </remarks>
        /// <exception cref="Tatum.CSharp.Bitcoin.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="xpub">Extended public key of a wallet.</param>
        /// <param name="index">Derivation index of the desired address to be generated.</param>
        /// <returns>GeneratedAddressBtc</returns>
        GeneratedAddressBtc BtcGenerateAddress(string xpub, decimal index);
        /// <summary>
        /// Generate the private key for a Bitcoin address
        /// </summary>
        /// <remarks>
        /// 1 credit per API call Generates a private key for an address from a mnemonic for a given derivation path index. The private key is generated for the specific index - each mnemonic can generate up to 2^32 private keys starting from index 0 until 2^31 - 1.
        /// </remarks>
        /// <exception cref="Tatum.CSharp.Bitcoin.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="privKeyRequest"></param>
        /// <returns>PrivKey</returns>
        PrivKey BtcGenerateAddressPrivateKey(PrivKeyRequest privKeyRequest);
        /// <summary>
        /// Generate a Bitcoin wallet
        /// </summary>
        /// <remarks>
        /// 1 credit per API call Tatum supports BIP44 HD wallets. Because they can generate 2^31 addresses from 1 mnemonic phrase, they are very convenient and secure. A mnemonic phrase consists of 24 special words in a defined order and can restore access to all generated addresses and private keys. Each address is identified by 3 main values: Private Key - your secret value, which should never be revealed Public Key - public address to be published Derivation index - index of generated address Tatum follows BIP44 specification and generates for Bitcoin wallet with derivation path m&#39;/44&#39;/0&#39;/0&#39;/0. More about BIP44 HD wallets can be found here - https://github.com/bitcoin/bips/blob/master/bip-0044.mediawiki. Generate BIP44 compatible Bitcoin wallet.
        /// </remarks>
        /// <exception cref="Tatum.CSharp.Bitcoin.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="mnemonic">Mnemonic to use for generation of extended public and private keys. (optional)</param>
        /// <returns>Wallet</returns>
        Wallet BtcGenerateWallet(string mnemonic = default(string));
        /// <summary>
        /// Get the balance of a Bitcoin address
        /// </summary>
        /// <remarks>
        /// 1 credit per API call Get the balance of a Bitcoin address.
        /// </remarks>
        /// <exception cref="Tatum.CSharp.Bitcoin.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="address">The blockchain address to get the balance for</param>
        /// <returns>BtcBasedBalance</returns>
        BtcBasedBalance BtcGetBalanceOfAddress(string address);
        /// <summary>
        /// Get a Bitcoin block by its hash or height
        /// </summary>
        /// <remarks>
        /// 1 credit per API call Gets Bitcoin block detail by block hash or height.
        /// </remarks>
        /// <exception cref="Tatum.CSharp.Bitcoin.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="hash">Block hash or height.</param>
        /// <returns>BtcBlock</returns>
        BtcBlock BtcGetBlock(string hash);
        /// <summary>
        /// Get Bitcoin blockchain information
        /// </summary>
        /// <remarks>
        /// 1 credit per API call Gets Bitcoin blockchain information. Obtains basic info like the testnet / mainnet version of the chain, the current block number and its hash.
        /// </remarks>
        /// <exception cref="Tatum.CSharp.Bitcoin.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <returns>BtcInfo</returns>
        BtcInfo BtcGetBlockChainInfo();
        /// <summary>
        /// Get the hash of a Bitcoin block
        /// </summary>
        /// <remarks>
        /// 1 credit per API call Gets a Bitcoin block hash. Returns the hash of the block to get the block&#39;s details.
        /// </remarks>
        /// <exception cref="Tatum.CSharp.Bitcoin.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="i">The number of blocks preceding a particular block on a blockchain.</param>
        /// <returns>BtcBlockHash</returns>
        BtcBlockHash BtcGetBlockHash(decimal i);
        /// <summary>
        /// Get transactions from the Bitcoin mempool
        /// </summary>
        /// <remarks>
        /// 1 credit per API call Gets Bitcoin transaction IDs in the mempool.
        /// </remarks>
        /// <exception cref="Tatum.CSharp.Bitcoin.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <returns>List&lt;string&gt;</returns>
        List<string> BtcGetMempool();
        /// <summary>
        /// Get a Bitcoin transaction by its hash
        /// </summary>
        /// <remarks>
        /// 1 credit per API call Get Bitcoin Transaction detail by transaction hash.
        /// </remarks>
        /// <exception cref="Tatum.CSharp.Bitcoin.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="hash">Transaction hash</param>
        /// <returns>BtcTx</returns>
        BtcTx BtcGetRawTransaction(string hash);
        /// <summary>
        /// Get all transactions for a Bitcoin address
        /// </summary>
        /// <remarks>
        /// 1 credit per API call Get all transactions for a Bitcoin address.
        /// </remarks>
        /// <exception cref="Tatum.CSharp.Bitcoin.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="address">Address</param>
        /// <param name="pageSize">Max number of items per page is 50.</param>
        /// <param name="offset">Offset to obtain the next page of data. (optional)</param>
        /// <returns>List&lt;BtcTx&gt;</returns>
        List<BtcTx> BtcGetTxByAddress(string address, decimal pageSize, decimal? offset = default(decimal?));
        /// <summary>
        /// Get information about a transaction output (UTXO) in a Bitcoin transaction
        /// </summary>
        /// <remarks>
        /// 1 credit per API call Get information about a transaction output in a transaction and check whether this output is a UTXO or has been spent. \&quot;UTXO\&quot; stands for \&quot;Unspent Transaction Output\&quot;. A UTXO is the amount of BTC/satoshis that remains at a Bitcoin address after a cryptocurrency transaction involving this address has been performed. The UTXO can then be used as input for a new cryptocurrency transaction. For more information about Bitcoin transactions and UTXO, see the Bitcoin user documentation. If the transaction output is an UTXO, the API returns data about it. If the transaction output has been spent and there is no UTXO to return, the API returns an error with the 404 response code.
        /// </remarks>
        /// <exception cref="Tatum.CSharp.Bitcoin.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="hash">The transaction hash</param>
        /// <param name="index">The index of the transaction output that you want to check for the UTXO</param>
        /// <returns>BtcUTXO</returns>
        BtcUTXO BtcGetUTXO(string hash, decimal index);
        /// <summary>
        /// Send BTC to Bitcoin addresses
        /// </summary>
        /// <remarks>
        /// 2 credits per API call Send BTC to blockchain addresses. Bitcoin transactions are based on UTXOs. \&quot;UTXO\&quot; stands for \&quot;Unspent Transaction Output\&quot;. A UTXO is the amount of BTC/satoshis that remains at a Bitcoin address after a cryptocurrency transaction involving this address has been performed. The UTXO can then be used as input for a new cryptocurrency transaction. For more information about Bitcoin transactions and UTXO, see the Bitcoin user documentation. To check UTXOs in a transaction, see the API for getting information about a transaction output (UTXO) in a Bitcoin transaction. You can build a BTC transaction by one of the following methods: Sending BTC from blockchain addresses The assets are sent from a list of addresses. For each address, the last 100 transactions are scanned for any UTXO to be included in the transaction. For easier control over the assets to be sent, we recommend that you use this method only if you have one address to send the assets from. To use this method, use the BtcTransactionFromAddress or BtcTransactionFromAddressKMS schema of the request body. Sending BTC from UTXOs The assets are sent from a list of UTXOs. Each UTXO is included in the transaction. Use this method if you want to manually calculate the amount to send. To use this method, use the BtcTransactionFromUTXO or BtcTransactionFromUTXOKMS schema of the request body. When an UTXO is entered into a transaction, the whole UTXO amount is included and must be spent. For example, address A receives two transactions, T1 with 1 BTC and T2 with 2 BTC. A transaction that consumes the UTXOs from both T1 and T2 will have an available amount of 3 BTC to spend: 1 BTC (from T1) + 2 BTC (from T2) &#x3D; 3 BTC (to spend in total) You can send the assets to one or multiple recipients in one transaction. If you send the assets to multiple addresses, each address must have its own amount to receive. Paying the gas fee and receiving the change When the amount that the recipients should receive is lower than the amount from the UTXOs, the difference between these two amounts is by default used as the gas fee for the transaction. Because this amount may be considerable and you may not want to spend it all on the gas fee, you can explicitly specify the fee amount and the blockchain address where any extra funds remaining after covering the fee will be sent (the fee and changeAddress parameters in the request body, correspondingly). Signing a transaction When sending BTC, you are charged a fee for the transaction, and you must sign the transaction with the private key of the blockchain address from which the fee will be deducted. Providing the private key in the API is not a secure way of signing transactions, because the private key can be stolen or exposed. Your private keys should never leave your security perimeter. You should use the private keys only for testing a solution you are building on the testnet of a blockchain. For signing transactions on the mainnet, we strongly recommend that you use the Tatum Key Management System (KMS) and provide the signature ID instead of the private key in the API. Alternatively, you can use the Tatum JavaScript client.
        /// </remarks>
        /// <exception cref="Tatum.CSharp.Bitcoin.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="btcTransactionFromAddress"></param>
        /// <returns>TransactionHash</returns>
        TransactionHash BtcTransferBlockchain(BtcTransactionFromAddress btcTransactionFromAddress);
        /// <summary>
        /// Send BTC to Bitcoin addresses
        /// </summary>
        /// <remarks>
        /// 2 credits per API call Send BTC to blockchain addresses. Bitcoin transactions are based on UTXOs. \&quot;UTXO\&quot; stands for \&quot;Unspent Transaction Output\&quot;. A UTXO is the amount of BTC/satoshis that remains at a Bitcoin address after a cryptocurrency transaction involving this address has been performed. The UTXO can then be used as input for a new cryptocurrency transaction. For more information about Bitcoin transactions and UTXO, see the Bitcoin user documentation. To check UTXOs in a transaction, see the API for getting information about a transaction output (UTXO) in a Bitcoin transaction. You can build a BTC transaction by one of the following methods: Sending BTC from blockchain addresses The assets are sent from a list of addresses. For each address, the last 100 transactions are scanned for any UTXO to be included in the transaction. For easier control over the assets to be sent, we recommend that you use this method only if you have one address to send the assets from. To use this method, use the BtcTransactionFromAddress or BtcTransactionFromAddressKMS schema of the request body. Sending BTC from UTXOs The assets are sent from a list of UTXOs. Each UTXO is included in the transaction. Use this method if you want to manually calculate the amount to send. To use this method, use the BtcTransactionFromUTXO or BtcTransactionFromUTXOKMS schema of the request body. When an UTXO is entered into a transaction, the whole UTXO amount is included and must be spent. For example, address A receives two transactions, T1 with 1 BTC and T2 with 2 BTC. A transaction that consumes the UTXOs from both T1 and T2 will have an available amount of 3 BTC to spend: 1 BTC (from T1) + 2 BTC (from T2) &#x3D; 3 BTC (to spend in total) You can send the assets to one or multiple recipients in one transaction. If you send the assets to multiple addresses, each address must have its own amount to receive. Paying the gas fee and receiving the change When the amount that the recipients should receive is lower than the amount from the UTXOs, the difference between these two amounts is by default used as the gas fee for the transaction. Because this amount may be considerable and you may not want to spend it all on the gas fee, you can explicitly specify the fee amount and the blockchain address where any extra funds remaining after covering the fee will be sent (the fee and changeAddress parameters in the request body, correspondingly). Signing a transaction When sending BTC, you are charged a fee for the transaction, and you must sign the transaction with the private key of the blockchain address from which the fee will be deducted. Providing the private key in the API is not a secure way of signing transactions, because the private key can be stolen or exposed. Your private keys should never leave your security perimeter. You should use the private keys only for testing a solution you are building on the testnet of a blockchain. For signing transactions on the mainnet, we strongly recommend that you use the Tatum Key Management System (KMS) and provide the signature ID instead of the private key in the API. Alternatively, you can use the Tatum JavaScript client.
        /// </remarks>
        /// <exception cref="Tatum.CSharp.Bitcoin.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="btcTransactionFromAddressKMS"></param>
        /// <returns>SignatureId</returns>
        SignatureId BtcTransferBlockchain(BtcTransactionFromAddressKMS btcTransactionFromAddressKMS);
        /// <summary>
        /// Send BTC to Bitcoin addresses
        /// </summary>
        /// <remarks>
        /// 2 credits per API call Send BTC to blockchain addresses. Bitcoin transactions are based on UTXOs. \&quot;UTXO\&quot; stands for \&quot;Unspent Transaction Output\&quot;. A UTXO is the amount of BTC/satoshis that remains at a Bitcoin address after a cryptocurrency transaction involving this address has been performed. The UTXO can then be used as input for a new cryptocurrency transaction. For more information about Bitcoin transactions and UTXO, see the Bitcoin user documentation. To check UTXOs in a transaction, see the API for getting information about a transaction output (UTXO) in a Bitcoin transaction. You can build a BTC transaction by one of the following methods: Sending BTC from blockchain addresses The assets are sent from a list of addresses. For each address, the last 100 transactions are scanned for any UTXO to be included in the transaction. For easier control over the assets to be sent, we recommend that you use this method only if you have one address to send the assets from. To use this method, use the BtcTransactionFromAddress or BtcTransactionFromAddressKMS schema of the request body. Sending BTC from UTXOs The assets are sent from a list of UTXOs. Each UTXO is included in the transaction. Use this method if you want to manually calculate the amount to send. To use this method, use the BtcTransactionFromUTXO or BtcTransactionFromUTXOKMS schema of the request body. When an UTXO is entered into a transaction, the whole UTXO amount is included and must be spent. For example, address A receives two transactions, T1 with 1 BTC and T2 with 2 BTC. A transaction that consumes the UTXOs from both T1 and T2 will have an available amount of 3 BTC to spend: 1 BTC (from T1) + 2 BTC (from T2) &#x3D; 3 BTC (to spend in total) You can send the assets to one or multiple recipients in one transaction. If you send the assets to multiple addresses, each address must have its own amount to receive. Paying the gas fee and receiving the change When the amount that the recipients should receive is lower than the amount from the UTXOs, the difference between these two amounts is by default used as the gas fee for the transaction. Because this amount may be considerable and you may not want to spend it all on the gas fee, you can explicitly specify the fee amount and the blockchain address where any extra funds remaining after covering the fee will be sent (the fee and changeAddress parameters in the request body, correspondingly). Signing a transaction When sending BTC, you are charged a fee for the transaction, and you must sign the transaction with the private key of the blockchain address from which the fee will be deducted. Providing the private key in the API is not a secure way of signing transactions, because the private key can be stolen or exposed. Your private keys should never leave your security perimeter. You should use the private keys only for testing a solution you are building on the testnet of a blockchain. For signing transactions on the mainnet, we strongly recommend that you use the Tatum Key Management System (KMS) and provide the signature ID instead of the private key in the API. Alternatively, you can use the Tatum JavaScript client.
        /// </remarks>
        /// <exception cref="Tatum.CSharp.Bitcoin.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="btcTransactionFromUTXO"></param>
        /// <returns>TransactionHash</returns>
        TransactionHash BtcTransferBlockchain(BtcTransactionFromUTXO btcTransactionFromUTXO);
        /// <summary>
        /// Send BTC to Bitcoin addresses
        /// </summary>
        /// <remarks>
        /// 2 credits per API call Send BTC to blockchain addresses. Bitcoin transactions are based on UTXOs. \&quot;UTXO\&quot; stands for \&quot;Unspent Transaction Output\&quot;. A UTXO is the amount of BTC/satoshis that remains at a Bitcoin address after a cryptocurrency transaction involving this address has been performed. The UTXO can then be used as input for a new cryptocurrency transaction. For more information about Bitcoin transactions and UTXO, see the Bitcoin user documentation. To check UTXOs in a transaction, see the API for getting information about a transaction output (UTXO) in a Bitcoin transaction. You can build a BTC transaction by one of the following methods: Sending BTC from blockchain addresses The assets are sent from a list of addresses. For each address, the last 100 transactions are scanned for any UTXO to be included in the transaction. For easier control over the assets to be sent, we recommend that you use this method only if you have one address to send the assets from. To use this method, use the BtcTransactionFromAddress or BtcTransactionFromAddressKMS schema of the request body. Sending BTC from UTXOs The assets are sent from a list of UTXOs. Each UTXO is included in the transaction. Use this method if you want to manually calculate the amount to send. To use this method, use the BtcTransactionFromUTXO or BtcTransactionFromUTXOKMS schema of the request body. When an UTXO is entered into a transaction, the whole UTXO amount is included and must be spent. For example, address A receives two transactions, T1 with 1 BTC and T2 with 2 BTC. A transaction that consumes the UTXOs from both T1 and T2 will have an available amount of 3 BTC to spend: 1 BTC (from T1) + 2 BTC (from T2) &#x3D; 3 BTC (to spend in total) You can send the assets to one or multiple recipients in one transaction. If you send the assets to multiple addresses, each address must have its own amount to receive. Paying the gas fee and receiving the change When the amount that the recipients should receive is lower than the amount from the UTXOs, the difference between these two amounts is by default used as the gas fee for the transaction. Because this amount may be considerable and you may not want to spend it all on the gas fee, you can explicitly specify the fee amount and the blockchain address where any extra funds remaining after covering the fee will be sent (the fee and changeAddress parameters in the request body, correspondingly). Signing a transaction When sending BTC, you are charged a fee for the transaction, and you must sign the transaction with the private key of the blockchain address from which the fee will be deducted. Providing the private key in the API is not a secure way of signing transactions, because the private key can be stolen or exposed. Your private keys should never leave your security perimeter. You should use the private keys only for testing a solution you are building on the testnet of a blockchain. For signing transactions on the mainnet, we strongly recommend that you use the Tatum Key Management System (KMS) and provide the signature ID instead of the private key in the API. Alternatively, you can use the Tatum JavaScript client.
        /// </remarks>
        /// <exception cref="Tatum.CSharp.Bitcoin.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="btcTransactionFromUTXOKMS"></param>
        /// <returns>SignatureId</returns>
        SignatureId BtcTransferBlockchain(BtcTransactionFromUTXOKMS btcTransactionFromUTXOKMS);
        #endregion Synchronous Operations
    }

    /// <summary>
    /// Represents a collection of functions to interact with the API endpoints
    /// </summary>
    public interface IBitcoinApiWithHttpInfoSync : IApiAccessor
    {
        #region Synchronous Operations With Http Info
        /// <summary>
        /// Broadcast a signed Bitcoin transaction
        /// </summary>
        /// <remarks>
        /// 2 credits per API call Broadcasts a signed transaction to the Bitcoin blockchain. This method is used internally from Tatum KMS or Tatum Client Libraries. It is possible to create a custom signing mechanism and only use this method for broadcasting data to the blockchain.
        /// </remarks>
        /// <exception cref="Tatum.CSharp.Bitcoin.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="broadcastKMS"></param>
        /// <returns>ApiResponse of TransactionHash</returns>
        ApiResponse<TransactionHash> BtcBroadcastWithHttpInfo(BroadcastKMS broadcastKMS);
        /// <summary>
        /// Generate a Bitcoin address from the wallet&#39;s extended public key
        /// </summary>
        /// <remarks>
        /// 1 credit per API call Generate a Bitcoin address from the extended public key of the wallet. The address is generated for the specific index - each extended public key can generate up to 2^32 addresses with the index starting from 0 up to 2^31 - 1.
        /// </remarks>
        /// <exception cref="Tatum.CSharp.Bitcoin.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="xpub">Extended public key of a wallet.</param>
        /// <param name="index">Derivation index of the desired address to be generated.</param>
        /// <returns>ApiResponse of GeneratedAddressBtc</returns>
        ApiResponse<GeneratedAddressBtc> BtcGenerateAddressWithHttpInfo(string xpub, decimal index);
        /// <summary>
        /// Generate the private key for a Bitcoin address
        /// </summary>
        /// <remarks>
        /// 1 credit per API call Generates a private key for an address from a mnemonic for a given derivation path index. The private key is generated for the specific index - each mnemonic can generate up to 2^32 private keys starting from index 0 until 2^31 - 1.
        /// </remarks>
        /// <exception cref="Tatum.CSharp.Bitcoin.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="privKeyRequest"></param>
        /// <returns>ApiResponse of PrivKey</returns>
        ApiResponse<PrivKey> BtcGenerateAddressPrivateKeyWithHttpInfo(PrivKeyRequest privKeyRequest);
        /// <summary>
        /// Generate a Bitcoin wallet
        /// </summary>
        /// <remarks>
        /// 1 credit per API call Tatum supports BIP44 HD wallets. Because they can generate 2^31 addresses from 1 mnemonic phrase, they are very convenient and secure. A mnemonic phrase consists of 24 special words in a defined order and can restore access to all generated addresses and private keys. Each address is identified by 3 main values: Private Key - your secret value, which should never be revealed Public Key - public address to be published Derivation index - index of generated address Tatum follows BIP44 specification and generates for Bitcoin wallet with derivation path m&#39;/44&#39;/0&#39;/0&#39;/0. More about BIP44 HD wallets can be found here - https://github.com/bitcoin/bips/blob/master/bip-0044.mediawiki. Generate BIP44 compatible Bitcoin wallet.
        /// </remarks>
        /// <exception cref="Tatum.CSharp.Bitcoin.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="mnemonic">Mnemonic to use for generation of extended public and private keys. (optional)</param>
        /// <returns>ApiResponse of Wallet</returns>
        ApiResponse<Wallet> BtcGenerateWalletWithHttpInfo(string mnemonic = default(string));
        /// <summary>
        /// Get the balance of a Bitcoin address
        /// </summary>
        /// <remarks>
        /// 1 credit per API call Get the balance of a Bitcoin address.
        /// </remarks>
        /// <exception cref="Tatum.CSharp.Bitcoin.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="address">The blockchain address to get the balance for</param>
        /// <returns>ApiResponse of BtcBasedBalance</returns>
        ApiResponse<BtcBasedBalance> BtcGetBalanceOfAddressWithHttpInfo(string address);
        /// <summary>
        /// Get a Bitcoin block by its hash or height
        /// </summary>
        /// <remarks>
        /// 1 credit per API call Gets Bitcoin block detail by block hash or height.
        /// </remarks>
        /// <exception cref="Tatum.CSharp.Bitcoin.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="hash">Block hash or height.</param>
        /// <returns>ApiResponse of BtcBlock</returns>
        ApiResponse<BtcBlock> BtcGetBlockWithHttpInfo(string hash);
        /// <summary>
        /// Get Bitcoin blockchain information
        /// </summary>
        /// <remarks>
        /// 1 credit per API call Gets Bitcoin blockchain information. Obtains basic info like the testnet / mainnet version of the chain, the current block number and its hash.
        /// </remarks>
        /// <exception cref="Tatum.CSharp.Bitcoin.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <returns>ApiResponse of BtcInfo</returns>
        ApiResponse<BtcInfo> BtcGetBlockChainInfoWithHttpInfo();
        /// <summary>
        /// Get the hash of a Bitcoin block
        /// </summary>
        /// <remarks>
        /// 1 credit per API call Gets a Bitcoin block hash. Returns the hash of the block to get the block&#39;s details.
        /// </remarks>
        /// <exception cref="Tatum.CSharp.Bitcoin.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="i">The number of blocks preceding a particular block on a blockchain.</param>
        /// <returns>ApiResponse of BtcBlockHash</returns>
        ApiResponse<BtcBlockHash> BtcGetBlockHashWithHttpInfo(decimal i);
        /// <summary>
        /// Get transactions from the Bitcoin mempool
        /// </summary>
        /// <remarks>
        /// 1 credit per API call Gets Bitcoin transaction IDs in the mempool.
        /// </remarks>
        /// <exception cref="Tatum.CSharp.Bitcoin.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <returns>ApiResponse of List&lt;string&gt;</returns>
        ApiResponse<List<string>> BtcGetMempoolWithHttpInfo();
        /// <summary>
        /// Get a Bitcoin transaction by its hash
        /// </summary>
        /// <remarks>
        /// 1 credit per API call Get Bitcoin Transaction detail by transaction hash.
        /// </remarks>
        /// <exception cref="Tatum.CSharp.Bitcoin.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="hash">Transaction hash</param>
        /// <returns>ApiResponse of BtcTx</returns>
        ApiResponse<BtcTx> BtcGetRawTransactionWithHttpInfo(string hash);
        /// <summary>
        /// Get all transactions for a Bitcoin address
        /// </summary>
        /// <remarks>
        /// 1 credit per API call Get all transactions for a Bitcoin address.
        /// </remarks>
        /// <exception cref="Tatum.CSharp.Bitcoin.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="address">Address</param>
        /// <param name="pageSize">Max number of items per page is 50.</param>
        /// <param name="offset">Offset to obtain the next page of data. (optional)</param>
        /// <returns>ApiResponse of List&lt;BtcTx&gt;</returns>
        ApiResponse<List<BtcTx>> BtcGetTxByAddressWithHttpInfo(string address, decimal pageSize, decimal? offset = default(decimal?));
        /// <summary>
        /// Get information about a transaction output (UTXO) in a Bitcoin transaction
        /// </summary>
        /// <remarks>
        /// 1 credit per API call Get information about a transaction output in a transaction and check whether this output is a UTXO or has been spent. \&quot;UTXO\&quot; stands for \&quot;Unspent Transaction Output\&quot;. A UTXO is the amount of BTC/satoshis that remains at a Bitcoin address after a cryptocurrency transaction involving this address has been performed. The UTXO can then be used as input for a new cryptocurrency transaction. For more information about Bitcoin transactions and UTXO, see the Bitcoin user documentation. If the transaction output is an UTXO, the API returns data about it. If the transaction output has been spent and there is no UTXO to return, the API returns an error with the 404 response code.
        /// </remarks>
        /// <exception cref="Tatum.CSharp.Bitcoin.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="hash">The transaction hash</param>
        /// <param name="index">The index of the transaction output that you want to check for the UTXO</param>
        /// <returns>ApiResponse of BtcUTXO</returns>
        ApiResponse<BtcUTXO> BtcGetUTXOWithHttpInfo(string hash, decimal index);
        /// <summary>
        /// Send BTC to Bitcoin addresses
        /// </summary>
        /// <remarks>
        /// 2 credits per API call Send BTC to blockchain addresses. Bitcoin transactions are based on UTXOs. \&quot;UTXO\&quot; stands for \&quot;Unspent Transaction Output\&quot;. A UTXO is the amount of BTC/satoshis that remains at a Bitcoin address after a cryptocurrency transaction involving this address has been performed. The UTXO can then be used as input for a new cryptocurrency transaction. For more information about Bitcoin transactions and UTXO, see the Bitcoin user documentation. To check UTXOs in a transaction, see the API for getting information about a transaction output (UTXO) in a Bitcoin transaction. You can build a BTC transaction by one of the following methods: Sending BTC from blockchain addresses The assets are sent from a list of addresses. For each address, the last 100 transactions are scanned for any UTXO to be included in the transaction. For easier control over the assets to be sent, we recommend that you use this method only if you have one address to send the assets from. To use this method, use the BtcTransactionFromAddress or BtcTransactionFromAddressKMS schema of the request body. Sending BTC from UTXOs The assets are sent from a list of UTXOs. Each UTXO is included in the transaction. Use this method if you want to manually calculate the amount to send. To use this method, use the BtcTransactionFromUTXO or BtcTransactionFromUTXOKMS schema of the request body. When an UTXO is entered into a transaction, the whole UTXO amount is included and must be spent. For example, address A receives two transactions, T1 with 1 BTC and T2 with 2 BTC. A transaction that consumes the UTXOs from both T1 and T2 will have an available amount of 3 BTC to spend: 1 BTC (from T1) + 2 BTC (from T2) &#x3D; 3 BTC (to spend in total) You can send the assets to one or multiple recipients in one transaction. If you send the assets to multiple addresses, each address must have its own amount to receive. Paying the gas fee and receiving the change When the amount that the recipients should receive is lower than the amount from the UTXOs, the difference between these two amounts is by default used as the gas fee for the transaction. Because this amount may be considerable and you may not want to spend it all on the gas fee, you can explicitly specify the fee amount and the blockchain address where any extra funds remaining after covering the fee will be sent (the fee and changeAddress parameters in the request body, correspondingly). Signing a transaction When sending BTC, you are charged a fee for the transaction, and you must sign the transaction with the private key of the blockchain address from which the fee will be deducted. Providing the private key in the API is not a secure way of signing transactions, because the private key can be stolen or exposed. Your private keys should never leave your security perimeter. You should use the private keys only for testing a solution you are building on the testnet of a blockchain. For signing transactions on the mainnet, we strongly recommend that you use the Tatum Key Management System (KMS) and provide the signature ID instead of the private key in the API. Alternatively, you can use the Tatum JavaScript client.
        /// </remarks>
        /// <exception cref="Tatum.CSharp.Bitcoin.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="btcTransactionFromAddress"></param>
        /// <returns>ApiResponse of TransactionHash</returns>
        ApiResponse<TransactionHash> BtcTransferBlockchainWithHttpInfo(BtcTransactionFromAddress btcTransactionFromAddress);
        /// <summary>
        /// Send BTC to Bitcoin addresses
        /// </summary>
        /// <remarks>
        /// 2 credits per API call Send BTC to blockchain addresses. Bitcoin transactions are based on UTXOs. \&quot;UTXO\&quot; stands for \&quot;Unspent Transaction Output\&quot;. A UTXO is the amount of BTC/satoshis that remains at a Bitcoin address after a cryptocurrency transaction involving this address has been performed. The UTXO can then be used as input for a new cryptocurrency transaction. For more information about Bitcoin transactions and UTXO, see the Bitcoin user documentation. To check UTXOs in a transaction, see the API for getting information about a transaction output (UTXO) in a Bitcoin transaction. You can build a BTC transaction by one of the following methods: Sending BTC from blockchain addresses The assets are sent from a list of addresses. For each address, the last 100 transactions are scanned for any UTXO to be included in the transaction. For easier control over the assets to be sent, we recommend that you use this method only if you have one address to send the assets from. To use this method, use the BtcTransactionFromAddress or BtcTransactionFromAddressKMS schema of the request body. Sending BTC from UTXOs The assets are sent from a list of UTXOs. Each UTXO is included in the transaction. Use this method if you want to manually calculate the amount to send. To use this method, use the BtcTransactionFromUTXO or BtcTransactionFromUTXOKMS schema of the request body. When an UTXO is entered into a transaction, the whole UTXO amount is included and must be spent. For example, address A receives two transactions, T1 with 1 BTC and T2 with 2 BTC. A transaction that consumes the UTXOs from both T1 and T2 will have an available amount of 3 BTC to spend: 1 BTC (from T1) + 2 BTC (from T2) &#x3D; 3 BTC (to spend in total) You can send the assets to one or multiple recipients in one transaction. If you send the assets to multiple addresses, each address must have its own amount to receive. Paying the gas fee and receiving the change When the amount that the recipients should receive is lower than the amount from the UTXOs, the difference between these two amounts is by default used as the gas fee for the transaction. Because this amount may be considerable and you may not want to spend it all on the gas fee, you can explicitly specify the fee amount and the blockchain address where any extra funds remaining after covering the fee will be sent (the fee and changeAddress parameters in the request body, correspondingly). Signing a transaction When sending BTC, you are charged a fee for the transaction, and you must sign the transaction with the private key of the blockchain address from which the fee will be deducted. Providing the private key in the API is not a secure way of signing transactions, because the private key can be stolen or exposed. Your private keys should never leave your security perimeter. You should use the private keys only for testing a solution you are building on the testnet of a blockchain. For signing transactions on the mainnet, we strongly recommend that you use the Tatum Key Management System (KMS) and provide the signature ID instead of the private key in the API. Alternatively, you can use the Tatum JavaScript client.
        /// </remarks>
        /// <exception cref="Tatum.CSharp.Bitcoin.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="btcTransactionFromAddressKMS"></param>
        /// <returns>ApiResponse of SignatureId</returns>
        ApiResponse<SignatureId> BtcTransferBlockchainWithHttpInfo(BtcTransactionFromAddressKMS btcTransactionFromAddressKMS);
        /// <summary>
        /// Send BTC to Bitcoin addresses
        /// </summary>
        /// <remarks>
        /// 2 credits per API call Send BTC to blockchain addresses. Bitcoin transactions are based on UTXOs. \&quot;UTXO\&quot; stands for \&quot;Unspent Transaction Output\&quot;. A UTXO is the amount of BTC/satoshis that remains at a Bitcoin address after a cryptocurrency transaction involving this address has been performed. The UTXO can then be used as input for a new cryptocurrency transaction. For more information about Bitcoin transactions and UTXO, see the Bitcoin user documentation. To check UTXOs in a transaction, see the API for getting information about a transaction output (UTXO) in a Bitcoin transaction. You can build a BTC transaction by one of the following methods: Sending BTC from blockchain addresses The assets are sent from a list of addresses. For each address, the last 100 transactions are scanned for any UTXO to be included in the transaction. For easier control over the assets to be sent, we recommend that you use this method only if you have one address to send the assets from. To use this method, use the BtcTransactionFromAddress or BtcTransactionFromAddressKMS schema of the request body. Sending BTC from UTXOs The assets are sent from a list of UTXOs. Each UTXO is included in the transaction. Use this method if you want to manually calculate the amount to send. To use this method, use the BtcTransactionFromUTXO or BtcTransactionFromUTXOKMS schema of the request body. When an UTXO is entered into a transaction, the whole UTXO amount is included and must be spent. For example, address A receives two transactions, T1 with 1 BTC and T2 with 2 BTC. A transaction that consumes the UTXOs from both T1 and T2 will have an available amount of 3 BTC to spend: 1 BTC (from T1) + 2 BTC (from T2) &#x3D; 3 BTC (to spend in total) You can send the assets to one or multiple recipients in one transaction. If you send the assets to multiple addresses, each address must have its own amount to receive. Paying the gas fee and receiving the change When the amount that the recipients should receive is lower than the amount from the UTXOs, the difference between these two amounts is by default used as the gas fee for the transaction. Because this amount may be considerable and you may not want to spend it all on the gas fee, you can explicitly specify the fee amount and the blockchain address where any extra funds remaining after covering the fee will be sent (the fee and changeAddress parameters in the request body, correspondingly). Signing a transaction When sending BTC, you are charged a fee for the transaction, and you must sign the transaction with the private key of the blockchain address from which the fee will be deducted. Providing the private key in the API is not a secure way of signing transactions, because the private key can be stolen or exposed. Your private keys should never leave your security perimeter. You should use the private keys only for testing a solution you are building on the testnet of a blockchain. For signing transactions on the mainnet, we strongly recommend that you use the Tatum Key Management System (KMS) and provide the signature ID instead of the private key in the API. Alternatively, you can use the Tatum JavaScript client.
        /// </remarks>
        /// <exception cref="Tatum.CSharp.Bitcoin.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="btcTransactionFromUTXO"></param>
        /// <returns>ApiResponse of TransactionHash</returns>
        ApiResponse<TransactionHash> BtcTransferBlockchainWithHttpInfo(BtcTransactionFromUTXO btcTransactionFromUTXO);
        /// <summary>
        /// Send BTC to Bitcoin addresses
        /// </summary>
        /// <remarks>
        /// 2 credits per API call Send BTC to blockchain addresses. Bitcoin transactions are based on UTXOs. \&quot;UTXO\&quot; stands for \&quot;Unspent Transaction Output\&quot;. A UTXO is the amount of BTC/satoshis that remains at a Bitcoin address after a cryptocurrency transaction involving this address has been performed. The UTXO can then be used as input for a new cryptocurrency transaction. For more information about Bitcoin transactions and UTXO, see the Bitcoin user documentation. To check UTXOs in a transaction, see the API for getting information about a transaction output (UTXO) in a Bitcoin transaction. You can build a BTC transaction by one of the following methods: Sending BTC from blockchain addresses The assets are sent from a list of addresses. For each address, the last 100 transactions are scanned for any UTXO to be included in the transaction. For easier control over the assets to be sent, we recommend that you use this method only if you have one address to send the assets from. To use this method, use the BtcTransactionFromAddress or BtcTransactionFromAddressKMS schema of the request body. Sending BTC from UTXOs The assets are sent from a list of UTXOs. Each UTXO is included in the transaction. Use this method if you want to manually calculate the amount to send. To use this method, use the BtcTransactionFromUTXO or BtcTransactionFromUTXOKMS schema of the request body. When an UTXO is entered into a transaction, the whole UTXO amount is included and must be spent. For example, address A receives two transactions, T1 with 1 BTC and T2 with 2 BTC. A transaction that consumes the UTXOs from both T1 and T2 will have an available amount of 3 BTC to spend: 1 BTC (from T1) + 2 BTC (from T2) &#x3D; 3 BTC (to spend in total) You can send the assets to one or multiple recipients in one transaction. If you send the assets to multiple addresses, each address must have its own amount to receive. Paying the gas fee and receiving the change When the amount that the recipients should receive is lower than the amount from the UTXOs, the difference between these two amounts is by default used as the gas fee for the transaction. Because this amount may be considerable and you may not want to spend it all on the gas fee, you can explicitly specify the fee amount and the blockchain address where any extra funds remaining after covering the fee will be sent (the fee and changeAddress parameters in the request body, correspondingly). Signing a transaction When sending BTC, you are charged a fee for the transaction, and you must sign the transaction with the private key of the blockchain address from which the fee will be deducted. Providing the private key in the API is not a secure way of signing transactions, because the private key can be stolen or exposed. Your private keys should never leave your security perimeter. You should use the private keys only for testing a solution you are building on the testnet of a blockchain. For signing transactions on the mainnet, we strongly recommend that you use the Tatum Key Management System (KMS) and provide the signature ID instead of the private key in the API. Alternatively, you can use the Tatum JavaScript client.
        /// </remarks>
        /// <exception cref="Tatum.CSharp.Bitcoin.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="btcTransactionFromUTXOKMS"></param>
        /// <returns>ApiResponse of SignatureId</returns>
        ApiResponse<SignatureId> BtcTransferBlockchainWithHttpInfo(BtcTransactionFromUTXOKMS btcTransactionFromUTXOKMS);
        #endregion Synchronous Operations With Http Info
    }

    /// <summary>
    /// Represents a collection of functions to interact with the API endpoints
    /// </summary>
    public interface IBitcoinApiAsync : IApiAccessor
    {
        #region Asynchronous Operations
        /// <summary>
        /// Broadcast a signed Bitcoin transaction
        /// </summary>
        /// <remarks>
        /// 2 credits per API call Broadcasts a signed transaction to the Bitcoin blockchain. This method is used internally from Tatum KMS or Tatum Client Libraries. It is possible to create a custom signing mechanism and only use this method for broadcasting data to the blockchain.
        /// </remarks>
        /// <exception cref="Tatum.CSharp.Bitcoin.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="broadcastKMS"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of TransactionHash</returns>
        System.Threading.Tasks.Task<TransactionHash> BtcBroadcastAsync(BroadcastKMS broadcastKMS, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        /// <summary>
        /// Generate a Bitcoin address from the wallet&#39;s extended public key
        /// </summary>
        /// <remarks>
        /// 1 credit per API call Generate a Bitcoin address from the extended public key of the wallet. The address is generated for the specific index - each extended public key can generate up to 2^32 addresses with the index starting from 0 up to 2^31 - 1.
        /// </remarks>
        /// <exception cref="Tatum.CSharp.Bitcoin.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="xpub">Extended public key of a wallet.</param>
        /// <param name="index">Derivation index of the desired address to be generated.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of GeneratedAddressBtc</returns>
        System.Threading.Tasks.Task<GeneratedAddressBtc> BtcGenerateAddressAsync(string xpub, decimal index, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        /// <summary>
        /// Generate the private key for a Bitcoin address
        /// </summary>
        /// <remarks>
        /// 1 credit per API call Generates a private key for an address from a mnemonic for a given derivation path index. The private key is generated for the specific index - each mnemonic can generate up to 2^32 private keys starting from index 0 until 2^31 - 1.
        /// </remarks>
        /// <exception cref="Tatum.CSharp.Bitcoin.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="privKeyRequest"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of PrivKey</returns>
        System.Threading.Tasks.Task<PrivKey> BtcGenerateAddressPrivateKeyAsync(PrivKeyRequest privKeyRequest, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        /// <summary>
        /// Generate a Bitcoin wallet
        /// </summary>
        /// <remarks>
        /// 1 credit per API call Tatum supports BIP44 HD wallets. Because they can generate 2^31 addresses from 1 mnemonic phrase, they are very convenient and secure. A mnemonic phrase consists of 24 special words in a defined order and can restore access to all generated addresses and private keys. Each address is identified by 3 main values: Private Key - your secret value, which should never be revealed Public Key - public address to be published Derivation index - index of generated address Tatum follows BIP44 specification and generates for Bitcoin wallet with derivation path m&#39;/44&#39;/0&#39;/0&#39;/0. More about BIP44 HD wallets can be found here - https://github.com/bitcoin/bips/blob/master/bip-0044.mediawiki. Generate BIP44 compatible Bitcoin wallet.
        /// </remarks>
        /// <exception cref="Tatum.CSharp.Bitcoin.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="mnemonic">Mnemonic to use for generation of extended public and private keys. (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of Wallet</returns>
        System.Threading.Tasks.Task<Wallet> BtcGenerateWalletAsync(string mnemonic = default(string), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        /// <summary>
        /// Get the balance of a Bitcoin address
        /// </summary>
        /// <remarks>
        /// 1 credit per API call Get the balance of a Bitcoin address.
        /// </remarks>
        /// <exception cref="Tatum.CSharp.Bitcoin.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="address">The blockchain address to get the balance for</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of BtcBasedBalance</returns>
        System.Threading.Tasks.Task<BtcBasedBalance> BtcGetBalanceOfAddressAsync(string address, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        /// <summary>
        /// Get a Bitcoin block by its hash or height
        /// </summary>
        /// <remarks>
        /// 1 credit per API call Gets Bitcoin block detail by block hash or height.
        /// </remarks>
        /// <exception cref="Tatum.CSharp.Bitcoin.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="hash">Block hash or height.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of BtcBlock</returns>
        System.Threading.Tasks.Task<BtcBlock> BtcGetBlockAsync(string hash, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        /// <summary>
        /// Get Bitcoin blockchain information
        /// </summary>
        /// <remarks>
        /// 1 credit per API call Gets Bitcoin blockchain information. Obtains basic info like the testnet / mainnet version of the chain, the current block number and its hash.
        /// </remarks>
        /// <exception cref="Tatum.CSharp.Bitcoin.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of BtcInfo</returns>
        System.Threading.Tasks.Task<BtcInfo> BtcGetBlockChainInfoAsync(System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        /// <summary>
        /// Get the hash of a Bitcoin block
        /// </summary>
        /// <remarks>
        /// 1 credit per API call Gets a Bitcoin block hash. Returns the hash of the block to get the block&#39;s details.
        /// </remarks>
        /// <exception cref="Tatum.CSharp.Bitcoin.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="i">The number of blocks preceding a particular block on a blockchain.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of BtcBlockHash</returns>
        System.Threading.Tasks.Task<BtcBlockHash> BtcGetBlockHashAsync(decimal i, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        /// <summary>
        /// Get transactions from the Bitcoin mempool
        /// </summary>
        /// <remarks>
        /// 1 credit per API call Gets Bitcoin transaction IDs in the mempool.
        /// </remarks>
        /// <exception cref="Tatum.CSharp.Bitcoin.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of List&lt;string&gt;</returns>
        System.Threading.Tasks.Task<List<string>> BtcGetMempoolAsync(System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        /// <summary>
        /// Get a Bitcoin transaction by its hash
        /// </summary>
        /// <remarks>
        /// 1 credit per API call Get Bitcoin Transaction detail by transaction hash.
        /// </remarks>
        /// <exception cref="Tatum.CSharp.Bitcoin.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="hash">Transaction hash</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of BtcTx</returns>
        System.Threading.Tasks.Task<BtcTx> BtcGetRawTransactionAsync(string hash, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        /// <summary>
        /// Get all transactions for a Bitcoin address
        /// </summary>
        /// <remarks>
        /// 1 credit per API call Get all transactions for a Bitcoin address.
        /// </remarks>
        /// <exception cref="Tatum.CSharp.Bitcoin.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="address">Address</param>
        /// <param name="pageSize">Max number of items per page is 50.</param>
        /// <param name="offset">Offset to obtain the next page of data. (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of List&lt;BtcTx&gt;</returns>
        System.Threading.Tasks.Task<List<BtcTx>> BtcGetTxByAddressAsync(string address, decimal pageSize, decimal? offset = default(decimal?), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        /// <summary>
        /// Get information about a transaction output (UTXO) in a Bitcoin transaction
        /// </summary>
        /// <remarks>
        /// 1 credit per API call Get information about a transaction output in a transaction and check whether this output is a UTXO or has been spent. \&quot;UTXO\&quot; stands for \&quot;Unspent Transaction Output\&quot;. A UTXO is the amount of BTC/satoshis that remains at a Bitcoin address after a cryptocurrency transaction involving this address has been performed. The UTXO can then be used as input for a new cryptocurrency transaction. For more information about Bitcoin transactions and UTXO, see the Bitcoin user documentation. If the transaction output is an UTXO, the API returns data about it. If the transaction output has been spent and there is no UTXO to return, the API returns an error with the 404 response code.
        /// </remarks>
        /// <exception cref="Tatum.CSharp.Bitcoin.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="hash">The transaction hash</param>
        /// <param name="index">The index of the transaction output that you want to check for the UTXO</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of BtcUTXO</returns>
        System.Threading.Tasks.Task<BtcUTXO> BtcGetUTXOAsync(string hash, decimal index, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        /// <summary>
        /// Send BTC to Bitcoin addresses
        /// </summary>
        /// <remarks>
        /// 2 credits per API call Send BTC to blockchain addresses. Bitcoin transactions are based on UTXOs. \&quot;UTXO\&quot; stands for \&quot;Unspent Transaction Output\&quot;. A UTXO is the amount of BTC/satoshis that remains at a Bitcoin address after a cryptocurrency transaction involving this address has been performed. The UTXO can then be used as input for a new cryptocurrency transaction. For more information about Bitcoin transactions and UTXO, see the Bitcoin user documentation. To check UTXOs in a transaction, see the API for getting information about a transaction output (UTXO) in a Bitcoin transaction. You can build a BTC transaction by one of the following methods: Sending BTC from blockchain addresses The assets are sent from a list of addresses. For each address, the last 100 transactions are scanned for any UTXO to be included in the transaction. For easier control over the assets to be sent, we recommend that you use this method only if you have one address to send the assets from. To use this method, use the BtcTransactionFromAddress or BtcTransactionFromAddressKMS schema of the request body. Sending BTC from UTXOs The assets are sent from a list of UTXOs. Each UTXO is included in the transaction. Use this method if you want to manually calculate the amount to send. To use this method, use the BtcTransactionFromUTXO or BtcTransactionFromUTXOKMS schema of the request body. When an UTXO is entered into a transaction, the whole UTXO amount is included and must be spent. For example, address A receives two transactions, T1 with 1 BTC and T2 with 2 BTC. A transaction that consumes the UTXOs from both T1 and T2 will have an available amount of 3 BTC to spend: 1 BTC (from T1) + 2 BTC (from T2) &#x3D; 3 BTC (to spend in total) You can send the assets to one or multiple recipients in one transaction. If you send the assets to multiple addresses, each address must have its own amount to receive. Paying the gas fee and receiving the change When the amount that the recipients should receive is lower than the amount from the UTXOs, the difference between these two amounts is by default used as the gas fee for the transaction. Because this amount may be considerable and you may not want to spend it all on the gas fee, you can explicitly specify the fee amount and the blockchain address where any extra funds remaining after covering the fee will be sent (the fee and changeAddress parameters in the request body, correspondingly). Signing a transaction When sending BTC, you are charged a fee for the transaction, and you must sign the transaction with the private key of the blockchain address from which the fee will be deducted. Providing the private key in the API is not a secure way of signing transactions, because the private key can be stolen or exposed. Your private keys should never leave your security perimeter. You should use the private keys only for testing a solution you are building on the testnet of a blockchain. For signing transactions on the mainnet, we strongly recommend that you use the Tatum Key Management System (KMS) and provide the signature ID instead of the private key in the API. Alternatively, you can use the Tatum JavaScript client.
        /// </remarks>
        /// <exception cref="Tatum.CSharp.Bitcoin.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="btcTransactionFromAddress"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of TransactionHash</returns>
        System.Threading.Tasks.Task<TransactionHash> BtcTransferBlockchainAsync(BtcTransactionFromAddress btcTransactionFromAddress, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        /// <summary>
        /// Send BTC to Bitcoin addresses
        /// </summary>
        /// <remarks>
        /// 2 credits per API call Send BTC to blockchain addresses. Bitcoin transactions are based on UTXOs. \&quot;UTXO\&quot; stands for \&quot;Unspent Transaction Output\&quot;. A UTXO is the amount of BTC/satoshis that remains at a Bitcoin address after a cryptocurrency transaction involving this address has been performed. The UTXO can then be used as input for a new cryptocurrency transaction. For more information about Bitcoin transactions and UTXO, see the Bitcoin user documentation. To check UTXOs in a transaction, see the API for getting information about a transaction output (UTXO) in a Bitcoin transaction. You can build a BTC transaction by one of the following methods: Sending BTC from blockchain addresses The assets are sent from a list of addresses. For each address, the last 100 transactions are scanned for any UTXO to be included in the transaction. For easier control over the assets to be sent, we recommend that you use this method only if you have one address to send the assets from. To use this method, use the BtcTransactionFromAddress or BtcTransactionFromAddressKMS schema of the request body. Sending BTC from UTXOs The assets are sent from a list of UTXOs. Each UTXO is included in the transaction. Use this method if you want to manually calculate the amount to send. To use this method, use the BtcTransactionFromUTXO or BtcTransactionFromUTXOKMS schema of the request body. When an UTXO is entered into a transaction, the whole UTXO amount is included and must be spent. For example, address A receives two transactions, T1 with 1 BTC and T2 with 2 BTC. A transaction that consumes the UTXOs from both T1 and T2 will have an available amount of 3 BTC to spend: 1 BTC (from T1) + 2 BTC (from T2) &#x3D; 3 BTC (to spend in total) You can send the assets to one or multiple recipients in one transaction. If you send the assets to multiple addresses, each address must have its own amount to receive. Paying the gas fee and receiving the change When the amount that the recipients should receive is lower than the amount from the UTXOs, the difference between these two amounts is by default used as the gas fee for the transaction. Because this amount may be considerable and you may not want to spend it all on the gas fee, you can explicitly specify the fee amount and the blockchain address where any extra funds remaining after covering the fee will be sent (the fee and changeAddress parameters in the request body, correspondingly). Signing a transaction When sending BTC, you are charged a fee for the transaction, and you must sign the transaction with the private key of the blockchain address from which the fee will be deducted. Providing the private key in the API is not a secure way of signing transactions, because the private key can be stolen or exposed. Your private keys should never leave your security perimeter. You should use the private keys only for testing a solution you are building on the testnet of a blockchain. For signing transactions on the mainnet, we strongly recommend that you use the Tatum Key Management System (KMS) and provide the signature ID instead of the private key in the API. Alternatively, you can use the Tatum JavaScript client.
        /// </remarks>
        /// <exception cref="Tatum.CSharp.Bitcoin.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="btcTransactionFromAddressKMS"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of SignatureId</returns>
        System.Threading.Tasks.Task<SignatureId> BtcTransferBlockchainAsync(BtcTransactionFromAddressKMS btcTransactionFromAddressKMS, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        /// <summary>
        /// Send BTC to Bitcoin addresses
        /// </summary>
        /// <remarks>
        /// 2 credits per API call Send BTC to blockchain addresses. Bitcoin transactions are based on UTXOs. \&quot;UTXO\&quot; stands for \&quot;Unspent Transaction Output\&quot;. A UTXO is the amount of BTC/satoshis that remains at a Bitcoin address after a cryptocurrency transaction involving this address has been performed. The UTXO can then be used as input for a new cryptocurrency transaction. For more information about Bitcoin transactions and UTXO, see the Bitcoin user documentation. To check UTXOs in a transaction, see the API for getting information about a transaction output (UTXO) in a Bitcoin transaction. You can build a BTC transaction by one of the following methods: Sending BTC from blockchain addresses The assets are sent from a list of addresses. For each address, the last 100 transactions are scanned for any UTXO to be included in the transaction. For easier control over the assets to be sent, we recommend that you use this method only if you have one address to send the assets from. To use this method, use the BtcTransactionFromAddress or BtcTransactionFromAddressKMS schema of the request body. Sending BTC from UTXOs The assets are sent from a list of UTXOs. Each UTXO is included in the transaction. Use this method if you want to manually calculate the amount to send. To use this method, use the BtcTransactionFromUTXO or BtcTransactionFromUTXOKMS schema of the request body. When an UTXO is entered into a transaction, the whole UTXO amount is included and must be spent. For example, address A receives two transactions, T1 with 1 BTC and T2 with 2 BTC. A transaction that consumes the UTXOs from both T1 and T2 will have an available amount of 3 BTC to spend: 1 BTC (from T1) + 2 BTC (from T2) &#x3D; 3 BTC (to spend in total) You can send the assets to one or multiple recipients in one transaction. If you send the assets to multiple addresses, each address must have its own amount to receive. Paying the gas fee and receiving the change When the amount that the recipients should receive is lower than the amount from the UTXOs, the difference between these two amounts is by default used as the gas fee for the transaction. Because this amount may be considerable and you may not want to spend it all on the gas fee, you can explicitly specify the fee amount and the blockchain address where any extra funds remaining after covering the fee will be sent (the fee and changeAddress parameters in the request body, correspondingly). Signing a transaction When sending BTC, you are charged a fee for the transaction, and you must sign the transaction with the private key of the blockchain address from which the fee will be deducted. Providing the private key in the API is not a secure way of signing transactions, because the private key can be stolen or exposed. Your private keys should never leave your security perimeter. You should use the private keys only for testing a solution you are building on the testnet of a blockchain. For signing transactions on the mainnet, we strongly recommend that you use the Tatum Key Management System (KMS) and provide the signature ID instead of the private key in the API. Alternatively, you can use the Tatum JavaScript client.
        /// </remarks>
        /// <exception cref="Tatum.CSharp.Bitcoin.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="btcTransactionFromUTXO"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of TransactionHash</returns>
        System.Threading.Tasks.Task<TransactionHash> BtcTransferBlockchainAsync(BtcTransactionFromUTXO btcTransactionFromUTXO, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        /// <summary>
        /// Send BTC to Bitcoin addresses
        /// </summary>
        /// <remarks>
        /// 2 credits per API call Send BTC to blockchain addresses. Bitcoin transactions are based on UTXOs. \&quot;UTXO\&quot; stands for \&quot;Unspent Transaction Output\&quot;. A UTXO is the amount of BTC/satoshis that remains at a Bitcoin address after a cryptocurrency transaction involving this address has been performed. The UTXO can then be used as input for a new cryptocurrency transaction. For more information about Bitcoin transactions and UTXO, see the Bitcoin user documentation. To check UTXOs in a transaction, see the API for getting information about a transaction output (UTXO) in a Bitcoin transaction. You can build a BTC transaction by one of the following methods: Sending BTC from blockchain addresses The assets are sent from a list of addresses. For each address, the last 100 transactions are scanned for any UTXO to be included in the transaction. For easier control over the assets to be sent, we recommend that you use this method only if you have one address to send the assets from. To use this method, use the BtcTransactionFromAddress or BtcTransactionFromAddressKMS schema of the request body. Sending BTC from UTXOs The assets are sent from a list of UTXOs. Each UTXO is included in the transaction. Use this method if you want to manually calculate the amount to send. To use this method, use the BtcTransactionFromUTXO or BtcTransactionFromUTXOKMS schema of the request body. When an UTXO is entered into a transaction, the whole UTXO amount is included and must be spent. For example, address A receives two transactions, T1 with 1 BTC and T2 with 2 BTC. A transaction that consumes the UTXOs from both T1 and T2 will have an available amount of 3 BTC to spend: 1 BTC (from T1) + 2 BTC (from T2) &#x3D; 3 BTC (to spend in total) You can send the assets to one or multiple recipients in one transaction. If you send the assets to multiple addresses, each address must have its own amount to receive. Paying the gas fee and receiving the change When the amount that the recipients should receive is lower than the amount from the UTXOs, the difference between these two amounts is by default used as the gas fee for the transaction. Because this amount may be considerable and you may not want to spend it all on the gas fee, you can explicitly specify the fee amount and the blockchain address where any extra funds remaining after covering the fee will be sent (the fee and changeAddress parameters in the request body, correspondingly). Signing a transaction When sending BTC, you are charged a fee for the transaction, and you must sign the transaction with the private key of the blockchain address from which the fee will be deducted. Providing the private key in the API is not a secure way of signing transactions, because the private key can be stolen or exposed. Your private keys should never leave your security perimeter. You should use the private keys only for testing a solution you are building on the testnet of a blockchain. For signing transactions on the mainnet, we strongly recommend that you use the Tatum Key Management System (KMS) and provide the signature ID instead of the private key in the API. Alternatively, you can use the Tatum JavaScript client.
        /// </remarks>
        /// <exception cref="Tatum.CSharp.Bitcoin.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="btcTransactionFromUTXOKMS"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of SignatureId</returns>
        System.Threading.Tasks.Task<SignatureId> BtcTransferBlockchainAsync(BtcTransactionFromUTXOKMS btcTransactionFromUTXOKMS, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        #endregion Asynchronous Operations
    }

    /// <summary>
    /// Represents a collection of functions to interact with the API endpoints
    /// </summary>
    public interface IBitcoinApiWithHttpInfoAsync : IApiAccessor
    {
        #region Asynchronous Operations With Http Info
        /// <summary>
        /// Broadcast a signed Bitcoin transaction
        /// </summary>
        /// <remarks>
        /// 2 credits per API call Broadcasts a signed transaction to the Bitcoin blockchain. This method is used internally from Tatum KMS or Tatum Client Libraries. It is possible to create a custom signing mechanism and only use this method for broadcasting data to the blockchain.
        /// </remarks>
        /// <exception cref="Tatum.CSharp.Bitcoin.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="broadcastKMS"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (TransactionHash)</returns>
        System.Threading.Tasks.Task<ApiResponse<TransactionHash>> BtcBroadcastWithHttpInfoAsync(BroadcastKMS broadcastKMS, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        /// <summary>
        /// Generate a Bitcoin address from the wallet&#39;s extended public key
        /// </summary>
        /// <remarks>
        /// 1 credit per API call Generate a Bitcoin address from the extended public key of the wallet. The address is generated for the specific index - each extended public key can generate up to 2^32 addresses with the index starting from 0 up to 2^31 - 1.
        /// </remarks>
        /// <exception cref="Tatum.CSharp.Bitcoin.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="xpub">Extended public key of a wallet.</param>
        /// <param name="index">Derivation index of the desired address to be generated.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (GeneratedAddressBtc)</returns>
        System.Threading.Tasks.Task<ApiResponse<GeneratedAddressBtc>> BtcGenerateAddressWithHttpInfoAsync(string xpub, decimal index, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        /// <summary>
        /// Generate the private key for a Bitcoin address
        /// </summary>
        /// <remarks>
        /// 1 credit per API call Generates a private key for an address from a mnemonic for a given derivation path index. The private key is generated for the specific index - each mnemonic can generate up to 2^32 private keys starting from index 0 until 2^31 - 1.
        /// </remarks>
        /// <exception cref="Tatum.CSharp.Bitcoin.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="privKeyRequest"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (PrivKey)</returns>
        System.Threading.Tasks.Task<ApiResponse<PrivKey>> BtcGenerateAddressPrivateKeyWithHttpInfoAsync(PrivKeyRequest privKeyRequest, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        /// <summary>
        /// Generate a Bitcoin wallet
        /// </summary>
        /// <remarks>
        /// 1 credit per API call Tatum supports BIP44 HD wallets. Because they can generate 2^31 addresses from 1 mnemonic phrase, they are very convenient and secure. A mnemonic phrase consists of 24 special words in a defined order and can restore access to all generated addresses and private keys. Each address is identified by 3 main values: Private Key - your secret value, which should never be revealed Public Key - public address to be published Derivation index - index of generated address Tatum follows BIP44 specification and generates for Bitcoin wallet with derivation path m&#39;/44&#39;/0&#39;/0&#39;/0. More about BIP44 HD wallets can be found here - https://github.com/bitcoin/bips/blob/master/bip-0044.mediawiki. Generate BIP44 compatible Bitcoin wallet.
        /// </remarks>
        /// <exception cref="Tatum.CSharp.Bitcoin.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="mnemonic">Mnemonic to use for generation of extended public and private keys. (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (Wallet)</returns>
        System.Threading.Tasks.Task<ApiResponse<Wallet>> BtcGenerateWalletWithHttpInfoAsync(string mnemonic = default(string), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        /// <summary>
        /// Get the balance of a Bitcoin address
        /// </summary>
        /// <remarks>
        /// 1 credit per API call Get the balance of a Bitcoin address.
        /// </remarks>
        /// <exception cref="Tatum.CSharp.Bitcoin.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="address">The blockchain address to get the balance for</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (BtcBasedBalance)</returns>
        System.Threading.Tasks.Task<ApiResponse<BtcBasedBalance>> BtcGetBalanceOfAddressWithHttpInfoAsync(string address, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        /// <summary>
        /// Get a Bitcoin block by its hash or height
        /// </summary>
        /// <remarks>
        /// 1 credit per API call Gets Bitcoin block detail by block hash or height.
        /// </remarks>
        /// <exception cref="Tatum.CSharp.Bitcoin.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="hash">Block hash or height.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (BtcBlock)</returns>
        System.Threading.Tasks.Task<ApiResponse<BtcBlock>> BtcGetBlockWithHttpInfoAsync(string hash, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        /// <summary>
        /// Get Bitcoin blockchain information
        /// </summary>
        /// <remarks>
        /// 1 credit per API call Gets Bitcoin blockchain information. Obtains basic info like the testnet / mainnet version of the chain, the current block number and its hash.
        /// </remarks>
        /// <exception cref="Tatum.CSharp.Bitcoin.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (BtcInfo)</returns>
        System.Threading.Tasks.Task<ApiResponse<BtcInfo>> BtcGetBlockChainInfoWithHttpInfoAsync(System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        /// <summary>
        /// Get the hash of a Bitcoin block
        /// </summary>
        /// <remarks>
        /// 1 credit per API call Gets a Bitcoin block hash. Returns the hash of the block to get the block&#39;s details.
        /// </remarks>
        /// <exception cref="Tatum.CSharp.Bitcoin.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="i">The number of blocks preceding a particular block on a blockchain.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (BtcBlockHash)</returns>
        System.Threading.Tasks.Task<ApiResponse<BtcBlockHash>> BtcGetBlockHashWithHttpInfoAsync(decimal i, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        /// <summary>
        /// Get transactions from the Bitcoin mempool
        /// </summary>
        /// <remarks>
        /// 1 credit per API call Gets Bitcoin transaction IDs in the mempool.
        /// </remarks>
        /// <exception cref="Tatum.CSharp.Bitcoin.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (List&lt;string&gt;)</returns>
        System.Threading.Tasks.Task<ApiResponse<List<string>>> BtcGetMempoolWithHttpInfoAsync(System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        /// <summary>
        /// Get a Bitcoin transaction by its hash
        /// </summary>
        /// <remarks>
        /// 1 credit per API call Get Bitcoin Transaction detail by transaction hash.
        /// </remarks>
        /// <exception cref="Tatum.CSharp.Bitcoin.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="hash">Transaction hash</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (BtcTx)</returns>
        System.Threading.Tasks.Task<ApiResponse<BtcTx>> BtcGetRawTransactionWithHttpInfoAsync(string hash, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        /// <summary>
        /// Get all transactions for a Bitcoin address
        /// </summary>
        /// <remarks>
        /// 1 credit per API call Get all transactions for a Bitcoin address.
        /// </remarks>
        /// <exception cref="Tatum.CSharp.Bitcoin.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="address">Address</param>
        /// <param name="pageSize">Max number of items per page is 50.</param>
        /// <param name="offset">Offset to obtain the next page of data. (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (List&lt;BtcTx&gt;)</returns>
        System.Threading.Tasks.Task<ApiResponse<List<BtcTx>>> BtcGetTxByAddressWithHttpInfoAsync(string address, decimal pageSize, decimal? offset = default(decimal?), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        /// <summary>
        /// Get information about a transaction output (UTXO) in a Bitcoin transaction
        /// </summary>
        /// <remarks>
        /// 1 credit per API call Get information about a transaction output in a transaction and check whether this output is a UTXO or has been spent. \&quot;UTXO\&quot; stands for \&quot;Unspent Transaction Output\&quot;. A UTXO is the amount of BTC/satoshis that remains at a Bitcoin address after a cryptocurrency transaction involving this address has been performed. The UTXO can then be used as input for a new cryptocurrency transaction. For more information about Bitcoin transactions and UTXO, see the Bitcoin user documentation. If the transaction output is an UTXO, the API returns data about it. If the transaction output has been spent and there is no UTXO to return, the API returns an error with the 404 response code.
        /// </remarks>
        /// <exception cref="Tatum.CSharp.Bitcoin.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="hash">The transaction hash</param>
        /// <param name="index">The index of the transaction output that you want to check for the UTXO</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (BtcUTXO)</returns>
        System.Threading.Tasks.Task<ApiResponse<BtcUTXO>> BtcGetUTXOWithHttpInfoAsync(string hash, decimal index, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        /// <summary>
        /// Send BTC to Bitcoin addresses
        /// </summary>
        /// <remarks>
        /// 2 credits per API call Send BTC to blockchain addresses. Bitcoin transactions are based on UTXOs. \&quot;UTXO\&quot; stands for \&quot;Unspent Transaction Output\&quot;. A UTXO is the amount of BTC/satoshis that remains at a Bitcoin address after a cryptocurrency transaction involving this address has been performed. The UTXO can then be used as input for a new cryptocurrency transaction. For more information about Bitcoin transactions and UTXO, see the Bitcoin user documentation. To check UTXOs in a transaction, see the API for getting information about a transaction output (UTXO) in a Bitcoin transaction. You can build a BTC transaction by one of the following methods: Sending BTC from blockchain addresses The assets are sent from a list of addresses. For each address, the last 100 transactions are scanned for any UTXO to be included in the transaction. For easier control over the assets to be sent, we recommend that you use this method only if you have one address to send the assets from. To use this method, use the BtcTransactionFromAddress or BtcTransactionFromAddressKMS schema of the request body. Sending BTC from UTXOs The assets are sent from a list of UTXOs. Each UTXO is included in the transaction. Use this method if you want to manually calculate the amount to send. To use this method, use the BtcTransactionFromUTXO or BtcTransactionFromUTXOKMS schema of the request body. When an UTXO is entered into a transaction, the whole UTXO amount is included and must be spent. For example, address A receives two transactions, T1 with 1 BTC and T2 with 2 BTC. A transaction that consumes the UTXOs from both T1 and T2 will have an available amount of 3 BTC to spend: 1 BTC (from T1) + 2 BTC (from T2) &#x3D; 3 BTC (to spend in total) You can send the assets to one or multiple recipients in one transaction. If you send the assets to multiple addresses, each address must have its own amount to receive. Paying the gas fee and receiving the change When the amount that the recipients should receive is lower than the amount from the UTXOs, the difference between these two amounts is by default used as the gas fee for the transaction. Because this amount may be considerable and you may not want to spend it all on the gas fee, you can explicitly specify the fee amount and the blockchain address where any extra funds remaining after covering the fee will be sent (the fee and changeAddress parameters in the request body, correspondingly). Signing a transaction When sending BTC, you are charged a fee for the transaction, and you must sign the transaction with the private key of the blockchain address from which the fee will be deducted. Providing the private key in the API is not a secure way of signing transactions, because the private key can be stolen or exposed. Your private keys should never leave your security perimeter. You should use the private keys only for testing a solution you are building on the testnet of a blockchain. For signing transactions on the mainnet, we strongly recommend that you use the Tatum Key Management System (KMS) and provide the signature ID instead of the private key in the API. Alternatively, you can use the Tatum JavaScript client.
        /// </remarks>
        /// <exception cref="Tatum.CSharp.Bitcoin.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="btcTransactionFromAddress"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (TransactionHash)</returns>
        System.Threading.Tasks.Task<ApiResponse<TransactionHash>> BtcTransferBlockchainWithHttpInfoAsync(BtcTransactionFromAddress btcTransactionFromAddress, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        /// <summary>
        /// Send BTC to Bitcoin addresses
        /// </summary>
        /// <remarks>
        /// 2 credits per API call Send BTC to blockchain addresses. Bitcoin transactions are based on UTXOs. \&quot;UTXO\&quot; stands for \&quot;Unspent Transaction Output\&quot;. A UTXO is the amount of BTC/satoshis that remains at a Bitcoin address after a cryptocurrency transaction involving this address has been performed. The UTXO can then be used as input for a new cryptocurrency transaction. For more information about Bitcoin transactions and UTXO, see the Bitcoin user documentation. To check UTXOs in a transaction, see the API for getting information about a transaction output (UTXO) in a Bitcoin transaction. You can build a BTC transaction by one of the following methods: Sending BTC from blockchain addresses The assets are sent from a list of addresses. For each address, the last 100 transactions are scanned for any UTXO to be included in the transaction. For easier control over the assets to be sent, we recommend that you use this method only if you have one address to send the assets from. To use this method, use the BtcTransactionFromAddress or BtcTransactionFromAddressKMS schema of the request body. Sending BTC from UTXOs The assets are sent from a list of UTXOs. Each UTXO is included in the transaction. Use this method if you want to manually calculate the amount to send. To use this method, use the BtcTransactionFromUTXO or BtcTransactionFromUTXOKMS schema of the request body. When an UTXO is entered into a transaction, the whole UTXO amount is included and must be spent. For example, address A receives two transactions, T1 with 1 BTC and T2 with 2 BTC. A transaction that consumes the UTXOs from both T1 and T2 will have an available amount of 3 BTC to spend: 1 BTC (from T1) + 2 BTC (from T2) &#x3D; 3 BTC (to spend in total) You can send the assets to one or multiple recipients in one transaction. If you send the assets to multiple addresses, each address must have its own amount to receive. Paying the gas fee and receiving the change When the amount that the recipients should receive is lower than the amount from the UTXOs, the difference between these two amounts is by default used as the gas fee for the transaction. Because this amount may be considerable and you may not want to spend it all on the gas fee, you can explicitly specify the fee amount and the blockchain address where any extra funds remaining after covering the fee will be sent (the fee and changeAddress parameters in the request body, correspondingly). Signing a transaction When sending BTC, you are charged a fee for the transaction, and you must sign the transaction with the private key of the blockchain address from which the fee will be deducted. Providing the private key in the API is not a secure way of signing transactions, because the private key can be stolen or exposed. Your private keys should never leave your security perimeter. You should use the private keys only for testing a solution you are building on the testnet of a blockchain. For signing transactions on the mainnet, we strongly recommend that you use the Tatum Key Management System (KMS) and provide the signature ID instead of the private key in the API. Alternatively, you can use the Tatum JavaScript client.
        /// </remarks>
        /// <exception cref="Tatum.CSharp.Bitcoin.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="btcTransactionFromAddressKMS"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (SignatureId)</returns>
        System.Threading.Tasks.Task<ApiResponse<SignatureId>> BtcTransferBlockchainWithHttpInfoAsync(BtcTransactionFromAddressKMS btcTransactionFromAddressKMS, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        /// <summary>
        /// Send BTC to Bitcoin addresses
        /// </summary>
        /// <remarks>
        /// 2 credits per API call Send BTC to blockchain addresses. Bitcoin transactions are based on UTXOs. \&quot;UTXO\&quot; stands for \&quot;Unspent Transaction Output\&quot;. A UTXO is the amount of BTC/satoshis that remains at a Bitcoin address after a cryptocurrency transaction involving this address has been performed. The UTXO can then be used as input for a new cryptocurrency transaction. For more information about Bitcoin transactions and UTXO, see the Bitcoin user documentation. To check UTXOs in a transaction, see the API for getting information about a transaction output (UTXO) in a Bitcoin transaction. You can build a BTC transaction by one of the following methods: Sending BTC from blockchain addresses The assets are sent from a list of addresses. For each address, the last 100 transactions are scanned for any UTXO to be included in the transaction. For easier control over the assets to be sent, we recommend that you use this method only if you have one address to send the assets from. To use this method, use the BtcTransactionFromAddress or BtcTransactionFromAddressKMS schema of the request body. Sending BTC from UTXOs The assets are sent from a list of UTXOs. Each UTXO is included in the transaction. Use this method if you want to manually calculate the amount to send. To use this method, use the BtcTransactionFromUTXO or BtcTransactionFromUTXOKMS schema of the request body. When an UTXO is entered into a transaction, the whole UTXO amount is included and must be spent. For example, address A receives two transactions, T1 with 1 BTC and T2 with 2 BTC. A transaction that consumes the UTXOs from both T1 and T2 will have an available amount of 3 BTC to spend: 1 BTC (from T1) + 2 BTC (from T2) &#x3D; 3 BTC (to spend in total) You can send the assets to one or multiple recipients in one transaction. If you send the assets to multiple addresses, each address must have its own amount to receive. Paying the gas fee and receiving the change When the amount that the recipients should receive is lower than the amount from the UTXOs, the difference between these two amounts is by default used as the gas fee for the transaction. Because this amount may be considerable and you may not want to spend it all on the gas fee, you can explicitly specify the fee amount and the blockchain address where any extra funds remaining after covering the fee will be sent (the fee and changeAddress parameters in the request body, correspondingly). Signing a transaction When sending BTC, you are charged a fee for the transaction, and you must sign the transaction with the private key of the blockchain address from which the fee will be deducted. Providing the private key in the API is not a secure way of signing transactions, because the private key can be stolen or exposed. Your private keys should never leave your security perimeter. You should use the private keys only for testing a solution you are building on the testnet of a blockchain. For signing transactions on the mainnet, we strongly recommend that you use the Tatum Key Management System (KMS) and provide the signature ID instead of the private key in the API. Alternatively, you can use the Tatum JavaScript client.
        /// </remarks>
        /// <exception cref="Tatum.CSharp.Bitcoin.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="btcTransactionFromUTXO"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (TransactionHash)</returns>
        System.Threading.Tasks.Task<ApiResponse<TransactionHash>> BtcTransferBlockchainWithHttpInfoAsync(BtcTransactionFromUTXO btcTransactionFromUTXO, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        /// <summary>
        /// Send BTC to Bitcoin addresses
        /// </summary>
        /// <remarks>
        /// 2 credits per API call Send BTC to blockchain addresses. Bitcoin transactions are based on UTXOs. \&quot;UTXO\&quot; stands for \&quot;Unspent Transaction Output\&quot;. A UTXO is the amount of BTC/satoshis that remains at a Bitcoin address after a cryptocurrency transaction involving this address has been performed. The UTXO can then be used as input for a new cryptocurrency transaction. For more information about Bitcoin transactions and UTXO, see the Bitcoin user documentation. To check UTXOs in a transaction, see the API for getting information about a transaction output (UTXO) in a Bitcoin transaction. You can build a BTC transaction by one of the following methods: Sending BTC from blockchain addresses The assets are sent from a list of addresses. For each address, the last 100 transactions are scanned for any UTXO to be included in the transaction. For easier control over the assets to be sent, we recommend that you use this method only if you have one address to send the assets from. To use this method, use the BtcTransactionFromAddress or BtcTransactionFromAddressKMS schema of the request body. Sending BTC from UTXOs The assets are sent from a list of UTXOs. Each UTXO is included in the transaction. Use this method if you want to manually calculate the amount to send. To use this method, use the BtcTransactionFromUTXO or BtcTransactionFromUTXOKMS schema of the request body. When an UTXO is entered into a transaction, the whole UTXO amount is included and must be spent. For example, address A receives two transactions, T1 with 1 BTC and T2 with 2 BTC. A transaction that consumes the UTXOs from both T1 and T2 will have an available amount of 3 BTC to spend: 1 BTC (from T1) + 2 BTC (from T2) &#x3D; 3 BTC (to spend in total) You can send the assets to one or multiple recipients in one transaction. If you send the assets to multiple addresses, each address must have its own amount to receive. Paying the gas fee and receiving the change When the amount that the recipients should receive is lower than the amount from the UTXOs, the difference between these two amounts is by default used as the gas fee for the transaction. Because this amount may be considerable and you may not want to spend it all on the gas fee, you can explicitly specify the fee amount and the blockchain address where any extra funds remaining after covering the fee will be sent (the fee and changeAddress parameters in the request body, correspondingly). Signing a transaction When sending BTC, you are charged a fee for the transaction, and you must sign the transaction with the private key of the blockchain address from which the fee will be deducted. Providing the private key in the API is not a secure way of signing transactions, because the private key can be stolen or exposed. Your private keys should never leave your security perimeter. You should use the private keys only for testing a solution you are building on the testnet of a blockchain. For signing transactions on the mainnet, we strongly recommend that you use the Tatum Key Management System (KMS) and provide the signature ID instead of the private key in the API. Alternatively, you can use the Tatum JavaScript client.
        /// </remarks>
        /// <exception cref="Tatum.CSharp.Bitcoin.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="btcTransactionFromUTXOKMS"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (SignatureId)</returns>
        System.Threading.Tasks.Task<ApiResponse<SignatureId>> BtcTransferBlockchainWithHttpInfoAsync(BtcTransactionFromUTXOKMS btcTransactionFromUTXOKMS, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        #endregion Asynchronous Operations With Http Info
    }


    /// <summary>
    /// Represents a collection of functions to interact with the API endpoints
    /// </summary>
    public interface IBitcoinApi : IBitcoinApiSync, IBitcoinApiWithHttpInfoSync, IBitcoinApiAsync, IBitcoinApiWithHttpInfoAsync
    {

    }

    /// <summary>
    /// Represents a collection of functions to interact with the API endpoints
    /// </summary>
    public partial class BitcoinApi : IBitcoinApi
    {
        private ExceptionFactory _exceptionFactory = (name, response) => null;

        /// <summary>
        /// Initializes a new instance of the <see cref="BitcoinApi"/> class.
        /// </summary>
        /// <param name="client">An instance of HttpClient.</param>
        /// <param name="handler">An optional instance of HttpClientHandler that is used by HttpClient.</param>
        /// <exception cref="ArgumentNullException"></exception>
        /// <returns></returns>
        /// <remarks>
        /// Some configuration settings will not be applied without passing an HttpClientHandler.
        /// The features affected are: Setting and Retrieving Cookies, Client Certificates, Proxy settings.
        /// </remarks>
        public BitcoinApi(HttpClient client, HttpClientHandler handler = null) : this(client, (string)null, handler)
        {
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="BitcoinApi"/> class.
        /// </summary>
        /// <param name="client">An instance of HttpClient.</param>
        /// <param name="basePath">The target service's base path in URL format.</param>
        /// <param name="handler">An optional instance of HttpClientHandler that is used by HttpClient.</param>
        /// <exception cref="ArgumentNullException"></exception>
        /// <exception cref="ArgumentException"></exception>
        /// <returns></returns>
        /// <remarks>
        /// Some configuration settings will not be applied without passing an HttpClientHandler.
        /// The features affected are: Setting and Retrieving Cookies, Client Certificates, Proxy settings.
        /// </remarks>
        public BitcoinApi(HttpClient client, string basePath, HttpClientHandler handler = null)
        {
            if (client == null) throw new ArgumentNullException(nameof(client));

            Configuration = Tatum.CSharp.Bitcoin.Core.Client.Configuration.MergeConfigurations(
                GlobalConfiguration.Instance,
                new Configuration { BasePath = basePath }
            );
            ApiClient = new ApiClient(client, Configuration.BasePath, handler);
            Client =  ApiClient;
            AsynchronousClient = ApiClient;
            ExceptionFactory = Tatum.CSharp.Bitcoin.Core.Client.Configuration.DefaultExceptionFactory;
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="BitcoinApi"/> class using Configuration object.
        /// </summary>
        /// <param name="client">An instance of HttpClient.</param>
        /// <param name="configuration">An instance of Configuration.</param>
        /// <param name="handler">An optional instance of HttpClientHandler that is used by HttpClient.</param>
        /// <exception cref="ArgumentNullException"></exception>
        /// <returns></returns>
        /// <remarks>
        /// Some configuration settings will not be applied without passing an HttpClientHandler.
        /// The features affected are: Setting and Retrieving Cookies, Client Certificates, Proxy settings.
        /// </remarks>
        public BitcoinApi(HttpClient client, Configuration configuration, HttpClientHandler handler = null)
        {
            if (configuration == null) throw new ArgumentNullException(nameof(configuration));
            if (client == null) throw new ArgumentNullException(nameof(client));

            Configuration = Tatum.CSharp.Bitcoin.Core.Client.Configuration.MergeConfigurations(
                GlobalConfiguration.Instance,
                configuration
            );
            ApiClient = new ApiClient(client, Configuration.BasePath, handler);
            Client = ApiClient;
            AsynchronousClient = ApiClient;
            ExceptionFactory = Tatum.CSharp.Bitcoin.Core.Client.Configuration.DefaultExceptionFactory;
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="BitcoinApi"/> class
        /// using a Configuration object and client instance.
        /// </summary>
        /// <param name="client">The client interface for synchronous API access.</param>
        /// <param name="asyncClient">The client interface for asynchronous API access.</param>
        /// <param name="configuration">The configuration object.</param>
        /// <exception cref="ArgumentNullException"></exception>
        public BitcoinApi(ISynchronousClient client, IAsynchronousClient asyncClient, IReadableConfiguration configuration)
        {
            Client = client ?? throw new ArgumentNullException(nameof(client));
            AsynchronousClient = asyncClient ?? throw new ArgumentNullException(nameof(asyncClient));
            Configuration = configuration ?? throw new ArgumentNullException(nameof(configuration));
            ExceptionFactory = Tatum.CSharp.Bitcoin.Core.Client.Configuration.DefaultExceptionFactory;
        }

        /// <summary>
        /// Holds the ApiClient if created
        /// </summary>
        public ApiClient ApiClient { get; set; }

        /// <summary>
        /// The client for accessing this underlying API asynchronously.
        /// </summary>
        public IAsynchronousClient AsynchronousClient { get; set; }

        /// <summary>
        /// The client for accessing this underlying API synchronously.
        /// </summary>
        public ISynchronousClient Client { get; set; }

        /// <summary>
        /// Gets the base path of the API client.
        /// </summary>
        /// <value>The base path</value>
        public string GetBasePath()
        {
            return Configuration.BasePath;
        }

        /// <summary>
        /// Gets or sets the configuration object
        /// </summary>
        /// <value>An instance of the Configuration</value>
        public IReadableConfiguration Configuration { get; set; }

        /// <summary>
        /// Provides a factory method hook for the creation of exceptions.
        /// </summary>
        public ExceptionFactory ExceptionFactory
        {
            get
            {
                if (_exceptionFactory != null && _exceptionFactory.GetInvocationList().Length > 1)
                {
                    throw new InvalidOperationException("Multicast delegate for ExceptionFactory is unsupported.");
                }
                return _exceptionFactory;
            }
            set => _exceptionFactory = value;
        }

        /// <summary>
        /// Broadcast a signed Bitcoin transaction 2 credits per API call Broadcasts a signed transaction to the Bitcoin blockchain. This method is used internally from Tatum KMS or Tatum Client Libraries. It is possible to create a custom signing mechanism and only use this method for broadcasting data to the blockchain.
        /// </summary>
        /// <exception cref="Tatum.CSharp.Bitcoin.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="broadcastKMS"></param>
        /// <returns>TransactionHash</returns>
        public TransactionHash BtcBroadcast(BroadcastKMS broadcastKMS)
        {
            var localVarResponse = BtcBroadcastWithHttpInfo(broadcastKMS);

            var exception = ExceptionFactory?.Invoke("BtcBroadcast", localVarResponse);
            if (exception != null) throw exception;

            return localVarResponse.Data;
        }

        /// <summary>
        /// Broadcast a signed Bitcoin transaction 2 credits per API call Broadcasts a signed transaction to the Bitcoin blockchain. This method is used internally from Tatum KMS or Tatum Client Libraries. It is possible to create a custom signing mechanism and only use this method for broadcasting data to the blockchain.
        /// </summary>
        /// <exception cref="Tatum.CSharp.Bitcoin.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="broadcastKMS"></param>
        /// <returns>ApiResponse of TransactionHash</returns>
        public ApiResponse<TransactionHash> BtcBroadcastWithHttpInfo(BroadcastKMS broadcastKMS)
        {
            // verify the required parameter 'broadcastKMS' is set
            if (broadcastKMS == null)
                throw new ApiException(400, "Missing required parameter 'broadcastKMS' when calling BitcoinApi->BtcBroadcast");

            var localVarRequestOptions = new RequestOptions();

            var contentTypes = new string[]{
                "application/json"
            };

            // to determine the Accept header
            var accepts = new string[]{
                "application/json"
            };

            var localVarContentType = ClientUtils.SelectHeaderContentType(contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = ClientUtils.SelectHeaderAccept(accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.Data = broadcastKMS;

            // authentication (X-API-Key) required
            if (!string.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("x-api-key")))
            {
                localVarRequestOptions.HeaderParameters.Add("x-api-key", Configuration.GetApiKeyWithPrefix("x-api-key"));
            }

            // make the HTTP request
            var localVarResponse = Client.Post<TransactionHash>("/v3/bitcoin/broadcast", localVarRequestOptions, Configuration);

            return localVarResponse;
        }

        /// <summary>
        /// Broadcast a signed Bitcoin transaction 2 credits per API call Broadcasts a signed transaction to the Bitcoin blockchain. This method is used internally from Tatum KMS or Tatum Client Libraries. It is possible to create a custom signing mechanism and only use this method for broadcasting data to the blockchain.
        /// </summary>
        /// <exception cref="Tatum.CSharp.Bitcoin.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="broadcastKMS"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of TransactionHash</returns>
        public async System.Threading.Tasks.Task<TransactionHash> BtcBroadcastAsync(BroadcastKMS broadcastKMS, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            var localVarResponse = await BtcBroadcastWithHttpInfoAsync(broadcastKMS, cancellationToken).ConfigureAwait(false);
            
            var exception = ExceptionFactory?.Invoke("BtcBroadcast", localVarResponse);
            if (exception != null) throw exception;

            return localVarResponse.Data;
        }

        /// <summary>
        /// Broadcast a signed Bitcoin transaction 2 credits per API call Broadcasts a signed transaction to the Bitcoin blockchain. This method is used internally from Tatum KMS or Tatum Client Libraries. It is possible to create a custom signing mechanism and only use this method for broadcasting data to the blockchain.
        /// </summary>
        /// <exception cref="Tatum.CSharp.Bitcoin.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="broadcastKMS"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (TransactionHash)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<TransactionHash>> BtcBroadcastWithHttpInfoAsync(BroadcastKMS broadcastKMS, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            // verify the required parameter 'broadcastKMS' is set
            if (broadcastKMS == null)
                throw new ApiException(400, "Missing required parameter 'broadcastKMS' when calling BitcoinApi->BtcBroadcast");

            var localVarRequestOptions = new RequestOptions();

            var contentTypes = new string[]{
                "application/json"
            };

            // to determine the Accept header
            var accepts = new string[]{
                "application/json"
            };


            var localVarContentType = ClientUtils.SelectHeaderContentType(contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = ClientUtils.SelectHeaderAccept(accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.Data = broadcastKMS;

            // authentication (X-API-Key) required
            if (!string.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("x-api-key")))
            {
                localVarRequestOptions.HeaderParameters.Add("x-api-key", Configuration.GetApiKeyWithPrefix("x-api-key"));
            }

            // make the HTTP request

            var localVarResponse = await AsynchronousClient.PostAsync<TransactionHash>("/v3/bitcoin/broadcast", localVarRequestOptions, Configuration, cancellationToken).ConfigureAwait(false);

            return localVarResponse;
        }

        /// <summary>
        /// Generate a Bitcoin address from the wallet&#39;s extended public key 1 credit per API call Generate a Bitcoin address from the extended public key of the wallet. The address is generated for the specific index - each extended public key can generate up to 2^32 addresses with the index starting from 0 up to 2^31 - 1.
        /// </summary>
        /// <exception cref="Tatum.CSharp.Bitcoin.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="xpub">Extended public key of a wallet.</param>
        /// <param name="index">Derivation index of the desired address to be generated.</param>
        /// <returns>GeneratedAddressBtc</returns>
        public GeneratedAddressBtc BtcGenerateAddress(string xpub, decimal index)
        {
            var localVarResponse = BtcGenerateAddressWithHttpInfo(xpub, index);

            var exception = ExceptionFactory?.Invoke("BtcGenerateAddress", localVarResponse);
            if (exception != null) throw exception;

            return localVarResponse.Data;
        }

        /// <summary>
        /// Generate a Bitcoin address from the wallet&#39;s extended public key 1 credit per API call Generate a Bitcoin address from the extended public key of the wallet. The address is generated for the specific index - each extended public key can generate up to 2^32 addresses with the index starting from 0 up to 2^31 - 1.
        /// </summary>
        /// <exception cref="Tatum.CSharp.Bitcoin.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="xpub">Extended public key of a wallet.</param>
        /// <param name="index">Derivation index of the desired address to be generated.</param>
        /// <returns>ApiResponse of GeneratedAddressBtc</returns>
        public ApiResponse<GeneratedAddressBtc> BtcGenerateAddressWithHttpInfo(string xpub, decimal index)
        {
            // verify the required parameter 'xpub' is set
            if (xpub == null)
                throw new ApiException(400, "Missing required parameter 'xpub' when calling BitcoinApi->BtcGenerateAddress");

            var localVarRequestOptions = new RequestOptions();

            var contentTypes = new string[]{
            };

            // to determine the Accept header
            var accepts = new string[]{
                "application/json"
            };

            var localVarContentType = ClientUtils.SelectHeaderContentType(contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = ClientUtils.SelectHeaderAccept(accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.PathParameters.Add("xpub", ClientUtils.ParameterToString(xpub)); // path parameter
            localVarRequestOptions.PathParameters.Add("index", ClientUtils.ParameterToString(index)); // path parameter

            // authentication (X-API-Key) required
            if (!string.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("x-api-key")))
            {
                localVarRequestOptions.HeaderParameters.Add("x-api-key", Configuration.GetApiKeyWithPrefix("x-api-key"));
            }

            // make the HTTP request
            var localVarResponse = Client.Get<GeneratedAddressBtc>("/v3/bitcoin/address/{xpub}/{index}", localVarRequestOptions, Configuration);

            return localVarResponse;
        }

        /// <summary>
        /// Generate a Bitcoin address from the wallet&#39;s extended public key 1 credit per API call Generate a Bitcoin address from the extended public key of the wallet. The address is generated for the specific index - each extended public key can generate up to 2^32 addresses with the index starting from 0 up to 2^31 - 1.
        /// </summary>
        /// <exception cref="Tatum.CSharp.Bitcoin.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="xpub">Extended public key of a wallet.</param>
        /// <param name="index">Derivation index of the desired address to be generated.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of GeneratedAddressBtc</returns>
        public async System.Threading.Tasks.Task<GeneratedAddressBtc> BtcGenerateAddressAsync(string xpub, decimal index, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            var localVarResponse = await BtcGenerateAddressWithHttpInfoAsync(xpub, index, cancellationToken).ConfigureAwait(false);
            
            var exception = ExceptionFactory?.Invoke("BtcGenerateAddress", localVarResponse);
            if (exception != null) throw exception;

            return localVarResponse.Data;
        }

        /// <summary>
        /// Generate a Bitcoin address from the wallet&#39;s extended public key 1 credit per API call Generate a Bitcoin address from the extended public key of the wallet. The address is generated for the specific index - each extended public key can generate up to 2^32 addresses with the index starting from 0 up to 2^31 - 1.
        /// </summary>
        /// <exception cref="Tatum.CSharp.Bitcoin.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="xpub">Extended public key of a wallet.</param>
        /// <param name="index">Derivation index of the desired address to be generated.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (GeneratedAddressBtc)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<GeneratedAddressBtc>> BtcGenerateAddressWithHttpInfoAsync(string xpub, decimal index, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            // verify the required parameter 'xpub' is set
            if (xpub == null)
                throw new ApiException(400, "Missing required parameter 'xpub' when calling BitcoinApi->BtcGenerateAddress");

            var localVarRequestOptions = new RequestOptions();

            var contentTypes = new string[]{
            };

            // to determine the Accept header
            var accepts = new string[]{
                "application/json"
            };


            var localVarContentType = ClientUtils.SelectHeaderContentType(contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = ClientUtils.SelectHeaderAccept(accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.PathParameters.Add("xpub", ClientUtils.ParameterToString(xpub)); // path parameter
            localVarRequestOptions.PathParameters.Add("index", ClientUtils.ParameterToString(index)); // path parameter

            // authentication (X-API-Key) required
            if (!string.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("x-api-key")))
            {
                localVarRequestOptions.HeaderParameters.Add("x-api-key", Configuration.GetApiKeyWithPrefix("x-api-key"));
            }

            // make the HTTP request

            var localVarResponse = await AsynchronousClient.GetAsync<GeneratedAddressBtc>("/v3/bitcoin/address/{xpub}/{index}", localVarRequestOptions, Configuration, cancellationToken).ConfigureAwait(false);

            return localVarResponse;
        }

        /// <summary>
        /// Generate the private key for a Bitcoin address 1 credit per API call Generates a private key for an address from a mnemonic for a given derivation path index. The private key is generated for the specific index - each mnemonic can generate up to 2^32 private keys starting from index 0 until 2^31 - 1.
        /// </summary>
        /// <exception cref="Tatum.CSharp.Bitcoin.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="privKeyRequest"></param>
        /// <returns>PrivKey</returns>
        public PrivKey BtcGenerateAddressPrivateKey(PrivKeyRequest privKeyRequest)
        {
            var localVarResponse = BtcGenerateAddressPrivateKeyWithHttpInfo(privKeyRequest);

            var exception = ExceptionFactory?.Invoke("BtcGenerateAddressPrivateKey", localVarResponse);
            if (exception != null) throw exception;

            return localVarResponse.Data;
        }

        /// <summary>
        /// Generate the private key for a Bitcoin address 1 credit per API call Generates a private key for an address from a mnemonic for a given derivation path index. The private key is generated for the specific index - each mnemonic can generate up to 2^32 private keys starting from index 0 until 2^31 - 1.
        /// </summary>
        /// <exception cref="Tatum.CSharp.Bitcoin.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="privKeyRequest"></param>
        /// <returns>ApiResponse of PrivKey</returns>
        public ApiResponse<PrivKey> BtcGenerateAddressPrivateKeyWithHttpInfo(PrivKeyRequest privKeyRequest)
        {
            // verify the required parameter 'privKeyRequest' is set
            if (privKeyRequest == null)
                throw new ApiException(400, "Missing required parameter 'privKeyRequest' when calling BitcoinApi->BtcGenerateAddressPrivateKey");

            var localVarRequestOptions = new RequestOptions();

            var contentTypes = new string[]{
                "application/json"
            };

            // to determine the Accept header
            var accepts = new string[]{
                "application/json"
            };

            var localVarContentType = ClientUtils.SelectHeaderContentType(contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = ClientUtils.SelectHeaderAccept(accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.Data = privKeyRequest;

            // authentication (X-API-Key) required
            if (!string.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("x-api-key")))
            {
                localVarRequestOptions.HeaderParameters.Add("x-api-key", Configuration.GetApiKeyWithPrefix("x-api-key"));
            }

            // make the HTTP request
            var localVarResponse = Client.Post<PrivKey>("/v3/bitcoin/wallet/priv", localVarRequestOptions, Configuration);

            return localVarResponse;
        }

        /// <summary>
        /// Generate the private key for a Bitcoin address 1 credit per API call Generates a private key for an address from a mnemonic for a given derivation path index. The private key is generated for the specific index - each mnemonic can generate up to 2^32 private keys starting from index 0 until 2^31 - 1.
        /// </summary>
        /// <exception cref="Tatum.CSharp.Bitcoin.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="privKeyRequest"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of PrivKey</returns>
        public async System.Threading.Tasks.Task<PrivKey> BtcGenerateAddressPrivateKeyAsync(PrivKeyRequest privKeyRequest, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            var localVarResponse = await BtcGenerateAddressPrivateKeyWithHttpInfoAsync(privKeyRequest, cancellationToken).ConfigureAwait(false);
            
            var exception = ExceptionFactory?.Invoke("BtcGenerateAddressPrivateKey", localVarResponse);
            if (exception != null) throw exception;

            return localVarResponse.Data;
        }

        /// <summary>
        /// Generate the private key for a Bitcoin address 1 credit per API call Generates a private key for an address from a mnemonic for a given derivation path index. The private key is generated for the specific index - each mnemonic can generate up to 2^32 private keys starting from index 0 until 2^31 - 1.
        /// </summary>
        /// <exception cref="Tatum.CSharp.Bitcoin.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="privKeyRequest"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (PrivKey)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<PrivKey>> BtcGenerateAddressPrivateKeyWithHttpInfoAsync(PrivKeyRequest privKeyRequest, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            // verify the required parameter 'privKeyRequest' is set
            if (privKeyRequest == null)
                throw new ApiException(400, "Missing required parameter 'privKeyRequest' when calling BitcoinApi->BtcGenerateAddressPrivateKey");

            var localVarRequestOptions = new RequestOptions();

            var contentTypes = new string[]{
                "application/json"
            };

            // to determine the Accept header
            var accepts = new string[]{
                "application/json"
            };


            var localVarContentType = ClientUtils.SelectHeaderContentType(contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = ClientUtils.SelectHeaderAccept(accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.Data = privKeyRequest;

            // authentication (X-API-Key) required
            if (!string.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("x-api-key")))
            {
                localVarRequestOptions.HeaderParameters.Add("x-api-key", Configuration.GetApiKeyWithPrefix("x-api-key"));
            }

            // make the HTTP request

            var localVarResponse = await AsynchronousClient.PostAsync<PrivKey>("/v3/bitcoin/wallet/priv", localVarRequestOptions, Configuration, cancellationToken).ConfigureAwait(false);

            return localVarResponse;
        }

        /// <summary>
        /// Generate a Bitcoin wallet 1 credit per API call Tatum supports BIP44 HD wallets. Because they can generate 2^31 addresses from 1 mnemonic phrase, they are very convenient and secure. A mnemonic phrase consists of 24 special words in a defined order and can restore access to all generated addresses and private keys. Each address is identified by 3 main values: Private Key - your secret value, which should never be revealed Public Key - public address to be published Derivation index - index of generated address Tatum follows BIP44 specification and generates for Bitcoin wallet with derivation path m&#39;/44&#39;/0&#39;/0&#39;/0. More about BIP44 HD wallets can be found here - https://github.com/bitcoin/bips/blob/master/bip-0044.mediawiki. Generate BIP44 compatible Bitcoin wallet.
        /// </summary>
        /// <exception cref="Tatum.CSharp.Bitcoin.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="mnemonic">Mnemonic to use for generation of extended public and private keys. (optional)</param>
        /// <returns>Wallet</returns>
        public Wallet BtcGenerateWallet(string mnemonic = default(string))
        {
            var localVarResponse = BtcGenerateWalletWithHttpInfo(mnemonic);

            var exception = ExceptionFactory?.Invoke("BtcGenerateWallet", localVarResponse);
            if (exception != null) throw exception;

            return localVarResponse.Data;
        }

        /// <summary>
        /// Generate a Bitcoin wallet 1 credit per API call Tatum supports BIP44 HD wallets. Because they can generate 2^31 addresses from 1 mnemonic phrase, they are very convenient and secure. A mnemonic phrase consists of 24 special words in a defined order and can restore access to all generated addresses and private keys. Each address is identified by 3 main values: Private Key - your secret value, which should never be revealed Public Key - public address to be published Derivation index - index of generated address Tatum follows BIP44 specification and generates for Bitcoin wallet with derivation path m&#39;/44&#39;/0&#39;/0&#39;/0. More about BIP44 HD wallets can be found here - https://github.com/bitcoin/bips/blob/master/bip-0044.mediawiki. Generate BIP44 compatible Bitcoin wallet.
        /// </summary>
        /// <exception cref="Tatum.CSharp.Bitcoin.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="mnemonic">Mnemonic to use for generation of extended public and private keys. (optional)</param>
        /// <returns>ApiResponse of Wallet</returns>
        public ApiResponse<Wallet> BtcGenerateWalletWithHttpInfo(string mnemonic = default(string))
        {
            var localVarRequestOptions = new RequestOptions();

            var contentTypes = new string[]{
            };

            // to determine the Accept header
            var accepts = new string[]{
                "application/json"
            };

            var localVarContentType = ClientUtils.SelectHeaderContentType(contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = ClientUtils.SelectHeaderAccept(accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            if (mnemonic != null)
            {
                localVarRequestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "mnemonic", mnemonic));
            }

            // authentication (X-API-Key) required
            if (!string.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("x-api-key")))
            {
                localVarRequestOptions.HeaderParameters.Add("x-api-key", Configuration.GetApiKeyWithPrefix("x-api-key"));
            }

            // make the HTTP request
            var localVarResponse = Client.Get<Wallet>("/v3/bitcoin/wallet", localVarRequestOptions, Configuration);

            return localVarResponse;
        }

        /// <summary>
        /// Generate a Bitcoin wallet 1 credit per API call Tatum supports BIP44 HD wallets. Because they can generate 2^31 addresses from 1 mnemonic phrase, they are very convenient and secure. A mnemonic phrase consists of 24 special words in a defined order and can restore access to all generated addresses and private keys. Each address is identified by 3 main values: Private Key - your secret value, which should never be revealed Public Key - public address to be published Derivation index - index of generated address Tatum follows BIP44 specification and generates for Bitcoin wallet with derivation path m&#39;/44&#39;/0&#39;/0&#39;/0. More about BIP44 HD wallets can be found here - https://github.com/bitcoin/bips/blob/master/bip-0044.mediawiki. Generate BIP44 compatible Bitcoin wallet.
        /// </summary>
        /// <exception cref="Tatum.CSharp.Bitcoin.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="mnemonic">Mnemonic to use for generation of extended public and private keys. (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of Wallet</returns>
        public async System.Threading.Tasks.Task<Wallet> BtcGenerateWalletAsync(string mnemonic = default(string), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            var localVarResponse = await BtcGenerateWalletWithHttpInfoAsync(mnemonic, cancellationToken).ConfigureAwait(false);
            
            var exception = ExceptionFactory?.Invoke("BtcGenerateWallet", localVarResponse);
            if (exception != null) throw exception;

            return localVarResponse.Data;
        }

        /// <summary>
        /// Generate a Bitcoin wallet 1 credit per API call Tatum supports BIP44 HD wallets. Because they can generate 2^31 addresses from 1 mnemonic phrase, they are very convenient and secure. A mnemonic phrase consists of 24 special words in a defined order and can restore access to all generated addresses and private keys. Each address is identified by 3 main values: Private Key - your secret value, which should never be revealed Public Key - public address to be published Derivation index - index of generated address Tatum follows BIP44 specification and generates for Bitcoin wallet with derivation path m&#39;/44&#39;/0&#39;/0&#39;/0. More about BIP44 HD wallets can be found here - https://github.com/bitcoin/bips/blob/master/bip-0044.mediawiki. Generate BIP44 compatible Bitcoin wallet.
        /// </summary>
        /// <exception cref="Tatum.CSharp.Bitcoin.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="mnemonic">Mnemonic to use for generation of extended public and private keys. (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (Wallet)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<Wallet>> BtcGenerateWalletWithHttpInfoAsync(string mnemonic = default(string), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            var localVarRequestOptions = new RequestOptions();

            var contentTypes = new string[]{
            };

            // to determine the Accept header
            var accepts = new string[]{
                "application/json"
            };


            var localVarContentType = ClientUtils.SelectHeaderContentType(contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = ClientUtils.SelectHeaderAccept(accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            if (mnemonic != null)
            {
                localVarRequestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "mnemonic", mnemonic));
            }

            // authentication (X-API-Key) required
            if (!string.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("x-api-key")))
            {
                localVarRequestOptions.HeaderParameters.Add("x-api-key", Configuration.GetApiKeyWithPrefix("x-api-key"));
            }

            // make the HTTP request

            var localVarResponse = await AsynchronousClient.GetAsync<Wallet>("/v3/bitcoin/wallet", localVarRequestOptions, Configuration, cancellationToken).ConfigureAwait(false);

            return localVarResponse;
        }

        /// <summary>
        /// Get the balance of a Bitcoin address 1 credit per API call Get the balance of a Bitcoin address.
        /// </summary>
        /// <exception cref="Tatum.CSharp.Bitcoin.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="address">The blockchain address to get the balance for</param>
        /// <returns>BtcBasedBalance</returns>
        public BtcBasedBalance BtcGetBalanceOfAddress(string address)
        {
            var localVarResponse = BtcGetBalanceOfAddressWithHttpInfo(address);

            var exception = ExceptionFactory?.Invoke("BtcGetBalanceOfAddress", localVarResponse);
            if (exception != null) throw exception;

            return localVarResponse.Data;
        }

        /// <summary>
        /// Get the balance of a Bitcoin address 1 credit per API call Get the balance of a Bitcoin address.
        /// </summary>
        /// <exception cref="Tatum.CSharp.Bitcoin.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="address">The blockchain address to get the balance for</param>
        /// <returns>ApiResponse of BtcBasedBalance</returns>
        public ApiResponse<BtcBasedBalance> BtcGetBalanceOfAddressWithHttpInfo(string address)
        {
            // verify the required parameter 'address' is set
            if (address == null)
                throw new ApiException(400, "Missing required parameter 'address' when calling BitcoinApi->BtcGetBalanceOfAddress");

            var localVarRequestOptions = new RequestOptions();

            var contentTypes = new string[]{
            };

            // to determine the Accept header
            var accepts = new string[]{
                "application/json"
            };

            var localVarContentType = ClientUtils.SelectHeaderContentType(contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = ClientUtils.SelectHeaderAccept(accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.PathParameters.Add("address", ClientUtils.ParameterToString(address)); // path parameter

            // authentication (X-API-Key) required
            if (!string.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("x-api-key")))
            {
                localVarRequestOptions.HeaderParameters.Add("x-api-key", Configuration.GetApiKeyWithPrefix("x-api-key"));
            }

            // make the HTTP request
            var localVarResponse = Client.Get<BtcBasedBalance>("/v3/bitcoin/address/balance/{address}", localVarRequestOptions, Configuration);

            return localVarResponse;
        }

        /// <summary>
        /// Get the balance of a Bitcoin address 1 credit per API call Get the balance of a Bitcoin address.
        /// </summary>
        /// <exception cref="Tatum.CSharp.Bitcoin.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="address">The blockchain address to get the balance for</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of BtcBasedBalance</returns>
        public async System.Threading.Tasks.Task<BtcBasedBalance> BtcGetBalanceOfAddressAsync(string address, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            var localVarResponse = await BtcGetBalanceOfAddressWithHttpInfoAsync(address, cancellationToken).ConfigureAwait(false);
            
            var exception = ExceptionFactory?.Invoke("BtcGetBalanceOfAddress", localVarResponse);
            if (exception != null) throw exception;

            return localVarResponse.Data;
        }

        /// <summary>
        /// Get the balance of a Bitcoin address 1 credit per API call Get the balance of a Bitcoin address.
        /// </summary>
        /// <exception cref="Tatum.CSharp.Bitcoin.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="address">The blockchain address to get the balance for</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (BtcBasedBalance)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<BtcBasedBalance>> BtcGetBalanceOfAddressWithHttpInfoAsync(string address, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            // verify the required parameter 'address' is set
            if (address == null)
                throw new ApiException(400, "Missing required parameter 'address' when calling BitcoinApi->BtcGetBalanceOfAddress");

            var localVarRequestOptions = new RequestOptions();

            var contentTypes = new string[]{
            };

            // to determine the Accept header
            var accepts = new string[]{
                "application/json"
            };


            var localVarContentType = ClientUtils.SelectHeaderContentType(contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = ClientUtils.SelectHeaderAccept(accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.PathParameters.Add("address", ClientUtils.ParameterToString(address)); // path parameter

            // authentication (X-API-Key) required
            if (!string.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("x-api-key")))
            {
                localVarRequestOptions.HeaderParameters.Add("x-api-key", Configuration.GetApiKeyWithPrefix("x-api-key"));
            }

            // make the HTTP request

            var localVarResponse = await AsynchronousClient.GetAsync<BtcBasedBalance>("/v3/bitcoin/address/balance/{address}", localVarRequestOptions, Configuration, cancellationToken).ConfigureAwait(false);

            return localVarResponse;
        }

        /// <summary>
        /// Get a Bitcoin block by its hash or height 1 credit per API call Gets Bitcoin block detail by block hash or height.
        /// </summary>
        /// <exception cref="Tatum.CSharp.Bitcoin.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="hash">Block hash or height.</param>
        /// <returns>BtcBlock</returns>
        public BtcBlock BtcGetBlock(string hash)
        {
            var localVarResponse = BtcGetBlockWithHttpInfo(hash);

            var exception = ExceptionFactory?.Invoke("BtcGetBlock", localVarResponse);
            if (exception != null) throw exception;

            return localVarResponse.Data;
        }

        /// <summary>
        /// Get a Bitcoin block by its hash or height 1 credit per API call Gets Bitcoin block detail by block hash or height.
        /// </summary>
        /// <exception cref="Tatum.CSharp.Bitcoin.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="hash">Block hash or height.</param>
        /// <returns>ApiResponse of BtcBlock</returns>
        public ApiResponse<BtcBlock> BtcGetBlockWithHttpInfo(string hash)
        {
            // verify the required parameter 'hash' is set
            if (hash == null)
                throw new ApiException(400, "Missing required parameter 'hash' when calling BitcoinApi->BtcGetBlock");

            var localVarRequestOptions = new RequestOptions();

            var contentTypes = new string[]{
            };

            // to determine the Accept header
            var accepts = new string[]{
                "application/json"
            };

            var localVarContentType = ClientUtils.SelectHeaderContentType(contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = ClientUtils.SelectHeaderAccept(accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.PathParameters.Add("hash", ClientUtils.ParameterToString(hash)); // path parameter

            // authentication (X-API-Key) required
            if (!string.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("x-api-key")))
            {
                localVarRequestOptions.HeaderParameters.Add("x-api-key", Configuration.GetApiKeyWithPrefix("x-api-key"));
            }

            // make the HTTP request
            var localVarResponse = Client.Get<BtcBlock>("/v3/bitcoin/block/{hash}", localVarRequestOptions, Configuration);

            return localVarResponse;
        }

        /// <summary>
        /// Get a Bitcoin block by its hash or height 1 credit per API call Gets Bitcoin block detail by block hash or height.
        /// </summary>
        /// <exception cref="Tatum.CSharp.Bitcoin.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="hash">Block hash or height.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of BtcBlock</returns>
        public async System.Threading.Tasks.Task<BtcBlock> BtcGetBlockAsync(string hash, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            var localVarResponse = await BtcGetBlockWithHttpInfoAsync(hash, cancellationToken).ConfigureAwait(false);
            
            var exception = ExceptionFactory?.Invoke("BtcGetBlock", localVarResponse);
            if (exception != null) throw exception;

            return localVarResponse.Data;
        }

        /// <summary>
        /// Get a Bitcoin block by its hash or height 1 credit per API call Gets Bitcoin block detail by block hash or height.
        /// </summary>
        /// <exception cref="Tatum.CSharp.Bitcoin.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="hash">Block hash or height.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (BtcBlock)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<BtcBlock>> BtcGetBlockWithHttpInfoAsync(string hash, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            // verify the required parameter 'hash' is set
            if (hash == null)
                throw new ApiException(400, "Missing required parameter 'hash' when calling BitcoinApi->BtcGetBlock");

            var localVarRequestOptions = new RequestOptions();

            var contentTypes = new string[]{
            };

            // to determine the Accept header
            var accepts = new string[]{
                "application/json"
            };


            var localVarContentType = ClientUtils.SelectHeaderContentType(contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = ClientUtils.SelectHeaderAccept(accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.PathParameters.Add("hash", ClientUtils.ParameterToString(hash)); // path parameter

            // authentication (X-API-Key) required
            if (!string.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("x-api-key")))
            {
                localVarRequestOptions.HeaderParameters.Add("x-api-key", Configuration.GetApiKeyWithPrefix("x-api-key"));
            }

            // make the HTTP request

            var localVarResponse = await AsynchronousClient.GetAsync<BtcBlock>("/v3/bitcoin/block/{hash}", localVarRequestOptions, Configuration, cancellationToken).ConfigureAwait(false);

            return localVarResponse;
        }

        /// <summary>
        /// Get Bitcoin blockchain information 1 credit per API call Gets Bitcoin blockchain information. Obtains basic info like the testnet / mainnet version of the chain, the current block number and its hash.
        /// </summary>
        /// <exception cref="Tatum.CSharp.Bitcoin.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <returns>BtcInfo</returns>
        public BtcInfo BtcGetBlockChainInfo()
        {
            var localVarResponse = BtcGetBlockChainInfoWithHttpInfo();

            var exception = ExceptionFactory?.Invoke("BtcGetBlockChainInfo", localVarResponse);
            if (exception != null) throw exception;

            return localVarResponse.Data;
        }

        /// <summary>
        /// Get Bitcoin blockchain information 1 credit per API call Gets Bitcoin blockchain information. Obtains basic info like the testnet / mainnet version of the chain, the current block number and its hash.
        /// </summary>
        /// <exception cref="Tatum.CSharp.Bitcoin.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <returns>ApiResponse of BtcInfo</returns>
        public ApiResponse<BtcInfo> BtcGetBlockChainInfoWithHttpInfo()
        {
            var localVarRequestOptions = new RequestOptions();

            var contentTypes = new string[]{
            };

            // to determine the Accept header
            var accepts = new string[]{
                "application/json"
            };

            var localVarContentType = ClientUtils.SelectHeaderContentType(contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = ClientUtils.SelectHeaderAccept(accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);


            // authentication (X-API-Key) required
            if (!string.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("x-api-key")))
            {
                localVarRequestOptions.HeaderParameters.Add("x-api-key", Configuration.GetApiKeyWithPrefix("x-api-key"));
            }

            // make the HTTP request
            var localVarResponse = Client.Get<BtcInfo>("/v3/bitcoin/info", localVarRequestOptions, Configuration);

            return localVarResponse;
        }

        /// <summary>
        /// Get Bitcoin blockchain information 1 credit per API call Gets Bitcoin blockchain information. Obtains basic info like the testnet / mainnet version of the chain, the current block number and its hash.
        /// </summary>
        /// <exception cref="Tatum.CSharp.Bitcoin.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of BtcInfo</returns>
        public async System.Threading.Tasks.Task<BtcInfo> BtcGetBlockChainInfoAsync(System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            var localVarResponse = await BtcGetBlockChainInfoWithHttpInfoAsync(cancellationToken).ConfigureAwait(false);
            
            var exception = ExceptionFactory?.Invoke("BtcGetBlockChainInfo", localVarResponse);
            if (exception != null) throw exception;

            return localVarResponse.Data;
        }

        /// <summary>
        /// Get Bitcoin blockchain information 1 credit per API call Gets Bitcoin blockchain information. Obtains basic info like the testnet / mainnet version of the chain, the current block number and its hash.
        /// </summary>
        /// <exception cref="Tatum.CSharp.Bitcoin.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (BtcInfo)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<BtcInfo>> BtcGetBlockChainInfoWithHttpInfoAsync(System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            var localVarRequestOptions = new RequestOptions();

            var contentTypes = new string[]{
            };

            // to determine the Accept header
            var accepts = new string[]{
                "application/json"
            };


            var localVarContentType = ClientUtils.SelectHeaderContentType(contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = ClientUtils.SelectHeaderAccept(accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);


            // authentication (X-API-Key) required
            if (!string.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("x-api-key")))
            {
                localVarRequestOptions.HeaderParameters.Add("x-api-key", Configuration.GetApiKeyWithPrefix("x-api-key"));
            }

            // make the HTTP request

            var localVarResponse = await AsynchronousClient.GetAsync<BtcInfo>("/v3/bitcoin/info", localVarRequestOptions, Configuration, cancellationToken).ConfigureAwait(false);

            return localVarResponse;
        }

        /// <summary>
        /// Get the hash of a Bitcoin block 1 credit per API call Gets a Bitcoin block hash. Returns the hash of the block to get the block&#39;s details.
        /// </summary>
        /// <exception cref="Tatum.CSharp.Bitcoin.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="i">The number of blocks preceding a particular block on a blockchain.</param>
        /// <returns>BtcBlockHash</returns>
        public BtcBlockHash BtcGetBlockHash(decimal i)
        {
            var localVarResponse = BtcGetBlockHashWithHttpInfo(i);

            var exception = ExceptionFactory?.Invoke("BtcGetBlockHash", localVarResponse);
            if (exception != null) throw exception;

            return localVarResponse.Data;
        }

        /// <summary>
        /// Get the hash of a Bitcoin block 1 credit per API call Gets a Bitcoin block hash. Returns the hash of the block to get the block&#39;s details.
        /// </summary>
        /// <exception cref="Tatum.CSharp.Bitcoin.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="i">The number of blocks preceding a particular block on a blockchain.</param>
        /// <returns>ApiResponse of BtcBlockHash</returns>
        public ApiResponse<BtcBlockHash> BtcGetBlockHashWithHttpInfo(decimal i)
        {
            var localVarRequestOptions = new RequestOptions();

            var contentTypes = new string[]{
            };

            // to determine the Accept header
            var accepts = new string[]{
                "application/json"
            };

            var localVarContentType = ClientUtils.SelectHeaderContentType(contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = ClientUtils.SelectHeaderAccept(accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.PathParameters.Add("i", ClientUtils.ParameterToString(i)); // path parameter

            // authentication (X-API-Key) required
            if (!string.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("x-api-key")))
            {
                localVarRequestOptions.HeaderParameters.Add("x-api-key", Configuration.GetApiKeyWithPrefix("x-api-key"));
            }

            // make the HTTP request
            var localVarResponse = Client.Get<BtcBlockHash>("/v3/bitcoin/block/hash/{i}", localVarRequestOptions, Configuration);

            return localVarResponse;
        }

        /// <summary>
        /// Get the hash of a Bitcoin block 1 credit per API call Gets a Bitcoin block hash. Returns the hash of the block to get the block&#39;s details.
        /// </summary>
        /// <exception cref="Tatum.CSharp.Bitcoin.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="i">The number of blocks preceding a particular block on a blockchain.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of BtcBlockHash</returns>
        public async System.Threading.Tasks.Task<BtcBlockHash> BtcGetBlockHashAsync(decimal i, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            var localVarResponse = await BtcGetBlockHashWithHttpInfoAsync(i, cancellationToken).ConfigureAwait(false);
            
            var exception = ExceptionFactory?.Invoke("BtcGetBlockHash", localVarResponse);
            if (exception != null) throw exception;

            return localVarResponse.Data;
        }

        /// <summary>
        /// Get the hash of a Bitcoin block 1 credit per API call Gets a Bitcoin block hash. Returns the hash of the block to get the block&#39;s details.
        /// </summary>
        /// <exception cref="Tatum.CSharp.Bitcoin.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="i">The number of blocks preceding a particular block on a blockchain.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (BtcBlockHash)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<BtcBlockHash>> BtcGetBlockHashWithHttpInfoAsync(decimal i, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            var localVarRequestOptions = new RequestOptions();

            var contentTypes = new string[]{
            };

            // to determine the Accept header
            var accepts = new string[]{
                "application/json"
            };


            var localVarContentType = ClientUtils.SelectHeaderContentType(contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = ClientUtils.SelectHeaderAccept(accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.PathParameters.Add("i", ClientUtils.ParameterToString(i)); // path parameter

            // authentication (X-API-Key) required
            if (!string.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("x-api-key")))
            {
                localVarRequestOptions.HeaderParameters.Add("x-api-key", Configuration.GetApiKeyWithPrefix("x-api-key"));
            }

            // make the HTTP request

            var localVarResponse = await AsynchronousClient.GetAsync<BtcBlockHash>("/v3/bitcoin/block/hash/{i}", localVarRequestOptions, Configuration, cancellationToken).ConfigureAwait(false);

            return localVarResponse;
        }

        /// <summary>
        /// Get transactions from the Bitcoin mempool 1 credit per API call Gets Bitcoin transaction IDs in the mempool.
        /// </summary>
        /// <exception cref="Tatum.CSharp.Bitcoin.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <returns>List&lt;string&gt;</returns>
        public List<string> BtcGetMempool()
        {
            var localVarResponse = BtcGetMempoolWithHttpInfo();

            var exception = ExceptionFactory?.Invoke("BtcGetMempool", localVarResponse);
            if (exception != null) throw exception;

            return localVarResponse.Data;
        }

        /// <summary>
        /// Get transactions from the Bitcoin mempool 1 credit per API call Gets Bitcoin transaction IDs in the mempool.
        /// </summary>
        /// <exception cref="Tatum.CSharp.Bitcoin.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <returns>ApiResponse of List&lt;string&gt;</returns>
        public ApiResponse<List<string>> BtcGetMempoolWithHttpInfo()
        {
            var localVarRequestOptions = new RequestOptions();

            var contentTypes = new string[]{
            };

            // to determine the Accept header
            var accepts = new string[]{
                "application/json"
            };

            var localVarContentType = ClientUtils.SelectHeaderContentType(contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = ClientUtils.SelectHeaderAccept(accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);


            // authentication (X-API-Key) required
            if (!string.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("x-api-key")))
            {
                localVarRequestOptions.HeaderParameters.Add("x-api-key", Configuration.GetApiKeyWithPrefix("x-api-key"));
            }

            // make the HTTP request
            var localVarResponse = Client.Get<List<string>>("/v3/bitcoin/mempool", localVarRequestOptions, Configuration);

            return localVarResponse;
        }

        /// <summary>
        /// Get transactions from the Bitcoin mempool 1 credit per API call Gets Bitcoin transaction IDs in the mempool.
        /// </summary>
        /// <exception cref="Tatum.CSharp.Bitcoin.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of List&lt;string&gt;</returns>
        public async System.Threading.Tasks.Task<List<string>> BtcGetMempoolAsync(System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            var localVarResponse = await BtcGetMempoolWithHttpInfoAsync(cancellationToken).ConfigureAwait(false);
            
            var exception = ExceptionFactory?.Invoke("BtcGetMempool", localVarResponse);
            if (exception != null) throw exception;

            return localVarResponse.Data;
        }

        /// <summary>
        /// Get transactions from the Bitcoin mempool 1 credit per API call Gets Bitcoin transaction IDs in the mempool.
        /// </summary>
        /// <exception cref="Tatum.CSharp.Bitcoin.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (List&lt;string&gt;)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<List<string>>> BtcGetMempoolWithHttpInfoAsync(System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            var localVarRequestOptions = new RequestOptions();

            var contentTypes = new string[]{
            };

            // to determine the Accept header
            var accepts = new string[]{
                "application/json"
            };


            var localVarContentType = ClientUtils.SelectHeaderContentType(contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = ClientUtils.SelectHeaderAccept(accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);


            // authentication (X-API-Key) required
            if (!string.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("x-api-key")))
            {
                localVarRequestOptions.HeaderParameters.Add("x-api-key", Configuration.GetApiKeyWithPrefix("x-api-key"));
            }

            // make the HTTP request

            var localVarResponse = await AsynchronousClient.GetAsync<List<string>>("/v3/bitcoin/mempool", localVarRequestOptions, Configuration, cancellationToken).ConfigureAwait(false);

            return localVarResponse;
        }

        /// <summary>
        /// Get a Bitcoin transaction by its hash 1 credit per API call Get Bitcoin Transaction detail by transaction hash.
        /// </summary>
        /// <exception cref="Tatum.CSharp.Bitcoin.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="hash">Transaction hash</param>
        /// <returns>BtcTx</returns>
        public BtcTx BtcGetRawTransaction(string hash)
        {
            var localVarResponse = BtcGetRawTransactionWithHttpInfo(hash);

            var exception = ExceptionFactory?.Invoke("BtcGetRawTransaction", localVarResponse);
            if (exception != null) throw exception;

            return localVarResponse.Data;
        }

        /// <summary>
        /// Get a Bitcoin transaction by its hash 1 credit per API call Get Bitcoin Transaction detail by transaction hash.
        /// </summary>
        /// <exception cref="Tatum.CSharp.Bitcoin.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="hash">Transaction hash</param>
        /// <returns>ApiResponse of BtcTx</returns>
        public ApiResponse<BtcTx> BtcGetRawTransactionWithHttpInfo(string hash)
        {
            // verify the required parameter 'hash' is set
            if (hash == null)
                throw new ApiException(400, "Missing required parameter 'hash' when calling BitcoinApi->BtcGetRawTransaction");

            var localVarRequestOptions = new RequestOptions();

            var contentTypes = new string[]{
            };

            // to determine the Accept header
            var accepts = new string[]{
                "application/json"
            };

            var localVarContentType = ClientUtils.SelectHeaderContentType(contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = ClientUtils.SelectHeaderAccept(accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.PathParameters.Add("hash", ClientUtils.ParameterToString(hash)); // path parameter

            // authentication (X-API-Key) required
            if (!string.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("x-api-key")))
            {
                localVarRequestOptions.HeaderParameters.Add("x-api-key", Configuration.GetApiKeyWithPrefix("x-api-key"));
            }

            // make the HTTP request
            var localVarResponse = Client.Get<BtcTx>("/v3/bitcoin/transaction/{hash}", localVarRequestOptions, Configuration);

            return localVarResponse;
        }

        /// <summary>
        /// Get a Bitcoin transaction by its hash 1 credit per API call Get Bitcoin Transaction detail by transaction hash.
        /// </summary>
        /// <exception cref="Tatum.CSharp.Bitcoin.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="hash">Transaction hash</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of BtcTx</returns>
        public async System.Threading.Tasks.Task<BtcTx> BtcGetRawTransactionAsync(string hash, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            var localVarResponse = await BtcGetRawTransactionWithHttpInfoAsync(hash, cancellationToken).ConfigureAwait(false);
            
            var exception = ExceptionFactory?.Invoke("BtcGetRawTransaction", localVarResponse);
            if (exception != null) throw exception;

            return localVarResponse.Data;
        }

        /// <summary>
        /// Get a Bitcoin transaction by its hash 1 credit per API call Get Bitcoin Transaction detail by transaction hash.
        /// </summary>
        /// <exception cref="Tatum.CSharp.Bitcoin.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="hash">Transaction hash</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (BtcTx)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<BtcTx>> BtcGetRawTransactionWithHttpInfoAsync(string hash, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            // verify the required parameter 'hash' is set
            if (hash == null)
                throw new ApiException(400, "Missing required parameter 'hash' when calling BitcoinApi->BtcGetRawTransaction");

            var localVarRequestOptions = new RequestOptions();

            var contentTypes = new string[]{
            };

            // to determine the Accept header
            var accepts = new string[]{
                "application/json"
            };


            var localVarContentType = ClientUtils.SelectHeaderContentType(contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = ClientUtils.SelectHeaderAccept(accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.PathParameters.Add("hash", ClientUtils.ParameterToString(hash)); // path parameter

            // authentication (X-API-Key) required
            if (!string.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("x-api-key")))
            {
                localVarRequestOptions.HeaderParameters.Add("x-api-key", Configuration.GetApiKeyWithPrefix("x-api-key"));
            }

            // make the HTTP request

            var localVarResponse = await AsynchronousClient.GetAsync<BtcTx>("/v3/bitcoin/transaction/{hash}", localVarRequestOptions, Configuration, cancellationToken).ConfigureAwait(false);

            return localVarResponse;
        }

        /// <summary>
        /// Get all transactions for a Bitcoin address 1 credit per API call Get all transactions for a Bitcoin address.
        /// </summary>
        /// <exception cref="Tatum.CSharp.Bitcoin.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="address">Address</param>
        /// <param name="pageSize">Max number of items per page is 50.</param>
        /// <param name="offset">Offset to obtain the next page of data. (optional)</param>
        /// <returns>List&lt;BtcTx&gt;</returns>
        public List<BtcTx> BtcGetTxByAddress(string address, decimal pageSize, decimal? offset = default(decimal?))
        {
            var localVarResponse = BtcGetTxByAddressWithHttpInfo(address, pageSize, offset);

            var exception = ExceptionFactory?.Invoke("BtcGetTxByAddress", localVarResponse);
            if (exception != null) throw exception;

            return localVarResponse.Data;
        }

        /// <summary>
        /// Get all transactions for a Bitcoin address 1 credit per API call Get all transactions for a Bitcoin address.
        /// </summary>
        /// <exception cref="Tatum.CSharp.Bitcoin.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="address">Address</param>
        /// <param name="pageSize">Max number of items per page is 50.</param>
        /// <param name="offset">Offset to obtain the next page of data. (optional)</param>
        /// <returns>ApiResponse of List&lt;BtcTx&gt;</returns>
        public ApiResponse<List<BtcTx>> BtcGetTxByAddressWithHttpInfo(string address, decimal pageSize, decimal? offset = default(decimal?))
        {
            // verify the required parameter 'address' is set
            if (address == null)
                throw new ApiException(400, "Missing required parameter 'address' when calling BitcoinApi->BtcGetTxByAddress");

            var localVarRequestOptions = new RequestOptions();

            var contentTypes = new string[]{
            };

            // to determine the Accept header
            var accepts = new string[]{
                "application/json"
            };

            var localVarContentType = ClientUtils.SelectHeaderContentType(contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = ClientUtils.SelectHeaderAccept(accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.PathParameters.Add("address", ClientUtils.ParameterToString(address)); // path parameter
            localVarRequestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "pageSize", pageSize));
            if (offset != null)
            {
                localVarRequestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "offset", offset));
            }

            // authentication (X-API-Key) required
            if (!string.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("x-api-key")))
            {
                localVarRequestOptions.HeaderParameters.Add("x-api-key", Configuration.GetApiKeyWithPrefix("x-api-key"));
            }

            // make the HTTP request
            var localVarResponse = Client.Get<List<BtcTx>>("/v3/bitcoin/transaction/address/{address}", localVarRequestOptions, Configuration);

            return localVarResponse;
        }

        /// <summary>
        /// Get all transactions for a Bitcoin address 1 credit per API call Get all transactions for a Bitcoin address.
        /// </summary>
        /// <exception cref="Tatum.CSharp.Bitcoin.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="address">Address</param>
        /// <param name="pageSize">Max number of items per page is 50.</param>
        /// <param name="offset">Offset to obtain the next page of data. (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of List&lt;BtcTx&gt;</returns>
        public async System.Threading.Tasks.Task<List<BtcTx>> BtcGetTxByAddressAsync(string address, decimal pageSize, decimal? offset = default(decimal?), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            var localVarResponse = await BtcGetTxByAddressWithHttpInfoAsync(address, pageSize, offset, cancellationToken).ConfigureAwait(false);
            
            var exception = ExceptionFactory?.Invoke("BtcGetTxByAddress", localVarResponse);
            if (exception != null) throw exception;

            return localVarResponse.Data;
        }

        /// <summary>
        /// Get all transactions for a Bitcoin address 1 credit per API call Get all transactions for a Bitcoin address.
        /// </summary>
        /// <exception cref="Tatum.CSharp.Bitcoin.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="address">Address</param>
        /// <param name="pageSize">Max number of items per page is 50.</param>
        /// <param name="offset">Offset to obtain the next page of data. (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (List&lt;BtcTx&gt;)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<List<BtcTx>>> BtcGetTxByAddressWithHttpInfoAsync(string address, decimal pageSize, decimal? offset = default(decimal?), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            // verify the required parameter 'address' is set
            if (address == null)
                throw new ApiException(400, "Missing required parameter 'address' when calling BitcoinApi->BtcGetTxByAddress");

            var localVarRequestOptions = new RequestOptions();

            var contentTypes = new string[]{
            };

            // to determine the Accept header
            var accepts = new string[]{
                "application/json"
            };


            var localVarContentType = ClientUtils.SelectHeaderContentType(contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = ClientUtils.SelectHeaderAccept(accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.PathParameters.Add("address", ClientUtils.ParameterToString(address)); // path parameter
            localVarRequestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "pageSize", pageSize));
            if (offset != null)
            {
                localVarRequestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "offset", offset));
            }

            // authentication (X-API-Key) required
            if (!string.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("x-api-key")))
            {
                localVarRequestOptions.HeaderParameters.Add("x-api-key", Configuration.GetApiKeyWithPrefix("x-api-key"));
            }

            // make the HTTP request

            var localVarResponse = await AsynchronousClient.GetAsync<List<BtcTx>>("/v3/bitcoin/transaction/address/{address}", localVarRequestOptions, Configuration, cancellationToken).ConfigureAwait(false);

            return localVarResponse;
        }

        /// <summary>
        /// Get information about a transaction output (UTXO) in a Bitcoin transaction 1 credit per API call Get information about a transaction output in a transaction and check whether this output is a UTXO or has been spent. \&quot;UTXO\&quot; stands for \&quot;Unspent Transaction Output\&quot;. A UTXO is the amount of BTC/satoshis that remains at a Bitcoin address after a cryptocurrency transaction involving this address has been performed. The UTXO can then be used as input for a new cryptocurrency transaction. For more information about Bitcoin transactions and UTXO, see the Bitcoin user documentation. If the transaction output is an UTXO, the API returns data about it. If the transaction output has been spent and there is no UTXO to return, the API returns an error with the 404 response code.
        /// </summary>
        /// <exception cref="Tatum.CSharp.Bitcoin.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="hash">The transaction hash</param>
        /// <param name="index">The index of the transaction output that you want to check for the UTXO</param>
        /// <returns>BtcUTXO</returns>
        public BtcUTXO BtcGetUTXO(string hash, decimal index)
        {
            var localVarResponse = BtcGetUTXOWithHttpInfo(hash, index);

            var exception = ExceptionFactory?.Invoke("BtcGetUTXO", localVarResponse);
            if (exception != null) throw exception;

            return localVarResponse.Data;
        }

        /// <summary>
        /// Get information about a transaction output (UTXO) in a Bitcoin transaction 1 credit per API call Get information about a transaction output in a transaction and check whether this output is a UTXO or has been spent. \&quot;UTXO\&quot; stands for \&quot;Unspent Transaction Output\&quot;. A UTXO is the amount of BTC/satoshis that remains at a Bitcoin address after a cryptocurrency transaction involving this address has been performed. The UTXO can then be used as input for a new cryptocurrency transaction. For more information about Bitcoin transactions and UTXO, see the Bitcoin user documentation. If the transaction output is an UTXO, the API returns data about it. If the transaction output has been spent and there is no UTXO to return, the API returns an error with the 404 response code.
        /// </summary>
        /// <exception cref="Tatum.CSharp.Bitcoin.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="hash">The transaction hash</param>
        /// <param name="index">The index of the transaction output that you want to check for the UTXO</param>
        /// <returns>ApiResponse of BtcUTXO</returns>
        public ApiResponse<BtcUTXO> BtcGetUTXOWithHttpInfo(string hash, decimal index)
        {
            // verify the required parameter 'hash' is set
            if (hash == null)
                throw new ApiException(400, "Missing required parameter 'hash' when calling BitcoinApi->BtcGetUTXO");

            var localVarRequestOptions = new RequestOptions();

            var contentTypes = new string[]{
            };

            // to determine the Accept header
            var accepts = new string[]{
                "application/json"
            };

            var localVarContentType = ClientUtils.SelectHeaderContentType(contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = ClientUtils.SelectHeaderAccept(accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.PathParameters.Add("hash", ClientUtils.ParameterToString(hash)); // path parameter
            localVarRequestOptions.PathParameters.Add("index", ClientUtils.ParameterToString(index)); // path parameter

            // authentication (X-API-Key) required
            if (!string.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("x-api-key")))
            {
                localVarRequestOptions.HeaderParameters.Add("x-api-key", Configuration.GetApiKeyWithPrefix("x-api-key"));
            }

            // make the HTTP request
            var localVarResponse = Client.Get<BtcUTXO>("/v3/bitcoin/utxo/{hash}/{index}", localVarRequestOptions, Configuration);

            return localVarResponse;
        }

        /// <summary>
        /// Get information about a transaction output (UTXO) in a Bitcoin transaction 1 credit per API call Get information about a transaction output in a transaction and check whether this output is a UTXO or has been spent. \&quot;UTXO\&quot; stands for \&quot;Unspent Transaction Output\&quot;. A UTXO is the amount of BTC/satoshis that remains at a Bitcoin address after a cryptocurrency transaction involving this address has been performed. The UTXO can then be used as input for a new cryptocurrency transaction. For more information about Bitcoin transactions and UTXO, see the Bitcoin user documentation. If the transaction output is an UTXO, the API returns data about it. If the transaction output has been spent and there is no UTXO to return, the API returns an error with the 404 response code.
        /// </summary>
        /// <exception cref="Tatum.CSharp.Bitcoin.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="hash">The transaction hash</param>
        /// <param name="index">The index of the transaction output that you want to check for the UTXO</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of BtcUTXO</returns>
        public async System.Threading.Tasks.Task<BtcUTXO> BtcGetUTXOAsync(string hash, decimal index, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            var localVarResponse = await BtcGetUTXOWithHttpInfoAsync(hash, index, cancellationToken).ConfigureAwait(false);
            
            var exception = ExceptionFactory?.Invoke("BtcGetUTXO", localVarResponse);
            if (exception != null) throw exception;

            return localVarResponse.Data;
        }

        /// <summary>
        /// Get information about a transaction output (UTXO) in a Bitcoin transaction 1 credit per API call Get information about a transaction output in a transaction and check whether this output is a UTXO or has been spent. \&quot;UTXO\&quot; stands for \&quot;Unspent Transaction Output\&quot;. A UTXO is the amount of BTC/satoshis that remains at a Bitcoin address after a cryptocurrency transaction involving this address has been performed. The UTXO can then be used as input for a new cryptocurrency transaction. For more information about Bitcoin transactions and UTXO, see the Bitcoin user documentation. If the transaction output is an UTXO, the API returns data about it. If the transaction output has been spent and there is no UTXO to return, the API returns an error with the 404 response code.
        /// </summary>
        /// <exception cref="Tatum.CSharp.Bitcoin.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="hash">The transaction hash</param>
        /// <param name="index">The index of the transaction output that you want to check for the UTXO</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (BtcUTXO)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<BtcUTXO>> BtcGetUTXOWithHttpInfoAsync(string hash, decimal index, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            // verify the required parameter 'hash' is set
            if (hash == null)
                throw new ApiException(400, "Missing required parameter 'hash' when calling BitcoinApi->BtcGetUTXO");

            var localVarRequestOptions = new RequestOptions();

            var contentTypes = new string[]{
            };

            // to determine the Accept header
            var accepts = new string[]{
                "application/json"
            };


            var localVarContentType = ClientUtils.SelectHeaderContentType(contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = ClientUtils.SelectHeaderAccept(accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.PathParameters.Add("hash", ClientUtils.ParameterToString(hash)); // path parameter
            localVarRequestOptions.PathParameters.Add("index", ClientUtils.ParameterToString(index)); // path parameter

            // authentication (X-API-Key) required
            if (!string.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("x-api-key")))
            {
                localVarRequestOptions.HeaderParameters.Add("x-api-key", Configuration.GetApiKeyWithPrefix("x-api-key"));
            }

            // make the HTTP request

            var localVarResponse = await AsynchronousClient.GetAsync<BtcUTXO>("/v3/bitcoin/utxo/{hash}/{index}", localVarRequestOptions, Configuration, cancellationToken).ConfigureAwait(false);

            return localVarResponse;
        }

        /// <summary>
        /// Send BTC to Bitcoin addresses 2 credits per API call Send BTC to blockchain addresses. Bitcoin transactions are based on UTXOs. \&quot;UTXO\&quot; stands for \&quot;Unspent Transaction Output\&quot;. A UTXO is the amount of BTC/satoshis that remains at a Bitcoin address after a cryptocurrency transaction involving this address has been performed. The UTXO can then be used as input for a new cryptocurrency transaction. For more information about Bitcoin transactions and UTXO, see the Bitcoin user documentation. To check UTXOs in a transaction, see the API for getting information about a transaction output (UTXO) in a Bitcoin transaction. You can build a BTC transaction by one of the following methods: Sending BTC from blockchain addresses The assets are sent from a list of addresses. For each address, the last 100 transactions are scanned for any UTXO to be included in the transaction. For easier control over the assets to be sent, we recommend that you use this method only if you have one address to send the assets from. To use this method, use the BtcTransactionFromAddress or BtcTransactionFromAddressKMS schema of the request body. Sending BTC from UTXOs The assets are sent from a list of UTXOs. Each UTXO is included in the transaction. Use this method if you want to manually calculate the amount to send. To use this method, use the BtcTransactionFromUTXO or BtcTransactionFromUTXOKMS schema of the request body. When an UTXO is entered into a transaction, the whole UTXO amount is included and must be spent. For example, address A receives two transactions, T1 with 1 BTC and T2 with 2 BTC. A transaction that consumes the UTXOs from both T1 and T2 will have an available amount of 3 BTC to spend: 1 BTC (from T1) + 2 BTC (from T2) &#x3D; 3 BTC (to spend in total) You can send the assets to one or multiple recipients in one transaction. If you send the assets to multiple addresses, each address must have its own amount to receive. Paying the gas fee and receiving the change When the amount that the recipients should receive is lower than the amount from the UTXOs, the difference between these two amounts is by default used as the gas fee for the transaction. Because this amount may be considerable and you may not want to spend it all on the gas fee, you can explicitly specify the fee amount and the blockchain address where any extra funds remaining after covering the fee will be sent (the fee and changeAddress parameters in the request body, correspondingly). Signing a transaction When sending BTC, you are charged a fee for the transaction, and you must sign the transaction with the private key of the blockchain address from which the fee will be deducted. Providing the private key in the API is not a secure way of signing transactions, because the private key can be stolen or exposed. Your private keys should never leave your security perimeter. You should use the private keys only for testing a solution you are building on the testnet of a blockchain. For signing transactions on the mainnet, we strongly recommend that you use the Tatum Key Management System (KMS) and provide the signature ID instead of the private key in the API. Alternatively, you can use the Tatum JavaScript client.
        /// </summary>
        /// <exception cref="Tatum.CSharp.Bitcoin.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="btcTransactionFromAddress"></param>
        /// <returns>TransactionHash</returns>
        public TransactionHash BtcTransferBlockchain(BtcTransactionFromAddress btcTransactionFromAddress)
        {
            var localVarResponse = BtcTransferBlockchainWithHttpInfo(btcTransactionFromAddress);

            var exception = ExceptionFactory?.Invoke("BtcTransferBlockchain", localVarResponse);
            if (exception != null) throw exception;

            return localVarResponse.Data;
        }

        /// <summary>
        /// Send BTC to Bitcoin addresses 2 credits per API call Send BTC to blockchain addresses. Bitcoin transactions are based on UTXOs. \&quot;UTXO\&quot; stands for \&quot;Unspent Transaction Output\&quot;. A UTXO is the amount of BTC/satoshis that remains at a Bitcoin address after a cryptocurrency transaction involving this address has been performed. The UTXO can then be used as input for a new cryptocurrency transaction. For more information about Bitcoin transactions and UTXO, see the Bitcoin user documentation. To check UTXOs in a transaction, see the API for getting information about a transaction output (UTXO) in a Bitcoin transaction. You can build a BTC transaction by one of the following methods: Sending BTC from blockchain addresses The assets are sent from a list of addresses. For each address, the last 100 transactions are scanned for any UTXO to be included in the transaction. For easier control over the assets to be sent, we recommend that you use this method only if you have one address to send the assets from. To use this method, use the BtcTransactionFromAddress or BtcTransactionFromAddressKMS schema of the request body. Sending BTC from UTXOs The assets are sent from a list of UTXOs. Each UTXO is included in the transaction. Use this method if you want to manually calculate the amount to send. To use this method, use the BtcTransactionFromUTXO or BtcTransactionFromUTXOKMS schema of the request body. When an UTXO is entered into a transaction, the whole UTXO amount is included and must be spent. For example, address A receives two transactions, T1 with 1 BTC and T2 with 2 BTC. A transaction that consumes the UTXOs from both T1 and T2 will have an available amount of 3 BTC to spend: 1 BTC (from T1) + 2 BTC (from T2) &#x3D; 3 BTC (to spend in total) You can send the assets to one or multiple recipients in one transaction. If you send the assets to multiple addresses, each address must have its own amount to receive. Paying the gas fee and receiving the change When the amount that the recipients should receive is lower than the amount from the UTXOs, the difference between these two amounts is by default used as the gas fee for the transaction. Because this amount may be considerable and you may not want to spend it all on the gas fee, you can explicitly specify the fee amount and the blockchain address where any extra funds remaining after covering the fee will be sent (the fee and changeAddress parameters in the request body, correspondingly). Signing a transaction When sending BTC, you are charged a fee for the transaction, and you must sign the transaction with the private key of the blockchain address from which the fee will be deducted. Providing the private key in the API is not a secure way of signing transactions, because the private key can be stolen or exposed. Your private keys should never leave your security perimeter. You should use the private keys only for testing a solution you are building on the testnet of a blockchain. For signing transactions on the mainnet, we strongly recommend that you use the Tatum Key Management System (KMS) and provide the signature ID instead of the private key in the API. Alternatively, you can use the Tatum JavaScript client.
        /// </summary>
        /// <exception cref="Tatum.CSharp.Bitcoin.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="btcTransactionFromAddress"></param>
        /// <returns>ApiResponse of TransactionHash</returns>
        public ApiResponse<TransactionHash> BtcTransferBlockchainWithHttpInfo(BtcTransactionFromAddress btcTransactionFromAddress)
        {
            // verify the required parameter 'btcTransactionFromAddress' is set
            if (btcTransactionFromAddress == null)
                throw new ApiException(400, "Missing required parameter 'btcTransactionFromAddress' when calling BitcoinApi->BtcTransferBlockchain");

            var localVarRequestOptions = new RequestOptions();

            var contentTypes = new string[]{
                "application/json"
            };

            // to determine the Accept header
            var accepts = new string[]{
                "application/json"
            };

            var localVarContentType = ClientUtils.SelectHeaderContentType(contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = ClientUtils.SelectHeaderAccept(accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.Data = btcTransactionFromAddress;

            // authentication (X-API-Key) required
            if (!string.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("x-api-key")))
            {
                localVarRequestOptions.HeaderParameters.Add("x-api-key", Configuration.GetApiKeyWithPrefix("x-api-key"));
            }

            // make the HTTP request
            var localVarResponse = Client.Post<TransactionHash>("/v3/bitcoin/transaction", localVarRequestOptions, Configuration);

            return localVarResponse;
        }

        /// <summary>
        /// Send BTC to Bitcoin addresses 2 credits per API call Send BTC to blockchain addresses. Bitcoin transactions are based on UTXOs. \&quot;UTXO\&quot; stands for \&quot;Unspent Transaction Output\&quot;. A UTXO is the amount of BTC/satoshis that remains at a Bitcoin address after a cryptocurrency transaction involving this address has been performed. The UTXO can then be used as input for a new cryptocurrency transaction. For more information about Bitcoin transactions and UTXO, see the Bitcoin user documentation. To check UTXOs in a transaction, see the API for getting information about a transaction output (UTXO) in a Bitcoin transaction. You can build a BTC transaction by one of the following methods: Sending BTC from blockchain addresses The assets are sent from a list of addresses. For each address, the last 100 transactions are scanned for any UTXO to be included in the transaction. For easier control over the assets to be sent, we recommend that you use this method only if you have one address to send the assets from. To use this method, use the BtcTransactionFromAddress or BtcTransactionFromAddressKMS schema of the request body. Sending BTC from UTXOs The assets are sent from a list of UTXOs. Each UTXO is included in the transaction. Use this method if you want to manually calculate the amount to send. To use this method, use the BtcTransactionFromUTXO or BtcTransactionFromUTXOKMS schema of the request body. When an UTXO is entered into a transaction, the whole UTXO amount is included and must be spent. For example, address A receives two transactions, T1 with 1 BTC and T2 with 2 BTC. A transaction that consumes the UTXOs from both T1 and T2 will have an available amount of 3 BTC to spend: 1 BTC (from T1) + 2 BTC (from T2) &#x3D; 3 BTC (to spend in total) You can send the assets to one or multiple recipients in one transaction. If you send the assets to multiple addresses, each address must have its own amount to receive. Paying the gas fee and receiving the change When the amount that the recipients should receive is lower than the amount from the UTXOs, the difference between these two amounts is by default used as the gas fee for the transaction. Because this amount may be considerable and you may not want to spend it all on the gas fee, you can explicitly specify the fee amount and the blockchain address where any extra funds remaining after covering the fee will be sent (the fee and changeAddress parameters in the request body, correspondingly). Signing a transaction When sending BTC, you are charged a fee for the transaction, and you must sign the transaction with the private key of the blockchain address from which the fee will be deducted. Providing the private key in the API is not a secure way of signing transactions, because the private key can be stolen or exposed. Your private keys should never leave your security perimeter. You should use the private keys only for testing a solution you are building on the testnet of a blockchain. For signing transactions on the mainnet, we strongly recommend that you use the Tatum Key Management System (KMS) and provide the signature ID instead of the private key in the API. Alternatively, you can use the Tatum JavaScript client.
        /// </summary>
        /// <exception cref="Tatum.CSharp.Bitcoin.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="btcTransactionFromAddress"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of TransactionHash</returns>
        public async System.Threading.Tasks.Task<TransactionHash> BtcTransferBlockchainAsync(BtcTransactionFromAddress btcTransactionFromAddress, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            var localVarResponse = await BtcTransferBlockchainWithHttpInfoAsync(btcTransactionFromAddress, cancellationToken).ConfigureAwait(false);
            
            var exception = ExceptionFactory?.Invoke("BtcTransferBlockchain", localVarResponse);
            if (exception != null) throw exception;

            return localVarResponse.Data;
        }

        /// <summary>
        /// Send BTC to Bitcoin addresses 2 credits per API call Send BTC to blockchain addresses. Bitcoin transactions are based on UTXOs. \&quot;UTXO\&quot; stands for \&quot;Unspent Transaction Output\&quot;. A UTXO is the amount of BTC/satoshis that remains at a Bitcoin address after a cryptocurrency transaction involving this address has been performed. The UTXO can then be used as input for a new cryptocurrency transaction. For more information about Bitcoin transactions and UTXO, see the Bitcoin user documentation. To check UTXOs in a transaction, see the API for getting information about a transaction output (UTXO) in a Bitcoin transaction. You can build a BTC transaction by one of the following methods: Sending BTC from blockchain addresses The assets are sent from a list of addresses. For each address, the last 100 transactions are scanned for any UTXO to be included in the transaction. For easier control over the assets to be sent, we recommend that you use this method only if you have one address to send the assets from. To use this method, use the BtcTransactionFromAddress or BtcTransactionFromAddressKMS schema of the request body. Sending BTC from UTXOs The assets are sent from a list of UTXOs. Each UTXO is included in the transaction. Use this method if you want to manually calculate the amount to send. To use this method, use the BtcTransactionFromUTXO or BtcTransactionFromUTXOKMS schema of the request body. When an UTXO is entered into a transaction, the whole UTXO amount is included and must be spent. For example, address A receives two transactions, T1 with 1 BTC and T2 with 2 BTC. A transaction that consumes the UTXOs from both T1 and T2 will have an available amount of 3 BTC to spend: 1 BTC (from T1) + 2 BTC (from T2) &#x3D; 3 BTC (to spend in total) You can send the assets to one or multiple recipients in one transaction. If you send the assets to multiple addresses, each address must have its own amount to receive. Paying the gas fee and receiving the change When the amount that the recipients should receive is lower than the amount from the UTXOs, the difference between these two amounts is by default used as the gas fee for the transaction. Because this amount may be considerable and you may not want to spend it all on the gas fee, you can explicitly specify the fee amount and the blockchain address where any extra funds remaining after covering the fee will be sent (the fee and changeAddress parameters in the request body, correspondingly). Signing a transaction When sending BTC, you are charged a fee for the transaction, and you must sign the transaction with the private key of the blockchain address from which the fee will be deducted. Providing the private key in the API is not a secure way of signing transactions, because the private key can be stolen or exposed. Your private keys should never leave your security perimeter. You should use the private keys only for testing a solution you are building on the testnet of a blockchain. For signing transactions on the mainnet, we strongly recommend that you use the Tatum Key Management System (KMS) and provide the signature ID instead of the private key in the API. Alternatively, you can use the Tatum JavaScript client.
        /// </summary>
        /// <exception cref="Tatum.CSharp.Bitcoin.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="btcTransactionFromAddress"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (TransactionHash)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<TransactionHash>> BtcTransferBlockchainWithHttpInfoAsync(BtcTransactionFromAddress btcTransactionFromAddress, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            // verify the required parameter 'btcTransactionFromAddress' is set
            if (btcTransactionFromAddress == null)
                throw new ApiException(400, "Missing required parameter 'btcTransactionFromAddress' when calling BitcoinApi->BtcTransferBlockchain");

            var localVarRequestOptions = new RequestOptions();

            var contentTypes = new string[]{
                "application/json"
            };

            // to determine the Accept header
            var accepts = new string[]{
                "application/json"
            };


            var localVarContentType = ClientUtils.SelectHeaderContentType(contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = ClientUtils.SelectHeaderAccept(accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.Data = btcTransactionFromAddress;

            // authentication (X-API-Key) required
            if (!string.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("x-api-key")))
            {
                localVarRequestOptions.HeaderParameters.Add("x-api-key", Configuration.GetApiKeyWithPrefix("x-api-key"));
            }

            // make the HTTP request

            var localVarResponse = await AsynchronousClient.PostAsync<TransactionHash>("/v3/bitcoin/transaction", localVarRequestOptions, Configuration, cancellationToken).ConfigureAwait(false);

            return localVarResponse;
        }

        /// <summary>
        /// Send BTC to Bitcoin addresses 2 credits per API call Send BTC to blockchain addresses. Bitcoin transactions are based on UTXOs. \&quot;UTXO\&quot; stands for \&quot;Unspent Transaction Output\&quot;. A UTXO is the amount of BTC/satoshis that remains at a Bitcoin address after a cryptocurrency transaction involving this address has been performed. The UTXO can then be used as input for a new cryptocurrency transaction. For more information about Bitcoin transactions and UTXO, see the Bitcoin user documentation. To check UTXOs in a transaction, see the API for getting information about a transaction output (UTXO) in a Bitcoin transaction. You can build a BTC transaction by one of the following methods: Sending BTC from blockchain addresses The assets are sent from a list of addresses. For each address, the last 100 transactions are scanned for any UTXO to be included in the transaction. For easier control over the assets to be sent, we recommend that you use this method only if you have one address to send the assets from. To use this method, use the BtcTransactionFromAddress or BtcTransactionFromAddressKMS schema of the request body. Sending BTC from UTXOs The assets are sent from a list of UTXOs. Each UTXO is included in the transaction. Use this method if you want to manually calculate the amount to send. To use this method, use the BtcTransactionFromUTXO or BtcTransactionFromUTXOKMS schema of the request body. When an UTXO is entered into a transaction, the whole UTXO amount is included and must be spent. For example, address A receives two transactions, T1 with 1 BTC and T2 with 2 BTC. A transaction that consumes the UTXOs from both T1 and T2 will have an available amount of 3 BTC to spend: 1 BTC (from T1) + 2 BTC (from T2) &#x3D; 3 BTC (to spend in total) You can send the assets to one or multiple recipients in one transaction. If you send the assets to multiple addresses, each address must have its own amount to receive. Paying the gas fee and receiving the change When the amount that the recipients should receive is lower than the amount from the UTXOs, the difference between these two amounts is by default used as the gas fee for the transaction. Because this amount may be considerable and you may not want to spend it all on the gas fee, you can explicitly specify the fee amount and the blockchain address where any extra funds remaining after covering the fee will be sent (the fee and changeAddress parameters in the request body, correspondingly). Signing a transaction When sending BTC, you are charged a fee for the transaction, and you must sign the transaction with the private key of the blockchain address from which the fee will be deducted. Providing the private key in the API is not a secure way of signing transactions, because the private key can be stolen or exposed. Your private keys should never leave your security perimeter. You should use the private keys only for testing a solution you are building on the testnet of a blockchain. For signing transactions on the mainnet, we strongly recommend that you use the Tatum Key Management System (KMS) and provide the signature ID instead of the private key in the API. Alternatively, you can use the Tatum JavaScript client.
        /// </summary>
        /// <exception cref="Tatum.CSharp.Bitcoin.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="btcTransactionFromAddressKMS"></param>
        /// <returns>SignatureId</returns>
        public SignatureId BtcTransferBlockchain(BtcTransactionFromAddressKMS btcTransactionFromAddressKMS)
        {
            var localVarResponse = BtcTransferBlockchainWithHttpInfo(btcTransactionFromAddressKMS);

            var exception = ExceptionFactory?.Invoke("BtcTransferBlockchain_0", localVarResponse);
            if (exception != null) throw exception;

            return localVarResponse.Data;
        }

        /// <summary>
        /// Send BTC to Bitcoin addresses 2 credits per API call Send BTC to blockchain addresses. Bitcoin transactions are based on UTXOs. \&quot;UTXO\&quot; stands for \&quot;Unspent Transaction Output\&quot;. A UTXO is the amount of BTC/satoshis that remains at a Bitcoin address after a cryptocurrency transaction involving this address has been performed. The UTXO can then be used as input for a new cryptocurrency transaction. For more information about Bitcoin transactions and UTXO, see the Bitcoin user documentation. To check UTXOs in a transaction, see the API for getting information about a transaction output (UTXO) in a Bitcoin transaction. You can build a BTC transaction by one of the following methods: Sending BTC from blockchain addresses The assets are sent from a list of addresses. For each address, the last 100 transactions are scanned for any UTXO to be included in the transaction. For easier control over the assets to be sent, we recommend that you use this method only if you have one address to send the assets from. To use this method, use the BtcTransactionFromAddress or BtcTransactionFromAddressKMS schema of the request body. Sending BTC from UTXOs The assets are sent from a list of UTXOs. Each UTXO is included in the transaction. Use this method if you want to manually calculate the amount to send. To use this method, use the BtcTransactionFromUTXO or BtcTransactionFromUTXOKMS schema of the request body. When an UTXO is entered into a transaction, the whole UTXO amount is included and must be spent. For example, address A receives two transactions, T1 with 1 BTC and T2 with 2 BTC. A transaction that consumes the UTXOs from both T1 and T2 will have an available amount of 3 BTC to spend: 1 BTC (from T1) + 2 BTC (from T2) &#x3D; 3 BTC (to spend in total) You can send the assets to one or multiple recipients in one transaction. If you send the assets to multiple addresses, each address must have its own amount to receive. Paying the gas fee and receiving the change When the amount that the recipients should receive is lower than the amount from the UTXOs, the difference between these two amounts is by default used as the gas fee for the transaction. Because this amount may be considerable and you may not want to spend it all on the gas fee, you can explicitly specify the fee amount and the blockchain address where any extra funds remaining after covering the fee will be sent (the fee and changeAddress parameters in the request body, correspondingly). Signing a transaction When sending BTC, you are charged a fee for the transaction, and you must sign the transaction with the private key of the blockchain address from which the fee will be deducted. Providing the private key in the API is not a secure way of signing transactions, because the private key can be stolen or exposed. Your private keys should never leave your security perimeter. You should use the private keys only for testing a solution you are building on the testnet of a blockchain. For signing transactions on the mainnet, we strongly recommend that you use the Tatum Key Management System (KMS) and provide the signature ID instead of the private key in the API. Alternatively, you can use the Tatum JavaScript client.
        /// </summary>
        /// <exception cref="Tatum.CSharp.Bitcoin.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="btcTransactionFromAddressKMS"></param>
        /// <returns>ApiResponse of SignatureId</returns>
        public ApiResponse<SignatureId> BtcTransferBlockchainWithHttpInfo(BtcTransactionFromAddressKMS btcTransactionFromAddressKMS)
        {
            // verify the required parameter 'btcTransactionFromAddressKMS' is set
            if (btcTransactionFromAddressKMS == null)
                throw new ApiException(400, "Missing required parameter 'btcTransactionFromAddressKMS' when calling BitcoinApi->BtcTransferBlockchain_0");

            var localVarRequestOptions = new RequestOptions();

            var contentTypes = new string[]{
                "application/json"
            };

            // to determine the Accept header
            var accepts = new string[]{
                "application/json"
            };

            var localVarContentType = ClientUtils.SelectHeaderContentType(contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = ClientUtils.SelectHeaderAccept(accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.Data = btcTransactionFromAddressKMS;

            // authentication (X-API-Key) required
            if (!string.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("x-api-key")))
            {
                localVarRequestOptions.HeaderParameters.Add("x-api-key", Configuration.GetApiKeyWithPrefix("x-api-key"));
            }

            // make the HTTP request
            var localVarResponse = Client.Post<SignatureId>("/v3/bitcoin/transaction", localVarRequestOptions, Configuration);

            return localVarResponse;
        }

        /// <summary>
        /// Send BTC to Bitcoin addresses 2 credits per API call Send BTC to blockchain addresses. Bitcoin transactions are based on UTXOs. \&quot;UTXO\&quot; stands for \&quot;Unspent Transaction Output\&quot;. A UTXO is the amount of BTC/satoshis that remains at a Bitcoin address after a cryptocurrency transaction involving this address has been performed. The UTXO can then be used as input for a new cryptocurrency transaction. For more information about Bitcoin transactions and UTXO, see the Bitcoin user documentation. To check UTXOs in a transaction, see the API for getting information about a transaction output (UTXO) in a Bitcoin transaction. You can build a BTC transaction by one of the following methods: Sending BTC from blockchain addresses The assets are sent from a list of addresses. For each address, the last 100 transactions are scanned for any UTXO to be included in the transaction. For easier control over the assets to be sent, we recommend that you use this method only if you have one address to send the assets from. To use this method, use the BtcTransactionFromAddress or BtcTransactionFromAddressKMS schema of the request body. Sending BTC from UTXOs The assets are sent from a list of UTXOs. Each UTXO is included in the transaction. Use this method if you want to manually calculate the amount to send. To use this method, use the BtcTransactionFromUTXO or BtcTransactionFromUTXOKMS schema of the request body. When an UTXO is entered into a transaction, the whole UTXO amount is included and must be spent. For example, address A receives two transactions, T1 with 1 BTC and T2 with 2 BTC. A transaction that consumes the UTXOs from both T1 and T2 will have an available amount of 3 BTC to spend: 1 BTC (from T1) + 2 BTC (from T2) &#x3D; 3 BTC (to spend in total) You can send the assets to one or multiple recipients in one transaction. If you send the assets to multiple addresses, each address must have its own amount to receive. Paying the gas fee and receiving the change When the amount that the recipients should receive is lower than the amount from the UTXOs, the difference between these two amounts is by default used as the gas fee for the transaction. Because this amount may be considerable and you may not want to spend it all on the gas fee, you can explicitly specify the fee amount and the blockchain address where any extra funds remaining after covering the fee will be sent (the fee and changeAddress parameters in the request body, correspondingly). Signing a transaction When sending BTC, you are charged a fee for the transaction, and you must sign the transaction with the private key of the blockchain address from which the fee will be deducted. Providing the private key in the API is not a secure way of signing transactions, because the private key can be stolen or exposed. Your private keys should never leave your security perimeter. You should use the private keys only for testing a solution you are building on the testnet of a blockchain. For signing transactions on the mainnet, we strongly recommend that you use the Tatum Key Management System (KMS) and provide the signature ID instead of the private key in the API. Alternatively, you can use the Tatum JavaScript client.
        /// </summary>
        /// <exception cref="Tatum.CSharp.Bitcoin.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="btcTransactionFromAddressKMS"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of SignatureId</returns>
        public async System.Threading.Tasks.Task<SignatureId> BtcTransferBlockchainAsync(BtcTransactionFromAddressKMS btcTransactionFromAddressKMS, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            var localVarResponse = await BtcTransferBlockchainWithHttpInfoAsync(btcTransactionFromAddressKMS, cancellationToken).ConfigureAwait(false);
            
            var exception = ExceptionFactory?.Invoke("BtcTransferBlockchain_0", localVarResponse);
            if (exception != null) throw exception;

            return localVarResponse.Data;
        }

        /// <summary>
        /// Send BTC to Bitcoin addresses 2 credits per API call Send BTC to blockchain addresses. Bitcoin transactions are based on UTXOs. \&quot;UTXO\&quot; stands for \&quot;Unspent Transaction Output\&quot;. A UTXO is the amount of BTC/satoshis that remains at a Bitcoin address after a cryptocurrency transaction involving this address has been performed. The UTXO can then be used as input for a new cryptocurrency transaction. For more information about Bitcoin transactions and UTXO, see the Bitcoin user documentation. To check UTXOs in a transaction, see the API for getting information about a transaction output (UTXO) in a Bitcoin transaction. You can build a BTC transaction by one of the following methods: Sending BTC from blockchain addresses The assets are sent from a list of addresses. For each address, the last 100 transactions are scanned for any UTXO to be included in the transaction. For easier control over the assets to be sent, we recommend that you use this method only if you have one address to send the assets from. To use this method, use the BtcTransactionFromAddress or BtcTransactionFromAddressKMS schema of the request body. Sending BTC from UTXOs The assets are sent from a list of UTXOs. Each UTXO is included in the transaction. Use this method if you want to manually calculate the amount to send. To use this method, use the BtcTransactionFromUTXO or BtcTransactionFromUTXOKMS schema of the request body. When an UTXO is entered into a transaction, the whole UTXO amount is included and must be spent. For example, address A receives two transactions, T1 with 1 BTC and T2 with 2 BTC. A transaction that consumes the UTXOs from both T1 and T2 will have an available amount of 3 BTC to spend: 1 BTC (from T1) + 2 BTC (from T2) &#x3D; 3 BTC (to spend in total) You can send the assets to one or multiple recipients in one transaction. If you send the assets to multiple addresses, each address must have its own amount to receive. Paying the gas fee and receiving the change When the amount that the recipients should receive is lower than the amount from the UTXOs, the difference between these two amounts is by default used as the gas fee for the transaction. Because this amount may be considerable and you may not want to spend it all on the gas fee, you can explicitly specify the fee amount and the blockchain address where any extra funds remaining after covering the fee will be sent (the fee and changeAddress parameters in the request body, correspondingly). Signing a transaction When sending BTC, you are charged a fee for the transaction, and you must sign the transaction with the private key of the blockchain address from which the fee will be deducted. Providing the private key in the API is not a secure way of signing transactions, because the private key can be stolen or exposed. Your private keys should never leave your security perimeter. You should use the private keys only for testing a solution you are building on the testnet of a blockchain. For signing transactions on the mainnet, we strongly recommend that you use the Tatum Key Management System (KMS) and provide the signature ID instead of the private key in the API. Alternatively, you can use the Tatum JavaScript client.
        /// </summary>
        /// <exception cref="Tatum.CSharp.Bitcoin.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="btcTransactionFromAddressKMS"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (SignatureId)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<SignatureId>> BtcTransferBlockchainWithHttpInfoAsync(BtcTransactionFromAddressKMS btcTransactionFromAddressKMS, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            // verify the required parameter 'btcTransactionFromAddressKMS' is set
            if (btcTransactionFromAddressKMS == null)
                throw new ApiException(400, "Missing required parameter 'btcTransactionFromAddressKMS' when calling BitcoinApi->BtcTransferBlockchain_0");

            var localVarRequestOptions = new RequestOptions();

            var contentTypes = new string[]{
                "application/json"
            };

            // to determine the Accept header
            var accepts = new string[]{
                "application/json"
            };


            var localVarContentType = ClientUtils.SelectHeaderContentType(contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = ClientUtils.SelectHeaderAccept(accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.Data = btcTransactionFromAddressKMS;

            // authentication (X-API-Key) required
            if (!string.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("x-api-key")))
            {
                localVarRequestOptions.HeaderParameters.Add("x-api-key", Configuration.GetApiKeyWithPrefix("x-api-key"));
            }

            // make the HTTP request

            var localVarResponse = await AsynchronousClient.PostAsync<SignatureId>("/v3/bitcoin/transaction", localVarRequestOptions, Configuration, cancellationToken).ConfigureAwait(false);

            return localVarResponse;
        }

        /// <summary>
        /// Send BTC to Bitcoin addresses 2 credits per API call Send BTC to blockchain addresses. Bitcoin transactions are based on UTXOs. \&quot;UTXO\&quot; stands for \&quot;Unspent Transaction Output\&quot;. A UTXO is the amount of BTC/satoshis that remains at a Bitcoin address after a cryptocurrency transaction involving this address has been performed. The UTXO can then be used as input for a new cryptocurrency transaction. For more information about Bitcoin transactions and UTXO, see the Bitcoin user documentation. To check UTXOs in a transaction, see the API for getting information about a transaction output (UTXO) in a Bitcoin transaction. You can build a BTC transaction by one of the following methods: Sending BTC from blockchain addresses The assets are sent from a list of addresses. For each address, the last 100 transactions are scanned for any UTXO to be included in the transaction. For easier control over the assets to be sent, we recommend that you use this method only if you have one address to send the assets from. To use this method, use the BtcTransactionFromAddress or BtcTransactionFromAddressKMS schema of the request body. Sending BTC from UTXOs The assets are sent from a list of UTXOs. Each UTXO is included in the transaction. Use this method if you want to manually calculate the amount to send. To use this method, use the BtcTransactionFromUTXO or BtcTransactionFromUTXOKMS schema of the request body. When an UTXO is entered into a transaction, the whole UTXO amount is included and must be spent. For example, address A receives two transactions, T1 with 1 BTC and T2 with 2 BTC. A transaction that consumes the UTXOs from both T1 and T2 will have an available amount of 3 BTC to spend: 1 BTC (from T1) + 2 BTC (from T2) &#x3D; 3 BTC (to spend in total) You can send the assets to one or multiple recipients in one transaction. If you send the assets to multiple addresses, each address must have its own amount to receive. Paying the gas fee and receiving the change When the amount that the recipients should receive is lower than the amount from the UTXOs, the difference between these two amounts is by default used as the gas fee for the transaction. Because this amount may be considerable and you may not want to spend it all on the gas fee, you can explicitly specify the fee amount and the blockchain address where any extra funds remaining after covering the fee will be sent (the fee and changeAddress parameters in the request body, correspondingly). Signing a transaction When sending BTC, you are charged a fee for the transaction, and you must sign the transaction with the private key of the blockchain address from which the fee will be deducted. Providing the private key in the API is not a secure way of signing transactions, because the private key can be stolen or exposed. Your private keys should never leave your security perimeter. You should use the private keys only for testing a solution you are building on the testnet of a blockchain. For signing transactions on the mainnet, we strongly recommend that you use the Tatum Key Management System (KMS) and provide the signature ID instead of the private key in the API. Alternatively, you can use the Tatum JavaScript client.
        /// </summary>
        /// <exception cref="Tatum.CSharp.Bitcoin.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="btcTransactionFromUTXO"></param>
        /// <returns>TransactionHash</returns>
        public TransactionHash BtcTransferBlockchain(BtcTransactionFromUTXO btcTransactionFromUTXO)
        {
            var localVarResponse = BtcTransferBlockchainWithHttpInfo(btcTransactionFromUTXO);

            var exception = ExceptionFactory?.Invoke("BtcTransferBlockchain_1", localVarResponse);
            if (exception != null) throw exception;

            return localVarResponse.Data;
        }

        /// <summary>
        /// Send BTC to Bitcoin addresses 2 credits per API call Send BTC to blockchain addresses. Bitcoin transactions are based on UTXOs. \&quot;UTXO\&quot; stands for \&quot;Unspent Transaction Output\&quot;. A UTXO is the amount of BTC/satoshis that remains at a Bitcoin address after a cryptocurrency transaction involving this address has been performed. The UTXO can then be used as input for a new cryptocurrency transaction. For more information about Bitcoin transactions and UTXO, see the Bitcoin user documentation. To check UTXOs in a transaction, see the API for getting information about a transaction output (UTXO) in a Bitcoin transaction. You can build a BTC transaction by one of the following methods: Sending BTC from blockchain addresses The assets are sent from a list of addresses. For each address, the last 100 transactions are scanned for any UTXO to be included in the transaction. For easier control over the assets to be sent, we recommend that you use this method only if you have one address to send the assets from. To use this method, use the BtcTransactionFromAddress or BtcTransactionFromAddressKMS schema of the request body. Sending BTC from UTXOs The assets are sent from a list of UTXOs. Each UTXO is included in the transaction. Use this method if you want to manually calculate the amount to send. To use this method, use the BtcTransactionFromUTXO or BtcTransactionFromUTXOKMS schema of the request body. When an UTXO is entered into a transaction, the whole UTXO amount is included and must be spent. For example, address A receives two transactions, T1 with 1 BTC and T2 with 2 BTC. A transaction that consumes the UTXOs from both T1 and T2 will have an available amount of 3 BTC to spend: 1 BTC (from T1) + 2 BTC (from T2) &#x3D; 3 BTC (to spend in total) You can send the assets to one or multiple recipients in one transaction. If you send the assets to multiple addresses, each address must have its own amount to receive. Paying the gas fee and receiving the change When the amount that the recipients should receive is lower than the amount from the UTXOs, the difference between these two amounts is by default used as the gas fee for the transaction. Because this amount may be considerable and you may not want to spend it all on the gas fee, you can explicitly specify the fee amount and the blockchain address where any extra funds remaining after covering the fee will be sent (the fee and changeAddress parameters in the request body, correspondingly). Signing a transaction When sending BTC, you are charged a fee for the transaction, and you must sign the transaction with the private key of the blockchain address from which the fee will be deducted. Providing the private key in the API is not a secure way of signing transactions, because the private key can be stolen or exposed. Your private keys should never leave your security perimeter. You should use the private keys only for testing a solution you are building on the testnet of a blockchain. For signing transactions on the mainnet, we strongly recommend that you use the Tatum Key Management System (KMS) and provide the signature ID instead of the private key in the API. Alternatively, you can use the Tatum JavaScript client.
        /// </summary>
        /// <exception cref="Tatum.CSharp.Bitcoin.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="btcTransactionFromUTXO"></param>
        /// <returns>ApiResponse of TransactionHash</returns>
        public ApiResponse<TransactionHash> BtcTransferBlockchainWithHttpInfo(BtcTransactionFromUTXO btcTransactionFromUTXO)
        {
            // verify the required parameter 'btcTransactionFromUTXO' is set
            if (btcTransactionFromUTXO == null)
                throw new ApiException(400, "Missing required parameter 'btcTransactionFromUTXO' when calling BitcoinApi->BtcTransferBlockchain_1");

            var localVarRequestOptions = new RequestOptions();

            var contentTypes = new string[]{
                "application/json"
            };

            // to determine the Accept header
            var accepts = new string[]{
                "application/json"
            };

            var localVarContentType = ClientUtils.SelectHeaderContentType(contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = ClientUtils.SelectHeaderAccept(accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.Data = btcTransactionFromUTXO;

            // authentication (X-API-Key) required
            if (!string.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("x-api-key")))
            {
                localVarRequestOptions.HeaderParameters.Add("x-api-key", Configuration.GetApiKeyWithPrefix("x-api-key"));
            }

            // make the HTTP request
            var localVarResponse = Client.Post<TransactionHash>("/v3/bitcoin/transaction", localVarRequestOptions, Configuration);

            return localVarResponse;
        }

        /// <summary>
        /// Send BTC to Bitcoin addresses 2 credits per API call Send BTC to blockchain addresses. Bitcoin transactions are based on UTXOs. \&quot;UTXO\&quot; stands for \&quot;Unspent Transaction Output\&quot;. A UTXO is the amount of BTC/satoshis that remains at a Bitcoin address after a cryptocurrency transaction involving this address has been performed. The UTXO can then be used as input for a new cryptocurrency transaction. For more information about Bitcoin transactions and UTXO, see the Bitcoin user documentation. To check UTXOs in a transaction, see the API for getting information about a transaction output (UTXO) in a Bitcoin transaction. You can build a BTC transaction by one of the following methods: Sending BTC from blockchain addresses The assets are sent from a list of addresses. For each address, the last 100 transactions are scanned for any UTXO to be included in the transaction. For easier control over the assets to be sent, we recommend that you use this method only if you have one address to send the assets from. To use this method, use the BtcTransactionFromAddress or BtcTransactionFromAddressKMS schema of the request body. Sending BTC from UTXOs The assets are sent from a list of UTXOs. Each UTXO is included in the transaction. Use this method if you want to manually calculate the amount to send. To use this method, use the BtcTransactionFromUTXO or BtcTransactionFromUTXOKMS schema of the request body. When an UTXO is entered into a transaction, the whole UTXO amount is included and must be spent. For example, address A receives two transactions, T1 with 1 BTC and T2 with 2 BTC. A transaction that consumes the UTXOs from both T1 and T2 will have an available amount of 3 BTC to spend: 1 BTC (from T1) + 2 BTC (from T2) &#x3D; 3 BTC (to spend in total) You can send the assets to one or multiple recipients in one transaction. If you send the assets to multiple addresses, each address must have its own amount to receive. Paying the gas fee and receiving the change When the amount that the recipients should receive is lower than the amount from the UTXOs, the difference between these two amounts is by default used as the gas fee for the transaction. Because this amount may be considerable and you may not want to spend it all on the gas fee, you can explicitly specify the fee amount and the blockchain address where any extra funds remaining after covering the fee will be sent (the fee and changeAddress parameters in the request body, correspondingly). Signing a transaction When sending BTC, you are charged a fee for the transaction, and you must sign the transaction with the private key of the blockchain address from which the fee will be deducted. Providing the private key in the API is not a secure way of signing transactions, because the private key can be stolen or exposed. Your private keys should never leave your security perimeter. You should use the private keys only for testing a solution you are building on the testnet of a blockchain. For signing transactions on the mainnet, we strongly recommend that you use the Tatum Key Management System (KMS) and provide the signature ID instead of the private key in the API. Alternatively, you can use the Tatum JavaScript client.
        /// </summary>
        /// <exception cref="Tatum.CSharp.Bitcoin.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="btcTransactionFromUTXO"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of TransactionHash</returns>
        public async System.Threading.Tasks.Task<TransactionHash> BtcTransferBlockchainAsync(BtcTransactionFromUTXO btcTransactionFromUTXO, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            var localVarResponse = await BtcTransferBlockchainWithHttpInfoAsync(btcTransactionFromUTXO, cancellationToken).ConfigureAwait(false);
            
            var exception = ExceptionFactory?.Invoke("BtcTransferBlockchain_1", localVarResponse);
            if (exception != null) throw exception;

            return localVarResponse.Data;
        }

        /// <summary>
        /// Send BTC to Bitcoin addresses 2 credits per API call Send BTC to blockchain addresses. Bitcoin transactions are based on UTXOs. \&quot;UTXO\&quot; stands for \&quot;Unspent Transaction Output\&quot;. A UTXO is the amount of BTC/satoshis that remains at a Bitcoin address after a cryptocurrency transaction involving this address has been performed. The UTXO can then be used as input for a new cryptocurrency transaction. For more information about Bitcoin transactions and UTXO, see the Bitcoin user documentation. To check UTXOs in a transaction, see the API for getting information about a transaction output (UTXO) in a Bitcoin transaction. You can build a BTC transaction by one of the following methods: Sending BTC from blockchain addresses The assets are sent from a list of addresses. For each address, the last 100 transactions are scanned for any UTXO to be included in the transaction. For easier control over the assets to be sent, we recommend that you use this method only if you have one address to send the assets from. To use this method, use the BtcTransactionFromAddress or BtcTransactionFromAddressKMS schema of the request body. Sending BTC from UTXOs The assets are sent from a list of UTXOs. Each UTXO is included in the transaction. Use this method if you want to manually calculate the amount to send. To use this method, use the BtcTransactionFromUTXO or BtcTransactionFromUTXOKMS schema of the request body. When an UTXO is entered into a transaction, the whole UTXO amount is included and must be spent. For example, address A receives two transactions, T1 with 1 BTC and T2 with 2 BTC. A transaction that consumes the UTXOs from both T1 and T2 will have an available amount of 3 BTC to spend: 1 BTC (from T1) + 2 BTC (from T2) &#x3D; 3 BTC (to spend in total) You can send the assets to one or multiple recipients in one transaction. If you send the assets to multiple addresses, each address must have its own amount to receive. Paying the gas fee and receiving the change When the amount that the recipients should receive is lower than the amount from the UTXOs, the difference between these two amounts is by default used as the gas fee for the transaction. Because this amount may be considerable and you may not want to spend it all on the gas fee, you can explicitly specify the fee amount and the blockchain address where any extra funds remaining after covering the fee will be sent (the fee and changeAddress parameters in the request body, correspondingly). Signing a transaction When sending BTC, you are charged a fee for the transaction, and you must sign the transaction with the private key of the blockchain address from which the fee will be deducted. Providing the private key in the API is not a secure way of signing transactions, because the private key can be stolen or exposed. Your private keys should never leave your security perimeter. You should use the private keys only for testing a solution you are building on the testnet of a blockchain. For signing transactions on the mainnet, we strongly recommend that you use the Tatum Key Management System (KMS) and provide the signature ID instead of the private key in the API. Alternatively, you can use the Tatum JavaScript client.
        /// </summary>
        /// <exception cref="Tatum.CSharp.Bitcoin.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="btcTransactionFromUTXO"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (TransactionHash)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<TransactionHash>> BtcTransferBlockchainWithHttpInfoAsync(BtcTransactionFromUTXO btcTransactionFromUTXO, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            // verify the required parameter 'btcTransactionFromUTXO' is set
            if (btcTransactionFromUTXO == null)
                throw new ApiException(400, "Missing required parameter 'btcTransactionFromUTXO' when calling BitcoinApi->BtcTransferBlockchain_1");

            var localVarRequestOptions = new RequestOptions();

            var contentTypes = new string[]{
                "application/json"
            };

            // to determine the Accept header
            var accepts = new string[]{
                "application/json"
            };


            var localVarContentType = ClientUtils.SelectHeaderContentType(contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = ClientUtils.SelectHeaderAccept(accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.Data = btcTransactionFromUTXO;

            // authentication (X-API-Key) required
            if (!string.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("x-api-key")))
            {
                localVarRequestOptions.HeaderParameters.Add("x-api-key", Configuration.GetApiKeyWithPrefix("x-api-key"));
            }

            // make the HTTP request

            var localVarResponse = await AsynchronousClient.PostAsync<TransactionHash>("/v3/bitcoin/transaction", localVarRequestOptions, Configuration, cancellationToken).ConfigureAwait(false);

            return localVarResponse;
        }

        /// <summary>
        /// Send BTC to Bitcoin addresses 2 credits per API call Send BTC to blockchain addresses. Bitcoin transactions are based on UTXOs. \&quot;UTXO\&quot; stands for \&quot;Unspent Transaction Output\&quot;. A UTXO is the amount of BTC/satoshis that remains at a Bitcoin address after a cryptocurrency transaction involving this address has been performed. The UTXO can then be used as input for a new cryptocurrency transaction. For more information about Bitcoin transactions and UTXO, see the Bitcoin user documentation. To check UTXOs in a transaction, see the API for getting information about a transaction output (UTXO) in a Bitcoin transaction. You can build a BTC transaction by one of the following methods: Sending BTC from blockchain addresses The assets are sent from a list of addresses. For each address, the last 100 transactions are scanned for any UTXO to be included in the transaction. For easier control over the assets to be sent, we recommend that you use this method only if you have one address to send the assets from. To use this method, use the BtcTransactionFromAddress or BtcTransactionFromAddressKMS schema of the request body. Sending BTC from UTXOs The assets are sent from a list of UTXOs. Each UTXO is included in the transaction. Use this method if you want to manually calculate the amount to send. To use this method, use the BtcTransactionFromUTXO or BtcTransactionFromUTXOKMS schema of the request body. When an UTXO is entered into a transaction, the whole UTXO amount is included and must be spent. For example, address A receives two transactions, T1 with 1 BTC and T2 with 2 BTC. A transaction that consumes the UTXOs from both T1 and T2 will have an available amount of 3 BTC to spend: 1 BTC (from T1) + 2 BTC (from T2) &#x3D; 3 BTC (to spend in total) You can send the assets to one or multiple recipients in one transaction. If you send the assets to multiple addresses, each address must have its own amount to receive. Paying the gas fee and receiving the change When the amount that the recipients should receive is lower than the amount from the UTXOs, the difference between these two amounts is by default used as the gas fee for the transaction. Because this amount may be considerable and you may not want to spend it all on the gas fee, you can explicitly specify the fee amount and the blockchain address where any extra funds remaining after covering the fee will be sent (the fee and changeAddress parameters in the request body, correspondingly). Signing a transaction When sending BTC, you are charged a fee for the transaction, and you must sign the transaction with the private key of the blockchain address from which the fee will be deducted. Providing the private key in the API is not a secure way of signing transactions, because the private key can be stolen or exposed. Your private keys should never leave your security perimeter. You should use the private keys only for testing a solution you are building on the testnet of a blockchain. For signing transactions on the mainnet, we strongly recommend that you use the Tatum Key Management System (KMS) and provide the signature ID instead of the private key in the API. Alternatively, you can use the Tatum JavaScript client.
        /// </summary>
        /// <exception cref="Tatum.CSharp.Bitcoin.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="btcTransactionFromUTXOKMS"></param>
        /// <returns>SignatureId</returns>
        public SignatureId BtcTransferBlockchain(BtcTransactionFromUTXOKMS btcTransactionFromUTXOKMS)
        {
            var localVarResponse = BtcTransferBlockchainWithHttpInfo(btcTransactionFromUTXOKMS);

            var exception = ExceptionFactory?.Invoke("BtcTransferBlockchain_2", localVarResponse);
            if (exception != null) throw exception;

            return localVarResponse.Data;
        }

        /// <summary>
        /// Send BTC to Bitcoin addresses 2 credits per API call Send BTC to blockchain addresses. Bitcoin transactions are based on UTXOs. \&quot;UTXO\&quot; stands for \&quot;Unspent Transaction Output\&quot;. A UTXO is the amount of BTC/satoshis that remains at a Bitcoin address after a cryptocurrency transaction involving this address has been performed. The UTXO can then be used as input for a new cryptocurrency transaction. For more information about Bitcoin transactions and UTXO, see the Bitcoin user documentation. To check UTXOs in a transaction, see the API for getting information about a transaction output (UTXO) in a Bitcoin transaction. You can build a BTC transaction by one of the following methods: Sending BTC from blockchain addresses The assets are sent from a list of addresses. For each address, the last 100 transactions are scanned for any UTXO to be included in the transaction. For easier control over the assets to be sent, we recommend that you use this method only if you have one address to send the assets from. To use this method, use the BtcTransactionFromAddress or BtcTransactionFromAddressKMS schema of the request body. Sending BTC from UTXOs The assets are sent from a list of UTXOs. Each UTXO is included in the transaction. Use this method if you want to manually calculate the amount to send. To use this method, use the BtcTransactionFromUTXO or BtcTransactionFromUTXOKMS schema of the request body. When an UTXO is entered into a transaction, the whole UTXO amount is included and must be spent. For example, address A receives two transactions, T1 with 1 BTC and T2 with 2 BTC. A transaction that consumes the UTXOs from both T1 and T2 will have an available amount of 3 BTC to spend: 1 BTC (from T1) + 2 BTC (from T2) &#x3D; 3 BTC (to spend in total) You can send the assets to one or multiple recipients in one transaction. If you send the assets to multiple addresses, each address must have its own amount to receive. Paying the gas fee and receiving the change When the amount that the recipients should receive is lower than the amount from the UTXOs, the difference between these two amounts is by default used as the gas fee for the transaction. Because this amount may be considerable and you may not want to spend it all on the gas fee, you can explicitly specify the fee amount and the blockchain address where any extra funds remaining after covering the fee will be sent (the fee and changeAddress parameters in the request body, correspondingly). Signing a transaction When sending BTC, you are charged a fee for the transaction, and you must sign the transaction with the private key of the blockchain address from which the fee will be deducted. Providing the private key in the API is not a secure way of signing transactions, because the private key can be stolen or exposed. Your private keys should never leave your security perimeter. You should use the private keys only for testing a solution you are building on the testnet of a blockchain. For signing transactions on the mainnet, we strongly recommend that you use the Tatum Key Management System (KMS) and provide the signature ID instead of the private key in the API. Alternatively, you can use the Tatum JavaScript client.
        /// </summary>
        /// <exception cref="Tatum.CSharp.Bitcoin.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="btcTransactionFromUTXOKMS"></param>
        /// <returns>ApiResponse of SignatureId</returns>
        public ApiResponse<SignatureId> BtcTransferBlockchainWithHttpInfo(BtcTransactionFromUTXOKMS btcTransactionFromUTXOKMS)
        {
            // verify the required parameter 'btcTransactionFromUTXOKMS' is set
            if (btcTransactionFromUTXOKMS == null)
                throw new ApiException(400, "Missing required parameter 'btcTransactionFromUTXOKMS' when calling BitcoinApi->BtcTransferBlockchain_2");

            var localVarRequestOptions = new RequestOptions();

            var contentTypes = new string[]{
                "application/json"
            };

            // to determine the Accept header
            var accepts = new string[]{
                "application/json"
            };

            var localVarContentType = ClientUtils.SelectHeaderContentType(contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = ClientUtils.SelectHeaderAccept(accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.Data = btcTransactionFromUTXOKMS;

            // authentication (X-API-Key) required
            if (!string.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("x-api-key")))
            {
                localVarRequestOptions.HeaderParameters.Add("x-api-key", Configuration.GetApiKeyWithPrefix("x-api-key"));
            }

            // make the HTTP request
            var localVarResponse = Client.Post<SignatureId>("/v3/bitcoin/transaction", localVarRequestOptions, Configuration);

            return localVarResponse;
        }

        /// <summary>
        /// Send BTC to Bitcoin addresses 2 credits per API call Send BTC to blockchain addresses. Bitcoin transactions are based on UTXOs. \&quot;UTXO\&quot; stands for \&quot;Unspent Transaction Output\&quot;. A UTXO is the amount of BTC/satoshis that remains at a Bitcoin address after a cryptocurrency transaction involving this address has been performed. The UTXO can then be used as input for a new cryptocurrency transaction. For more information about Bitcoin transactions and UTXO, see the Bitcoin user documentation. To check UTXOs in a transaction, see the API for getting information about a transaction output (UTXO) in a Bitcoin transaction. You can build a BTC transaction by one of the following methods: Sending BTC from blockchain addresses The assets are sent from a list of addresses. For each address, the last 100 transactions are scanned for any UTXO to be included in the transaction. For easier control over the assets to be sent, we recommend that you use this method only if you have one address to send the assets from. To use this method, use the BtcTransactionFromAddress or BtcTransactionFromAddressKMS schema of the request body. Sending BTC from UTXOs The assets are sent from a list of UTXOs. Each UTXO is included in the transaction. Use this method if you want to manually calculate the amount to send. To use this method, use the BtcTransactionFromUTXO or BtcTransactionFromUTXOKMS schema of the request body. When an UTXO is entered into a transaction, the whole UTXO amount is included and must be spent. For example, address A receives two transactions, T1 with 1 BTC and T2 with 2 BTC. A transaction that consumes the UTXOs from both T1 and T2 will have an available amount of 3 BTC to spend: 1 BTC (from T1) + 2 BTC (from T2) &#x3D; 3 BTC (to spend in total) You can send the assets to one or multiple recipients in one transaction. If you send the assets to multiple addresses, each address must have its own amount to receive. Paying the gas fee and receiving the change When the amount that the recipients should receive is lower than the amount from the UTXOs, the difference between these two amounts is by default used as the gas fee for the transaction. Because this amount may be considerable and you may not want to spend it all on the gas fee, you can explicitly specify the fee amount and the blockchain address where any extra funds remaining after covering the fee will be sent (the fee and changeAddress parameters in the request body, correspondingly). Signing a transaction When sending BTC, you are charged a fee for the transaction, and you must sign the transaction with the private key of the blockchain address from which the fee will be deducted. Providing the private key in the API is not a secure way of signing transactions, because the private key can be stolen or exposed. Your private keys should never leave your security perimeter. You should use the private keys only for testing a solution you are building on the testnet of a blockchain. For signing transactions on the mainnet, we strongly recommend that you use the Tatum Key Management System (KMS) and provide the signature ID instead of the private key in the API. Alternatively, you can use the Tatum JavaScript client.
        /// </summary>
        /// <exception cref="Tatum.CSharp.Bitcoin.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="btcTransactionFromUTXOKMS"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of SignatureId</returns>
        public async System.Threading.Tasks.Task<SignatureId> BtcTransferBlockchainAsync(BtcTransactionFromUTXOKMS btcTransactionFromUTXOKMS, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            var localVarResponse = await BtcTransferBlockchainWithHttpInfoAsync(btcTransactionFromUTXOKMS, cancellationToken).ConfigureAwait(false);
            
            var exception = ExceptionFactory?.Invoke("BtcTransferBlockchain_2", localVarResponse);
            if (exception != null) throw exception;

            return localVarResponse.Data;
        }

        /// <summary>
        /// Send BTC to Bitcoin addresses 2 credits per API call Send BTC to blockchain addresses. Bitcoin transactions are based on UTXOs. \&quot;UTXO\&quot; stands for \&quot;Unspent Transaction Output\&quot;. A UTXO is the amount of BTC/satoshis that remains at a Bitcoin address after a cryptocurrency transaction involving this address has been performed. The UTXO can then be used as input for a new cryptocurrency transaction. For more information about Bitcoin transactions and UTXO, see the Bitcoin user documentation. To check UTXOs in a transaction, see the API for getting information about a transaction output (UTXO) in a Bitcoin transaction. You can build a BTC transaction by one of the following methods: Sending BTC from blockchain addresses The assets are sent from a list of addresses. For each address, the last 100 transactions are scanned for any UTXO to be included in the transaction. For easier control over the assets to be sent, we recommend that you use this method only if you have one address to send the assets from. To use this method, use the BtcTransactionFromAddress or BtcTransactionFromAddressKMS schema of the request body. Sending BTC from UTXOs The assets are sent from a list of UTXOs. Each UTXO is included in the transaction. Use this method if you want to manually calculate the amount to send. To use this method, use the BtcTransactionFromUTXO or BtcTransactionFromUTXOKMS schema of the request body. When an UTXO is entered into a transaction, the whole UTXO amount is included and must be spent. For example, address A receives two transactions, T1 with 1 BTC and T2 with 2 BTC. A transaction that consumes the UTXOs from both T1 and T2 will have an available amount of 3 BTC to spend: 1 BTC (from T1) + 2 BTC (from T2) &#x3D; 3 BTC (to spend in total) You can send the assets to one or multiple recipients in one transaction. If you send the assets to multiple addresses, each address must have its own amount to receive. Paying the gas fee and receiving the change When the amount that the recipients should receive is lower than the amount from the UTXOs, the difference between these two amounts is by default used as the gas fee for the transaction. Because this amount may be considerable and you may not want to spend it all on the gas fee, you can explicitly specify the fee amount and the blockchain address where any extra funds remaining after covering the fee will be sent (the fee and changeAddress parameters in the request body, correspondingly). Signing a transaction When sending BTC, you are charged a fee for the transaction, and you must sign the transaction with the private key of the blockchain address from which the fee will be deducted. Providing the private key in the API is not a secure way of signing transactions, because the private key can be stolen or exposed. Your private keys should never leave your security perimeter. You should use the private keys only for testing a solution you are building on the testnet of a blockchain. For signing transactions on the mainnet, we strongly recommend that you use the Tatum Key Management System (KMS) and provide the signature ID instead of the private key in the API. Alternatively, you can use the Tatum JavaScript client.
        /// </summary>
        /// <exception cref="Tatum.CSharp.Bitcoin.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="btcTransactionFromUTXOKMS"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (SignatureId)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<SignatureId>> BtcTransferBlockchainWithHttpInfoAsync(BtcTransactionFromUTXOKMS btcTransactionFromUTXOKMS, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            // verify the required parameter 'btcTransactionFromUTXOKMS' is set
            if (btcTransactionFromUTXOKMS == null)
                throw new ApiException(400, "Missing required parameter 'btcTransactionFromUTXOKMS' when calling BitcoinApi->BtcTransferBlockchain_2");

            var localVarRequestOptions = new RequestOptions();

            var contentTypes = new string[]{
                "application/json"
            };

            // to determine the Accept header
            var accepts = new string[]{
                "application/json"
            };


            var localVarContentType = ClientUtils.SelectHeaderContentType(contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = ClientUtils.SelectHeaderAccept(accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.Data = btcTransactionFromUTXOKMS;

            // authentication (X-API-Key) required
            if (!string.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("x-api-key")))
            {
                localVarRequestOptions.HeaderParameters.Add("x-api-key", Configuration.GetApiKeyWithPrefix("x-api-key"));
            }

            // make the HTTP request

            var localVarResponse = await AsynchronousClient.PostAsync<SignatureId>("/v3/bitcoin/transaction", localVarRequestOptions, Configuration, cancellationToken).ConfigureAwait(false);

            return localVarResponse;
        }

    }
}
