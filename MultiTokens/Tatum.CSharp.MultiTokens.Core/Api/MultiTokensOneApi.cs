/*
 * Tatum API Reference
 *
 * # Welcome to the Tatum API Reference!  ## What is Tatum?  Tatum offers a flexible framework to build, run, and scale blockchain apps fast. To learn more about the Tatum blockchain development framework, visit [our website](https://tatum.io/framework).  The Tatum API features powerful endpoints that simplify a complex blockchain into single API requests. Code for all supported blockchains using unified API calls.  ## Supported blockchains  Tatum supports multiple blockchains and various blockchain features.  Because not all blockchains function identically, Tatum supports a different set of features on each blockchain.  To see all the blockchains that Tatum supports, please refer to [this article](https://docs.tatum.io/introduction/supported-blockchains).  ## Need help?  To chat with other developers, get help from the Support team, and engage with the thriving Tatum community, join  our [Discord server](https://discord.com/invite/tatum). For more information about how to work with Tatum, review the [online documentation](https://docs.tatum.io/).  # Authentication  When using the Tatum API, you authenticate yourself with an **API key**. <SecurityDefinitions /> 
 *
 * The version of the OpenAPI document: 3.17.2
 * Generated by: https://github.com/openapitools/openapi-generator.git
 */


using System;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.Linq;
using System.Net;
using System.Net.Http;
using System.Net.Mime;
using Tatum.CSharp.MultiTokens.Core.Client;
using Tatum.CSharp.MultiTokens.Core.Model;

namespace Tatum.CSharp.MultiTokens.Core.Api
{

    /// <summary>
    /// Represents a collection of functions to interact with the API endpoints
    /// </summary>
    public interface IMultiTokensOneApiSync : IApiAccessor
    {
        #region Synchronous Operations
        /// <summary>
        /// Add a Multi Token minter
        /// </summary>
        /// <remarks>
        /// 2 credits per API call Add Multi Token minter. This API is supported for the following blockchains: BNB Smart Chain Celo Ethereum Harmony Klaytn KuCoin Community Chain Polygon Signing a transaction When adding a Multi Token minter, you are charged a fee for the transaction, and you must sign the transaction with the private key of the blockchain address from which the fee will be deducted. Providing the private key in the API is not a secure way of signing transactions, because the private key can be stolen or exposed. Your private keys should never leave your security perimeter. You should use the private keys only for testing a solution you are building on the testnet of a blockchain. For signing transactions on the mainnet, we strongly recommend that you use the Tatum Key Management System (KMS) and provide the signature ID instead of the private key in the API. Alternatively, you can use the Tatum JavaScript client.
        /// </remarks>
        /// <exception cref="Tatum.CSharp.MultiTokens.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="addMultiTokenMinter"></param>
        /// <param name="xTestnetType">Type of testnet. Defaults to Sepolia. Valid only for ETH invocations. (optional, default to ethereum-sepolia)</param>
        /// <returns>TransactionHash</returns>
        TransactionHash AddMultiTokenMinter(AddMultiTokenMinter addMultiTokenMinter, string xTestnetType = default(string));
        /// <summary>
        /// Add a Multi Token minter
        /// </summary>
        /// <remarks>
        /// 2 credits per API call Add Multi Token minter. This API is supported for the following blockchains: BNB Smart Chain Celo Ethereum Harmony Klaytn KuCoin Community Chain Polygon Signing a transaction When adding a Multi Token minter, you are charged a fee for the transaction, and you must sign the transaction with the private key of the blockchain address from which the fee will be deducted. Providing the private key in the API is not a secure way of signing transactions, because the private key can be stolen or exposed. Your private keys should never leave your security perimeter. You should use the private keys only for testing a solution you are building on the testnet of a blockchain. For signing transactions on the mainnet, we strongly recommend that you use the Tatum Key Management System (KMS) and provide the signature ID instead of the private key in the API. Alternatively, you can use the Tatum JavaScript client.
        /// </remarks>
        /// <exception cref="Tatum.CSharp.MultiTokens.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="addMultiTokenMinterKMS"></param>
        /// <param name="xTestnetType">Type of testnet. Defaults to Sepolia. Valid only for ETH invocations. (optional, default to ethereum-sepolia)</param>
        /// <returns>SignatureId</returns>
        SignatureId AddMultiTokenMinter(AddMultiTokenMinterKMS addMultiTokenMinterKMS, string xTestnetType = default(string));
        /// <summary>
        /// Burn a Multi Token
        /// </summary>
        /// <remarks>
        /// 2 credits per API call Burn a fixed amount of Multi Tokens by id. This method destroys Multi Tokens from smart contract defined in contractAddress. This API is supported for the following blockchains: BNB Smart Chain Celo Ethereum Harmony Klaytn KuCoin Community Chain Polygon Signing a transaction When burning a Multi Token, you are charged a fee for the transaction, and you must sign the transaction with the private key of the blockchain address from which the fee will be deducted. Providing the private key in the API is not a secure way of signing transactions, because the private key can be stolen or exposed. Your private keys should never leave your security perimeter. You should use the private keys only for testing a solution you are building on the testnet of a blockchain. For signing transactions on the mainnet, we strongly recommend that you use the Tatum Key Management System (KMS) and provide the signature ID instead of the private key in the API. Alternatively, you can use the Tatum JavaScript client.
        /// </remarks>
        /// <exception cref="Tatum.CSharp.MultiTokens.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="burnMultiToken"></param>
        /// <param name="xTestnetType">Type of testnet. Defaults to Sepolia. Valid only for ETH invocations. (optional, default to ethereum-sepolia)</param>
        /// <returns>TransactionHash</returns>
        TransactionHash BurnMultiToken(BurnMultiToken burnMultiToken, string xTestnetType = default(string));
        /// <summary>
        /// Burn multiple Multi Tokens
        /// </summary>
        /// <remarks>
        /// 2 credits per API call Burn multiple Multi Token Tokens by id assigned to same address in one transaction. This method destroys any Multi Tokens token from smart contract defined in contractAddress. This API is supported for the following blockchains: BNB Smart Chain Celo Ethereum Harmony Klaytn KuCoin Community Chain Polygon Signing a transaction When burning multiple Multi Tokens, you are charged a fee for the transaction, and you must sign the transaction with the private key of the blockchain address from which the fee will be deducted. Providing the private key in the API is not a secure way of signing transactions, because the private key can be stolen or exposed. Your private keys should never leave your security perimeter. You should use the private keys only for testing a solution you are building on the testnet of a blockchain. For signing transactions on the mainnet, we strongly recommend that you use the Tatum Key Management System (KMS) and provide the signature ID instead of the private key in the API. Alternatively, you can use the Tatum JavaScript client.
        /// </remarks>
        /// <exception cref="Tatum.CSharp.MultiTokens.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="burnMultiTokenBatch"></param>
        /// <param name="xTestnetType">Type of testnet. Defaults to Sepolia. Valid only for ETH invocations. (optional, default to ethereum-sepolia)</param>
        /// <returns>TransactionHash</returns>
        TransactionHash BurnMultiTokenBatch(BurnMultiTokenBatch burnMultiTokenBatch, string xTestnetType = default(string));
        /// <summary>
        /// Burn multiple Multi Tokens
        /// </summary>
        /// <remarks>
        /// 2 credits per API call Burn multiple Multi Token Tokens by id assigned to same address in one transaction. This method destroys any Multi Tokens token from smart contract defined in contractAddress. This API is supported for the following blockchains: BNB Smart Chain Celo Ethereum Harmony Klaytn KuCoin Community Chain Polygon Signing a transaction When burning multiple Multi Tokens, you are charged a fee for the transaction, and you must sign the transaction with the private key of the blockchain address from which the fee will be deducted. Providing the private key in the API is not a secure way of signing transactions, because the private key can be stolen or exposed. Your private keys should never leave your security perimeter. You should use the private keys only for testing a solution you are building on the testnet of a blockchain. For signing transactions on the mainnet, we strongly recommend that you use the Tatum Key Management System (KMS) and provide the signature ID instead of the private key in the API. Alternatively, you can use the Tatum JavaScript client.
        /// </remarks>
        /// <exception cref="Tatum.CSharp.MultiTokens.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="burnMultiTokenBatchKMS"></param>
        /// <param name="xTestnetType">Type of testnet. Defaults to Sepolia. Valid only for ETH invocations. (optional, default to ethereum-sepolia)</param>
        /// <returns>SignatureId</returns>
        SignatureId BurnMultiTokenBatch(BurnMultiTokenBatchKMS burnMultiTokenBatchKMS, string xTestnetType = default(string));
        /// <summary>
        /// Burn a Multi Token
        /// </summary>
        /// <remarks>
        /// 2 credits per API call Burn a fixed amount of Multi Tokens by id. This method destroys Multi Tokens from smart contract defined in contractAddress. This API is supported for the following blockchains: BNB Smart Chain Celo Ethereum Harmony Klaytn KuCoin Community Chain Polygon Signing a transaction When burning a Multi Token, you are charged a fee for the transaction, and you must sign the transaction with the private key of the blockchain address from which the fee will be deducted. Providing the private key in the API is not a secure way of signing transactions, because the private key can be stolen or exposed. Your private keys should never leave your security perimeter. You should use the private keys only for testing a solution you are building on the testnet of a blockchain. For signing transactions on the mainnet, we strongly recommend that you use the Tatum Key Management System (KMS) and provide the signature ID instead of the private key in the API. Alternatively, you can use the Tatum JavaScript client.
        /// </remarks>
        /// <exception cref="Tatum.CSharp.MultiTokens.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="burnMultiTokenKMS"></param>
        /// <param name="xTestnetType">Type of testnet. Defaults to Sepolia. Valid only for ETH invocations. (optional, default to ethereum-sepolia)</param>
        /// <returns>SignatureId</returns>
        SignatureId BurnMultiToken(BurnMultiTokenKMS burnMultiTokenKMS, string xTestnetType = default(string));
        /// <summary>
        /// Deploy a Multi Token smart contract
        /// </summary>
        /// <remarks>
        /// 2 credits per API call Deploy Multi Token Smart Contract. This method creates new ERC1155 Smart Contract (Multi Tokens) on the blockchain. Smart contract is standardized and audited. It is possible to mint, burn and transfer tokens. It is also possible to mint multiple tokens at once. This API is supported for the following blockchains: BNB Smart Chain Celo Ethereum Harmony Klaytn KuCoin Community Chain Polygon Signing a transaction When deploying a Multi Token smart contract, you are charged a fee for the transaction, and you must sign the transaction with the private key of the blockchain address from which the fee will be deducted. Providing the private key in the API is not a secure way of signing transactions, because the private key can be stolen or exposed. Your private keys should never leave your security perimeter. You should use the private keys only for testing a solution you are building on the testnet of a blockchain. For signing transactions on the mainnet, we strongly recommend that you use the Tatum Key Management System (KMS) and provide the signature ID instead of the private key in the API. Alternatively, you can use the Tatum JavaScript client.
        /// </remarks>
        /// <exception cref="Tatum.CSharp.MultiTokens.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="deployMultiToken"></param>
        /// <param name="xTestnetType">Type of testnet. Defaults to Sepolia. Valid only for ETH invocations. (optional, default to ethereum-sepolia)</param>
        /// <returns>TransactionHash</returns>
        TransactionHash DeployMultiToken(DeployMultiToken deployMultiToken, string xTestnetType = default(string));
        /// <summary>
        /// Deploy a Multi Token smart contract
        /// </summary>
        /// <remarks>
        /// 2 credits per API call Deploy Multi Token Smart Contract. This method creates new ERC1155 Smart Contract (Multi Tokens) on the blockchain. Smart contract is standardized and audited. It is possible to mint, burn and transfer tokens. It is also possible to mint multiple tokens at once. This API is supported for the following blockchains: BNB Smart Chain Celo Ethereum Harmony Klaytn KuCoin Community Chain Polygon Signing a transaction When deploying a Multi Token smart contract, you are charged a fee for the transaction, and you must sign the transaction with the private key of the blockchain address from which the fee will be deducted. Providing the private key in the API is not a secure way of signing transactions, because the private key can be stolen or exposed. Your private keys should never leave your security perimeter. You should use the private keys only for testing a solution you are building on the testnet of a blockchain. For signing transactions on the mainnet, we strongly recommend that you use the Tatum Key Management System (KMS) and provide the signature ID instead of the private key in the API. Alternatively, you can use the Tatum JavaScript client.
        /// </remarks>
        /// <exception cref="Tatum.CSharp.MultiTokens.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="deployMultiTokenKMS"></param>
        /// <param name="xTestnetType">Type of testnet. Defaults to Sepolia. Valid only for ETH invocations. (optional, default to ethereum-sepolia)</param>
        /// <returns>SignatureId</returns>
        SignatureId DeployMultiToken(DeployMultiTokenKMS deployMultiTokenKMS, string xTestnetType = default(string));
        /// <summary>
        /// Mint a Multi Token
        /// </summary>
        /// <remarks>
        /// 2 credits per API call Mint a fixed amount of Multi Token and transfer it to destination account. Create and transfer any Multi Token token from smart contract defined in contractAddress. It is possible to add Metadata to the created token with a more detailed information about instead. This API is supported for the following blockchains: BNB Smart Chain Celo Ethereum Harmony Klaytn KuCoin Community Chain Polygon Signing a transaction When minting a Multi Token, you are charged a fee for the transaction, and you must sign the transaction with the private key of the blockchain address from which the fee will be deducted. Providing the private key in the API is not a secure way of signing transactions, because the private key can be stolen or exposed. Your private keys should never leave your security perimeter. You should use the private keys only for testing a solution you are building on the testnet of a blockchain. For signing transactions on the mainnet, we strongly recommend that you use the Tatum Key Management System (KMS) and provide the signature ID instead of the private key in the API. Alternatively, you can use the Tatum JavaScript client.
        /// </remarks>
        /// <exception cref="Tatum.CSharp.MultiTokens.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="mintMultiToken"></param>
        /// <param name="xTestnetType">Type of testnet. Defaults to Sepolia. Valid only for ETH invocations. (optional, default to ethereum-sepolia)</param>
        /// <returns>TransactionHash</returns>
        TransactionHash MintMultiToken(MintMultiToken mintMultiToken, string xTestnetType = default(string));
        /// <summary>
        /// Mint multiple Multi Tokens
        /// </summary>
        /// <remarks>
        /// 2 credits per API call Create a fixed amount of multiple Multi Tokens Tokens and transfer them to destination account in one transaction. Create and transfer Multi Tokens tokens from smart contract defined in contractAddress. This API is supported for the following blockchains: BNB Smart Chain Celo Ethereum Harmony Klaytn KuCoin Community Chain Polygon Signing a transaction When minting multiple Multi Tokens, you are charged a fee for the transaction, and you must sign the transaction with the private key of the blockchain address from which the fee will be deducted. Providing the private key in the API is not a secure way of signing transactions, because the private key can be stolen or exposed. Your private keys should never leave your security perimeter. You should use the private keys only for testing a solution you are building on the testnet of a blockchain. For signing transactions on the mainnet, we strongly recommend that you use the Tatum Key Management System (KMS) and provide the signature ID instead of the private key in the API. Alternatively, you can use the Tatum JavaScript client.
        /// </remarks>
        /// <exception cref="Tatum.CSharp.MultiTokens.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="mintMultiTokenBatch"></param>
        /// <param name="xTestnetType">Type of testnet. Defaults to Sepolia. Valid only for ETH invocations. (optional, default to ethereum-sepolia)</param>
        /// <returns>TransactionHash</returns>
        TransactionHash MintMultiTokenBatch(MintMultiTokenBatch mintMultiTokenBatch, string xTestnetType = default(string));
        /// <summary>
        /// Mint multiple Multi Tokens
        /// </summary>
        /// <remarks>
        /// 2 credits per API call Create a fixed amount of multiple Multi Tokens Tokens and transfer them to destination account in one transaction. Create and transfer Multi Tokens tokens from smart contract defined in contractAddress. This API is supported for the following blockchains: BNB Smart Chain Celo Ethereum Harmony Klaytn KuCoin Community Chain Polygon Signing a transaction When minting multiple Multi Tokens, you are charged a fee for the transaction, and you must sign the transaction with the private key of the blockchain address from which the fee will be deducted. Providing the private key in the API is not a secure way of signing transactions, because the private key can be stolen or exposed. Your private keys should never leave your security perimeter. You should use the private keys only for testing a solution you are building on the testnet of a blockchain. For signing transactions on the mainnet, we strongly recommend that you use the Tatum Key Management System (KMS) and provide the signature ID instead of the private key in the API. Alternatively, you can use the Tatum JavaScript client.
        /// </remarks>
        /// <exception cref="Tatum.CSharp.MultiTokens.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="mintMultiTokenBatchKMS"></param>
        /// <param name="xTestnetType">Type of testnet. Defaults to Sepolia. Valid only for ETH invocations. (optional, default to ethereum-sepolia)</param>
        /// <returns>SignatureId</returns>
        SignatureId MintMultiTokenBatch(MintMultiTokenBatchKMS mintMultiTokenBatchKMS, string xTestnetType = default(string));
        /// <summary>
        /// Mint a Multi Token
        /// </summary>
        /// <remarks>
        /// 2 credits per API call Mint a fixed amount of Multi Token and transfer it to destination account. Create and transfer any Multi Token token from smart contract defined in contractAddress. It is possible to add Metadata to the created token with a more detailed information about instead. This API is supported for the following blockchains: BNB Smart Chain Celo Ethereum Harmony Klaytn KuCoin Community Chain Polygon Signing a transaction When minting a Multi Token, you are charged a fee for the transaction, and you must sign the transaction with the private key of the blockchain address from which the fee will be deducted. Providing the private key in the API is not a secure way of signing transactions, because the private key can be stolen or exposed. Your private keys should never leave your security perimeter. You should use the private keys only for testing a solution you are building on the testnet of a blockchain. For signing transactions on the mainnet, we strongly recommend that you use the Tatum Key Management System (KMS) and provide the signature ID instead of the private key in the API. Alternatively, you can use the Tatum JavaScript client.
        /// </remarks>
        /// <exception cref="Tatum.CSharp.MultiTokens.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="mintMultiTokenKMS"></param>
        /// <param name="xTestnetType">Type of testnet. Defaults to Sepolia. Valid only for ETH invocations. (optional, default to ethereum-sepolia)</param>
        /// <returns>SignatureId</returns>
        SignatureId MintMultiToken(MintMultiTokenKMS mintMultiTokenKMS, string xTestnetType = default(string));
        /// <summary>
        /// Get the amount of a specific MultiToken that a blockchain address holds
        /// </summary>
        /// <remarks>
        /// 1 credit per API call Get the amount of a specific Multi Token (minted on the smart contract specified by the contractAddress path parameter in the request endpoint URL) that a blockchain address holds. This API is supported for the following blockchains: BNB Smart Chain Celo Ethereum Harmony Klaytn KuCoin Community Chain Polygon
        /// </remarks>
        /// <exception cref="Tatum.CSharp.MultiTokens.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="address">The blockchain address that you want to get the token balance of</param>
        /// <param name="contractAddress">The address of the Multi Token smart contract</param>
        /// <param name="tokenId">The ID of the Multi Token</param>
        /// <param name="xTestnetType">Type of testnet. Defaults to Sepolia. Valid only for ETH invocations. (optional, default to ethereum-sepolia)</param>
        /// <returns>MultiTokenBalanceValue</returns>
        MultiTokenBalanceValue MultiTokenGetBalance(string address, string contractAddress, string tokenId, string xTestnetType = default(string));
        /// <summary>
        /// Get the amount of one or multiple Multi Tokens for multiple blockchain addresses
        /// </summary>
        /// <remarks>
        /// 1 credit per API call For multiple blockchain addresses, get the amount of one or multiple Multi Tokens (minted on the smart contract specified by the contractAddress path parameter in the request endpoint URL) that those addresses hold. This API is supported for the following blockchains: BNB Smart Chain Celo Ethereum Harmony Klaytn KuCoin Community Chain Polygon
        /// </remarks>
        /// <exception cref="Tatum.CSharp.MultiTokens.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="contractAddress">The address of the Multi Token smart contract</param>
        /// <param name="tokenId">Comma-separated IDs of the Multi Tokens to get the amounts for</param>
        /// <param name="address">Comma-separated blockchain addresses to get the token balance for</param>
        /// <param name="xTestnetType">Type of testnet. Defaults to Sepolia. Valid only for ETH invocations. (optional, default to ethereum-sepolia)</param>
        /// <returns>MultiTokenBalanceBatch</returns>
        MultiTokenBalanceBatch MultiTokenGetBalanceBatch(string contractAddress, string tokenId, string address, string xTestnetType = default(string));
        /// <summary>
        /// Get Multi Token metadata
        /// </summary>
        /// <remarks>
        /// 1 credit per API call Get Multi Token metadata. This API is supported for the following blockchains: BNB Smart Chain Celo Ethereum Harmony Klaytn KuCoin Community Chain Polygon
        /// </remarks>
        /// <exception cref="Tatum.CSharp.MultiTokens.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="token">Token ID</param>
        /// <param name="contractAddress">Multi Token contract address</param>
        /// <param name="xTestnetType">Type of testnet. Defaults to Sepolia. Valid only for ETH invocations. (optional, default to ethereum-sepolia)</param>
        /// <returns>MultiTokenMetadata</returns>
        MultiTokenMetadata MultiTokenGetMetadata(string token, string contractAddress, string xTestnetType = default(string));
        /// <summary>
        /// Get a Multi Token transaction by its hash
        /// </summary>
        /// <remarks>
        /// 1 credit per API call Get Multi Token transaction by transaction hash. This API is supported for the following blockchains: BNB Smart Chain Celo Ethereum Harmony Klaytn KuCoin Community Chain Polygon
        /// </remarks>
        /// <exception cref="Tatum.CSharp.MultiTokens.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="hash">Transaction hash</param>
        /// <param name="xTestnetType">Type of testnet. Defaults to Sepolia. Valid only for ETH invocations. (optional, default to ethereum-sepolia)</param>
        /// <returns>EthTx</returns>
        EthTx MultiTokenGetTransaction(string hash, string xTestnetType = default(string));
        /// <summary>
        /// Transfer a Multi Token
        /// </summary>
        /// <remarks>
        /// 2 credits per API call Transfer a certain amount of Multi Token from account to another account. Transfer Multi Tokens token from smart contract defined in contractAddress. Only 1 specific token with specified tokenId and value can be transferred. This method invokes ERC1155 method safeTransfer() to transfer the token in case of ETH, Celo and blockchains. This API is supported for the following blockchains: BNB Smart Chain Celo Ethereum Harmony Klaytn KuCoin Community Chain Polygon Signing a transaction When transferring a Multi Token, you are charged a fee for the transaction, and you must sign the transaction with the private key of the blockchain address from which the fee will be deducted. Providing the private key in the API is not a secure way of signing transactions, because the private key can be stolen or exposed. Your private keys should never leave your security perimeter. You should use the private keys only for testing a solution you are building on the testnet of a blockchain. For signing transactions on the mainnet, we strongly recommend that you use the Tatum Key Management System (KMS) and provide the signature ID instead of the private key in the API. Alternatively, you can use the Tatum JavaScript client.
        /// </remarks>
        /// <exception cref="Tatum.CSharp.MultiTokens.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="transferMultiToken"></param>
        /// <param name="xTestnetType">Type of testnet. Defaults to Sepolia. Valid only for ETH invocations. (optional, default to ethereum-sepolia)</param>
        /// <returns>TransactionHash</returns>
        TransactionHash TransferMultiToken(TransferMultiToken transferMultiToken, string xTestnetType = default(string));
        /// <summary>
        /// Transfer multiple Multi Tokens
        /// </summary>
        /// <remarks>
        /// 2 credits per API call Transfer Multi Token Batch from account to various other accounts in one transaction. Transfer multiple Multi Tokens token from smart contract defined in contractAddress. Multiple token with specified tokenIds and values can be transferred. This method invokes ERC1155 method safeTransfer() to transfer the token in case of ETH, Celo and BSC. This API is supported for the following blockchains: BNB Smart Chain Celo Ethereum Harmony Klaytn KuCoin Community Chain Polygon Signing a transaction When transferring multiple Multi Tokens, you are charged a fee for the transaction, and you must sign the transaction with the private key of the blockchain address from which the fee will be deducted. Providing the private key in the API is not a secure way of signing transactions, because the private key can be stolen or exposed. Your private keys should never leave your security perimeter. You should use the private keys only for testing a solution you are building on the testnet of a blockchain. For signing transactions on the mainnet, we strongly recommend that you use the Tatum Key Management System (KMS) and provide the signature ID instead of the private key in the API. Alternatively, you can use the Tatum JavaScript client.
        /// </remarks>
        /// <exception cref="Tatum.CSharp.MultiTokens.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="transferMultiTokenBatch"></param>
        /// <param name="xTestnetType">Type of testnet. Defaults to Sepolia. Valid only for ETH invocations. (optional, default to ethereum-sepolia)</param>
        /// <returns>TransactionHash</returns>
        TransactionHash TransferMultiTokenBatch(TransferMultiTokenBatch transferMultiTokenBatch, string xTestnetType = default(string));
        /// <summary>
        /// Transfer multiple Multi Tokens
        /// </summary>
        /// <remarks>
        /// 2 credits per API call Transfer Multi Token Batch from account to various other accounts in one transaction. Transfer multiple Multi Tokens token from smart contract defined in contractAddress. Multiple token with specified tokenIds and values can be transferred. This method invokes ERC1155 method safeTransfer() to transfer the token in case of ETH, Celo and BSC. This API is supported for the following blockchains: BNB Smart Chain Celo Ethereum Harmony Klaytn KuCoin Community Chain Polygon Signing a transaction When transferring multiple Multi Tokens, you are charged a fee for the transaction, and you must sign the transaction with the private key of the blockchain address from which the fee will be deducted. Providing the private key in the API is not a secure way of signing transactions, because the private key can be stolen or exposed. Your private keys should never leave your security perimeter. You should use the private keys only for testing a solution you are building on the testnet of a blockchain. For signing transactions on the mainnet, we strongly recommend that you use the Tatum Key Management System (KMS) and provide the signature ID instead of the private key in the API. Alternatively, you can use the Tatum JavaScript client.
        /// </remarks>
        /// <exception cref="Tatum.CSharp.MultiTokens.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="transferMultiTokenBatchKMS"></param>
        /// <param name="xTestnetType">Type of testnet. Defaults to Sepolia. Valid only for ETH invocations. (optional, default to ethereum-sepolia)</param>
        /// <returns>SignatureId</returns>
        SignatureId TransferMultiTokenBatch(TransferMultiTokenBatchKMS transferMultiTokenBatchKMS, string xTestnetType = default(string));
        /// <summary>
        /// Transfer a Multi Token
        /// </summary>
        /// <remarks>
        /// 2 credits per API call Transfer a certain amount of Multi Token from account to another account. Transfer Multi Tokens token from smart contract defined in contractAddress. Only 1 specific token with specified tokenId and value can be transferred. This method invokes ERC1155 method safeTransfer() to transfer the token in case of ETH, Celo and blockchains. This API is supported for the following blockchains: BNB Smart Chain Celo Ethereum Harmony Klaytn KuCoin Community Chain Polygon Signing a transaction When transferring a Multi Token, you are charged a fee for the transaction, and you must sign the transaction with the private key of the blockchain address from which the fee will be deducted. Providing the private key in the API is not a secure way of signing transactions, because the private key can be stolen or exposed. Your private keys should never leave your security perimeter. You should use the private keys only for testing a solution you are building on the testnet of a blockchain. For signing transactions on the mainnet, we strongly recommend that you use the Tatum Key Management System (KMS) and provide the signature ID instead of the private key in the API. Alternatively, you can use the Tatum JavaScript client.
        /// </remarks>
        /// <exception cref="Tatum.CSharp.MultiTokens.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="transferMultiTokenKMS"></param>
        /// <param name="xTestnetType">Type of testnet. Defaults to Sepolia. Valid only for ETH invocations. (optional, default to ethereum-sepolia)</param>
        /// <returns>SignatureId</returns>
        SignatureId TransferMultiToken(TransferMultiTokenKMS transferMultiTokenKMS, string xTestnetType = default(string));
        #endregion Synchronous Operations
    }

    /// <summary>
    /// Represents a collection of functions to interact with the API endpoints
    /// </summary>
    public interface IMultiTokensOneApiWithHttpInfoSync : IApiAccessor
    {
        #region Synchronous Operations With Http Info
        /// <summary>
        /// Add a Multi Token minter
        /// </summary>
        /// <remarks>
        /// 2 credits per API call Add Multi Token minter. This API is supported for the following blockchains: BNB Smart Chain Celo Ethereum Harmony Klaytn KuCoin Community Chain Polygon Signing a transaction When adding a Multi Token minter, you are charged a fee for the transaction, and you must sign the transaction with the private key of the blockchain address from which the fee will be deducted. Providing the private key in the API is not a secure way of signing transactions, because the private key can be stolen or exposed. Your private keys should never leave your security perimeter. You should use the private keys only for testing a solution you are building on the testnet of a blockchain. For signing transactions on the mainnet, we strongly recommend that you use the Tatum Key Management System (KMS) and provide the signature ID instead of the private key in the API. Alternatively, you can use the Tatum JavaScript client.
        /// </remarks>
        /// <exception cref="Tatum.CSharp.MultiTokens.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="addMultiTokenMinter"></param>
        /// <param name="xTestnetType">Type of testnet. Defaults to Sepolia. Valid only for ETH invocations. (optional, default to ethereum-sepolia)</param>
        /// <returns>ApiResponse of TransactionHash</returns>
        ApiResponse<TransactionHash> AddMultiTokenMinterWithHttpInfo(AddMultiTokenMinter addMultiTokenMinter, string xTestnetType = default(string));
        /// <summary>
        /// Add a Multi Token minter
        /// </summary>
        /// <remarks>
        /// 2 credits per API call Add Multi Token minter. This API is supported for the following blockchains: BNB Smart Chain Celo Ethereum Harmony Klaytn KuCoin Community Chain Polygon Signing a transaction When adding a Multi Token minter, you are charged a fee for the transaction, and you must sign the transaction with the private key of the blockchain address from which the fee will be deducted. Providing the private key in the API is not a secure way of signing transactions, because the private key can be stolen or exposed. Your private keys should never leave your security perimeter. You should use the private keys only for testing a solution you are building on the testnet of a blockchain. For signing transactions on the mainnet, we strongly recommend that you use the Tatum Key Management System (KMS) and provide the signature ID instead of the private key in the API. Alternatively, you can use the Tatum JavaScript client.
        /// </remarks>
        /// <exception cref="Tatum.CSharp.MultiTokens.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="addMultiTokenMinterKMS"></param>
        /// <param name="xTestnetType">Type of testnet. Defaults to Sepolia. Valid only for ETH invocations. (optional, default to ethereum-sepolia)</param>
        /// <returns>ApiResponse of SignatureId</returns>
        ApiResponse<SignatureId> AddMultiTokenMinterWithHttpInfo(AddMultiTokenMinterKMS addMultiTokenMinterKMS, string xTestnetType = default(string));
        /// <summary>
        /// Burn a Multi Token
        /// </summary>
        /// <remarks>
        /// 2 credits per API call Burn a fixed amount of Multi Tokens by id. This method destroys Multi Tokens from smart contract defined in contractAddress. This API is supported for the following blockchains: BNB Smart Chain Celo Ethereum Harmony Klaytn KuCoin Community Chain Polygon Signing a transaction When burning a Multi Token, you are charged a fee for the transaction, and you must sign the transaction with the private key of the blockchain address from which the fee will be deducted. Providing the private key in the API is not a secure way of signing transactions, because the private key can be stolen or exposed. Your private keys should never leave your security perimeter. You should use the private keys only for testing a solution you are building on the testnet of a blockchain. For signing transactions on the mainnet, we strongly recommend that you use the Tatum Key Management System (KMS) and provide the signature ID instead of the private key in the API. Alternatively, you can use the Tatum JavaScript client.
        /// </remarks>
        /// <exception cref="Tatum.CSharp.MultiTokens.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="burnMultiToken"></param>
        /// <param name="xTestnetType">Type of testnet. Defaults to Sepolia. Valid only for ETH invocations. (optional, default to ethereum-sepolia)</param>
        /// <returns>ApiResponse of TransactionHash</returns>
        ApiResponse<TransactionHash> BurnMultiTokenWithHttpInfo(BurnMultiToken burnMultiToken, string xTestnetType = default(string));
        /// <summary>
        /// Burn multiple Multi Tokens
        /// </summary>
        /// <remarks>
        /// 2 credits per API call Burn multiple Multi Token Tokens by id assigned to same address in one transaction. This method destroys any Multi Tokens token from smart contract defined in contractAddress. This API is supported for the following blockchains: BNB Smart Chain Celo Ethereum Harmony Klaytn KuCoin Community Chain Polygon Signing a transaction When burning multiple Multi Tokens, you are charged a fee for the transaction, and you must sign the transaction with the private key of the blockchain address from which the fee will be deducted. Providing the private key in the API is not a secure way of signing transactions, because the private key can be stolen or exposed. Your private keys should never leave your security perimeter. You should use the private keys only for testing a solution you are building on the testnet of a blockchain. For signing transactions on the mainnet, we strongly recommend that you use the Tatum Key Management System (KMS) and provide the signature ID instead of the private key in the API. Alternatively, you can use the Tatum JavaScript client.
        /// </remarks>
        /// <exception cref="Tatum.CSharp.MultiTokens.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="burnMultiTokenBatch"></param>
        /// <param name="xTestnetType">Type of testnet. Defaults to Sepolia. Valid only for ETH invocations. (optional, default to ethereum-sepolia)</param>
        /// <returns>ApiResponse of TransactionHash</returns>
        ApiResponse<TransactionHash> BurnMultiTokenBatchWithHttpInfo(BurnMultiTokenBatch burnMultiTokenBatch, string xTestnetType = default(string));
        /// <summary>
        /// Burn multiple Multi Tokens
        /// </summary>
        /// <remarks>
        /// 2 credits per API call Burn multiple Multi Token Tokens by id assigned to same address in one transaction. This method destroys any Multi Tokens token from smart contract defined in contractAddress. This API is supported for the following blockchains: BNB Smart Chain Celo Ethereum Harmony Klaytn KuCoin Community Chain Polygon Signing a transaction When burning multiple Multi Tokens, you are charged a fee for the transaction, and you must sign the transaction with the private key of the blockchain address from which the fee will be deducted. Providing the private key in the API is not a secure way of signing transactions, because the private key can be stolen or exposed. Your private keys should never leave your security perimeter. You should use the private keys only for testing a solution you are building on the testnet of a blockchain. For signing transactions on the mainnet, we strongly recommend that you use the Tatum Key Management System (KMS) and provide the signature ID instead of the private key in the API. Alternatively, you can use the Tatum JavaScript client.
        /// </remarks>
        /// <exception cref="Tatum.CSharp.MultiTokens.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="burnMultiTokenBatchKMS"></param>
        /// <param name="xTestnetType">Type of testnet. Defaults to Sepolia. Valid only for ETH invocations. (optional, default to ethereum-sepolia)</param>
        /// <returns>ApiResponse of SignatureId</returns>
        ApiResponse<SignatureId> BurnMultiTokenBatchWithHttpInfo(BurnMultiTokenBatchKMS burnMultiTokenBatchKMS, string xTestnetType = default(string));
        /// <summary>
        /// Burn a Multi Token
        /// </summary>
        /// <remarks>
        /// 2 credits per API call Burn a fixed amount of Multi Tokens by id. This method destroys Multi Tokens from smart contract defined in contractAddress. This API is supported for the following blockchains: BNB Smart Chain Celo Ethereum Harmony Klaytn KuCoin Community Chain Polygon Signing a transaction When burning a Multi Token, you are charged a fee for the transaction, and you must sign the transaction with the private key of the blockchain address from which the fee will be deducted. Providing the private key in the API is not a secure way of signing transactions, because the private key can be stolen or exposed. Your private keys should never leave your security perimeter. You should use the private keys only for testing a solution you are building on the testnet of a blockchain. For signing transactions on the mainnet, we strongly recommend that you use the Tatum Key Management System (KMS) and provide the signature ID instead of the private key in the API. Alternatively, you can use the Tatum JavaScript client.
        /// </remarks>
        /// <exception cref="Tatum.CSharp.MultiTokens.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="burnMultiTokenKMS"></param>
        /// <param name="xTestnetType">Type of testnet. Defaults to Sepolia. Valid only for ETH invocations. (optional, default to ethereum-sepolia)</param>
        /// <returns>ApiResponse of SignatureId</returns>
        ApiResponse<SignatureId> BurnMultiTokenWithHttpInfo(BurnMultiTokenKMS burnMultiTokenKMS, string xTestnetType = default(string));
        /// <summary>
        /// Deploy a Multi Token smart contract
        /// </summary>
        /// <remarks>
        /// 2 credits per API call Deploy Multi Token Smart Contract. This method creates new ERC1155 Smart Contract (Multi Tokens) on the blockchain. Smart contract is standardized and audited. It is possible to mint, burn and transfer tokens. It is also possible to mint multiple tokens at once. This API is supported for the following blockchains: BNB Smart Chain Celo Ethereum Harmony Klaytn KuCoin Community Chain Polygon Signing a transaction When deploying a Multi Token smart contract, you are charged a fee for the transaction, and you must sign the transaction with the private key of the blockchain address from which the fee will be deducted. Providing the private key in the API is not a secure way of signing transactions, because the private key can be stolen or exposed. Your private keys should never leave your security perimeter. You should use the private keys only for testing a solution you are building on the testnet of a blockchain. For signing transactions on the mainnet, we strongly recommend that you use the Tatum Key Management System (KMS) and provide the signature ID instead of the private key in the API. Alternatively, you can use the Tatum JavaScript client.
        /// </remarks>
        /// <exception cref="Tatum.CSharp.MultiTokens.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="deployMultiToken"></param>
        /// <param name="xTestnetType">Type of testnet. Defaults to Sepolia. Valid only for ETH invocations. (optional, default to ethereum-sepolia)</param>
        /// <returns>ApiResponse of TransactionHash</returns>
        ApiResponse<TransactionHash> DeployMultiTokenWithHttpInfo(DeployMultiToken deployMultiToken, string xTestnetType = default(string));
        /// <summary>
        /// Deploy a Multi Token smart contract
        /// </summary>
        /// <remarks>
        /// 2 credits per API call Deploy Multi Token Smart Contract. This method creates new ERC1155 Smart Contract (Multi Tokens) on the blockchain. Smart contract is standardized and audited. It is possible to mint, burn and transfer tokens. It is also possible to mint multiple tokens at once. This API is supported for the following blockchains: BNB Smart Chain Celo Ethereum Harmony Klaytn KuCoin Community Chain Polygon Signing a transaction When deploying a Multi Token smart contract, you are charged a fee for the transaction, and you must sign the transaction with the private key of the blockchain address from which the fee will be deducted. Providing the private key in the API is not a secure way of signing transactions, because the private key can be stolen or exposed. Your private keys should never leave your security perimeter. You should use the private keys only for testing a solution you are building on the testnet of a blockchain. For signing transactions on the mainnet, we strongly recommend that you use the Tatum Key Management System (KMS) and provide the signature ID instead of the private key in the API. Alternatively, you can use the Tatum JavaScript client.
        /// </remarks>
        /// <exception cref="Tatum.CSharp.MultiTokens.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="deployMultiTokenKMS"></param>
        /// <param name="xTestnetType">Type of testnet. Defaults to Sepolia. Valid only for ETH invocations. (optional, default to ethereum-sepolia)</param>
        /// <returns>ApiResponse of SignatureId</returns>
        ApiResponse<SignatureId> DeployMultiTokenWithHttpInfo(DeployMultiTokenKMS deployMultiTokenKMS, string xTestnetType = default(string));
        /// <summary>
        /// Mint a Multi Token
        /// </summary>
        /// <remarks>
        /// 2 credits per API call Mint a fixed amount of Multi Token and transfer it to destination account. Create and transfer any Multi Token token from smart contract defined in contractAddress. It is possible to add Metadata to the created token with a more detailed information about instead. This API is supported for the following blockchains: BNB Smart Chain Celo Ethereum Harmony Klaytn KuCoin Community Chain Polygon Signing a transaction When minting a Multi Token, you are charged a fee for the transaction, and you must sign the transaction with the private key of the blockchain address from which the fee will be deducted. Providing the private key in the API is not a secure way of signing transactions, because the private key can be stolen or exposed. Your private keys should never leave your security perimeter. You should use the private keys only for testing a solution you are building on the testnet of a blockchain. For signing transactions on the mainnet, we strongly recommend that you use the Tatum Key Management System (KMS) and provide the signature ID instead of the private key in the API. Alternatively, you can use the Tatum JavaScript client.
        /// </remarks>
        /// <exception cref="Tatum.CSharp.MultiTokens.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="mintMultiToken"></param>
        /// <param name="xTestnetType">Type of testnet. Defaults to Sepolia. Valid only for ETH invocations. (optional, default to ethereum-sepolia)</param>
        /// <returns>ApiResponse of TransactionHash</returns>
        ApiResponse<TransactionHash> MintMultiTokenWithHttpInfo(MintMultiToken mintMultiToken, string xTestnetType = default(string));
        /// <summary>
        /// Mint multiple Multi Tokens
        /// </summary>
        /// <remarks>
        /// 2 credits per API call Create a fixed amount of multiple Multi Tokens Tokens and transfer them to destination account in one transaction. Create and transfer Multi Tokens tokens from smart contract defined in contractAddress. This API is supported for the following blockchains: BNB Smart Chain Celo Ethereum Harmony Klaytn KuCoin Community Chain Polygon Signing a transaction When minting multiple Multi Tokens, you are charged a fee for the transaction, and you must sign the transaction with the private key of the blockchain address from which the fee will be deducted. Providing the private key in the API is not a secure way of signing transactions, because the private key can be stolen or exposed. Your private keys should never leave your security perimeter. You should use the private keys only for testing a solution you are building on the testnet of a blockchain. For signing transactions on the mainnet, we strongly recommend that you use the Tatum Key Management System (KMS) and provide the signature ID instead of the private key in the API. Alternatively, you can use the Tatum JavaScript client.
        /// </remarks>
        /// <exception cref="Tatum.CSharp.MultiTokens.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="mintMultiTokenBatch"></param>
        /// <param name="xTestnetType">Type of testnet. Defaults to Sepolia. Valid only for ETH invocations. (optional, default to ethereum-sepolia)</param>
        /// <returns>ApiResponse of TransactionHash</returns>
        ApiResponse<TransactionHash> MintMultiTokenBatchWithHttpInfo(MintMultiTokenBatch mintMultiTokenBatch, string xTestnetType = default(string));
        /// <summary>
        /// Mint multiple Multi Tokens
        /// </summary>
        /// <remarks>
        /// 2 credits per API call Create a fixed amount of multiple Multi Tokens Tokens and transfer them to destination account in one transaction. Create and transfer Multi Tokens tokens from smart contract defined in contractAddress. This API is supported for the following blockchains: BNB Smart Chain Celo Ethereum Harmony Klaytn KuCoin Community Chain Polygon Signing a transaction When minting multiple Multi Tokens, you are charged a fee for the transaction, and you must sign the transaction with the private key of the blockchain address from which the fee will be deducted. Providing the private key in the API is not a secure way of signing transactions, because the private key can be stolen or exposed. Your private keys should never leave your security perimeter. You should use the private keys only for testing a solution you are building on the testnet of a blockchain. For signing transactions on the mainnet, we strongly recommend that you use the Tatum Key Management System (KMS) and provide the signature ID instead of the private key in the API. Alternatively, you can use the Tatum JavaScript client.
        /// </remarks>
        /// <exception cref="Tatum.CSharp.MultiTokens.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="mintMultiTokenBatchKMS"></param>
        /// <param name="xTestnetType">Type of testnet. Defaults to Sepolia. Valid only for ETH invocations. (optional, default to ethereum-sepolia)</param>
        /// <returns>ApiResponse of SignatureId</returns>
        ApiResponse<SignatureId> MintMultiTokenBatchWithHttpInfo(MintMultiTokenBatchKMS mintMultiTokenBatchKMS, string xTestnetType = default(string));
        /// <summary>
        /// Mint a Multi Token
        /// </summary>
        /// <remarks>
        /// 2 credits per API call Mint a fixed amount of Multi Token and transfer it to destination account. Create and transfer any Multi Token token from smart contract defined in contractAddress. It is possible to add Metadata to the created token with a more detailed information about instead. This API is supported for the following blockchains: BNB Smart Chain Celo Ethereum Harmony Klaytn KuCoin Community Chain Polygon Signing a transaction When minting a Multi Token, you are charged a fee for the transaction, and you must sign the transaction with the private key of the blockchain address from which the fee will be deducted. Providing the private key in the API is not a secure way of signing transactions, because the private key can be stolen or exposed. Your private keys should never leave your security perimeter. You should use the private keys only for testing a solution you are building on the testnet of a blockchain. For signing transactions on the mainnet, we strongly recommend that you use the Tatum Key Management System (KMS) and provide the signature ID instead of the private key in the API. Alternatively, you can use the Tatum JavaScript client.
        /// </remarks>
        /// <exception cref="Tatum.CSharp.MultiTokens.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="mintMultiTokenKMS"></param>
        /// <param name="xTestnetType">Type of testnet. Defaults to Sepolia. Valid only for ETH invocations. (optional, default to ethereum-sepolia)</param>
        /// <returns>ApiResponse of SignatureId</returns>
        ApiResponse<SignatureId> MintMultiTokenWithHttpInfo(MintMultiTokenKMS mintMultiTokenKMS, string xTestnetType = default(string));
        /// <summary>
        /// Get the amount of a specific MultiToken that a blockchain address holds
        /// </summary>
        /// <remarks>
        /// 1 credit per API call Get the amount of a specific Multi Token (minted on the smart contract specified by the contractAddress path parameter in the request endpoint URL) that a blockchain address holds. This API is supported for the following blockchains: BNB Smart Chain Celo Ethereum Harmony Klaytn KuCoin Community Chain Polygon
        /// </remarks>
        /// <exception cref="Tatum.CSharp.MultiTokens.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="address">The blockchain address that you want to get the token balance of</param>
        /// <param name="contractAddress">The address of the Multi Token smart contract</param>
        /// <param name="tokenId">The ID of the Multi Token</param>
        /// <param name="xTestnetType">Type of testnet. Defaults to Sepolia. Valid only for ETH invocations. (optional, default to ethereum-sepolia)</param>
        /// <returns>ApiResponse of MultiTokenBalanceValue</returns>
        ApiResponse<MultiTokenBalanceValue> MultiTokenGetBalanceWithHttpInfo(string address, string contractAddress, string tokenId, string xTestnetType = default(string));
        /// <summary>
        /// Get the amount of one or multiple Multi Tokens for multiple blockchain addresses
        /// </summary>
        /// <remarks>
        /// 1 credit per API call For multiple blockchain addresses, get the amount of one or multiple Multi Tokens (minted on the smart contract specified by the contractAddress path parameter in the request endpoint URL) that those addresses hold. This API is supported for the following blockchains: BNB Smart Chain Celo Ethereum Harmony Klaytn KuCoin Community Chain Polygon
        /// </remarks>
        /// <exception cref="Tatum.CSharp.MultiTokens.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="contractAddress">The address of the Multi Token smart contract</param>
        /// <param name="tokenId">Comma-separated IDs of the Multi Tokens to get the amounts for</param>
        /// <param name="address">Comma-separated blockchain addresses to get the token balance for</param>
        /// <param name="xTestnetType">Type of testnet. Defaults to Sepolia. Valid only for ETH invocations. (optional, default to ethereum-sepolia)</param>
        /// <returns>ApiResponse of MultiTokenBalanceBatch</returns>
        ApiResponse<MultiTokenBalanceBatch> MultiTokenGetBalanceBatchWithHttpInfo(string contractAddress, string tokenId, string address, string xTestnetType = default(string));
        /// <summary>
        /// Get Multi Token metadata
        /// </summary>
        /// <remarks>
        /// 1 credit per API call Get Multi Token metadata. This API is supported for the following blockchains: BNB Smart Chain Celo Ethereum Harmony Klaytn KuCoin Community Chain Polygon
        /// </remarks>
        /// <exception cref="Tatum.CSharp.MultiTokens.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="token">Token ID</param>
        /// <param name="contractAddress">Multi Token contract address</param>
        /// <param name="xTestnetType">Type of testnet. Defaults to Sepolia. Valid only for ETH invocations. (optional, default to ethereum-sepolia)</param>
        /// <returns>ApiResponse of MultiTokenMetadata</returns>
        ApiResponse<MultiTokenMetadata> MultiTokenGetMetadataWithHttpInfo(string token, string contractAddress, string xTestnetType = default(string));
        /// <summary>
        /// Get a Multi Token transaction by its hash
        /// </summary>
        /// <remarks>
        /// 1 credit per API call Get Multi Token transaction by transaction hash. This API is supported for the following blockchains: BNB Smart Chain Celo Ethereum Harmony Klaytn KuCoin Community Chain Polygon
        /// </remarks>
        /// <exception cref="Tatum.CSharp.MultiTokens.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="hash">Transaction hash</param>
        /// <param name="xTestnetType">Type of testnet. Defaults to Sepolia. Valid only for ETH invocations. (optional, default to ethereum-sepolia)</param>
        /// <returns>ApiResponse of EthTx</returns>
        ApiResponse<EthTx> MultiTokenGetTransactionWithHttpInfo(string hash, string xTestnetType = default(string));
        /// <summary>
        /// Transfer a Multi Token
        /// </summary>
        /// <remarks>
        /// 2 credits per API call Transfer a certain amount of Multi Token from account to another account. Transfer Multi Tokens token from smart contract defined in contractAddress. Only 1 specific token with specified tokenId and value can be transferred. This method invokes ERC1155 method safeTransfer() to transfer the token in case of ETH, Celo and blockchains. This API is supported for the following blockchains: BNB Smart Chain Celo Ethereum Harmony Klaytn KuCoin Community Chain Polygon Signing a transaction When transferring a Multi Token, you are charged a fee for the transaction, and you must sign the transaction with the private key of the blockchain address from which the fee will be deducted. Providing the private key in the API is not a secure way of signing transactions, because the private key can be stolen or exposed. Your private keys should never leave your security perimeter. You should use the private keys only for testing a solution you are building on the testnet of a blockchain. For signing transactions on the mainnet, we strongly recommend that you use the Tatum Key Management System (KMS) and provide the signature ID instead of the private key in the API. Alternatively, you can use the Tatum JavaScript client.
        /// </remarks>
        /// <exception cref="Tatum.CSharp.MultiTokens.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="transferMultiToken"></param>
        /// <param name="xTestnetType">Type of testnet. Defaults to Sepolia. Valid only for ETH invocations. (optional, default to ethereum-sepolia)</param>
        /// <returns>ApiResponse of TransactionHash</returns>
        ApiResponse<TransactionHash> TransferMultiTokenWithHttpInfo(TransferMultiToken transferMultiToken, string xTestnetType = default(string));
        /// <summary>
        /// Transfer multiple Multi Tokens
        /// </summary>
        /// <remarks>
        /// 2 credits per API call Transfer Multi Token Batch from account to various other accounts in one transaction. Transfer multiple Multi Tokens token from smart contract defined in contractAddress. Multiple token with specified tokenIds and values can be transferred. This method invokes ERC1155 method safeTransfer() to transfer the token in case of ETH, Celo and BSC. This API is supported for the following blockchains: BNB Smart Chain Celo Ethereum Harmony Klaytn KuCoin Community Chain Polygon Signing a transaction When transferring multiple Multi Tokens, you are charged a fee for the transaction, and you must sign the transaction with the private key of the blockchain address from which the fee will be deducted. Providing the private key in the API is not a secure way of signing transactions, because the private key can be stolen or exposed. Your private keys should never leave your security perimeter. You should use the private keys only for testing a solution you are building on the testnet of a blockchain. For signing transactions on the mainnet, we strongly recommend that you use the Tatum Key Management System (KMS) and provide the signature ID instead of the private key in the API. Alternatively, you can use the Tatum JavaScript client.
        /// </remarks>
        /// <exception cref="Tatum.CSharp.MultiTokens.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="transferMultiTokenBatch"></param>
        /// <param name="xTestnetType">Type of testnet. Defaults to Sepolia. Valid only for ETH invocations. (optional, default to ethereum-sepolia)</param>
        /// <returns>ApiResponse of TransactionHash</returns>
        ApiResponse<TransactionHash> TransferMultiTokenBatchWithHttpInfo(TransferMultiTokenBatch transferMultiTokenBatch, string xTestnetType = default(string));
        /// <summary>
        /// Transfer multiple Multi Tokens
        /// </summary>
        /// <remarks>
        /// 2 credits per API call Transfer Multi Token Batch from account to various other accounts in one transaction. Transfer multiple Multi Tokens token from smart contract defined in contractAddress. Multiple token with specified tokenIds and values can be transferred. This method invokes ERC1155 method safeTransfer() to transfer the token in case of ETH, Celo and BSC. This API is supported for the following blockchains: BNB Smart Chain Celo Ethereum Harmony Klaytn KuCoin Community Chain Polygon Signing a transaction When transferring multiple Multi Tokens, you are charged a fee for the transaction, and you must sign the transaction with the private key of the blockchain address from which the fee will be deducted. Providing the private key in the API is not a secure way of signing transactions, because the private key can be stolen or exposed. Your private keys should never leave your security perimeter. You should use the private keys only for testing a solution you are building on the testnet of a blockchain. For signing transactions on the mainnet, we strongly recommend that you use the Tatum Key Management System (KMS) and provide the signature ID instead of the private key in the API. Alternatively, you can use the Tatum JavaScript client.
        /// </remarks>
        /// <exception cref="Tatum.CSharp.MultiTokens.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="transferMultiTokenBatchKMS"></param>
        /// <param name="xTestnetType">Type of testnet. Defaults to Sepolia. Valid only for ETH invocations. (optional, default to ethereum-sepolia)</param>
        /// <returns>ApiResponse of SignatureId</returns>
        ApiResponse<SignatureId> TransferMultiTokenBatchWithHttpInfo(TransferMultiTokenBatchKMS transferMultiTokenBatchKMS, string xTestnetType = default(string));
        /// <summary>
        /// Transfer a Multi Token
        /// </summary>
        /// <remarks>
        /// 2 credits per API call Transfer a certain amount of Multi Token from account to another account. Transfer Multi Tokens token from smart contract defined in contractAddress. Only 1 specific token with specified tokenId and value can be transferred. This method invokes ERC1155 method safeTransfer() to transfer the token in case of ETH, Celo and blockchains. This API is supported for the following blockchains: BNB Smart Chain Celo Ethereum Harmony Klaytn KuCoin Community Chain Polygon Signing a transaction When transferring a Multi Token, you are charged a fee for the transaction, and you must sign the transaction with the private key of the blockchain address from which the fee will be deducted. Providing the private key in the API is not a secure way of signing transactions, because the private key can be stolen or exposed. Your private keys should never leave your security perimeter. You should use the private keys only for testing a solution you are building on the testnet of a blockchain. For signing transactions on the mainnet, we strongly recommend that you use the Tatum Key Management System (KMS) and provide the signature ID instead of the private key in the API. Alternatively, you can use the Tatum JavaScript client.
        /// </remarks>
        /// <exception cref="Tatum.CSharp.MultiTokens.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="transferMultiTokenKMS"></param>
        /// <param name="xTestnetType">Type of testnet. Defaults to Sepolia. Valid only for ETH invocations. (optional, default to ethereum-sepolia)</param>
        /// <returns>ApiResponse of SignatureId</returns>
        ApiResponse<SignatureId> TransferMultiTokenWithHttpInfo(TransferMultiTokenKMS transferMultiTokenKMS, string xTestnetType = default(string));
        #endregion Synchronous Operations With Http Info
    }

    /// <summary>
    /// Represents a collection of functions to interact with the API endpoints
    /// </summary>
    public interface IMultiTokensOneApiAsync : IApiAccessor
    {
        #region Asynchronous Operations
        /// <summary>
        /// Add a Multi Token minter
        /// </summary>
        /// <remarks>
        /// 2 credits per API call Add Multi Token minter. This API is supported for the following blockchains: BNB Smart Chain Celo Ethereum Harmony Klaytn KuCoin Community Chain Polygon Signing a transaction When adding a Multi Token minter, you are charged a fee for the transaction, and you must sign the transaction with the private key of the blockchain address from which the fee will be deducted. Providing the private key in the API is not a secure way of signing transactions, because the private key can be stolen or exposed. Your private keys should never leave your security perimeter. You should use the private keys only for testing a solution you are building on the testnet of a blockchain. For signing transactions on the mainnet, we strongly recommend that you use the Tatum Key Management System (KMS) and provide the signature ID instead of the private key in the API. Alternatively, you can use the Tatum JavaScript client.
        /// </remarks>
        /// <exception cref="Tatum.CSharp.MultiTokens.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="addMultiTokenMinter"></param>
        /// <param name="xTestnetType">Type of testnet. Defaults to Sepolia. Valid only for ETH invocations. (optional, default to ethereum-sepolia)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of TransactionHash</returns>
        System.Threading.Tasks.Task<TransactionHash> AddMultiTokenMinterAsync(AddMultiTokenMinter addMultiTokenMinter, string xTestnetType = default(string), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        /// <summary>
        /// Add a Multi Token minter
        /// </summary>
        /// <remarks>
        /// 2 credits per API call Add Multi Token minter. This API is supported for the following blockchains: BNB Smart Chain Celo Ethereum Harmony Klaytn KuCoin Community Chain Polygon Signing a transaction When adding a Multi Token minter, you are charged a fee for the transaction, and you must sign the transaction with the private key of the blockchain address from which the fee will be deducted. Providing the private key in the API is not a secure way of signing transactions, because the private key can be stolen or exposed. Your private keys should never leave your security perimeter. You should use the private keys only for testing a solution you are building on the testnet of a blockchain. For signing transactions on the mainnet, we strongly recommend that you use the Tatum Key Management System (KMS) and provide the signature ID instead of the private key in the API. Alternatively, you can use the Tatum JavaScript client.
        /// </remarks>
        /// <exception cref="Tatum.CSharp.MultiTokens.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="addMultiTokenMinterKMS"></param>
        /// <param name="xTestnetType">Type of testnet. Defaults to Sepolia. Valid only for ETH invocations. (optional, default to ethereum-sepolia)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of SignatureId</returns>
        System.Threading.Tasks.Task<SignatureId> AddMultiTokenMinterAsync(AddMultiTokenMinterKMS addMultiTokenMinterKMS, string xTestnetType = default(string), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        /// <summary>
        /// Burn a Multi Token
        /// </summary>
        /// <remarks>
        /// 2 credits per API call Burn a fixed amount of Multi Tokens by id. This method destroys Multi Tokens from smart contract defined in contractAddress. This API is supported for the following blockchains: BNB Smart Chain Celo Ethereum Harmony Klaytn KuCoin Community Chain Polygon Signing a transaction When burning a Multi Token, you are charged a fee for the transaction, and you must sign the transaction with the private key of the blockchain address from which the fee will be deducted. Providing the private key in the API is not a secure way of signing transactions, because the private key can be stolen or exposed. Your private keys should never leave your security perimeter. You should use the private keys only for testing a solution you are building on the testnet of a blockchain. For signing transactions on the mainnet, we strongly recommend that you use the Tatum Key Management System (KMS) and provide the signature ID instead of the private key in the API. Alternatively, you can use the Tatum JavaScript client.
        /// </remarks>
        /// <exception cref="Tatum.CSharp.MultiTokens.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="burnMultiToken"></param>
        /// <param name="xTestnetType">Type of testnet. Defaults to Sepolia. Valid only for ETH invocations. (optional, default to ethereum-sepolia)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of TransactionHash</returns>
        System.Threading.Tasks.Task<TransactionHash> BurnMultiTokenAsync(BurnMultiToken burnMultiToken, string xTestnetType = default(string), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        /// <summary>
        /// Burn multiple Multi Tokens
        /// </summary>
        /// <remarks>
        /// 2 credits per API call Burn multiple Multi Token Tokens by id assigned to same address in one transaction. This method destroys any Multi Tokens token from smart contract defined in contractAddress. This API is supported for the following blockchains: BNB Smart Chain Celo Ethereum Harmony Klaytn KuCoin Community Chain Polygon Signing a transaction When burning multiple Multi Tokens, you are charged a fee for the transaction, and you must sign the transaction with the private key of the blockchain address from which the fee will be deducted. Providing the private key in the API is not a secure way of signing transactions, because the private key can be stolen or exposed. Your private keys should never leave your security perimeter. You should use the private keys only for testing a solution you are building on the testnet of a blockchain. For signing transactions on the mainnet, we strongly recommend that you use the Tatum Key Management System (KMS) and provide the signature ID instead of the private key in the API. Alternatively, you can use the Tatum JavaScript client.
        /// </remarks>
        /// <exception cref="Tatum.CSharp.MultiTokens.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="burnMultiTokenBatch"></param>
        /// <param name="xTestnetType">Type of testnet. Defaults to Sepolia. Valid only for ETH invocations. (optional, default to ethereum-sepolia)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of TransactionHash</returns>
        System.Threading.Tasks.Task<TransactionHash> BurnMultiTokenBatchAsync(BurnMultiTokenBatch burnMultiTokenBatch, string xTestnetType = default(string), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        /// <summary>
        /// Burn multiple Multi Tokens
        /// </summary>
        /// <remarks>
        /// 2 credits per API call Burn multiple Multi Token Tokens by id assigned to same address in one transaction. This method destroys any Multi Tokens token from smart contract defined in contractAddress. This API is supported for the following blockchains: BNB Smart Chain Celo Ethereum Harmony Klaytn KuCoin Community Chain Polygon Signing a transaction When burning multiple Multi Tokens, you are charged a fee for the transaction, and you must sign the transaction with the private key of the blockchain address from which the fee will be deducted. Providing the private key in the API is not a secure way of signing transactions, because the private key can be stolen or exposed. Your private keys should never leave your security perimeter. You should use the private keys only for testing a solution you are building on the testnet of a blockchain. For signing transactions on the mainnet, we strongly recommend that you use the Tatum Key Management System (KMS) and provide the signature ID instead of the private key in the API. Alternatively, you can use the Tatum JavaScript client.
        /// </remarks>
        /// <exception cref="Tatum.CSharp.MultiTokens.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="burnMultiTokenBatchKMS"></param>
        /// <param name="xTestnetType">Type of testnet. Defaults to Sepolia. Valid only for ETH invocations. (optional, default to ethereum-sepolia)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of SignatureId</returns>
        System.Threading.Tasks.Task<SignatureId> BurnMultiTokenBatchAsync(BurnMultiTokenBatchKMS burnMultiTokenBatchKMS, string xTestnetType = default(string), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        /// <summary>
        /// Burn a Multi Token
        /// </summary>
        /// <remarks>
        /// 2 credits per API call Burn a fixed amount of Multi Tokens by id. This method destroys Multi Tokens from smart contract defined in contractAddress. This API is supported for the following blockchains: BNB Smart Chain Celo Ethereum Harmony Klaytn KuCoin Community Chain Polygon Signing a transaction When burning a Multi Token, you are charged a fee for the transaction, and you must sign the transaction with the private key of the blockchain address from which the fee will be deducted. Providing the private key in the API is not a secure way of signing transactions, because the private key can be stolen or exposed. Your private keys should never leave your security perimeter. You should use the private keys only for testing a solution you are building on the testnet of a blockchain. For signing transactions on the mainnet, we strongly recommend that you use the Tatum Key Management System (KMS) and provide the signature ID instead of the private key in the API. Alternatively, you can use the Tatum JavaScript client.
        /// </remarks>
        /// <exception cref="Tatum.CSharp.MultiTokens.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="burnMultiTokenKMS"></param>
        /// <param name="xTestnetType">Type of testnet. Defaults to Sepolia. Valid only for ETH invocations. (optional, default to ethereum-sepolia)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of SignatureId</returns>
        System.Threading.Tasks.Task<SignatureId> BurnMultiTokenAsync(BurnMultiTokenKMS burnMultiTokenKMS, string xTestnetType = default(string), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        /// <summary>
        /// Deploy a Multi Token smart contract
        /// </summary>
        /// <remarks>
        /// 2 credits per API call Deploy Multi Token Smart Contract. This method creates new ERC1155 Smart Contract (Multi Tokens) on the blockchain. Smart contract is standardized and audited. It is possible to mint, burn and transfer tokens. It is also possible to mint multiple tokens at once. This API is supported for the following blockchains: BNB Smart Chain Celo Ethereum Harmony Klaytn KuCoin Community Chain Polygon Signing a transaction When deploying a Multi Token smart contract, you are charged a fee for the transaction, and you must sign the transaction with the private key of the blockchain address from which the fee will be deducted. Providing the private key in the API is not a secure way of signing transactions, because the private key can be stolen or exposed. Your private keys should never leave your security perimeter. You should use the private keys only for testing a solution you are building on the testnet of a blockchain. For signing transactions on the mainnet, we strongly recommend that you use the Tatum Key Management System (KMS) and provide the signature ID instead of the private key in the API. Alternatively, you can use the Tatum JavaScript client.
        /// </remarks>
        /// <exception cref="Tatum.CSharp.MultiTokens.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="deployMultiToken"></param>
        /// <param name="xTestnetType">Type of testnet. Defaults to Sepolia. Valid only for ETH invocations. (optional, default to ethereum-sepolia)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of TransactionHash</returns>
        System.Threading.Tasks.Task<TransactionHash> DeployMultiTokenAsync(DeployMultiToken deployMultiToken, string xTestnetType = default(string), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        /// <summary>
        /// Deploy a Multi Token smart contract
        /// </summary>
        /// <remarks>
        /// 2 credits per API call Deploy Multi Token Smart Contract. This method creates new ERC1155 Smart Contract (Multi Tokens) on the blockchain. Smart contract is standardized and audited. It is possible to mint, burn and transfer tokens. It is also possible to mint multiple tokens at once. This API is supported for the following blockchains: BNB Smart Chain Celo Ethereum Harmony Klaytn KuCoin Community Chain Polygon Signing a transaction When deploying a Multi Token smart contract, you are charged a fee for the transaction, and you must sign the transaction with the private key of the blockchain address from which the fee will be deducted. Providing the private key in the API is not a secure way of signing transactions, because the private key can be stolen or exposed. Your private keys should never leave your security perimeter. You should use the private keys only for testing a solution you are building on the testnet of a blockchain. For signing transactions on the mainnet, we strongly recommend that you use the Tatum Key Management System (KMS) and provide the signature ID instead of the private key in the API. Alternatively, you can use the Tatum JavaScript client.
        /// </remarks>
        /// <exception cref="Tatum.CSharp.MultiTokens.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="deployMultiTokenKMS"></param>
        /// <param name="xTestnetType">Type of testnet. Defaults to Sepolia. Valid only for ETH invocations. (optional, default to ethereum-sepolia)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of SignatureId</returns>
        System.Threading.Tasks.Task<SignatureId> DeployMultiTokenAsync(DeployMultiTokenKMS deployMultiTokenKMS, string xTestnetType = default(string), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        /// <summary>
        /// Mint a Multi Token
        /// </summary>
        /// <remarks>
        /// 2 credits per API call Mint a fixed amount of Multi Token and transfer it to destination account. Create and transfer any Multi Token token from smart contract defined in contractAddress. It is possible to add Metadata to the created token with a more detailed information about instead. This API is supported for the following blockchains: BNB Smart Chain Celo Ethereum Harmony Klaytn KuCoin Community Chain Polygon Signing a transaction When minting a Multi Token, you are charged a fee for the transaction, and you must sign the transaction with the private key of the blockchain address from which the fee will be deducted. Providing the private key in the API is not a secure way of signing transactions, because the private key can be stolen or exposed. Your private keys should never leave your security perimeter. You should use the private keys only for testing a solution you are building on the testnet of a blockchain. For signing transactions on the mainnet, we strongly recommend that you use the Tatum Key Management System (KMS) and provide the signature ID instead of the private key in the API. Alternatively, you can use the Tatum JavaScript client.
        /// </remarks>
        /// <exception cref="Tatum.CSharp.MultiTokens.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="mintMultiToken"></param>
        /// <param name="xTestnetType">Type of testnet. Defaults to Sepolia. Valid only for ETH invocations. (optional, default to ethereum-sepolia)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of TransactionHash</returns>
        System.Threading.Tasks.Task<TransactionHash> MintMultiTokenAsync(MintMultiToken mintMultiToken, string xTestnetType = default(string), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        /// <summary>
        /// Mint multiple Multi Tokens
        /// </summary>
        /// <remarks>
        /// 2 credits per API call Create a fixed amount of multiple Multi Tokens Tokens and transfer them to destination account in one transaction. Create and transfer Multi Tokens tokens from smart contract defined in contractAddress. This API is supported for the following blockchains: BNB Smart Chain Celo Ethereum Harmony Klaytn KuCoin Community Chain Polygon Signing a transaction When minting multiple Multi Tokens, you are charged a fee for the transaction, and you must sign the transaction with the private key of the blockchain address from which the fee will be deducted. Providing the private key in the API is not a secure way of signing transactions, because the private key can be stolen or exposed. Your private keys should never leave your security perimeter. You should use the private keys only for testing a solution you are building on the testnet of a blockchain. For signing transactions on the mainnet, we strongly recommend that you use the Tatum Key Management System (KMS) and provide the signature ID instead of the private key in the API. Alternatively, you can use the Tatum JavaScript client.
        /// </remarks>
        /// <exception cref="Tatum.CSharp.MultiTokens.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="mintMultiTokenBatch"></param>
        /// <param name="xTestnetType">Type of testnet. Defaults to Sepolia. Valid only for ETH invocations. (optional, default to ethereum-sepolia)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of TransactionHash</returns>
        System.Threading.Tasks.Task<TransactionHash> MintMultiTokenBatchAsync(MintMultiTokenBatch mintMultiTokenBatch, string xTestnetType = default(string), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        /// <summary>
        /// Mint multiple Multi Tokens
        /// </summary>
        /// <remarks>
        /// 2 credits per API call Create a fixed amount of multiple Multi Tokens Tokens and transfer them to destination account in one transaction. Create and transfer Multi Tokens tokens from smart contract defined in contractAddress. This API is supported for the following blockchains: BNB Smart Chain Celo Ethereum Harmony Klaytn KuCoin Community Chain Polygon Signing a transaction When minting multiple Multi Tokens, you are charged a fee for the transaction, and you must sign the transaction with the private key of the blockchain address from which the fee will be deducted. Providing the private key in the API is not a secure way of signing transactions, because the private key can be stolen or exposed. Your private keys should never leave your security perimeter. You should use the private keys only for testing a solution you are building on the testnet of a blockchain. For signing transactions on the mainnet, we strongly recommend that you use the Tatum Key Management System (KMS) and provide the signature ID instead of the private key in the API. Alternatively, you can use the Tatum JavaScript client.
        /// </remarks>
        /// <exception cref="Tatum.CSharp.MultiTokens.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="mintMultiTokenBatchKMS"></param>
        /// <param name="xTestnetType">Type of testnet. Defaults to Sepolia. Valid only for ETH invocations. (optional, default to ethereum-sepolia)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of SignatureId</returns>
        System.Threading.Tasks.Task<SignatureId> MintMultiTokenBatchAsync(MintMultiTokenBatchKMS mintMultiTokenBatchKMS, string xTestnetType = default(string), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        /// <summary>
        /// Mint a Multi Token
        /// </summary>
        /// <remarks>
        /// 2 credits per API call Mint a fixed amount of Multi Token and transfer it to destination account. Create and transfer any Multi Token token from smart contract defined in contractAddress. It is possible to add Metadata to the created token with a more detailed information about instead. This API is supported for the following blockchains: BNB Smart Chain Celo Ethereum Harmony Klaytn KuCoin Community Chain Polygon Signing a transaction When minting a Multi Token, you are charged a fee for the transaction, and you must sign the transaction with the private key of the blockchain address from which the fee will be deducted. Providing the private key in the API is not a secure way of signing transactions, because the private key can be stolen or exposed. Your private keys should never leave your security perimeter. You should use the private keys only for testing a solution you are building on the testnet of a blockchain. For signing transactions on the mainnet, we strongly recommend that you use the Tatum Key Management System (KMS) and provide the signature ID instead of the private key in the API. Alternatively, you can use the Tatum JavaScript client.
        /// </remarks>
        /// <exception cref="Tatum.CSharp.MultiTokens.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="mintMultiTokenKMS"></param>
        /// <param name="xTestnetType">Type of testnet. Defaults to Sepolia. Valid only for ETH invocations. (optional, default to ethereum-sepolia)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of SignatureId</returns>
        System.Threading.Tasks.Task<SignatureId> MintMultiTokenAsync(MintMultiTokenKMS mintMultiTokenKMS, string xTestnetType = default(string), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        /// <summary>
        /// Get the amount of a specific MultiToken that a blockchain address holds
        /// </summary>
        /// <remarks>
        /// 1 credit per API call Get the amount of a specific Multi Token (minted on the smart contract specified by the contractAddress path parameter in the request endpoint URL) that a blockchain address holds. This API is supported for the following blockchains: BNB Smart Chain Celo Ethereum Harmony Klaytn KuCoin Community Chain Polygon
        /// </remarks>
        /// <exception cref="Tatum.CSharp.MultiTokens.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="address">The blockchain address that you want to get the token balance of</param>
        /// <param name="contractAddress">The address of the Multi Token smart contract</param>
        /// <param name="tokenId">The ID of the Multi Token</param>
        /// <param name="xTestnetType">Type of testnet. Defaults to Sepolia. Valid only for ETH invocations. (optional, default to ethereum-sepolia)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of MultiTokenBalanceValue</returns>
        System.Threading.Tasks.Task<MultiTokenBalanceValue> MultiTokenGetBalanceAsync(string address, string contractAddress, string tokenId, string xTestnetType = default(string), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        /// <summary>
        /// Get the amount of one or multiple Multi Tokens for multiple blockchain addresses
        /// </summary>
        /// <remarks>
        /// 1 credit per API call For multiple blockchain addresses, get the amount of one or multiple Multi Tokens (minted on the smart contract specified by the contractAddress path parameter in the request endpoint URL) that those addresses hold. This API is supported for the following blockchains: BNB Smart Chain Celo Ethereum Harmony Klaytn KuCoin Community Chain Polygon
        /// </remarks>
        /// <exception cref="Tatum.CSharp.MultiTokens.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="contractAddress">The address of the Multi Token smart contract</param>
        /// <param name="tokenId">Comma-separated IDs of the Multi Tokens to get the amounts for</param>
        /// <param name="address">Comma-separated blockchain addresses to get the token balance for</param>
        /// <param name="xTestnetType">Type of testnet. Defaults to Sepolia. Valid only for ETH invocations. (optional, default to ethereum-sepolia)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of MultiTokenBalanceBatch</returns>
        System.Threading.Tasks.Task<MultiTokenBalanceBatch> MultiTokenGetBalanceBatchAsync(string contractAddress, string tokenId, string address, string xTestnetType = default(string), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        /// <summary>
        /// Get Multi Token metadata
        /// </summary>
        /// <remarks>
        /// 1 credit per API call Get Multi Token metadata. This API is supported for the following blockchains: BNB Smart Chain Celo Ethereum Harmony Klaytn KuCoin Community Chain Polygon
        /// </remarks>
        /// <exception cref="Tatum.CSharp.MultiTokens.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="token">Token ID</param>
        /// <param name="contractAddress">Multi Token contract address</param>
        /// <param name="xTestnetType">Type of testnet. Defaults to Sepolia. Valid only for ETH invocations. (optional, default to ethereum-sepolia)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of MultiTokenMetadata</returns>
        System.Threading.Tasks.Task<MultiTokenMetadata> MultiTokenGetMetadataAsync(string token, string contractAddress, string xTestnetType = default(string), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        /// <summary>
        /// Get a Multi Token transaction by its hash
        /// </summary>
        /// <remarks>
        /// 1 credit per API call Get Multi Token transaction by transaction hash. This API is supported for the following blockchains: BNB Smart Chain Celo Ethereum Harmony Klaytn KuCoin Community Chain Polygon
        /// </remarks>
        /// <exception cref="Tatum.CSharp.MultiTokens.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="hash">Transaction hash</param>
        /// <param name="xTestnetType">Type of testnet. Defaults to Sepolia. Valid only for ETH invocations. (optional, default to ethereum-sepolia)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of EthTx</returns>
        System.Threading.Tasks.Task<EthTx> MultiTokenGetTransactionAsync(string hash, string xTestnetType = default(string), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        /// <summary>
        /// Transfer a Multi Token
        /// </summary>
        /// <remarks>
        /// 2 credits per API call Transfer a certain amount of Multi Token from account to another account. Transfer Multi Tokens token from smart contract defined in contractAddress. Only 1 specific token with specified tokenId and value can be transferred. This method invokes ERC1155 method safeTransfer() to transfer the token in case of ETH, Celo and blockchains. This API is supported for the following blockchains: BNB Smart Chain Celo Ethereum Harmony Klaytn KuCoin Community Chain Polygon Signing a transaction When transferring a Multi Token, you are charged a fee for the transaction, and you must sign the transaction with the private key of the blockchain address from which the fee will be deducted. Providing the private key in the API is not a secure way of signing transactions, because the private key can be stolen or exposed. Your private keys should never leave your security perimeter. You should use the private keys only for testing a solution you are building on the testnet of a blockchain. For signing transactions on the mainnet, we strongly recommend that you use the Tatum Key Management System (KMS) and provide the signature ID instead of the private key in the API. Alternatively, you can use the Tatum JavaScript client.
        /// </remarks>
        /// <exception cref="Tatum.CSharp.MultiTokens.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="transferMultiToken"></param>
        /// <param name="xTestnetType">Type of testnet. Defaults to Sepolia. Valid only for ETH invocations. (optional, default to ethereum-sepolia)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of TransactionHash</returns>
        System.Threading.Tasks.Task<TransactionHash> TransferMultiTokenAsync(TransferMultiToken transferMultiToken, string xTestnetType = default(string), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        /// <summary>
        /// Transfer multiple Multi Tokens
        /// </summary>
        /// <remarks>
        /// 2 credits per API call Transfer Multi Token Batch from account to various other accounts in one transaction. Transfer multiple Multi Tokens token from smart contract defined in contractAddress. Multiple token with specified tokenIds and values can be transferred. This method invokes ERC1155 method safeTransfer() to transfer the token in case of ETH, Celo and BSC. This API is supported for the following blockchains: BNB Smart Chain Celo Ethereum Harmony Klaytn KuCoin Community Chain Polygon Signing a transaction When transferring multiple Multi Tokens, you are charged a fee for the transaction, and you must sign the transaction with the private key of the blockchain address from which the fee will be deducted. Providing the private key in the API is not a secure way of signing transactions, because the private key can be stolen or exposed. Your private keys should never leave your security perimeter. You should use the private keys only for testing a solution you are building on the testnet of a blockchain. For signing transactions on the mainnet, we strongly recommend that you use the Tatum Key Management System (KMS) and provide the signature ID instead of the private key in the API. Alternatively, you can use the Tatum JavaScript client.
        /// </remarks>
        /// <exception cref="Tatum.CSharp.MultiTokens.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="transferMultiTokenBatch"></param>
        /// <param name="xTestnetType">Type of testnet. Defaults to Sepolia. Valid only for ETH invocations. (optional, default to ethereum-sepolia)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of TransactionHash</returns>
        System.Threading.Tasks.Task<TransactionHash> TransferMultiTokenBatchAsync(TransferMultiTokenBatch transferMultiTokenBatch, string xTestnetType = default(string), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        /// <summary>
        /// Transfer multiple Multi Tokens
        /// </summary>
        /// <remarks>
        /// 2 credits per API call Transfer Multi Token Batch from account to various other accounts in one transaction. Transfer multiple Multi Tokens token from smart contract defined in contractAddress. Multiple token with specified tokenIds and values can be transferred. This method invokes ERC1155 method safeTransfer() to transfer the token in case of ETH, Celo and BSC. This API is supported for the following blockchains: BNB Smart Chain Celo Ethereum Harmony Klaytn KuCoin Community Chain Polygon Signing a transaction When transferring multiple Multi Tokens, you are charged a fee for the transaction, and you must sign the transaction with the private key of the blockchain address from which the fee will be deducted. Providing the private key in the API is not a secure way of signing transactions, because the private key can be stolen or exposed. Your private keys should never leave your security perimeter. You should use the private keys only for testing a solution you are building on the testnet of a blockchain. For signing transactions on the mainnet, we strongly recommend that you use the Tatum Key Management System (KMS) and provide the signature ID instead of the private key in the API. Alternatively, you can use the Tatum JavaScript client.
        /// </remarks>
        /// <exception cref="Tatum.CSharp.MultiTokens.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="transferMultiTokenBatchKMS"></param>
        /// <param name="xTestnetType">Type of testnet. Defaults to Sepolia. Valid only for ETH invocations. (optional, default to ethereum-sepolia)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of SignatureId</returns>
        System.Threading.Tasks.Task<SignatureId> TransferMultiTokenBatchAsync(TransferMultiTokenBatchKMS transferMultiTokenBatchKMS, string xTestnetType = default(string), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        /// <summary>
        /// Transfer a Multi Token
        /// </summary>
        /// <remarks>
        /// 2 credits per API call Transfer a certain amount of Multi Token from account to another account. Transfer Multi Tokens token from smart contract defined in contractAddress. Only 1 specific token with specified tokenId and value can be transferred. This method invokes ERC1155 method safeTransfer() to transfer the token in case of ETH, Celo and blockchains. This API is supported for the following blockchains: BNB Smart Chain Celo Ethereum Harmony Klaytn KuCoin Community Chain Polygon Signing a transaction When transferring a Multi Token, you are charged a fee for the transaction, and you must sign the transaction with the private key of the blockchain address from which the fee will be deducted. Providing the private key in the API is not a secure way of signing transactions, because the private key can be stolen or exposed. Your private keys should never leave your security perimeter. You should use the private keys only for testing a solution you are building on the testnet of a blockchain. For signing transactions on the mainnet, we strongly recommend that you use the Tatum Key Management System (KMS) and provide the signature ID instead of the private key in the API. Alternatively, you can use the Tatum JavaScript client.
        /// </remarks>
        /// <exception cref="Tatum.CSharp.MultiTokens.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="transferMultiTokenKMS"></param>
        /// <param name="xTestnetType">Type of testnet. Defaults to Sepolia. Valid only for ETH invocations. (optional, default to ethereum-sepolia)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of SignatureId</returns>
        System.Threading.Tasks.Task<SignatureId> TransferMultiTokenAsync(TransferMultiTokenKMS transferMultiTokenKMS, string xTestnetType = default(string), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        #endregion Asynchronous Operations
    }

    /// <summary>
    /// Represents a collection of functions to interact with the API endpoints
    /// </summary>
    public interface IMultiTokensOneApiWithHttpInfoAsync : IApiAccessor
    {
        #region Asynchronous Operations With Http Info
        /// <summary>
        /// Add a Multi Token minter
        /// </summary>
        /// <remarks>
        /// 2 credits per API call Add Multi Token minter. This API is supported for the following blockchains: BNB Smart Chain Celo Ethereum Harmony Klaytn KuCoin Community Chain Polygon Signing a transaction When adding a Multi Token minter, you are charged a fee for the transaction, and you must sign the transaction with the private key of the blockchain address from which the fee will be deducted. Providing the private key in the API is not a secure way of signing transactions, because the private key can be stolen or exposed. Your private keys should never leave your security perimeter. You should use the private keys only for testing a solution you are building on the testnet of a blockchain. For signing transactions on the mainnet, we strongly recommend that you use the Tatum Key Management System (KMS) and provide the signature ID instead of the private key in the API. Alternatively, you can use the Tatum JavaScript client.
        /// </remarks>
        /// <exception cref="Tatum.CSharp.MultiTokens.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="addMultiTokenMinter"></param>
        /// <param name="xTestnetType">Type of testnet. Defaults to Sepolia. Valid only for ETH invocations. (optional, default to ethereum-sepolia)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (TransactionHash)</returns>
        System.Threading.Tasks.Task<ApiResponse<TransactionHash>> AddMultiTokenMinterWithHttpInfoAsync(AddMultiTokenMinter addMultiTokenMinter, string xTestnetType = default(string), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        /// <summary>
        /// Add a Multi Token minter
        /// </summary>
        /// <remarks>
        /// 2 credits per API call Add Multi Token minter. This API is supported for the following blockchains: BNB Smart Chain Celo Ethereum Harmony Klaytn KuCoin Community Chain Polygon Signing a transaction When adding a Multi Token minter, you are charged a fee for the transaction, and you must sign the transaction with the private key of the blockchain address from which the fee will be deducted. Providing the private key in the API is not a secure way of signing transactions, because the private key can be stolen or exposed. Your private keys should never leave your security perimeter. You should use the private keys only for testing a solution you are building on the testnet of a blockchain. For signing transactions on the mainnet, we strongly recommend that you use the Tatum Key Management System (KMS) and provide the signature ID instead of the private key in the API. Alternatively, you can use the Tatum JavaScript client.
        /// </remarks>
        /// <exception cref="Tatum.CSharp.MultiTokens.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="addMultiTokenMinterKMS"></param>
        /// <param name="xTestnetType">Type of testnet. Defaults to Sepolia. Valid only for ETH invocations. (optional, default to ethereum-sepolia)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (SignatureId)</returns>
        System.Threading.Tasks.Task<ApiResponse<SignatureId>> AddMultiTokenMinterWithHttpInfoAsync(AddMultiTokenMinterKMS addMultiTokenMinterKMS, string xTestnetType = default(string), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        /// <summary>
        /// Burn a Multi Token
        /// </summary>
        /// <remarks>
        /// 2 credits per API call Burn a fixed amount of Multi Tokens by id. This method destroys Multi Tokens from smart contract defined in contractAddress. This API is supported for the following blockchains: BNB Smart Chain Celo Ethereum Harmony Klaytn KuCoin Community Chain Polygon Signing a transaction When burning a Multi Token, you are charged a fee for the transaction, and you must sign the transaction with the private key of the blockchain address from which the fee will be deducted. Providing the private key in the API is not a secure way of signing transactions, because the private key can be stolen or exposed. Your private keys should never leave your security perimeter. You should use the private keys only for testing a solution you are building on the testnet of a blockchain. For signing transactions on the mainnet, we strongly recommend that you use the Tatum Key Management System (KMS) and provide the signature ID instead of the private key in the API. Alternatively, you can use the Tatum JavaScript client.
        /// </remarks>
        /// <exception cref="Tatum.CSharp.MultiTokens.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="burnMultiToken"></param>
        /// <param name="xTestnetType">Type of testnet. Defaults to Sepolia. Valid only for ETH invocations. (optional, default to ethereum-sepolia)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (TransactionHash)</returns>
        System.Threading.Tasks.Task<ApiResponse<TransactionHash>> BurnMultiTokenWithHttpInfoAsync(BurnMultiToken burnMultiToken, string xTestnetType = default(string), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        /// <summary>
        /// Burn multiple Multi Tokens
        /// </summary>
        /// <remarks>
        /// 2 credits per API call Burn multiple Multi Token Tokens by id assigned to same address in one transaction. This method destroys any Multi Tokens token from smart contract defined in contractAddress. This API is supported for the following blockchains: BNB Smart Chain Celo Ethereum Harmony Klaytn KuCoin Community Chain Polygon Signing a transaction When burning multiple Multi Tokens, you are charged a fee for the transaction, and you must sign the transaction with the private key of the blockchain address from which the fee will be deducted. Providing the private key in the API is not a secure way of signing transactions, because the private key can be stolen or exposed. Your private keys should never leave your security perimeter. You should use the private keys only for testing a solution you are building on the testnet of a blockchain. For signing transactions on the mainnet, we strongly recommend that you use the Tatum Key Management System (KMS) and provide the signature ID instead of the private key in the API. Alternatively, you can use the Tatum JavaScript client.
        /// </remarks>
        /// <exception cref="Tatum.CSharp.MultiTokens.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="burnMultiTokenBatch"></param>
        /// <param name="xTestnetType">Type of testnet. Defaults to Sepolia. Valid only for ETH invocations. (optional, default to ethereum-sepolia)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (TransactionHash)</returns>
        System.Threading.Tasks.Task<ApiResponse<TransactionHash>> BurnMultiTokenBatchWithHttpInfoAsync(BurnMultiTokenBatch burnMultiTokenBatch, string xTestnetType = default(string), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        /// <summary>
        /// Burn multiple Multi Tokens
        /// </summary>
        /// <remarks>
        /// 2 credits per API call Burn multiple Multi Token Tokens by id assigned to same address in one transaction. This method destroys any Multi Tokens token from smart contract defined in contractAddress. This API is supported for the following blockchains: BNB Smart Chain Celo Ethereum Harmony Klaytn KuCoin Community Chain Polygon Signing a transaction When burning multiple Multi Tokens, you are charged a fee for the transaction, and you must sign the transaction with the private key of the blockchain address from which the fee will be deducted. Providing the private key in the API is not a secure way of signing transactions, because the private key can be stolen or exposed. Your private keys should never leave your security perimeter. You should use the private keys only for testing a solution you are building on the testnet of a blockchain. For signing transactions on the mainnet, we strongly recommend that you use the Tatum Key Management System (KMS) and provide the signature ID instead of the private key in the API. Alternatively, you can use the Tatum JavaScript client.
        /// </remarks>
        /// <exception cref="Tatum.CSharp.MultiTokens.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="burnMultiTokenBatchKMS"></param>
        /// <param name="xTestnetType">Type of testnet. Defaults to Sepolia. Valid only for ETH invocations. (optional, default to ethereum-sepolia)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (SignatureId)</returns>
        System.Threading.Tasks.Task<ApiResponse<SignatureId>> BurnMultiTokenBatchWithHttpInfoAsync(BurnMultiTokenBatchKMS burnMultiTokenBatchKMS, string xTestnetType = default(string), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        /// <summary>
        /// Burn a Multi Token
        /// </summary>
        /// <remarks>
        /// 2 credits per API call Burn a fixed amount of Multi Tokens by id. This method destroys Multi Tokens from smart contract defined in contractAddress. This API is supported for the following blockchains: BNB Smart Chain Celo Ethereum Harmony Klaytn KuCoin Community Chain Polygon Signing a transaction When burning a Multi Token, you are charged a fee for the transaction, and you must sign the transaction with the private key of the blockchain address from which the fee will be deducted. Providing the private key in the API is not a secure way of signing transactions, because the private key can be stolen or exposed. Your private keys should never leave your security perimeter. You should use the private keys only for testing a solution you are building on the testnet of a blockchain. For signing transactions on the mainnet, we strongly recommend that you use the Tatum Key Management System (KMS) and provide the signature ID instead of the private key in the API. Alternatively, you can use the Tatum JavaScript client.
        /// </remarks>
        /// <exception cref="Tatum.CSharp.MultiTokens.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="burnMultiTokenKMS"></param>
        /// <param name="xTestnetType">Type of testnet. Defaults to Sepolia. Valid only for ETH invocations. (optional, default to ethereum-sepolia)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (SignatureId)</returns>
        System.Threading.Tasks.Task<ApiResponse<SignatureId>> BurnMultiTokenWithHttpInfoAsync(BurnMultiTokenKMS burnMultiTokenKMS, string xTestnetType = default(string), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        /// <summary>
        /// Deploy a Multi Token smart contract
        /// </summary>
        /// <remarks>
        /// 2 credits per API call Deploy Multi Token Smart Contract. This method creates new ERC1155 Smart Contract (Multi Tokens) on the blockchain. Smart contract is standardized and audited. It is possible to mint, burn and transfer tokens. It is also possible to mint multiple tokens at once. This API is supported for the following blockchains: BNB Smart Chain Celo Ethereum Harmony Klaytn KuCoin Community Chain Polygon Signing a transaction When deploying a Multi Token smart contract, you are charged a fee for the transaction, and you must sign the transaction with the private key of the blockchain address from which the fee will be deducted. Providing the private key in the API is not a secure way of signing transactions, because the private key can be stolen or exposed. Your private keys should never leave your security perimeter. You should use the private keys only for testing a solution you are building on the testnet of a blockchain. For signing transactions on the mainnet, we strongly recommend that you use the Tatum Key Management System (KMS) and provide the signature ID instead of the private key in the API. Alternatively, you can use the Tatum JavaScript client.
        /// </remarks>
        /// <exception cref="Tatum.CSharp.MultiTokens.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="deployMultiToken"></param>
        /// <param name="xTestnetType">Type of testnet. Defaults to Sepolia. Valid only for ETH invocations. (optional, default to ethereum-sepolia)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (TransactionHash)</returns>
        System.Threading.Tasks.Task<ApiResponse<TransactionHash>> DeployMultiTokenWithHttpInfoAsync(DeployMultiToken deployMultiToken, string xTestnetType = default(string), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        /// <summary>
        /// Deploy a Multi Token smart contract
        /// </summary>
        /// <remarks>
        /// 2 credits per API call Deploy Multi Token Smart Contract. This method creates new ERC1155 Smart Contract (Multi Tokens) on the blockchain. Smart contract is standardized and audited. It is possible to mint, burn and transfer tokens. It is also possible to mint multiple tokens at once. This API is supported for the following blockchains: BNB Smart Chain Celo Ethereum Harmony Klaytn KuCoin Community Chain Polygon Signing a transaction When deploying a Multi Token smart contract, you are charged a fee for the transaction, and you must sign the transaction with the private key of the blockchain address from which the fee will be deducted. Providing the private key in the API is not a secure way of signing transactions, because the private key can be stolen or exposed. Your private keys should never leave your security perimeter. You should use the private keys only for testing a solution you are building on the testnet of a blockchain. For signing transactions on the mainnet, we strongly recommend that you use the Tatum Key Management System (KMS) and provide the signature ID instead of the private key in the API. Alternatively, you can use the Tatum JavaScript client.
        /// </remarks>
        /// <exception cref="Tatum.CSharp.MultiTokens.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="deployMultiTokenKMS"></param>
        /// <param name="xTestnetType">Type of testnet. Defaults to Sepolia. Valid only for ETH invocations. (optional, default to ethereum-sepolia)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (SignatureId)</returns>
        System.Threading.Tasks.Task<ApiResponse<SignatureId>> DeployMultiTokenWithHttpInfoAsync(DeployMultiTokenKMS deployMultiTokenKMS, string xTestnetType = default(string), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        /// <summary>
        /// Mint a Multi Token
        /// </summary>
        /// <remarks>
        /// 2 credits per API call Mint a fixed amount of Multi Token and transfer it to destination account. Create and transfer any Multi Token token from smart contract defined in contractAddress. It is possible to add Metadata to the created token with a more detailed information about instead. This API is supported for the following blockchains: BNB Smart Chain Celo Ethereum Harmony Klaytn KuCoin Community Chain Polygon Signing a transaction When minting a Multi Token, you are charged a fee for the transaction, and you must sign the transaction with the private key of the blockchain address from which the fee will be deducted. Providing the private key in the API is not a secure way of signing transactions, because the private key can be stolen or exposed. Your private keys should never leave your security perimeter. You should use the private keys only for testing a solution you are building on the testnet of a blockchain. For signing transactions on the mainnet, we strongly recommend that you use the Tatum Key Management System (KMS) and provide the signature ID instead of the private key in the API. Alternatively, you can use the Tatum JavaScript client.
        /// </remarks>
        /// <exception cref="Tatum.CSharp.MultiTokens.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="mintMultiToken"></param>
        /// <param name="xTestnetType">Type of testnet. Defaults to Sepolia. Valid only for ETH invocations. (optional, default to ethereum-sepolia)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (TransactionHash)</returns>
        System.Threading.Tasks.Task<ApiResponse<TransactionHash>> MintMultiTokenWithHttpInfoAsync(MintMultiToken mintMultiToken, string xTestnetType = default(string), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        /// <summary>
        /// Mint multiple Multi Tokens
        /// </summary>
        /// <remarks>
        /// 2 credits per API call Create a fixed amount of multiple Multi Tokens Tokens and transfer them to destination account in one transaction. Create and transfer Multi Tokens tokens from smart contract defined in contractAddress. This API is supported for the following blockchains: BNB Smart Chain Celo Ethereum Harmony Klaytn KuCoin Community Chain Polygon Signing a transaction When minting multiple Multi Tokens, you are charged a fee for the transaction, and you must sign the transaction with the private key of the blockchain address from which the fee will be deducted. Providing the private key in the API is not a secure way of signing transactions, because the private key can be stolen or exposed. Your private keys should never leave your security perimeter. You should use the private keys only for testing a solution you are building on the testnet of a blockchain. For signing transactions on the mainnet, we strongly recommend that you use the Tatum Key Management System (KMS) and provide the signature ID instead of the private key in the API. Alternatively, you can use the Tatum JavaScript client.
        /// </remarks>
        /// <exception cref="Tatum.CSharp.MultiTokens.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="mintMultiTokenBatch"></param>
        /// <param name="xTestnetType">Type of testnet. Defaults to Sepolia. Valid only for ETH invocations. (optional, default to ethereum-sepolia)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (TransactionHash)</returns>
        System.Threading.Tasks.Task<ApiResponse<TransactionHash>> MintMultiTokenBatchWithHttpInfoAsync(MintMultiTokenBatch mintMultiTokenBatch, string xTestnetType = default(string), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        /// <summary>
        /// Mint multiple Multi Tokens
        /// </summary>
        /// <remarks>
        /// 2 credits per API call Create a fixed amount of multiple Multi Tokens Tokens and transfer them to destination account in one transaction. Create and transfer Multi Tokens tokens from smart contract defined in contractAddress. This API is supported for the following blockchains: BNB Smart Chain Celo Ethereum Harmony Klaytn KuCoin Community Chain Polygon Signing a transaction When minting multiple Multi Tokens, you are charged a fee for the transaction, and you must sign the transaction with the private key of the blockchain address from which the fee will be deducted. Providing the private key in the API is not a secure way of signing transactions, because the private key can be stolen or exposed. Your private keys should never leave your security perimeter. You should use the private keys only for testing a solution you are building on the testnet of a blockchain. For signing transactions on the mainnet, we strongly recommend that you use the Tatum Key Management System (KMS) and provide the signature ID instead of the private key in the API. Alternatively, you can use the Tatum JavaScript client.
        /// </remarks>
        /// <exception cref="Tatum.CSharp.MultiTokens.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="mintMultiTokenBatchKMS"></param>
        /// <param name="xTestnetType">Type of testnet. Defaults to Sepolia. Valid only for ETH invocations. (optional, default to ethereum-sepolia)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (SignatureId)</returns>
        System.Threading.Tasks.Task<ApiResponse<SignatureId>> MintMultiTokenBatchWithHttpInfoAsync(MintMultiTokenBatchKMS mintMultiTokenBatchKMS, string xTestnetType = default(string), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        /// <summary>
        /// Mint a Multi Token
        /// </summary>
        /// <remarks>
        /// 2 credits per API call Mint a fixed amount of Multi Token and transfer it to destination account. Create and transfer any Multi Token token from smart contract defined in contractAddress. It is possible to add Metadata to the created token with a more detailed information about instead. This API is supported for the following blockchains: BNB Smart Chain Celo Ethereum Harmony Klaytn KuCoin Community Chain Polygon Signing a transaction When minting a Multi Token, you are charged a fee for the transaction, and you must sign the transaction with the private key of the blockchain address from which the fee will be deducted. Providing the private key in the API is not a secure way of signing transactions, because the private key can be stolen or exposed. Your private keys should never leave your security perimeter. You should use the private keys only for testing a solution you are building on the testnet of a blockchain. For signing transactions on the mainnet, we strongly recommend that you use the Tatum Key Management System (KMS) and provide the signature ID instead of the private key in the API. Alternatively, you can use the Tatum JavaScript client.
        /// </remarks>
        /// <exception cref="Tatum.CSharp.MultiTokens.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="mintMultiTokenKMS"></param>
        /// <param name="xTestnetType">Type of testnet. Defaults to Sepolia. Valid only for ETH invocations. (optional, default to ethereum-sepolia)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (SignatureId)</returns>
        System.Threading.Tasks.Task<ApiResponse<SignatureId>> MintMultiTokenWithHttpInfoAsync(MintMultiTokenKMS mintMultiTokenKMS, string xTestnetType = default(string), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        /// <summary>
        /// Get the amount of a specific MultiToken that a blockchain address holds
        /// </summary>
        /// <remarks>
        /// 1 credit per API call Get the amount of a specific Multi Token (minted on the smart contract specified by the contractAddress path parameter in the request endpoint URL) that a blockchain address holds. This API is supported for the following blockchains: BNB Smart Chain Celo Ethereum Harmony Klaytn KuCoin Community Chain Polygon
        /// </remarks>
        /// <exception cref="Tatum.CSharp.MultiTokens.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="address">The blockchain address that you want to get the token balance of</param>
        /// <param name="contractAddress">The address of the Multi Token smart contract</param>
        /// <param name="tokenId">The ID of the Multi Token</param>
        /// <param name="xTestnetType">Type of testnet. Defaults to Sepolia. Valid only for ETH invocations. (optional, default to ethereum-sepolia)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (MultiTokenBalanceValue)</returns>
        System.Threading.Tasks.Task<ApiResponse<MultiTokenBalanceValue>> MultiTokenGetBalanceWithHttpInfoAsync(string address, string contractAddress, string tokenId, string xTestnetType = default(string), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        /// <summary>
        /// Get the amount of one or multiple Multi Tokens for multiple blockchain addresses
        /// </summary>
        /// <remarks>
        /// 1 credit per API call For multiple blockchain addresses, get the amount of one or multiple Multi Tokens (minted on the smart contract specified by the contractAddress path parameter in the request endpoint URL) that those addresses hold. This API is supported for the following blockchains: BNB Smart Chain Celo Ethereum Harmony Klaytn KuCoin Community Chain Polygon
        /// </remarks>
        /// <exception cref="Tatum.CSharp.MultiTokens.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="contractAddress">The address of the Multi Token smart contract</param>
        /// <param name="tokenId">Comma-separated IDs of the Multi Tokens to get the amounts for</param>
        /// <param name="address">Comma-separated blockchain addresses to get the token balance for</param>
        /// <param name="xTestnetType">Type of testnet. Defaults to Sepolia. Valid only for ETH invocations. (optional, default to ethereum-sepolia)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (MultiTokenBalanceBatch)</returns>
        System.Threading.Tasks.Task<ApiResponse<MultiTokenBalanceBatch>> MultiTokenGetBalanceBatchWithHttpInfoAsync(string contractAddress, string tokenId, string address, string xTestnetType = default(string), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        /// <summary>
        /// Get Multi Token metadata
        /// </summary>
        /// <remarks>
        /// 1 credit per API call Get Multi Token metadata. This API is supported for the following blockchains: BNB Smart Chain Celo Ethereum Harmony Klaytn KuCoin Community Chain Polygon
        /// </remarks>
        /// <exception cref="Tatum.CSharp.MultiTokens.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="token">Token ID</param>
        /// <param name="contractAddress">Multi Token contract address</param>
        /// <param name="xTestnetType">Type of testnet. Defaults to Sepolia. Valid only for ETH invocations. (optional, default to ethereum-sepolia)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (MultiTokenMetadata)</returns>
        System.Threading.Tasks.Task<ApiResponse<MultiTokenMetadata>> MultiTokenGetMetadataWithHttpInfoAsync(string token, string contractAddress, string xTestnetType = default(string), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        /// <summary>
        /// Get a Multi Token transaction by its hash
        /// </summary>
        /// <remarks>
        /// 1 credit per API call Get Multi Token transaction by transaction hash. This API is supported for the following blockchains: BNB Smart Chain Celo Ethereum Harmony Klaytn KuCoin Community Chain Polygon
        /// </remarks>
        /// <exception cref="Tatum.CSharp.MultiTokens.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="hash">Transaction hash</param>
        /// <param name="xTestnetType">Type of testnet. Defaults to Sepolia. Valid only for ETH invocations. (optional, default to ethereum-sepolia)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (EthTx)</returns>
        System.Threading.Tasks.Task<ApiResponse<EthTx>> MultiTokenGetTransactionWithHttpInfoAsync(string hash, string xTestnetType = default(string), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        /// <summary>
        /// Transfer a Multi Token
        /// </summary>
        /// <remarks>
        /// 2 credits per API call Transfer a certain amount of Multi Token from account to another account. Transfer Multi Tokens token from smart contract defined in contractAddress. Only 1 specific token with specified tokenId and value can be transferred. This method invokes ERC1155 method safeTransfer() to transfer the token in case of ETH, Celo and blockchains. This API is supported for the following blockchains: BNB Smart Chain Celo Ethereum Harmony Klaytn KuCoin Community Chain Polygon Signing a transaction When transferring a Multi Token, you are charged a fee for the transaction, and you must sign the transaction with the private key of the blockchain address from which the fee will be deducted. Providing the private key in the API is not a secure way of signing transactions, because the private key can be stolen or exposed. Your private keys should never leave your security perimeter. You should use the private keys only for testing a solution you are building on the testnet of a blockchain. For signing transactions on the mainnet, we strongly recommend that you use the Tatum Key Management System (KMS) and provide the signature ID instead of the private key in the API. Alternatively, you can use the Tatum JavaScript client.
        /// </remarks>
        /// <exception cref="Tatum.CSharp.MultiTokens.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="transferMultiToken"></param>
        /// <param name="xTestnetType">Type of testnet. Defaults to Sepolia. Valid only for ETH invocations. (optional, default to ethereum-sepolia)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (TransactionHash)</returns>
        System.Threading.Tasks.Task<ApiResponse<TransactionHash>> TransferMultiTokenWithHttpInfoAsync(TransferMultiToken transferMultiToken, string xTestnetType = default(string), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        /// <summary>
        /// Transfer multiple Multi Tokens
        /// </summary>
        /// <remarks>
        /// 2 credits per API call Transfer Multi Token Batch from account to various other accounts in one transaction. Transfer multiple Multi Tokens token from smart contract defined in contractAddress. Multiple token with specified tokenIds and values can be transferred. This method invokes ERC1155 method safeTransfer() to transfer the token in case of ETH, Celo and BSC. This API is supported for the following blockchains: BNB Smart Chain Celo Ethereum Harmony Klaytn KuCoin Community Chain Polygon Signing a transaction When transferring multiple Multi Tokens, you are charged a fee for the transaction, and you must sign the transaction with the private key of the blockchain address from which the fee will be deducted. Providing the private key in the API is not a secure way of signing transactions, because the private key can be stolen or exposed. Your private keys should never leave your security perimeter. You should use the private keys only for testing a solution you are building on the testnet of a blockchain. For signing transactions on the mainnet, we strongly recommend that you use the Tatum Key Management System (KMS) and provide the signature ID instead of the private key in the API. Alternatively, you can use the Tatum JavaScript client.
        /// </remarks>
        /// <exception cref="Tatum.CSharp.MultiTokens.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="transferMultiTokenBatch"></param>
        /// <param name="xTestnetType">Type of testnet. Defaults to Sepolia. Valid only for ETH invocations. (optional, default to ethereum-sepolia)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (TransactionHash)</returns>
        System.Threading.Tasks.Task<ApiResponse<TransactionHash>> TransferMultiTokenBatchWithHttpInfoAsync(TransferMultiTokenBatch transferMultiTokenBatch, string xTestnetType = default(string), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        /// <summary>
        /// Transfer multiple Multi Tokens
        /// </summary>
        /// <remarks>
        /// 2 credits per API call Transfer Multi Token Batch from account to various other accounts in one transaction. Transfer multiple Multi Tokens token from smart contract defined in contractAddress. Multiple token with specified tokenIds and values can be transferred. This method invokes ERC1155 method safeTransfer() to transfer the token in case of ETH, Celo and BSC. This API is supported for the following blockchains: BNB Smart Chain Celo Ethereum Harmony Klaytn KuCoin Community Chain Polygon Signing a transaction When transferring multiple Multi Tokens, you are charged a fee for the transaction, and you must sign the transaction with the private key of the blockchain address from which the fee will be deducted. Providing the private key in the API is not a secure way of signing transactions, because the private key can be stolen or exposed. Your private keys should never leave your security perimeter. You should use the private keys only for testing a solution you are building on the testnet of a blockchain. For signing transactions on the mainnet, we strongly recommend that you use the Tatum Key Management System (KMS) and provide the signature ID instead of the private key in the API. Alternatively, you can use the Tatum JavaScript client.
        /// </remarks>
        /// <exception cref="Tatum.CSharp.MultiTokens.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="transferMultiTokenBatchKMS"></param>
        /// <param name="xTestnetType">Type of testnet. Defaults to Sepolia. Valid only for ETH invocations. (optional, default to ethereum-sepolia)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (SignatureId)</returns>
        System.Threading.Tasks.Task<ApiResponse<SignatureId>> TransferMultiTokenBatchWithHttpInfoAsync(TransferMultiTokenBatchKMS transferMultiTokenBatchKMS, string xTestnetType = default(string), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        /// <summary>
        /// Transfer a Multi Token
        /// </summary>
        /// <remarks>
        /// 2 credits per API call Transfer a certain amount of Multi Token from account to another account. Transfer Multi Tokens token from smart contract defined in contractAddress. Only 1 specific token with specified tokenId and value can be transferred. This method invokes ERC1155 method safeTransfer() to transfer the token in case of ETH, Celo and blockchains. This API is supported for the following blockchains: BNB Smart Chain Celo Ethereum Harmony Klaytn KuCoin Community Chain Polygon Signing a transaction When transferring a Multi Token, you are charged a fee for the transaction, and you must sign the transaction with the private key of the blockchain address from which the fee will be deducted. Providing the private key in the API is not a secure way of signing transactions, because the private key can be stolen or exposed. Your private keys should never leave your security perimeter. You should use the private keys only for testing a solution you are building on the testnet of a blockchain. For signing transactions on the mainnet, we strongly recommend that you use the Tatum Key Management System (KMS) and provide the signature ID instead of the private key in the API. Alternatively, you can use the Tatum JavaScript client.
        /// </remarks>
        /// <exception cref="Tatum.CSharp.MultiTokens.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="transferMultiTokenKMS"></param>
        /// <param name="xTestnetType">Type of testnet. Defaults to Sepolia. Valid only for ETH invocations. (optional, default to ethereum-sepolia)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (SignatureId)</returns>
        System.Threading.Tasks.Task<ApiResponse<SignatureId>> TransferMultiTokenWithHttpInfoAsync(TransferMultiTokenKMS transferMultiTokenKMS, string xTestnetType = default(string), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        #endregion Asynchronous Operations With Http Info
    }


    /// <summary>
    /// Represents a collection of functions to interact with the API endpoints
    /// </summary>
    public interface IMultiTokensOneApi : IMultiTokensOneApiSync, IMultiTokensOneApiWithHttpInfoSync, IMultiTokensOneApiAsync, IMultiTokensOneApiWithHttpInfoAsync
    {

    }

    /// <summary>
    /// Represents a collection of functions to interact with the API endpoints
    /// </summary>
    public partial class MultiTokensOneApi : IMultiTokensOneApi
    {
        private ExceptionFactory _exceptionFactory = (name, response) => null;

        /// <summary>
        /// Initializes a new instance of the <see cref="MultiTokensOneApi"/> class.
        /// </summary>
        /// <param name="client">An instance of HttpClient.</param>
        /// <param name="handler">An optional instance of HttpClientHandler that is used by HttpClient.</param>
        /// <exception cref="ArgumentNullException"></exception>
        /// <returns></returns>
        /// <remarks>
        /// Some configuration settings will not be applied without passing an HttpClientHandler.
        /// The features affected are: Setting and Retrieving Cookies, Client Certificates, Proxy settings.
        /// </remarks>
        public MultiTokensOneApi(HttpClient client, HttpClientHandler handler = null) : this(client, (string)null, handler)
        {
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="MultiTokensOneApi"/> class.
        /// </summary>
        /// <param name="client">An instance of HttpClient.</param>
        /// <param name="basePath">The target service's base path in URL format.</param>
        /// <param name="handler">An optional instance of HttpClientHandler that is used by HttpClient.</param>
        /// <exception cref="ArgumentNullException"></exception>
        /// <exception cref="ArgumentException"></exception>
        /// <returns></returns>
        /// <remarks>
        /// Some configuration settings will not be applied without passing an HttpClientHandler.
        /// The features affected are: Setting and Retrieving Cookies, Client Certificates, Proxy settings.
        /// </remarks>
        public MultiTokensOneApi(HttpClient client, string basePath, HttpClientHandler handler = null)
        {
            if (client == null) throw new ArgumentNullException(nameof(client));

            Configuration = Tatum.CSharp.MultiTokens.Core.Client.Configuration.MergeConfigurations(
                GlobalConfiguration.Instance,
                new Configuration { BasePath = basePath }
            );
            ApiClient = new ApiClient(client, Configuration.BasePath, handler);
            Client =  ApiClient;
            AsynchronousClient = ApiClient;
            ExceptionFactory = Tatum.CSharp.MultiTokens.Core.Client.Configuration.DefaultExceptionFactory;
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="MultiTokensOneApi"/> class using Configuration object.
        /// </summary>
        /// <param name="client">An instance of HttpClient.</param>
        /// <param name="configuration">An instance of Configuration.</param>
        /// <param name="handler">An optional instance of HttpClientHandler that is used by HttpClient.</param>
        /// <exception cref="ArgumentNullException"></exception>
        /// <returns></returns>
        /// <remarks>
        /// Some configuration settings will not be applied without passing an HttpClientHandler.
        /// The features affected are: Setting and Retrieving Cookies, Client Certificates, Proxy settings.
        /// </remarks>
        public MultiTokensOneApi(HttpClient client, Configuration configuration, HttpClientHandler handler = null)
        {
            if (configuration == null) throw new ArgumentNullException(nameof(configuration));
            if (client == null) throw new ArgumentNullException(nameof(client));

            Configuration = Tatum.CSharp.MultiTokens.Core.Client.Configuration.MergeConfigurations(
                GlobalConfiguration.Instance,
                configuration
            );
            ApiClient = new ApiClient(client, Configuration.BasePath, handler);
            Client = ApiClient;
            AsynchronousClient = ApiClient;
            ExceptionFactory = Tatum.CSharp.MultiTokens.Core.Client.Configuration.DefaultExceptionFactory;
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="MultiTokensOneApi"/> class
        /// using a Configuration object and client instance.
        /// </summary>
        /// <param name="client">The client interface for synchronous API access.</param>
        /// <param name="asyncClient">The client interface for asynchronous API access.</param>
        /// <param name="configuration">The configuration object.</param>
        /// <exception cref="ArgumentNullException"></exception>
        public MultiTokensOneApi(ISynchronousClient client, IAsynchronousClient asyncClient, IReadableConfiguration configuration)
        {
            Client = client ?? throw new ArgumentNullException(nameof(client));
            AsynchronousClient = asyncClient ?? throw new ArgumentNullException(nameof(asyncClient));
            Configuration = configuration ?? throw new ArgumentNullException(nameof(configuration));
            ExceptionFactory = Tatum.CSharp.MultiTokens.Core.Client.Configuration.DefaultExceptionFactory;
        }

        /// <summary>
        /// Holds the ApiClient if created
        /// </summary>
        public ApiClient ApiClient { get; set; }

        /// <summary>
        /// The client for accessing this underlying API asynchronously.
        /// </summary>
        public IAsynchronousClient AsynchronousClient { get; set; }

        /// <summary>
        /// The client for accessing this underlying API synchronously.
        /// </summary>
        public ISynchronousClient Client { get; set; }

        /// <summary>
        /// Gets the base path of the API client.
        /// </summary>
        /// <value>The base path</value>
        public string GetBasePath()
        {
            return Configuration.BasePath;
        }

        /// <summary>
        /// Gets or sets the configuration object
        /// </summary>
        /// <value>An instance of the Configuration</value>
        public IReadableConfiguration Configuration { get; set; }

        /// <summary>
        /// Provides a factory method hook for the creation of exceptions.
        /// </summary>
        public ExceptionFactory ExceptionFactory
        {
            get
            {
                if (_exceptionFactory != null && _exceptionFactory.GetInvocationList().Length > 1)
                {
                    throw new InvalidOperationException("Multicast delegate for ExceptionFactory is unsupported.");
                }
                return _exceptionFactory;
            }
            set => _exceptionFactory = value;
        }

        /// <summary>
        /// Add a Multi Token minter 2 credits per API call Add Multi Token minter. This API is supported for the following blockchains: BNB Smart Chain Celo Ethereum Harmony Klaytn KuCoin Community Chain Polygon Signing a transaction When adding a Multi Token minter, you are charged a fee for the transaction, and you must sign the transaction with the private key of the blockchain address from which the fee will be deducted. Providing the private key in the API is not a secure way of signing transactions, because the private key can be stolen or exposed. Your private keys should never leave your security perimeter. You should use the private keys only for testing a solution you are building on the testnet of a blockchain. For signing transactions on the mainnet, we strongly recommend that you use the Tatum Key Management System (KMS) and provide the signature ID instead of the private key in the API. Alternatively, you can use the Tatum JavaScript client.
        /// </summary>
        /// <exception cref="Tatum.CSharp.MultiTokens.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="addMultiTokenMinter"></param>
        /// <param name="xTestnetType">Type of testnet. Defaults to Sepolia. Valid only for ETH invocations. (optional, default to ethereum-sepolia)</param>
        /// <returns>TransactionHash</returns>
        public TransactionHash AddMultiTokenMinter(AddMultiTokenMinter addMultiTokenMinter, string xTestnetType = default(string))
        {
            var localVarResponse = AddMultiTokenMinterWithHttpInfo(addMultiTokenMinter, xTestnetType);

            var exception = ExceptionFactory?.Invoke("AddMultiTokenMinter", localVarResponse);
            if (exception != null) throw exception;

            return localVarResponse.Data;
        }

        /// <summary>
        /// Add a Multi Token minter 2 credits per API call Add Multi Token minter. This API is supported for the following blockchains: BNB Smart Chain Celo Ethereum Harmony Klaytn KuCoin Community Chain Polygon Signing a transaction When adding a Multi Token minter, you are charged a fee for the transaction, and you must sign the transaction with the private key of the blockchain address from which the fee will be deducted. Providing the private key in the API is not a secure way of signing transactions, because the private key can be stolen or exposed. Your private keys should never leave your security perimeter. You should use the private keys only for testing a solution you are building on the testnet of a blockchain. For signing transactions on the mainnet, we strongly recommend that you use the Tatum Key Management System (KMS) and provide the signature ID instead of the private key in the API. Alternatively, you can use the Tatum JavaScript client.
        /// </summary>
        /// <exception cref="Tatum.CSharp.MultiTokens.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="addMultiTokenMinter"></param>
        /// <param name="xTestnetType">Type of testnet. Defaults to Sepolia. Valid only for ETH invocations. (optional, default to ethereum-sepolia)</param>
        /// <returns>ApiResponse of TransactionHash</returns>
        public ApiResponse<TransactionHash> AddMultiTokenMinterWithHttpInfo(AddMultiTokenMinter addMultiTokenMinter, string xTestnetType = default(string))
        {
            // verify the required parameter 'addMultiTokenMinter' is set
            if (addMultiTokenMinter == null)
                throw new ApiException(400, "Missing required parameter 'addMultiTokenMinter' when calling MultiTokensOneApi->AddMultiTokenMinter");

            var localVarRequestOptions = new RequestOptions();

            var contentTypes = new string[]{
                "application/json"
            };

            // to determine the Accept header
            var accepts = new string[]{
                "application/json"
            };

            var localVarContentType = ClientUtils.SelectHeaderContentType(contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = ClientUtils.SelectHeaderAccept(accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            if (xTestnetType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("x-testnet-type", ClientUtils.ParameterToString(xTestnetType)); // header parameter
            }
            localVarRequestOptions.Data = addMultiTokenMinter;

            // authentication (X-API-Key) required
            if (!string.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("x-api-key")))
            {
                localVarRequestOptions.HeaderParameters.Add("x-api-key", Configuration.GetApiKeyWithPrefix("x-api-key"));
            }

            // make the HTTP request
            var localVarResponse = Client.Post<TransactionHash>("/v3/multitoken/mint/add", localVarRequestOptions, Configuration);

            return localVarResponse;
        }

        /// <summary>
        /// Add a Multi Token minter 2 credits per API call Add Multi Token minter. This API is supported for the following blockchains: BNB Smart Chain Celo Ethereum Harmony Klaytn KuCoin Community Chain Polygon Signing a transaction When adding a Multi Token minter, you are charged a fee for the transaction, and you must sign the transaction with the private key of the blockchain address from which the fee will be deducted. Providing the private key in the API is not a secure way of signing transactions, because the private key can be stolen or exposed. Your private keys should never leave your security perimeter. You should use the private keys only for testing a solution you are building on the testnet of a blockchain. For signing transactions on the mainnet, we strongly recommend that you use the Tatum Key Management System (KMS) and provide the signature ID instead of the private key in the API. Alternatively, you can use the Tatum JavaScript client.
        /// </summary>
        /// <exception cref="Tatum.CSharp.MultiTokens.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="addMultiTokenMinter"></param>
        /// <param name="xTestnetType">Type of testnet. Defaults to Sepolia. Valid only for ETH invocations. (optional, default to ethereum-sepolia)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of TransactionHash</returns>
        public async System.Threading.Tasks.Task<TransactionHash> AddMultiTokenMinterAsync(AddMultiTokenMinter addMultiTokenMinter, string xTestnetType = default(string), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            var localVarResponse = await AddMultiTokenMinterWithHttpInfoAsync(addMultiTokenMinter, xTestnetType, cancellationToken).ConfigureAwait(false);
            
            var exception = ExceptionFactory?.Invoke("AddMultiTokenMinter", localVarResponse);
            if (exception != null) throw exception;

            return localVarResponse.Data;
        }

        /// <summary>
        /// Add a Multi Token minter 2 credits per API call Add Multi Token minter. This API is supported for the following blockchains: BNB Smart Chain Celo Ethereum Harmony Klaytn KuCoin Community Chain Polygon Signing a transaction When adding a Multi Token minter, you are charged a fee for the transaction, and you must sign the transaction with the private key of the blockchain address from which the fee will be deducted. Providing the private key in the API is not a secure way of signing transactions, because the private key can be stolen or exposed. Your private keys should never leave your security perimeter. You should use the private keys only for testing a solution you are building on the testnet of a blockchain. For signing transactions on the mainnet, we strongly recommend that you use the Tatum Key Management System (KMS) and provide the signature ID instead of the private key in the API. Alternatively, you can use the Tatum JavaScript client.
        /// </summary>
        /// <exception cref="Tatum.CSharp.MultiTokens.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="addMultiTokenMinter"></param>
        /// <param name="xTestnetType">Type of testnet. Defaults to Sepolia. Valid only for ETH invocations. (optional, default to ethereum-sepolia)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (TransactionHash)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<TransactionHash>> AddMultiTokenMinterWithHttpInfoAsync(AddMultiTokenMinter addMultiTokenMinter, string xTestnetType = default(string), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            // verify the required parameter 'addMultiTokenMinter' is set
            if (addMultiTokenMinter == null)
                throw new ApiException(400, "Missing required parameter 'addMultiTokenMinter' when calling MultiTokensOneApi->AddMultiTokenMinter");

            var localVarRequestOptions = new RequestOptions();

            var contentTypes = new string[]{
                "application/json"
            };

            // to determine the Accept header
            var accepts = new string[]{
                "application/json"
            };


            var localVarContentType = ClientUtils.SelectHeaderContentType(contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = ClientUtils.SelectHeaderAccept(accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            if (xTestnetType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("x-testnet-type", ClientUtils.ParameterToString(xTestnetType)); // header parameter
            }
            localVarRequestOptions.Data = addMultiTokenMinter;

            // authentication (X-API-Key) required
            if (!string.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("x-api-key")))
            {
                localVarRequestOptions.HeaderParameters.Add("x-api-key", Configuration.GetApiKeyWithPrefix("x-api-key"));
            }

            // make the HTTP request

            var localVarResponse = await AsynchronousClient.PostAsync<TransactionHash>("/v3/multitoken/mint/add", localVarRequestOptions, Configuration, cancellationToken).ConfigureAwait(false);

            return localVarResponse;
        }

        /// <summary>
        /// Add a Multi Token minter 2 credits per API call Add Multi Token minter. This API is supported for the following blockchains: BNB Smart Chain Celo Ethereum Harmony Klaytn KuCoin Community Chain Polygon Signing a transaction When adding a Multi Token minter, you are charged a fee for the transaction, and you must sign the transaction with the private key of the blockchain address from which the fee will be deducted. Providing the private key in the API is not a secure way of signing transactions, because the private key can be stolen or exposed. Your private keys should never leave your security perimeter. You should use the private keys only for testing a solution you are building on the testnet of a blockchain. For signing transactions on the mainnet, we strongly recommend that you use the Tatum Key Management System (KMS) and provide the signature ID instead of the private key in the API. Alternatively, you can use the Tatum JavaScript client.
        /// </summary>
        /// <exception cref="Tatum.CSharp.MultiTokens.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="addMultiTokenMinterKMS"></param>
        /// <param name="xTestnetType">Type of testnet. Defaults to Sepolia. Valid only for ETH invocations. (optional, default to ethereum-sepolia)</param>
        /// <returns>SignatureId</returns>
        public SignatureId AddMultiTokenMinter(AddMultiTokenMinterKMS addMultiTokenMinterKMS, string xTestnetType = default(string))
        {
            var localVarResponse = AddMultiTokenMinterWithHttpInfo(addMultiTokenMinterKMS, xTestnetType);

            var exception = ExceptionFactory?.Invoke("AddMultiTokenMinter_0", localVarResponse);
            if (exception != null) throw exception;

            return localVarResponse.Data;
        }

        /// <summary>
        /// Add a Multi Token minter 2 credits per API call Add Multi Token minter. This API is supported for the following blockchains: BNB Smart Chain Celo Ethereum Harmony Klaytn KuCoin Community Chain Polygon Signing a transaction When adding a Multi Token minter, you are charged a fee for the transaction, and you must sign the transaction with the private key of the blockchain address from which the fee will be deducted. Providing the private key in the API is not a secure way of signing transactions, because the private key can be stolen or exposed. Your private keys should never leave your security perimeter. You should use the private keys only for testing a solution you are building on the testnet of a blockchain. For signing transactions on the mainnet, we strongly recommend that you use the Tatum Key Management System (KMS) and provide the signature ID instead of the private key in the API. Alternatively, you can use the Tatum JavaScript client.
        /// </summary>
        /// <exception cref="Tatum.CSharp.MultiTokens.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="addMultiTokenMinterKMS"></param>
        /// <param name="xTestnetType">Type of testnet. Defaults to Sepolia. Valid only for ETH invocations. (optional, default to ethereum-sepolia)</param>
        /// <returns>ApiResponse of SignatureId</returns>
        public ApiResponse<SignatureId> AddMultiTokenMinterWithHttpInfo(AddMultiTokenMinterKMS addMultiTokenMinterKMS, string xTestnetType = default(string))
        {
            // verify the required parameter 'addMultiTokenMinterKMS' is set
            if (addMultiTokenMinterKMS == null)
                throw new ApiException(400, "Missing required parameter 'addMultiTokenMinterKMS' when calling MultiTokensOneApi->AddMultiTokenMinter_0");

            var localVarRequestOptions = new RequestOptions();

            var contentTypes = new string[]{
                "application/json"
            };

            // to determine the Accept header
            var accepts = new string[]{
                "application/json"
            };

            var localVarContentType = ClientUtils.SelectHeaderContentType(contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = ClientUtils.SelectHeaderAccept(accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            if (xTestnetType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("x-testnet-type", ClientUtils.ParameterToString(xTestnetType)); // header parameter
            }
            localVarRequestOptions.Data = addMultiTokenMinterKMS;

            // authentication (X-API-Key) required
            if (!string.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("x-api-key")))
            {
                localVarRequestOptions.HeaderParameters.Add("x-api-key", Configuration.GetApiKeyWithPrefix("x-api-key"));
            }

            // make the HTTP request
            var localVarResponse = Client.Post<SignatureId>("/v3/multitoken/mint/add", localVarRequestOptions, Configuration);

            return localVarResponse;
        }

        /// <summary>
        /// Add a Multi Token minter 2 credits per API call Add Multi Token minter. This API is supported for the following blockchains: BNB Smart Chain Celo Ethereum Harmony Klaytn KuCoin Community Chain Polygon Signing a transaction When adding a Multi Token minter, you are charged a fee for the transaction, and you must sign the transaction with the private key of the blockchain address from which the fee will be deducted. Providing the private key in the API is not a secure way of signing transactions, because the private key can be stolen or exposed. Your private keys should never leave your security perimeter. You should use the private keys only for testing a solution you are building on the testnet of a blockchain. For signing transactions on the mainnet, we strongly recommend that you use the Tatum Key Management System (KMS) and provide the signature ID instead of the private key in the API. Alternatively, you can use the Tatum JavaScript client.
        /// </summary>
        /// <exception cref="Tatum.CSharp.MultiTokens.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="addMultiTokenMinterKMS"></param>
        /// <param name="xTestnetType">Type of testnet. Defaults to Sepolia. Valid only for ETH invocations. (optional, default to ethereum-sepolia)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of SignatureId</returns>
        public async System.Threading.Tasks.Task<SignatureId> AddMultiTokenMinterAsync(AddMultiTokenMinterKMS addMultiTokenMinterKMS, string xTestnetType = default(string), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            var localVarResponse = await AddMultiTokenMinterWithHttpInfoAsync(addMultiTokenMinterKMS, xTestnetType, cancellationToken).ConfigureAwait(false);
            
            var exception = ExceptionFactory?.Invoke("AddMultiTokenMinter_0", localVarResponse);
            if (exception != null) throw exception;

            return localVarResponse.Data;
        }

        /// <summary>
        /// Add a Multi Token minter 2 credits per API call Add Multi Token minter. This API is supported for the following blockchains: BNB Smart Chain Celo Ethereum Harmony Klaytn KuCoin Community Chain Polygon Signing a transaction When adding a Multi Token minter, you are charged a fee for the transaction, and you must sign the transaction with the private key of the blockchain address from which the fee will be deducted. Providing the private key in the API is not a secure way of signing transactions, because the private key can be stolen or exposed. Your private keys should never leave your security perimeter. You should use the private keys only for testing a solution you are building on the testnet of a blockchain. For signing transactions on the mainnet, we strongly recommend that you use the Tatum Key Management System (KMS) and provide the signature ID instead of the private key in the API. Alternatively, you can use the Tatum JavaScript client.
        /// </summary>
        /// <exception cref="Tatum.CSharp.MultiTokens.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="addMultiTokenMinterKMS"></param>
        /// <param name="xTestnetType">Type of testnet. Defaults to Sepolia. Valid only for ETH invocations. (optional, default to ethereum-sepolia)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (SignatureId)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<SignatureId>> AddMultiTokenMinterWithHttpInfoAsync(AddMultiTokenMinterKMS addMultiTokenMinterKMS, string xTestnetType = default(string), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            // verify the required parameter 'addMultiTokenMinterKMS' is set
            if (addMultiTokenMinterKMS == null)
                throw new ApiException(400, "Missing required parameter 'addMultiTokenMinterKMS' when calling MultiTokensOneApi->AddMultiTokenMinter_0");

            var localVarRequestOptions = new RequestOptions();

            var contentTypes = new string[]{
                "application/json"
            };

            // to determine the Accept header
            var accepts = new string[]{
                "application/json"
            };


            var localVarContentType = ClientUtils.SelectHeaderContentType(contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = ClientUtils.SelectHeaderAccept(accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            if (xTestnetType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("x-testnet-type", ClientUtils.ParameterToString(xTestnetType)); // header parameter
            }
            localVarRequestOptions.Data = addMultiTokenMinterKMS;

            // authentication (X-API-Key) required
            if (!string.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("x-api-key")))
            {
                localVarRequestOptions.HeaderParameters.Add("x-api-key", Configuration.GetApiKeyWithPrefix("x-api-key"));
            }

            // make the HTTP request

            var localVarResponse = await AsynchronousClient.PostAsync<SignatureId>("/v3/multitoken/mint/add", localVarRequestOptions, Configuration, cancellationToken).ConfigureAwait(false);

            return localVarResponse;
        }

        /// <summary>
        /// Burn a Multi Token 2 credits per API call Burn a fixed amount of Multi Tokens by id. This method destroys Multi Tokens from smart contract defined in contractAddress. This API is supported for the following blockchains: BNB Smart Chain Celo Ethereum Harmony Klaytn KuCoin Community Chain Polygon Signing a transaction When burning a Multi Token, you are charged a fee for the transaction, and you must sign the transaction with the private key of the blockchain address from which the fee will be deducted. Providing the private key in the API is not a secure way of signing transactions, because the private key can be stolen or exposed. Your private keys should never leave your security perimeter. You should use the private keys only for testing a solution you are building on the testnet of a blockchain. For signing transactions on the mainnet, we strongly recommend that you use the Tatum Key Management System (KMS) and provide the signature ID instead of the private key in the API. Alternatively, you can use the Tatum JavaScript client.
        /// </summary>
        /// <exception cref="Tatum.CSharp.MultiTokens.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="burnMultiToken"></param>
        /// <param name="xTestnetType">Type of testnet. Defaults to Sepolia. Valid only for ETH invocations. (optional, default to ethereum-sepolia)</param>
        /// <returns>TransactionHash</returns>
        public TransactionHash BurnMultiToken(BurnMultiToken burnMultiToken, string xTestnetType = default(string))
        {
            var localVarResponse = BurnMultiTokenWithHttpInfo(burnMultiToken, xTestnetType);

            var exception = ExceptionFactory?.Invoke("BurnMultiToken", localVarResponse);
            if (exception != null) throw exception;

            return localVarResponse.Data;
        }

        /// <summary>
        /// Burn a Multi Token 2 credits per API call Burn a fixed amount of Multi Tokens by id. This method destroys Multi Tokens from smart contract defined in contractAddress. This API is supported for the following blockchains: BNB Smart Chain Celo Ethereum Harmony Klaytn KuCoin Community Chain Polygon Signing a transaction When burning a Multi Token, you are charged a fee for the transaction, and you must sign the transaction with the private key of the blockchain address from which the fee will be deducted. Providing the private key in the API is not a secure way of signing transactions, because the private key can be stolen or exposed. Your private keys should never leave your security perimeter. You should use the private keys only for testing a solution you are building on the testnet of a blockchain. For signing transactions on the mainnet, we strongly recommend that you use the Tatum Key Management System (KMS) and provide the signature ID instead of the private key in the API. Alternatively, you can use the Tatum JavaScript client.
        /// </summary>
        /// <exception cref="Tatum.CSharp.MultiTokens.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="burnMultiToken"></param>
        /// <param name="xTestnetType">Type of testnet. Defaults to Sepolia. Valid only for ETH invocations. (optional, default to ethereum-sepolia)</param>
        /// <returns>ApiResponse of TransactionHash</returns>
        public ApiResponse<TransactionHash> BurnMultiTokenWithHttpInfo(BurnMultiToken burnMultiToken, string xTestnetType = default(string))
        {
            // verify the required parameter 'burnMultiToken' is set
            if (burnMultiToken == null)
                throw new ApiException(400, "Missing required parameter 'burnMultiToken' when calling MultiTokensOneApi->BurnMultiToken");

            var localVarRequestOptions = new RequestOptions();

            var contentTypes = new string[]{
                "application/json"
            };

            // to determine the Accept header
            var accepts = new string[]{
                "application/json"
            };

            var localVarContentType = ClientUtils.SelectHeaderContentType(contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = ClientUtils.SelectHeaderAccept(accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            if (xTestnetType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("x-testnet-type", ClientUtils.ParameterToString(xTestnetType)); // header parameter
            }
            localVarRequestOptions.Data = burnMultiToken;

            // authentication (X-API-Key) required
            if (!string.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("x-api-key")))
            {
                localVarRequestOptions.HeaderParameters.Add("x-api-key", Configuration.GetApiKeyWithPrefix("x-api-key"));
            }

            // make the HTTP request
            var localVarResponse = Client.Post<TransactionHash>("/v3/multitoken/burn", localVarRequestOptions, Configuration);

            return localVarResponse;
        }

        /// <summary>
        /// Burn a Multi Token 2 credits per API call Burn a fixed amount of Multi Tokens by id. This method destroys Multi Tokens from smart contract defined in contractAddress. This API is supported for the following blockchains: BNB Smart Chain Celo Ethereum Harmony Klaytn KuCoin Community Chain Polygon Signing a transaction When burning a Multi Token, you are charged a fee for the transaction, and you must sign the transaction with the private key of the blockchain address from which the fee will be deducted. Providing the private key in the API is not a secure way of signing transactions, because the private key can be stolen or exposed. Your private keys should never leave your security perimeter. You should use the private keys only for testing a solution you are building on the testnet of a blockchain. For signing transactions on the mainnet, we strongly recommend that you use the Tatum Key Management System (KMS) and provide the signature ID instead of the private key in the API. Alternatively, you can use the Tatum JavaScript client.
        /// </summary>
        /// <exception cref="Tatum.CSharp.MultiTokens.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="burnMultiToken"></param>
        /// <param name="xTestnetType">Type of testnet. Defaults to Sepolia. Valid only for ETH invocations. (optional, default to ethereum-sepolia)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of TransactionHash</returns>
        public async System.Threading.Tasks.Task<TransactionHash> BurnMultiTokenAsync(BurnMultiToken burnMultiToken, string xTestnetType = default(string), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            var localVarResponse = await BurnMultiTokenWithHttpInfoAsync(burnMultiToken, xTestnetType, cancellationToken).ConfigureAwait(false);
            
            var exception = ExceptionFactory?.Invoke("BurnMultiToken", localVarResponse);
            if (exception != null) throw exception;

            return localVarResponse.Data;
        }

        /// <summary>
        /// Burn a Multi Token 2 credits per API call Burn a fixed amount of Multi Tokens by id. This method destroys Multi Tokens from smart contract defined in contractAddress. This API is supported for the following blockchains: BNB Smart Chain Celo Ethereum Harmony Klaytn KuCoin Community Chain Polygon Signing a transaction When burning a Multi Token, you are charged a fee for the transaction, and you must sign the transaction with the private key of the blockchain address from which the fee will be deducted. Providing the private key in the API is not a secure way of signing transactions, because the private key can be stolen or exposed. Your private keys should never leave your security perimeter. You should use the private keys only for testing a solution you are building on the testnet of a blockchain. For signing transactions on the mainnet, we strongly recommend that you use the Tatum Key Management System (KMS) and provide the signature ID instead of the private key in the API. Alternatively, you can use the Tatum JavaScript client.
        /// </summary>
        /// <exception cref="Tatum.CSharp.MultiTokens.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="burnMultiToken"></param>
        /// <param name="xTestnetType">Type of testnet. Defaults to Sepolia. Valid only for ETH invocations. (optional, default to ethereum-sepolia)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (TransactionHash)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<TransactionHash>> BurnMultiTokenWithHttpInfoAsync(BurnMultiToken burnMultiToken, string xTestnetType = default(string), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            // verify the required parameter 'burnMultiToken' is set
            if (burnMultiToken == null)
                throw new ApiException(400, "Missing required parameter 'burnMultiToken' when calling MultiTokensOneApi->BurnMultiToken");

            var localVarRequestOptions = new RequestOptions();

            var contentTypes = new string[]{
                "application/json"
            };

            // to determine the Accept header
            var accepts = new string[]{
                "application/json"
            };


            var localVarContentType = ClientUtils.SelectHeaderContentType(contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = ClientUtils.SelectHeaderAccept(accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            if (xTestnetType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("x-testnet-type", ClientUtils.ParameterToString(xTestnetType)); // header parameter
            }
            localVarRequestOptions.Data = burnMultiToken;

            // authentication (X-API-Key) required
            if (!string.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("x-api-key")))
            {
                localVarRequestOptions.HeaderParameters.Add("x-api-key", Configuration.GetApiKeyWithPrefix("x-api-key"));
            }

            // make the HTTP request

            var localVarResponse = await AsynchronousClient.PostAsync<TransactionHash>("/v3/multitoken/burn", localVarRequestOptions, Configuration, cancellationToken).ConfigureAwait(false);

            return localVarResponse;
        }

        /// <summary>
        /// Burn multiple Multi Tokens 2 credits per API call Burn multiple Multi Token Tokens by id assigned to same address in one transaction. This method destroys any Multi Tokens token from smart contract defined in contractAddress. This API is supported for the following blockchains: BNB Smart Chain Celo Ethereum Harmony Klaytn KuCoin Community Chain Polygon Signing a transaction When burning multiple Multi Tokens, you are charged a fee for the transaction, and you must sign the transaction with the private key of the blockchain address from which the fee will be deducted. Providing the private key in the API is not a secure way of signing transactions, because the private key can be stolen or exposed. Your private keys should never leave your security perimeter. You should use the private keys only for testing a solution you are building on the testnet of a blockchain. For signing transactions on the mainnet, we strongly recommend that you use the Tatum Key Management System (KMS) and provide the signature ID instead of the private key in the API. Alternatively, you can use the Tatum JavaScript client.
        /// </summary>
        /// <exception cref="Tatum.CSharp.MultiTokens.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="burnMultiTokenBatch"></param>
        /// <param name="xTestnetType">Type of testnet. Defaults to Sepolia. Valid only for ETH invocations. (optional, default to ethereum-sepolia)</param>
        /// <returns>TransactionHash</returns>
        public TransactionHash BurnMultiTokenBatch(BurnMultiTokenBatch burnMultiTokenBatch, string xTestnetType = default(string))
        {
            var localVarResponse = BurnMultiTokenBatchWithHttpInfo(burnMultiTokenBatch, xTestnetType);

            var exception = ExceptionFactory?.Invoke("BurnMultiTokenBatch", localVarResponse);
            if (exception != null) throw exception;

            return localVarResponse.Data;
        }

        /// <summary>
        /// Burn multiple Multi Tokens 2 credits per API call Burn multiple Multi Token Tokens by id assigned to same address in one transaction. This method destroys any Multi Tokens token from smart contract defined in contractAddress. This API is supported for the following blockchains: BNB Smart Chain Celo Ethereum Harmony Klaytn KuCoin Community Chain Polygon Signing a transaction When burning multiple Multi Tokens, you are charged a fee for the transaction, and you must sign the transaction with the private key of the blockchain address from which the fee will be deducted. Providing the private key in the API is not a secure way of signing transactions, because the private key can be stolen or exposed. Your private keys should never leave your security perimeter. You should use the private keys only for testing a solution you are building on the testnet of a blockchain. For signing transactions on the mainnet, we strongly recommend that you use the Tatum Key Management System (KMS) and provide the signature ID instead of the private key in the API. Alternatively, you can use the Tatum JavaScript client.
        /// </summary>
        /// <exception cref="Tatum.CSharp.MultiTokens.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="burnMultiTokenBatch"></param>
        /// <param name="xTestnetType">Type of testnet. Defaults to Sepolia. Valid only for ETH invocations. (optional, default to ethereum-sepolia)</param>
        /// <returns>ApiResponse of TransactionHash</returns>
        public ApiResponse<TransactionHash> BurnMultiTokenBatchWithHttpInfo(BurnMultiTokenBatch burnMultiTokenBatch, string xTestnetType = default(string))
        {
            // verify the required parameter 'burnMultiTokenBatch' is set
            if (burnMultiTokenBatch == null)
                throw new ApiException(400, "Missing required parameter 'burnMultiTokenBatch' when calling MultiTokensOneApi->BurnMultiTokenBatch");

            var localVarRequestOptions = new RequestOptions();

            var contentTypes = new string[]{
                "application/json"
            };

            // to determine the Accept header
            var accepts = new string[]{
                "application/json"
            };

            var localVarContentType = ClientUtils.SelectHeaderContentType(contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = ClientUtils.SelectHeaderAccept(accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            if (xTestnetType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("x-testnet-type", ClientUtils.ParameterToString(xTestnetType)); // header parameter
            }
            localVarRequestOptions.Data = burnMultiTokenBatch;

            // authentication (X-API-Key) required
            if (!string.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("x-api-key")))
            {
                localVarRequestOptions.HeaderParameters.Add("x-api-key", Configuration.GetApiKeyWithPrefix("x-api-key"));
            }

            // make the HTTP request
            var localVarResponse = Client.Post<TransactionHash>("/v3/multitoken/burn/batch", localVarRequestOptions, Configuration);

            return localVarResponse;
        }

        /// <summary>
        /// Burn multiple Multi Tokens 2 credits per API call Burn multiple Multi Token Tokens by id assigned to same address in one transaction. This method destroys any Multi Tokens token from smart contract defined in contractAddress. This API is supported for the following blockchains: BNB Smart Chain Celo Ethereum Harmony Klaytn KuCoin Community Chain Polygon Signing a transaction When burning multiple Multi Tokens, you are charged a fee for the transaction, and you must sign the transaction with the private key of the blockchain address from which the fee will be deducted. Providing the private key in the API is not a secure way of signing transactions, because the private key can be stolen or exposed. Your private keys should never leave your security perimeter. You should use the private keys only for testing a solution you are building on the testnet of a blockchain. For signing transactions on the mainnet, we strongly recommend that you use the Tatum Key Management System (KMS) and provide the signature ID instead of the private key in the API. Alternatively, you can use the Tatum JavaScript client.
        /// </summary>
        /// <exception cref="Tatum.CSharp.MultiTokens.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="burnMultiTokenBatch"></param>
        /// <param name="xTestnetType">Type of testnet. Defaults to Sepolia. Valid only for ETH invocations. (optional, default to ethereum-sepolia)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of TransactionHash</returns>
        public async System.Threading.Tasks.Task<TransactionHash> BurnMultiTokenBatchAsync(BurnMultiTokenBatch burnMultiTokenBatch, string xTestnetType = default(string), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            var localVarResponse = await BurnMultiTokenBatchWithHttpInfoAsync(burnMultiTokenBatch, xTestnetType, cancellationToken).ConfigureAwait(false);
            
            var exception = ExceptionFactory?.Invoke("BurnMultiTokenBatch", localVarResponse);
            if (exception != null) throw exception;

            return localVarResponse.Data;
        }

        /// <summary>
        /// Burn multiple Multi Tokens 2 credits per API call Burn multiple Multi Token Tokens by id assigned to same address in one transaction. This method destroys any Multi Tokens token from smart contract defined in contractAddress. This API is supported for the following blockchains: BNB Smart Chain Celo Ethereum Harmony Klaytn KuCoin Community Chain Polygon Signing a transaction When burning multiple Multi Tokens, you are charged a fee for the transaction, and you must sign the transaction with the private key of the blockchain address from which the fee will be deducted. Providing the private key in the API is not a secure way of signing transactions, because the private key can be stolen or exposed. Your private keys should never leave your security perimeter. You should use the private keys only for testing a solution you are building on the testnet of a blockchain. For signing transactions on the mainnet, we strongly recommend that you use the Tatum Key Management System (KMS) and provide the signature ID instead of the private key in the API. Alternatively, you can use the Tatum JavaScript client.
        /// </summary>
        /// <exception cref="Tatum.CSharp.MultiTokens.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="burnMultiTokenBatch"></param>
        /// <param name="xTestnetType">Type of testnet. Defaults to Sepolia. Valid only for ETH invocations. (optional, default to ethereum-sepolia)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (TransactionHash)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<TransactionHash>> BurnMultiTokenBatchWithHttpInfoAsync(BurnMultiTokenBatch burnMultiTokenBatch, string xTestnetType = default(string), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            // verify the required parameter 'burnMultiTokenBatch' is set
            if (burnMultiTokenBatch == null)
                throw new ApiException(400, "Missing required parameter 'burnMultiTokenBatch' when calling MultiTokensOneApi->BurnMultiTokenBatch");

            var localVarRequestOptions = new RequestOptions();

            var contentTypes = new string[]{
                "application/json"
            };

            // to determine the Accept header
            var accepts = new string[]{
                "application/json"
            };


            var localVarContentType = ClientUtils.SelectHeaderContentType(contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = ClientUtils.SelectHeaderAccept(accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            if (xTestnetType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("x-testnet-type", ClientUtils.ParameterToString(xTestnetType)); // header parameter
            }
            localVarRequestOptions.Data = burnMultiTokenBatch;

            // authentication (X-API-Key) required
            if (!string.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("x-api-key")))
            {
                localVarRequestOptions.HeaderParameters.Add("x-api-key", Configuration.GetApiKeyWithPrefix("x-api-key"));
            }

            // make the HTTP request

            var localVarResponse = await AsynchronousClient.PostAsync<TransactionHash>("/v3/multitoken/burn/batch", localVarRequestOptions, Configuration, cancellationToken).ConfigureAwait(false);

            return localVarResponse;
        }

        /// <summary>
        /// Burn multiple Multi Tokens 2 credits per API call Burn multiple Multi Token Tokens by id assigned to same address in one transaction. This method destroys any Multi Tokens token from smart contract defined in contractAddress. This API is supported for the following blockchains: BNB Smart Chain Celo Ethereum Harmony Klaytn KuCoin Community Chain Polygon Signing a transaction When burning multiple Multi Tokens, you are charged a fee for the transaction, and you must sign the transaction with the private key of the blockchain address from which the fee will be deducted. Providing the private key in the API is not a secure way of signing transactions, because the private key can be stolen or exposed. Your private keys should never leave your security perimeter. You should use the private keys only for testing a solution you are building on the testnet of a blockchain. For signing transactions on the mainnet, we strongly recommend that you use the Tatum Key Management System (KMS) and provide the signature ID instead of the private key in the API. Alternatively, you can use the Tatum JavaScript client.
        /// </summary>
        /// <exception cref="Tatum.CSharp.MultiTokens.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="burnMultiTokenBatchKMS"></param>
        /// <param name="xTestnetType">Type of testnet. Defaults to Sepolia. Valid only for ETH invocations. (optional, default to ethereum-sepolia)</param>
        /// <returns>SignatureId</returns>
        public SignatureId BurnMultiTokenBatch(BurnMultiTokenBatchKMS burnMultiTokenBatchKMS, string xTestnetType = default(string))
        {
            var localVarResponse = BurnMultiTokenBatchWithHttpInfo(burnMultiTokenBatchKMS, xTestnetType);

            var exception = ExceptionFactory?.Invoke("BurnMultiTokenBatch_0", localVarResponse);
            if (exception != null) throw exception;

            return localVarResponse.Data;
        }

        /// <summary>
        /// Burn multiple Multi Tokens 2 credits per API call Burn multiple Multi Token Tokens by id assigned to same address in one transaction. This method destroys any Multi Tokens token from smart contract defined in contractAddress. This API is supported for the following blockchains: BNB Smart Chain Celo Ethereum Harmony Klaytn KuCoin Community Chain Polygon Signing a transaction When burning multiple Multi Tokens, you are charged a fee for the transaction, and you must sign the transaction with the private key of the blockchain address from which the fee will be deducted. Providing the private key in the API is not a secure way of signing transactions, because the private key can be stolen or exposed. Your private keys should never leave your security perimeter. You should use the private keys only for testing a solution you are building on the testnet of a blockchain. For signing transactions on the mainnet, we strongly recommend that you use the Tatum Key Management System (KMS) and provide the signature ID instead of the private key in the API. Alternatively, you can use the Tatum JavaScript client.
        /// </summary>
        /// <exception cref="Tatum.CSharp.MultiTokens.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="burnMultiTokenBatchKMS"></param>
        /// <param name="xTestnetType">Type of testnet. Defaults to Sepolia. Valid only for ETH invocations. (optional, default to ethereum-sepolia)</param>
        /// <returns>ApiResponse of SignatureId</returns>
        public ApiResponse<SignatureId> BurnMultiTokenBatchWithHttpInfo(BurnMultiTokenBatchKMS burnMultiTokenBatchKMS, string xTestnetType = default(string))
        {
            // verify the required parameter 'burnMultiTokenBatchKMS' is set
            if (burnMultiTokenBatchKMS == null)
                throw new ApiException(400, "Missing required parameter 'burnMultiTokenBatchKMS' when calling MultiTokensOneApi->BurnMultiTokenBatch_0");

            var localVarRequestOptions = new RequestOptions();

            var contentTypes = new string[]{
                "application/json"
            };

            // to determine the Accept header
            var accepts = new string[]{
                "application/json"
            };

            var localVarContentType = ClientUtils.SelectHeaderContentType(contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = ClientUtils.SelectHeaderAccept(accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            if (xTestnetType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("x-testnet-type", ClientUtils.ParameterToString(xTestnetType)); // header parameter
            }
            localVarRequestOptions.Data = burnMultiTokenBatchKMS;

            // authentication (X-API-Key) required
            if (!string.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("x-api-key")))
            {
                localVarRequestOptions.HeaderParameters.Add("x-api-key", Configuration.GetApiKeyWithPrefix("x-api-key"));
            }

            // make the HTTP request
            var localVarResponse = Client.Post<SignatureId>("/v3/multitoken/burn/batch", localVarRequestOptions, Configuration);

            return localVarResponse;
        }

        /// <summary>
        /// Burn multiple Multi Tokens 2 credits per API call Burn multiple Multi Token Tokens by id assigned to same address in one transaction. This method destroys any Multi Tokens token from smart contract defined in contractAddress. This API is supported for the following blockchains: BNB Smart Chain Celo Ethereum Harmony Klaytn KuCoin Community Chain Polygon Signing a transaction When burning multiple Multi Tokens, you are charged a fee for the transaction, and you must sign the transaction with the private key of the blockchain address from which the fee will be deducted. Providing the private key in the API is not a secure way of signing transactions, because the private key can be stolen or exposed. Your private keys should never leave your security perimeter. You should use the private keys only for testing a solution you are building on the testnet of a blockchain. For signing transactions on the mainnet, we strongly recommend that you use the Tatum Key Management System (KMS) and provide the signature ID instead of the private key in the API. Alternatively, you can use the Tatum JavaScript client.
        /// </summary>
        /// <exception cref="Tatum.CSharp.MultiTokens.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="burnMultiTokenBatchKMS"></param>
        /// <param name="xTestnetType">Type of testnet. Defaults to Sepolia. Valid only for ETH invocations. (optional, default to ethereum-sepolia)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of SignatureId</returns>
        public async System.Threading.Tasks.Task<SignatureId> BurnMultiTokenBatchAsync(BurnMultiTokenBatchKMS burnMultiTokenBatchKMS, string xTestnetType = default(string), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            var localVarResponse = await BurnMultiTokenBatchWithHttpInfoAsync(burnMultiTokenBatchKMS, xTestnetType, cancellationToken).ConfigureAwait(false);
            
            var exception = ExceptionFactory?.Invoke("BurnMultiTokenBatch_0", localVarResponse);
            if (exception != null) throw exception;

            return localVarResponse.Data;
        }

        /// <summary>
        /// Burn multiple Multi Tokens 2 credits per API call Burn multiple Multi Token Tokens by id assigned to same address in one transaction. This method destroys any Multi Tokens token from smart contract defined in contractAddress. This API is supported for the following blockchains: BNB Smart Chain Celo Ethereum Harmony Klaytn KuCoin Community Chain Polygon Signing a transaction When burning multiple Multi Tokens, you are charged a fee for the transaction, and you must sign the transaction with the private key of the blockchain address from which the fee will be deducted. Providing the private key in the API is not a secure way of signing transactions, because the private key can be stolen or exposed. Your private keys should never leave your security perimeter. You should use the private keys only for testing a solution you are building on the testnet of a blockchain. For signing transactions on the mainnet, we strongly recommend that you use the Tatum Key Management System (KMS) and provide the signature ID instead of the private key in the API. Alternatively, you can use the Tatum JavaScript client.
        /// </summary>
        /// <exception cref="Tatum.CSharp.MultiTokens.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="burnMultiTokenBatchKMS"></param>
        /// <param name="xTestnetType">Type of testnet. Defaults to Sepolia. Valid only for ETH invocations. (optional, default to ethereum-sepolia)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (SignatureId)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<SignatureId>> BurnMultiTokenBatchWithHttpInfoAsync(BurnMultiTokenBatchKMS burnMultiTokenBatchKMS, string xTestnetType = default(string), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            // verify the required parameter 'burnMultiTokenBatchKMS' is set
            if (burnMultiTokenBatchKMS == null)
                throw new ApiException(400, "Missing required parameter 'burnMultiTokenBatchKMS' when calling MultiTokensOneApi->BurnMultiTokenBatch_0");

            var localVarRequestOptions = new RequestOptions();

            var contentTypes = new string[]{
                "application/json"
            };

            // to determine the Accept header
            var accepts = new string[]{
                "application/json"
            };


            var localVarContentType = ClientUtils.SelectHeaderContentType(contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = ClientUtils.SelectHeaderAccept(accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            if (xTestnetType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("x-testnet-type", ClientUtils.ParameterToString(xTestnetType)); // header parameter
            }
            localVarRequestOptions.Data = burnMultiTokenBatchKMS;

            // authentication (X-API-Key) required
            if (!string.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("x-api-key")))
            {
                localVarRequestOptions.HeaderParameters.Add("x-api-key", Configuration.GetApiKeyWithPrefix("x-api-key"));
            }

            // make the HTTP request

            var localVarResponse = await AsynchronousClient.PostAsync<SignatureId>("/v3/multitoken/burn/batch", localVarRequestOptions, Configuration, cancellationToken).ConfigureAwait(false);

            return localVarResponse;
        }

        /// <summary>
        /// Burn a Multi Token 2 credits per API call Burn a fixed amount of Multi Tokens by id. This method destroys Multi Tokens from smart contract defined in contractAddress. This API is supported for the following blockchains: BNB Smart Chain Celo Ethereum Harmony Klaytn KuCoin Community Chain Polygon Signing a transaction When burning a Multi Token, you are charged a fee for the transaction, and you must sign the transaction with the private key of the blockchain address from which the fee will be deducted. Providing the private key in the API is not a secure way of signing transactions, because the private key can be stolen or exposed. Your private keys should never leave your security perimeter. You should use the private keys only for testing a solution you are building on the testnet of a blockchain. For signing transactions on the mainnet, we strongly recommend that you use the Tatum Key Management System (KMS) and provide the signature ID instead of the private key in the API. Alternatively, you can use the Tatum JavaScript client.
        /// </summary>
        /// <exception cref="Tatum.CSharp.MultiTokens.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="burnMultiTokenKMS"></param>
        /// <param name="xTestnetType">Type of testnet. Defaults to Sepolia. Valid only for ETH invocations. (optional, default to ethereum-sepolia)</param>
        /// <returns>SignatureId</returns>
        public SignatureId BurnMultiToken(BurnMultiTokenKMS burnMultiTokenKMS, string xTestnetType = default(string))
        {
            var localVarResponse = BurnMultiTokenWithHttpInfo(burnMultiTokenKMS, xTestnetType);

            var exception = ExceptionFactory?.Invoke("BurnMultiToken_0", localVarResponse);
            if (exception != null) throw exception;

            return localVarResponse.Data;
        }

        /// <summary>
        /// Burn a Multi Token 2 credits per API call Burn a fixed amount of Multi Tokens by id. This method destroys Multi Tokens from smart contract defined in contractAddress. This API is supported for the following blockchains: BNB Smart Chain Celo Ethereum Harmony Klaytn KuCoin Community Chain Polygon Signing a transaction When burning a Multi Token, you are charged a fee for the transaction, and you must sign the transaction with the private key of the blockchain address from which the fee will be deducted. Providing the private key in the API is not a secure way of signing transactions, because the private key can be stolen or exposed. Your private keys should never leave your security perimeter. You should use the private keys only for testing a solution you are building on the testnet of a blockchain. For signing transactions on the mainnet, we strongly recommend that you use the Tatum Key Management System (KMS) and provide the signature ID instead of the private key in the API. Alternatively, you can use the Tatum JavaScript client.
        /// </summary>
        /// <exception cref="Tatum.CSharp.MultiTokens.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="burnMultiTokenKMS"></param>
        /// <param name="xTestnetType">Type of testnet. Defaults to Sepolia. Valid only for ETH invocations. (optional, default to ethereum-sepolia)</param>
        /// <returns>ApiResponse of SignatureId</returns>
        public ApiResponse<SignatureId> BurnMultiTokenWithHttpInfo(BurnMultiTokenKMS burnMultiTokenKMS, string xTestnetType = default(string))
        {
            // verify the required parameter 'burnMultiTokenKMS' is set
            if (burnMultiTokenKMS == null)
                throw new ApiException(400, "Missing required parameter 'burnMultiTokenKMS' when calling MultiTokensOneApi->BurnMultiToken_0");

            var localVarRequestOptions = new RequestOptions();

            var contentTypes = new string[]{
                "application/json"
            };

            // to determine the Accept header
            var accepts = new string[]{
                "application/json"
            };

            var localVarContentType = ClientUtils.SelectHeaderContentType(contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = ClientUtils.SelectHeaderAccept(accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            if (xTestnetType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("x-testnet-type", ClientUtils.ParameterToString(xTestnetType)); // header parameter
            }
            localVarRequestOptions.Data = burnMultiTokenKMS;

            // authentication (X-API-Key) required
            if (!string.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("x-api-key")))
            {
                localVarRequestOptions.HeaderParameters.Add("x-api-key", Configuration.GetApiKeyWithPrefix("x-api-key"));
            }

            // make the HTTP request
            var localVarResponse = Client.Post<SignatureId>("/v3/multitoken/burn", localVarRequestOptions, Configuration);

            return localVarResponse;
        }

        /// <summary>
        /// Burn a Multi Token 2 credits per API call Burn a fixed amount of Multi Tokens by id. This method destroys Multi Tokens from smart contract defined in contractAddress. This API is supported for the following blockchains: BNB Smart Chain Celo Ethereum Harmony Klaytn KuCoin Community Chain Polygon Signing a transaction When burning a Multi Token, you are charged a fee for the transaction, and you must sign the transaction with the private key of the blockchain address from which the fee will be deducted. Providing the private key in the API is not a secure way of signing transactions, because the private key can be stolen or exposed. Your private keys should never leave your security perimeter. You should use the private keys only for testing a solution you are building on the testnet of a blockchain. For signing transactions on the mainnet, we strongly recommend that you use the Tatum Key Management System (KMS) and provide the signature ID instead of the private key in the API. Alternatively, you can use the Tatum JavaScript client.
        /// </summary>
        /// <exception cref="Tatum.CSharp.MultiTokens.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="burnMultiTokenKMS"></param>
        /// <param name="xTestnetType">Type of testnet. Defaults to Sepolia. Valid only for ETH invocations. (optional, default to ethereum-sepolia)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of SignatureId</returns>
        public async System.Threading.Tasks.Task<SignatureId> BurnMultiTokenAsync(BurnMultiTokenKMS burnMultiTokenKMS, string xTestnetType = default(string), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            var localVarResponse = await BurnMultiTokenWithHttpInfoAsync(burnMultiTokenKMS, xTestnetType, cancellationToken).ConfigureAwait(false);
            
            var exception = ExceptionFactory?.Invoke("BurnMultiToken_0", localVarResponse);
            if (exception != null) throw exception;

            return localVarResponse.Data;
        }

        /// <summary>
        /// Burn a Multi Token 2 credits per API call Burn a fixed amount of Multi Tokens by id. This method destroys Multi Tokens from smart contract defined in contractAddress. This API is supported for the following blockchains: BNB Smart Chain Celo Ethereum Harmony Klaytn KuCoin Community Chain Polygon Signing a transaction When burning a Multi Token, you are charged a fee for the transaction, and you must sign the transaction with the private key of the blockchain address from which the fee will be deducted. Providing the private key in the API is not a secure way of signing transactions, because the private key can be stolen or exposed. Your private keys should never leave your security perimeter. You should use the private keys only for testing a solution you are building on the testnet of a blockchain. For signing transactions on the mainnet, we strongly recommend that you use the Tatum Key Management System (KMS) and provide the signature ID instead of the private key in the API. Alternatively, you can use the Tatum JavaScript client.
        /// </summary>
        /// <exception cref="Tatum.CSharp.MultiTokens.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="burnMultiTokenKMS"></param>
        /// <param name="xTestnetType">Type of testnet. Defaults to Sepolia. Valid only for ETH invocations. (optional, default to ethereum-sepolia)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (SignatureId)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<SignatureId>> BurnMultiTokenWithHttpInfoAsync(BurnMultiTokenKMS burnMultiTokenKMS, string xTestnetType = default(string), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            // verify the required parameter 'burnMultiTokenKMS' is set
            if (burnMultiTokenKMS == null)
                throw new ApiException(400, "Missing required parameter 'burnMultiTokenKMS' when calling MultiTokensOneApi->BurnMultiToken_0");

            var localVarRequestOptions = new RequestOptions();

            var contentTypes = new string[]{
                "application/json"
            };

            // to determine the Accept header
            var accepts = new string[]{
                "application/json"
            };


            var localVarContentType = ClientUtils.SelectHeaderContentType(contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = ClientUtils.SelectHeaderAccept(accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            if (xTestnetType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("x-testnet-type", ClientUtils.ParameterToString(xTestnetType)); // header parameter
            }
            localVarRequestOptions.Data = burnMultiTokenKMS;

            // authentication (X-API-Key) required
            if (!string.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("x-api-key")))
            {
                localVarRequestOptions.HeaderParameters.Add("x-api-key", Configuration.GetApiKeyWithPrefix("x-api-key"));
            }

            // make the HTTP request

            var localVarResponse = await AsynchronousClient.PostAsync<SignatureId>("/v3/multitoken/burn", localVarRequestOptions, Configuration, cancellationToken).ConfigureAwait(false);

            return localVarResponse;
        }

        /// <summary>
        /// Deploy a Multi Token smart contract 2 credits per API call Deploy Multi Token Smart Contract. This method creates new ERC1155 Smart Contract (Multi Tokens) on the blockchain. Smart contract is standardized and audited. It is possible to mint, burn and transfer tokens. It is also possible to mint multiple tokens at once. This API is supported for the following blockchains: BNB Smart Chain Celo Ethereum Harmony Klaytn KuCoin Community Chain Polygon Signing a transaction When deploying a Multi Token smart contract, you are charged a fee for the transaction, and you must sign the transaction with the private key of the blockchain address from which the fee will be deducted. Providing the private key in the API is not a secure way of signing transactions, because the private key can be stolen or exposed. Your private keys should never leave your security perimeter. You should use the private keys only for testing a solution you are building on the testnet of a blockchain. For signing transactions on the mainnet, we strongly recommend that you use the Tatum Key Management System (KMS) and provide the signature ID instead of the private key in the API. Alternatively, you can use the Tatum JavaScript client.
        /// </summary>
        /// <exception cref="Tatum.CSharp.MultiTokens.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="deployMultiToken"></param>
        /// <param name="xTestnetType">Type of testnet. Defaults to Sepolia. Valid only for ETH invocations. (optional, default to ethereum-sepolia)</param>
        /// <returns>TransactionHash</returns>
        public TransactionHash DeployMultiToken(DeployMultiToken deployMultiToken, string xTestnetType = default(string))
        {
            var localVarResponse = DeployMultiTokenWithHttpInfo(deployMultiToken, xTestnetType);

            var exception = ExceptionFactory?.Invoke("DeployMultiToken", localVarResponse);
            if (exception != null) throw exception;

            return localVarResponse.Data;
        }

        /// <summary>
        /// Deploy a Multi Token smart contract 2 credits per API call Deploy Multi Token Smart Contract. This method creates new ERC1155 Smart Contract (Multi Tokens) on the blockchain. Smart contract is standardized and audited. It is possible to mint, burn and transfer tokens. It is also possible to mint multiple tokens at once. This API is supported for the following blockchains: BNB Smart Chain Celo Ethereum Harmony Klaytn KuCoin Community Chain Polygon Signing a transaction When deploying a Multi Token smart contract, you are charged a fee for the transaction, and you must sign the transaction with the private key of the blockchain address from which the fee will be deducted. Providing the private key in the API is not a secure way of signing transactions, because the private key can be stolen or exposed. Your private keys should never leave your security perimeter. You should use the private keys only for testing a solution you are building on the testnet of a blockchain. For signing transactions on the mainnet, we strongly recommend that you use the Tatum Key Management System (KMS) and provide the signature ID instead of the private key in the API. Alternatively, you can use the Tatum JavaScript client.
        /// </summary>
        /// <exception cref="Tatum.CSharp.MultiTokens.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="deployMultiToken"></param>
        /// <param name="xTestnetType">Type of testnet. Defaults to Sepolia. Valid only for ETH invocations. (optional, default to ethereum-sepolia)</param>
        /// <returns>ApiResponse of TransactionHash</returns>
        public ApiResponse<TransactionHash> DeployMultiTokenWithHttpInfo(DeployMultiToken deployMultiToken, string xTestnetType = default(string))
        {
            // verify the required parameter 'deployMultiToken' is set
            if (deployMultiToken == null)
                throw new ApiException(400, "Missing required parameter 'deployMultiToken' when calling MultiTokensOneApi->DeployMultiToken");

            var localVarRequestOptions = new RequestOptions();

            var contentTypes = new string[]{
                "application/json"
            };

            // to determine the Accept header
            var accepts = new string[]{
                "application/json"
            };

            var localVarContentType = ClientUtils.SelectHeaderContentType(contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = ClientUtils.SelectHeaderAccept(accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            if (xTestnetType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("x-testnet-type", ClientUtils.ParameterToString(xTestnetType)); // header parameter
            }
            localVarRequestOptions.Data = deployMultiToken;

            // authentication (X-API-Key) required
            if (!string.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("x-api-key")))
            {
                localVarRequestOptions.HeaderParameters.Add("x-api-key", Configuration.GetApiKeyWithPrefix("x-api-key"));
            }

            // make the HTTP request
            var localVarResponse = Client.Post<TransactionHash>("/v3/multitoken/deploy", localVarRequestOptions, Configuration);

            return localVarResponse;
        }

        /// <summary>
        /// Deploy a Multi Token smart contract 2 credits per API call Deploy Multi Token Smart Contract. This method creates new ERC1155 Smart Contract (Multi Tokens) on the blockchain. Smart contract is standardized and audited. It is possible to mint, burn and transfer tokens. It is also possible to mint multiple tokens at once. This API is supported for the following blockchains: BNB Smart Chain Celo Ethereum Harmony Klaytn KuCoin Community Chain Polygon Signing a transaction When deploying a Multi Token smart contract, you are charged a fee for the transaction, and you must sign the transaction with the private key of the blockchain address from which the fee will be deducted. Providing the private key in the API is not a secure way of signing transactions, because the private key can be stolen or exposed. Your private keys should never leave your security perimeter. You should use the private keys only for testing a solution you are building on the testnet of a blockchain. For signing transactions on the mainnet, we strongly recommend that you use the Tatum Key Management System (KMS) and provide the signature ID instead of the private key in the API. Alternatively, you can use the Tatum JavaScript client.
        /// </summary>
        /// <exception cref="Tatum.CSharp.MultiTokens.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="deployMultiToken"></param>
        /// <param name="xTestnetType">Type of testnet. Defaults to Sepolia. Valid only for ETH invocations. (optional, default to ethereum-sepolia)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of TransactionHash</returns>
        public async System.Threading.Tasks.Task<TransactionHash> DeployMultiTokenAsync(DeployMultiToken deployMultiToken, string xTestnetType = default(string), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            var localVarResponse = await DeployMultiTokenWithHttpInfoAsync(deployMultiToken, xTestnetType, cancellationToken).ConfigureAwait(false);
            
            var exception = ExceptionFactory?.Invoke("DeployMultiToken", localVarResponse);
            if (exception != null) throw exception;

            return localVarResponse.Data;
        }

        /// <summary>
        /// Deploy a Multi Token smart contract 2 credits per API call Deploy Multi Token Smart Contract. This method creates new ERC1155 Smart Contract (Multi Tokens) on the blockchain. Smart contract is standardized and audited. It is possible to mint, burn and transfer tokens. It is also possible to mint multiple tokens at once. This API is supported for the following blockchains: BNB Smart Chain Celo Ethereum Harmony Klaytn KuCoin Community Chain Polygon Signing a transaction When deploying a Multi Token smart contract, you are charged a fee for the transaction, and you must sign the transaction with the private key of the blockchain address from which the fee will be deducted. Providing the private key in the API is not a secure way of signing transactions, because the private key can be stolen or exposed. Your private keys should never leave your security perimeter. You should use the private keys only for testing a solution you are building on the testnet of a blockchain. For signing transactions on the mainnet, we strongly recommend that you use the Tatum Key Management System (KMS) and provide the signature ID instead of the private key in the API. Alternatively, you can use the Tatum JavaScript client.
        /// </summary>
        /// <exception cref="Tatum.CSharp.MultiTokens.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="deployMultiToken"></param>
        /// <param name="xTestnetType">Type of testnet. Defaults to Sepolia. Valid only for ETH invocations. (optional, default to ethereum-sepolia)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (TransactionHash)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<TransactionHash>> DeployMultiTokenWithHttpInfoAsync(DeployMultiToken deployMultiToken, string xTestnetType = default(string), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            // verify the required parameter 'deployMultiToken' is set
            if (deployMultiToken == null)
                throw new ApiException(400, "Missing required parameter 'deployMultiToken' when calling MultiTokensOneApi->DeployMultiToken");

            var localVarRequestOptions = new RequestOptions();

            var contentTypes = new string[]{
                "application/json"
            };

            // to determine the Accept header
            var accepts = new string[]{
                "application/json"
            };


            var localVarContentType = ClientUtils.SelectHeaderContentType(contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = ClientUtils.SelectHeaderAccept(accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            if (xTestnetType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("x-testnet-type", ClientUtils.ParameterToString(xTestnetType)); // header parameter
            }
            localVarRequestOptions.Data = deployMultiToken;

            // authentication (X-API-Key) required
            if (!string.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("x-api-key")))
            {
                localVarRequestOptions.HeaderParameters.Add("x-api-key", Configuration.GetApiKeyWithPrefix("x-api-key"));
            }

            // make the HTTP request

            var localVarResponse = await AsynchronousClient.PostAsync<TransactionHash>("/v3/multitoken/deploy", localVarRequestOptions, Configuration, cancellationToken).ConfigureAwait(false);

            return localVarResponse;
        }

        /// <summary>
        /// Deploy a Multi Token smart contract 2 credits per API call Deploy Multi Token Smart Contract. This method creates new ERC1155 Smart Contract (Multi Tokens) on the blockchain. Smart contract is standardized and audited. It is possible to mint, burn and transfer tokens. It is also possible to mint multiple tokens at once. This API is supported for the following blockchains: BNB Smart Chain Celo Ethereum Harmony Klaytn KuCoin Community Chain Polygon Signing a transaction When deploying a Multi Token smart contract, you are charged a fee for the transaction, and you must sign the transaction with the private key of the blockchain address from which the fee will be deducted. Providing the private key in the API is not a secure way of signing transactions, because the private key can be stolen or exposed. Your private keys should never leave your security perimeter. You should use the private keys only for testing a solution you are building on the testnet of a blockchain. For signing transactions on the mainnet, we strongly recommend that you use the Tatum Key Management System (KMS) and provide the signature ID instead of the private key in the API. Alternatively, you can use the Tatum JavaScript client.
        /// </summary>
        /// <exception cref="Tatum.CSharp.MultiTokens.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="deployMultiTokenKMS"></param>
        /// <param name="xTestnetType">Type of testnet. Defaults to Sepolia. Valid only for ETH invocations. (optional, default to ethereum-sepolia)</param>
        /// <returns>SignatureId</returns>
        public SignatureId DeployMultiToken(DeployMultiTokenKMS deployMultiTokenKMS, string xTestnetType = default(string))
        {
            var localVarResponse = DeployMultiTokenWithHttpInfo(deployMultiTokenKMS, xTestnetType);

            var exception = ExceptionFactory?.Invoke("DeployMultiToken_0", localVarResponse);
            if (exception != null) throw exception;

            return localVarResponse.Data;
        }

        /// <summary>
        /// Deploy a Multi Token smart contract 2 credits per API call Deploy Multi Token Smart Contract. This method creates new ERC1155 Smart Contract (Multi Tokens) on the blockchain. Smart contract is standardized and audited. It is possible to mint, burn and transfer tokens. It is also possible to mint multiple tokens at once. This API is supported for the following blockchains: BNB Smart Chain Celo Ethereum Harmony Klaytn KuCoin Community Chain Polygon Signing a transaction When deploying a Multi Token smart contract, you are charged a fee for the transaction, and you must sign the transaction with the private key of the blockchain address from which the fee will be deducted. Providing the private key in the API is not a secure way of signing transactions, because the private key can be stolen or exposed. Your private keys should never leave your security perimeter. You should use the private keys only for testing a solution you are building on the testnet of a blockchain. For signing transactions on the mainnet, we strongly recommend that you use the Tatum Key Management System (KMS) and provide the signature ID instead of the private key in the API. Alternatively, you can use the Tatum JavaScript client.
        /// </summary>
        /// <exception cref="Tatum.CSharp.MultiTokens.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="deployMultiTokenKMS"></param>
        /// <param name="xTestnetType">Type of testnet. Defaults to Sepolia. Valid only for ETH invocations. (optional, default to ethereum-sepolia)</param>
        /// <returns>ApiResponse of SignatureId</returns>
        public ApiResponse<SignatureId> DeployMultiTokenWithHttpInfo(DeployMultiTokenKMS deployMultiTokenKMS, string xTestnetType = default(string))
        {
            // verify the required parameter 'deployMultiTokenKMS' is set
            if (deployMultiTokenKMS == null)
                throw new ApiException(400, "Missing required parameter 'deployMultiTokenKMS' when calling MultiTokensOneApi->DeployMultiToken_0");

            var localVarRequestOptions = new RequestOptions();

            var contentTypes = new string[]{
                "application/json"
            };

            // to determine the Accept header
            var accepts = new string[]{
                "application/json"
            };

            var localVarContentType = ClientUtils.SelectHeaderContentType(contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = ClientUtils.SelectHeaderAccept(accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            if (xTestnetType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("x-testnet-type", ClientUtils.ParameterToString(xTestnetType)); // header parameter
            }
            localVarRequestOptions.Data = deployMultiTokenKMS;

            // authentication (X-API-Key) required
            if (!string.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("x-api-key")))
            {
                localVarRequestOptions.HeaderParameters.Add("x-api-key", Configuration.GetApiKeyWithPrefix("x-api-key"));
            }

            // make the HTTP request
            var localVarResponse = Client.Post<SignatureId>("/v3/multitoken/deploy", localVarRequestOptions, Configuration);

            return localVarResponse;
        }

        /// <summary>
        /// Deploy a Multi Token smart contract 2 credits per API call Deploy Multi Token Smart Contract. This method creates new ERC1155 Smart Contract (Multi Tokens) on the blockchain. Smart contract is standardized and audited. It is possible to mint, burn and transfer tokens. It is also possible to mint multiple tokens at once. This API is supported for the following blockchains: BNB Smart Chain Celo Ethereum Harmony Klaytn KuCoin Community Chain Polygon Signing a transaction When deploying a Multi Token smart contract, you are charged a fee for the transaction, and you must sign the transaction with the private key of the blockchain address from which the fee will be deducted. Providing the private key in the API is not a secure way of signing transactions, because the private key can be stolen or exposed. Your private keys should never leave your security perimeter. You should use the private keys only for testing a solution you are building on the testnet of a blockchain. For signing transactions on the mainnet, we strongly recommend that you use the Tatum Key Management System (KMS) and provide the signature ID instead of the private key in the API. Alternatively, you can use the Tatum JavaScript client.
        /// </summary>
        /// <exception cref="Tatum.CSharp.MultiTokens.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="deployMultiTokenKMS"></param>
        /// <param name="xTestnetType">Type of testnet. Defaults to Sepolia. Valid only for ETH invocations. (optional, default to ethereum-sepolia)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of SignatureId</returns>
        public async System.Threading.Tasks.Task<SignatureId> DeployMultiTokenAsync(DeployMultiTokenKMS deployMultiTokenKMS, string xTestnetType = default(string), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            var localVarResponse = await DeployMultiTokenWithHttpInfoAsync(deployMultiTokenKMS, xTestnetType, cancellationToken).ConfigureAwait(false);
            
            var exception = ExceptionFactory?.Invoke("DeployMultiToken_0", localVarResponse);
            if (exception != null) throw exception;

            return localVarResponse.Data;
        }

        /// <summary>
        /// Deploy a Multi Token smart contract 2 credits per API call Deploy Multi Token Smart Contract. This method creates new ERC1155 Smart Contract (Multi Tokens) on the blockchain. Smart contract is standardized and audited. It is possible to mint, burn and transfer tokens. It is also possible to mint multiple tokens at once. This API is supported for the following blockchains: BNB Smart Chain Celo Ethereum Harmony Klaytn KuCoin Community Chain Polygon Signing a transaction When deploying a Multi Token smart contract, you are charged a fee for the transaction, and you must sign the transaction with the private key of the blockchain address from which the fee will be deducted. Providing the private key in the API is not a secure way of signing transactions, because the private key can be stolen or exposed. Your private keys should never leave your security perimeter. You should use the private keys only for testing a solution you are building on the testnet of a blockchain. For signing transactions on the mainnet, we strongly recommend that you use the Tatum Key Management System (KMS) and provide the signature ID instead of the private key in the API. Alternatively, you can use the Tatum JavaScript client.
        /// </summary>
        /// <exception cref="Tatum.CSharp.MultiTokens.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="deployMultiTokenKMS"></param>
        /// <param name="xTestnetType">Type of testnet. Defaults to Sepolia. Valid only for ETH invocations. (optional, default to ethereum-sepolia)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (SignatureId)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<SignatureId>> DeployMultiTokenWithHttpInfoAsync(DeployMultiTokenKMS deployMultiTokenKMS, string xTestnetType = default(string), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            // verify the required parameter 'deployMultiTokenKMS' is set
            if (deployMultiTokenKMS == null)
                throw new ApiException(400, "Missing required parameter 'deployMultiTokenKMS' when calling MultiTokensOneApi->DeployMultiToken_0");

            var localVarRequestOptions = new RequestOptions();

            var contentTypes = new string[]{
                "application/json"
            };

            // to determine the Accept header
            var accepts = new string[]{
                "application/json"
            };


            var localVarContentType = ClientUtils.SelectHeaderContentType(contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = ClientUtils.SelectHeaderAccept(accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            if (xTestnetType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("x-testnet-type", ClientUtils.ParameterToString(xTestnetType)); // header parameter
            }
            localVarRequestOptions.Data = deployMultiTokenKMS;

            // authentication (X-API-Key) required
            if (!string.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("x-api-key")))
            {
                localVarRequestOptions.HeaderParameters.Add("x-api-key", Configuration.GetApiKeyWithPrefix("x-api-key"));
            }

            // make the HTTP request

            var localVarResponse = await AsynchronousClient.PostAsync<SignatureId>("/v3/multitoken/deploy", localVarRequestOptions, Configuration, cancellationToken).ConfigureAwait(false);

            return localVarResponse;
        }

        /// <summary>
        /// Mint a Multi Token 2 credits per API call Mint a fixed amount of Multi Token and transfer it to destination account. Create and transfer any Multi Token token from smart contract defined in contractAddress. It is possible to add Metadata to the created token with a more detailed information about instead. This API is supported for the following blockchains: BNB Smart Chain Celo Ethereum Harmony Klaytn KuCoin Community Chain Polygon Signing a transaction When minting a Multi Token, you are charged a fee for the transaction, and you must sign the transaction with the private key of the blockchain address from which the fee will be deducted. Providing the private key in the API is not a secure way of signing transactions, because the private key can be stolen or exposed. Your private keys should never leave your security perimeter. You should use the private keys only for testing a solution you are building on the testnet of a blockchain. For signing transactions on the mainnet, we strongly recommend that you use the Tatum Key Management System (KMS) and provide the signature ID instead of the private key in the API. Alternatively, you can use the Tatum JavaScript client.
        /// </summary>
        /// <exception cref="Tatum.CSharp.MultiTokens.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="mintMultiToken"></param>
        /// <param name="xTestnetType">Type of testnet. Defaults to Sepolia. Valid only for ETH invocations. (optional, default to ethereum-sepolia)</param>
        /// <returns>TransactionHash</returns>
        public TransactionHash MintMultiToken(MintMultiToken mintMultiToken, string xTestnetType = default(string))
        {
            var localVarResponse = MintMultiTokenWithHttpInfo(mintMultiToken, xTestnetType);

            var exception = ExceptionFactory?.Invoke("MintMultiToken", localVarResponse);
            if (exception != null) throw exception;

            return localVarResponse.Data;
        }

        /// <summary>
        /// Mint a Multi Token 2 credits per API call Mint a fixed amount of Multi Token and transfer it to destination account. Create and transfer any Multi Token token from smart contract defined in contractAddress. It is possible to add Metadata to the created token with a more detailed information about instead. This API is supported for the following blockchains: BNB Smart Chain Celo Ethereum Harmony Klaytn KuCoin Community Chain Polygon Signing a transaction When minting a Multi Token, you are charged a fee for the transaction, and you must sign the transaction with the private key of the blockchain address from which the fee will be deducted. Providing the private key in the API is not a secure way of signing transactions, because the private key can be stolen or exposed. Your private keys should never leave your security perimeter. You should use the private keys only for testing a solution you are building on the testnet of a blockchain. For signing transactions on the mainnet, we strongly recommend that you use the Tatum Key Management System (KMS) and provide the signature ID instead of the private key in the API. Alternatively, you can use the Tatum JavaScript client.
        /// </summary>
        /// <exception cref="Tatum.CSharp.MultiTokens.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="mintMultiToken"></param>
        /// <param name="xTestnetType">Type of testnet. Defaults to Sepolia. Valid only for ETH invocations. (optional, default to ethereum-sepolia)</param>
        /// <returns>ApiResponse of TransactionHash</returns>
        public ApiResponse<TransactionHash> MintMultiTokenWithHttpInfo(MintMultiToken mintMultiToken, string xTestnetType = default(string))
        {
            // verify the required parameter 'mintMultiToken' is set
            if (mintMultiToken == null)
                throw new ApiException(400, "Missing required parameter 'mintMultiToken' when calling MultiTokensOneApi->MintMultiToken");

            var localVarRequestOptions = new RequestOptions();

            var contentTypes = new string[]{
                "application/json"
            };

            // to determine the Accept header
            var accepts = new string[]{
                "application/json"
            };

            var localVarContentType = ClientUtils.SelectHeaderContentType(contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = ClientUtils.SelectHeaderAccept(accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            if (xTestnetType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("x-testnet-type", ClientUtils.ParameterToString(xTestnetType)); // header parameter
            }
            localVarRequestOptions.Data = mintMultiToken;

            // authentication (X-API-Key) required
            if (!string.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("x-api-key")))
            {
                localVarRequestOptions.HeaderParameters.Add("x-api-key", Configuration.GetApiKeyWithPrefix("x-api-key"));
            }

            // make the HTTP request
            var localVarResponse = Client.Post<TransactionHash>("/v3/multitoken/mint", localVarRequestOptions, Configuration);

            return localVarResponse;
        }

        /// <summary>
        /// Mint a Multi Token 2 credits per API call Mint a fixed amount of Multi Token and transfer it to destination account. Create and transfer any Multi Token token from smart contract defined in contractAddress. It is possible to add Metadata to the created token with a more detailed information about instead. This API is supported for the following blockchains: BNB Smart Chain Celo Ethereum Harmony Klaytn KuCoin Community Chain Polygon Signing a transaction When minting a Multi Token, you are charged a fee for the transaction, and you must sign the transaction with the private key of the blockchain address from which the fee will be deducted. Providing the private key in the API is not a secure way of signing transactions, because the private key can be stolen or exposed. Your private keys should never leave your security perimeter. You should use the private keys only for testing a solution you are building on the testnet of a blockchain. For signing transactions on the mainnet, we strongly recommend that you use the Tatum Key Management System (KMS) and provide the signature ID instead of the private key in the API. Alternatively, you can use the Tatum JavaScript client.
        /// </summary>
        /// <exception cref="Tatum.CSharp.MultiTokens.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="mintMultiToken"></param>
        /// <param name="xTestnetType">Type of testnet. Defaults to Sepolia. Valid only for ETH invocations. (optional, default to ethereum-sepolia)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of TransactionHash</returns>
        public async System.Threading.Tasks.Task<TransactionHash> MintMultiTokenAsync(MintMultiToken mintMultiToken, string xTestnetType = default(string), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            var localVarResponse = await MintMultiTokenWithHttpInfoAsync(mintMultiToken, xTestnetType, cancellationToken).ConfigureAwait(false);
            
            var exception = ExceptionFactory?.Invoke("MintMultiToken", localVarResponse);
            if (exception != null) throw exception;

            return localVarResponse.Data;
        }

        /// <summary>
        /// Mint a Multi Token 2 credits per API call Mint a fixed amount of Multi Token and transfer it to destination account. Create and transfer any Multi Token token from smart contract defined in contractAddress. It is possible to add Metadata to the created token with a more detailed information about instead. This API is supported for the following blockchains: BNB Smart Chain Celo Ethereum Harmony Klaytn KuCoin Community Chain Polygon Signing a transaction When minting a Multi Token, you are charged a fee for the transaction, and you must sign the transaction with the private key of the blockchain address from which the fee will be deducted. Providing the private key in the API is not a secure way of signing transactions, because the private key can be stolen or exposed. Your private keys should never leave your security perimeter. You should use the private keys only for testing a solution you are building on the testnet of a blockchain. For signing transactions on the mainnet, we strongly recommend that you use the Tatum Key Management System (KMS) and provide the signature ID instead of the private key in the API. Alternatively, you can use the Tatum JavaScript client.
        /// </summary>
        /// <exception cref="Tatum.CSharp.MultiTokens.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="mintMultiToken"></param>
        /// <param name="xTestnetType">Type of testnet. Defaults to Sepolia. Valid only for ETH invocations. (optional, default to ethereum-sepolia)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (TransactionHash)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<TransactionHash>> MintMultiTokenWithHttpInfoAsync(MintMultiToken mintMultiToken, string xTestnetType = default(string), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            // verify the required parameter 'mintMultiToken' is set
            if (mintMultiToken == null)
                throw new ApiException(400, "Missing required parameter 'mintMultiToken' when calling MultiTokensOneApi->MintMultiToken");

            var localVarRequestOptions = new RequestOptions();

            var contentTypes = new string[]{
                "application/json"
            };

            // to determine the Accept header
            var accepts = new string[]{
                "application/json"
            };


            var localVarContentType = ClientUtils.SelectHeaderContentType(contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = ClientUtils.SelectHeaderAccept(accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            if (xTestnetType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("x-testnet-type", ClientUtils.ParameterToString(xTestnetType)); // header parameter
            }
            localVarRequestOptions.Data = mintMultiToken;

            // authentication (X-API-Key) required
            if (!string.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("x-api-key")))
            {
                localVarRequestOptions.HeaderParameters.Add("x-api-key", Configuration.GetApiKeyWithPrefix("x-api-key"));
            }

            // make the HTTP request

            var localVarResponse = await AsynchronousClient.PostAsync<TransactionHash>("/v3/multitoken/mint", localVarRequestOptions, Configuration, cancellationToken).ConfigureAwait(false);

            return localVarResponse;
        }

        /// <summary>
        /// Mint multiple Multi Tokens 2 credits per API call Create a fixed amount of multiple Multi Tokens Tokens and transfer them to destination account in one transaction. Create and transfer Multi Tokens tokens from smart contract defined in contractAddress. This API is supported for the following blockchains: BNB Smart Chain Celo Ethereum Harmony Klaytn KuCoin Community Chain Polygon Signing a transaction When minting multiple Multi Tokens, you are charged a fee for the transaction, and you must sign the transaction with the private key of the blockchain address from which the fee will be deducted. Providing the private key in the API is not a secure way of signing transactions, because the private key can be stolen or exposed. Your private keys should never leave your security perimeter. You should use the private keys only for testing a solution you are building on the testnet of a blockchain. For signing transactions on the mainnet, we strongly recommend that you use the Tatum Key Management System (KMS) and provide the signature ID instead of the private key in the API. Alternatively, you can use the Tatum JavaScript client.
        /// </summary>
        /// <exception cref="Tatum.CSharp.MultiTokens.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="mintMultiTokenBatch"></param>
        /// <param name="xTestnetType">Type of testnet. Defaults to Sepolia. Valid only for ETH invocations. (optional, default to ethereum-sepolia)</param>
        /// <returns>TransactionHash</returns>
        public TransactionHash MintMultiTokenBatch(MintMultiTokenBatch mintMultiTokenBatch, string xTestnetType = default(string))
        {
            var localVarResponse = MintMultiTokenBatchWithHttpInfo(mintMultiTokenBatch, xTestnetType);

            var exception = ExceptionFactory?.Invoke("MintMultiTokenBatch", localVarResponse);
            if (exception != null) throw exception;

            return localVarResponse.Data;
        }

        /// <summary>
        /// Mint multiple Multi Tokens 2 credits per API call Create a fixed amount of multiple Multi Tokens Tokens and transfer them to destination account in one transaction. Create and transfer Multi Tokens tokens from smart contract defined in contractAddress. This API is supported for the following blockchains: BNB Smart Chain Celo Ethereum Harmony Klaytn KuCoin Community Chain Polygon Signing a transaction When minting multiple Multi Tokens, you are charged a fee for the transaction, and you must sign the transaction with the private key of the blockchain address from which the fee will be deducted. Providing the private key in the API is not a secure way of signing transactions, because the private key can be stolen or exposed. Your private keys should never leave your security perimeter. You should use the private keys only for testing a solution you are building on the testnet of a blockchain. For signing transactions on the mainnet, we strongly recommend that you use the Tatum Key Management System (KMS) and provide the signature ID instead of the private key in the API. Alternatively, you can use the Tatum JavaScript client.
        /// </summary>
        /// <exception cref="Tatum.CSharp.MultiTokens.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="mintMultiTokenBatch"></param>
        /// <param name="xTestnetType">Type of testnet. Defaults to Sepolia. Valid only for ETH invocations. (optional, default to ethereum-sepolia)</param>
        /// <returns>ApiResponse of TransactionHash</returns>
        public ApiResponse<TransactionHash> MintMultiTokenBatchWithHttpInfo(MintMultiTokenBatch mintMultiTokenBatch, string xTestnetType = default(string))
        {
            // verify the required parameter 'mintMultiTokenBatch' is set
            if (mintMultiTokenBatch == null)
                throw new ApiException(400, "Missing required parameter 'mintMultiTokenBatch' when calling MultiTokensOneApi->MintMultiTokenBatch");

            var localVarRequestOptions = new RequestOptions();

            var contentTypes = new string[]{
                "application/json"
            };

            // to determine the Accept header
            var accepts = new string[]{
                "application/json"
            };

            var localVarContentType = ClientUtils.SelectHeaderContentType(contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = ClientUtils.SelectHeaderAccept(accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            if (xTestnetType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("x-testnet-type", ClientUtils.ParameterToString(xTestnetType)); // header parameter
            }
            localVarRequestOptions.Data = mintMultiTokenBatch;

            // authentication (X-API-Key) required
            if (!string.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("x-api-key")))
            {
                localVarRequestOptions.HeaderParameters.Add("x-api-key", Configuration.GetApiKeyWithPrefix("x-api-key"));
            }

            // make the HTTP request
            var localVarResponse = Client.Post<TransactionHash>("/v3/multitoken/mint/batch", localVarRequestOptions, Configuration);

            return localVarResponse;
        }

        /// <summary>
        /// Mint multiple Multi Tokens 2 credits per API call Create a fixed amount of multiple Multi Tokens Tokens and transfer them to destination account in one transaction. Create and transfer Multi Tokens tokens from smart contract defined in contractAddress. This API is supported for the following blockchains: BNB Smart Chain Celo Ethereum Harmony Klaytn KuCoin Community Chain Polygon Signing a transaction When minting multiple Multi Tokens, you are charged a fee for the transaction, and you must sign the transaction with the private key of the blockchain address from which the fee will be deducted. Providing the private key in the API is not a secure way of signing transactions, because the private key can be stolen or exposed. Your private keys should never leave your security perimeter. You should use the private keys only for testing a solution you are building on the testnet of a blockchain. For signing transactions on the mainnet, we strongly recommend that you use the Tatum Key Management System (KMS) and provide the signature ID instead of the private key in the API. Alternatively, you can use the Tatum JavaScript client.
        /// </summary>
        /// <exception cref="Tatum.CSharp.MultiTokens.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="mintMultiTokenBatch"></param>
        /// <param name="xTestnetType">Type of testnet. Defaults to Sepolia. Valid only for ETH invocations. (optional, default to ethereum-sepolia)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of TransactionHash</returns>
        public async System.Threading.Tasks.Task<TransactionHash> MintMultiTokenBatchAsync(MintMultiTokenBatch mintMultiTokenBatch, string xTestnetType = default(string), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            var localVarResponse = await MintMultiTokenBatchWithHttpInfoAsync(mintMultiTokenBatch, xTestnetType, cancellationToken).ConfigureAwait(false);
            
            var exception = ExceptionFactory?.Invoke("MintMultiTokenBatch", localVarResponse);
            if (exception != null) throw exception;

            return localVarResponse.Data;
        }

        /// <summary>
        /// Mint multiple Multi Tokens 2 credits per API call Create a fixed amount of multiple Multi Tokens Tokens and transfer them to destination account in one transaction. Create and transfer Multi Tokens tokens from smart contract defined in contractAddress. This API is supported for the following blockchains: BNB Smart Chain Celo Ethereum Harmony Klaytn KuCoin Community Chain Polygon Signing a transaction When minting multiple Multi Tokens, you are charged a fee for the transaction, and you must sign the transaction with the private key of the blockchain address from which the fee will be deducted. Providing the private key in the API is not a secure way of signing transactions, because the private key can be stolen or exposed. Your private keys should never leave your security perimeter. You should use the private keys only for testing a solution you are building on the testnet of a blockchain. For signing transactions on the mainnet, we strongly recommend that you use the Tatum Key Management System (KMS) and provide the signature ID instead of the private key in the API. Alternatively, you can use the Tatum JavaScript client.
        /// </summary>
        /// <exception cref="Tatum.CSharp.MultiTokens.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="mintMultiTokenBatch"></param>
        /// <param name="xTestnetType">Type of testnet. Defaults to Sepolia. Valid only for ETH invocations. (optional, default to ethereum-sepolia)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (TransactionHash)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<TransactionHash>> MintMultiTokenBatchWithHttpInfoAsync(MintMultiTokenBatch mintMultiTokenBatch, string xTestnetType = default(string), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            // verify the required parameter 'mintMultiTokenBatch' is set
            if (mintMultiTokenBatch == null)
                throw new ApiException(400, "Missing required parameter 'mintMultiTokenBatch' when calling MultiTokensOneApi->MintMultiTokenBatch");

            var localVarRequestOptions = new RequestOptions();

            var contentTypes = new string[]{
                "application/json"
            };

            // to determine the Accept header
            var accepts = new string[]{
                "application/json"
            };


            var localVarContentType = ClientUtils.SelectHeaderContentType(contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = ClientUtils.SelectHeaderAccept(accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            if (xTestnetType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("x-testnet-type", ClientUtils.ParameterToString(xTestnetType)); // header parameter
            }
            localVarRequestOptions.Data = mintMultiTokenBatch;

            // authentication (X-API-Key) required
            if (!string.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("x-api-key")))
            {
                localVarRequestOptions.HeaderParameters.Add("x-api-key", Configuration.GetApiKeyWithPrefix("x-api-key"));
            }

            // make the HTTP request

            var localVarResponse = await AsynchronousClient.PostAsync<TransactionHash>("/v3/multitoken/mint/batch", localVarRequestOptions, Configuration, cancellationToken).ConfigureAwait(false);

            return localVarResponse;
        }

        /// <summary>
        /// Mint multiple Multi Tokens 2 credits per API call Create a fixed amount of multiple Multi Tokens Tokens and transfer them to destination account in one transaction. Create and transfer Multi Tokens tokens from smart contract defined in contractAddress. This API is supported for the following blockchains: BNB Smart Chain Celo Ethereum Harmony Klaytn KuCoin Community Chain Polygon Signing a transaction When minting multiple Multi Tokens, you are charged a fee for the transaction, and you must sign the transaction with the private key of the blockchain address from which the fee will be deducted. Providing the private key in the API is not a secure way of signing transactions, because the private key can be stolen or exposed. Your private keys should never leave your security perimeter. You should use the private keys only for testing a solution you are building on the testnet of a blockchain. For signing transactions on the mainnet, we strongly recommend that you use the Tatum Key Management System (KMS) and provide the signature ID instead of the private key in the API. Alternatively, you can use the Tatum JavaScript client.
        /// </summary>
        /// <exception cref="Tatum.CSharp.MultiTokens.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="mintMultiTokenBatchKMS"></param>
        /// <param name="xTestnetType">Type of testnet. Defaults to Sepolia. Valid only for ETH invocations. (optional, default to ethereum-sepolia)</param>
        /// <returns>SignatureId</returns>
        public SignatureId MintMultiTokenBatch(MintMultiTokenBatchKMS mintMultiTokenBatchKMS, string xTestnetType = default(string))
        {
            var localVarResponse = MintMultiTokenBatchWithHttpInfo(mintMultiTokenBatchKMS, xTestnetType);

            var exception = ExceptionFactory?.Invoke("MintMultiTokenBatch_0", localVarResponse);
            if (exception != null) throw exception;

            return localVarResponse.Data;
        }

        /// <summary>
        /// Mint multiple Multi Tokens 2 credits per API call Create a fixed amount of multiple Multi Tokens Tokens and transfer them to destination account in one transaction. Create and transfer Multi Tokens tokens from smart contract defined in contractAddress. This API is supported for the following blockchains: BNB Smart Chain Celo Ethereum Harmony Klaytn KuCoin Community Chain Polygon Signing a transaction When minting multiple Multi Tokens, you are charged a fee for the transaction, and you must sign the transaction with the private key of the blockchain address from which the fee will be deducted. Providing the private key in the API is not a secure way of signing transactions, because the private key can be stolen or exposed. Your private keys should never leave your security perimeter. You should use the private keys only for testing a solution you are building on the testnet of a blockchain. For signing transactions on the mainnet, we strongly recommend that you use the Tatum Key Management System (KMS) and provide the signature ID instead of the private key in the API. Alternatively, you can use the Tatum JavaScript client.
        /// </summary>
        /// <exception cref="Tatum.CSharp.MultiTokens.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="mintMultiTokenBatchKMS"></param>
        /// <param name="xTestnetType">Type of testnet. Defaults to Sepolia. Valid only for ETH invocations. (optional, default to ethereum-sepolia)</param>
        /// <returns>ApiResponse of SignatureId</returns>
        public ApiResponse<SignatureId> MintMultiTokenBatchWithHttpInfo(MintMultiTokenBatchKMS mintMultiTokenBatchKMS, string xTestnetType = default(string))
        {
            // verify the required parameter 'mintMultiTokenBatchKMS' is set
            if (mintMultiTokenBatchKMS == null)
                throw new ApiException(400, "Missing required parameter 'mintMultiTokenBatchKMS' when calling MultiTokensOneApi->MintMultiTokenBatch_0");

            var localVarRequestOptions = new RequestOptions();

            var contentTypes = new string[]{
                "application/json"
            };

            // to determine the Accept header
            var accepts = new string[]{
                "application/json"
            };

            var localVarContentType = ClientUtils.SelectHeaderContentType(contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = ClientUtils.SelectHeaderAccept(accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            if (xTestnetType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("x-testnet-type", ClientUtils.ParameterToString(xTestnetType)); // header parameter
            }
            localVarRequestOptions.Data = mintMultiTokenBatchKMS;

            // authentication (X-API-Key) required
            if (!string.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("x-api-key")))
            {
                localVarRequestOptions.HeaderParameters.Add("x-api-key", Configuration.GetApiKeyWithPrefix("x-api-key"));
            }

            // make the HTTP request
            var localVarResponse = Client.Post<SignatureId>("/v3/multitoken/mint/batch", localVarRequestOptions, Configuration);

            return localVarResponse;
        }

        /// <summary>
        /// Mint multiple Multi Tokens 2 credits per API call Create a fixed amount of multiple Multi Tokens Tokens and transfer them to destination account in one transaction. Create and transfer Multi Tokens tokens from smart contract defined in contractAddress. This API is supported for the following blockchains: BNB Smart Chain Celo Ethereum Harmony Klaytn KuCoin Community Chain Polygon Signing a transaction When minting multiple Multi Tokens, you are charged a fee for the transaction, and you must sign the transaction with the private key of the blockchain address from which the fee will be deducted. Providing the private key in the API is not a secure way of signing transactions, because the private key can be stolen or exposed. Your private keys should never leave your security perimeter. You should use the private keys only for testing a solution you are building on the testnet of a blockchain. For signing transactions on the mainnet, we strongly recommend that you use the Tatum Key Management System (KMS) and provide the signature ID instead of the private key in the API. Alternatively, you can use the Tatum JavaScript client.
        /// </summary>
        /// <exception cref="Tatum.CSharp.MultiTokens.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="mintMultiTokenBatchKMS"></param>
        /// <param name="xTestnetType">Type of testnet. Defaults to Sepolia. Valid only for ETH invocations. (optional, default to ethereum-sepolia)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of SignatureId</returns>
        public async System.Threading.Tasks.Task<SignatureId> MintMultiTokenBatchAsync(MintMultiTokenBatchKMS mintMultiTokenBatchKMS, string xTestnetType = default(string), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            var localVarResponse = await MintMultiTokenBatchWithHttpInfoAsync(mintMultiTokenBatchKMS, xTestnetType, cancellationToken).ConfigureAwait(false);
            
            var exception = ExceptionFactory?.Invoke("MintMultiTokenBatch_0", localVarResponse);
            if (exception != null) throw exception;

            return localVarResponse.Data;
        }

        /// <summary>
        /// Mint multiple Multi Tokens 2 credits per API call Create a fixed amount of multiple Multi Tokens Tokens and transfer them to destination account in one transaction. Create and transfer Multi Tokens tokens from smart contract defined in contractAddress. This API is supported for the following blockchains: BNB Smart Chain Celo Ethereum Harmony Klaytn KuCoin Community Chain Polygon Signing a transaction When minting multiple Multi Tokens, you are charged a fee for the transaction, and you must sign the transaction with the private key of the blockchain address from which the fee will be deducted. Providing the private key in the API is not a secure way of signing transactions, because the private key can be stolen or exposed. Your private keys should never leave your security perimeter. You should use the private keys only for testing a solution you are building on the testnet of a blockchain. For signing transactions on the mainnet, we strongly recommend that you use the Tatum Key Management System (KMS) and provide the signature ID instead of the private key in the API. Alternatively, you can use the Tatum JavaScript client.
        /// </summary>
        /// <exception cref="Tatum.CSharp.MultiTokens.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="mintMultiTokenBatchKMS"></param>
        /// <param name="xTestnetType">Type of testnet. Defaults to Sepolia. Valid only for ETH invocations. (optional, default to ethereum-sepolia)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (SignatureId)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<SignatureId>> MintMultiTokenBatchWithHttpInfoAsync(MintMultiTokenBatchKMS mintMultiTokenBatchKMS, string xTestnetType = default(string), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            // verify the required parameter 'mintMultiTokenBatchKMS' is set
            if (mintMultiTokenBatchKMS == null)
                throw new ApiException(400, "Missing required parameter 'mintMultiTokenBatchKMS' when calling MultiTokensOneApi->MintMultiTokenBatch_0");

            var localVarRequestOptions = new RequestOptions();

            var contentTypes = new string[]{
                "application/json"
            };

            // to determine the Accept header
            var accepts = new string[]{
                "application/json"
            };


            var localVarContentType = ClientUtils.SelectHeaderContentType(contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = ClientUtils.SelectHeaderAccept(accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            if (xTestnetType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("x-testnet-type", ClientUtils.ParameterToString(xTestnetType)); // header parameter
            }
            localVarRequestOptions.Data = mintMultiTokenBatchKMS;

            // authentication (X-API-Key) required
            if (!string.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("x-api-key")))
            {
                localVarRequestOptions.HeaderParameters.Add("x-api-key", Configuration.GetApiKeyWithPrefix("x-api-key"));
            }

            // make the HTTP request

            var localVarResponse = await AsynchronousClient.PostAsync<SignatureId>("/v3/multitoken/mint/batch", localVarRequestOptions, Configuration, cancellationToken).ConfigureAwait(false);

            return localVarResponse;
        }

        /// <summary>
        /// Mint a Multi Token 2 credits per API call Mint a fixed amount of Multi Token and transfer it to destination account. Create and transfer any Multi Token token from smart contract defined in contractAddress. It is possible to add Metadata to the created token with a more detailed information about instead. This API is supported for the following blockchains: BNB Smart Chain Celo Ethereum Harmony Klaytn KuCoin Community Chain Polygon Signing a transaction When minting a Multi Token, you are charged a fee for the transaction, and you must sign the transaction with the private key of the blockchain address from which the fee will be deducted. Providing the private key in the API is not a secure way of signing transactions, because the private key can be stolen or exposed. Your private keys should never leave your security perimeter. You should use the private keys only for testing a solution you are building on the testnet of a blockchain. For signing transactions on the mainnet, we strongly recommend that you use the Tatum Key Management System (KMS) and provide the signature ID instead of the private key in the API. Alternatively, you can use the Tatum JavaScript client.
        /// </summary>
        /// <exception cref="Tatum.CSharp.MultiTokens.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="mintMultiTokenKMS"></param>
        /// <param name="xTestnetType">Type of testnet. Defaults to Sepolia. Valid only for ETH invocations. (optional, default to ethereum-sepolia)</param>
        /// <returns>SignatureId</returns>
        public SignatureId MintMultiToken(MintMultiTokenKMS mintMultiTokenKMS, string xTestnetType = default(string))
        {
            var localVarResponse = MintMultiTokenWithHttpInfo(mintMultiTokenKMS, xTestnetType);

            var exception = ExceptionFactory?.Invoke("MintMultiToken_0", localVarResponse);
            if (exception != null) throw exception;

            return localVarResponse.Data;
        }

        /// <summary>
        /// Mint a Multi Token 2 credits per API call Mint a fixed amount of Multi Token and transfer it to destination account. Create and transfer any Multi Token token from smart contract defined in contractAddress. It is possible to add Metadata to the created token with a more detailed information about instead. This API is supported for the following blockchains: BNB Smart Chain Celo Ethereum Harmony Klaytn KuCoin Community Chain Polygon Signing a transaction When minting a Multi Token, you are charged a fee for the transaction, and you must sign the transaction with the private key of the blockchain address from which the fee will be deducted. Providing the private key in the API is not a secure way of signing transactions, because the private key can be stolen or exposed. Your private keys should never leave your security perimeter. You should use the private keys only for testing a solution you are building on the testnet of a blockchain. For signing transactions on the mainnet, we strongly recommend that you use the Tatum Key Management System (KMS) and provide the signature ID instead of the private key in the API. Alternatively, you can use the Tatum JavaScript client.
        /// </summary>
        /// <exception cref="Tatum.CSharp.MultiTokens.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="mintMultiTokenKMS"></param>
        /// <param name="xTestnetType">Type of testnet. Defaults to Sepolia. Valid only for ETH invocations. (optional, default to ethereum-sepolia)</param>
        /// <returns>ApiResponse of SignatureId</returns>
        public ApiResponse<SignatureId> MintMultiTokenWithHttpInfo(MintMultiTokenKMS mintMultiTokenKMS, string xTestnetType = default(string))
        {
            // verify the required parameter 'mintMultiTokenKMS' is set
            if (mintMultiTokenKMS == null)
                throw new ApiException(400, "Missing required parameter 'mintMultiTokenKMS' when calling MultiTokensOneApi->MintMultiToken_0");

            var localVarRequestOptions = new RequestOptions();

            var contentTypes = new string[]{
                "application/json"
            };

            // to determine the Accept header
            var accepts = new string[]{
                "application/json"
            };

            var localVarContentType = ClientUtils.SelectHeaderContentType(contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = ClientUtils.SelectHeaderAccept(accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            if (xTestnetType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("x-testnet-type", ClientUtils.ParameterToString(xTestnetType)); // header parameter
            }
            localVarRequestOptions.Data = mintMultiTokenKMS;

            // authentication (X-API-Key) required
            if (!string.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("x-api-key")))
            {
                localVarRequestOptions.HeaderParameters.Add("x-api-key", Configuration.GetApiKeyWithPrefix("x-api-key"));
            }

            // make the HTTP request
            var localVarResponse = Client.Post<SignatureId>("/v3/multitoken/mint", localVarRequestOptions, Configuration);

            return localVarResponse;
        }

        /// <summary>
        /// Mint a Multi Token 2 credits per API call Mint a fixed amount of Multi Token and transfer it to destination account. Create and transfer any Multi Token token from smart contract defined in contractAddress. It is possible to add Metadata to the created token with a more detailed information about instead. This API is supported for the following blockchains: BNB Smart Chain Celo Ethereum Harmony Klaytn KuCoin Community Chain Polygon Signing a transaction When minting a Multi Token, you are charged a fee for the transaction, and you must sign the transaction with the private key of the blockchain address from which the fee will be deducted. Providing the private key in the API is not a secure way of signing transactions, because the private key can be stolen or exposed. Your private keys should never leave your security perimeter. You should use the private keys only for testing a solution you are building on the testnet of a blockchain. For signing transactions on the mainnet, we strongly recommend that you use the Tatum Key Management System (KMS) and provide the signature ID instead of the private key in the API. Alternatively, you can use the Tatum JavaScript client.
        /// </summary>
        /// <exception cref="Tatum.CSharp.MultiTokens.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="mintMultiTokenKMS"></param>
        /// <param name="xTestnetType">Type of testnet. Defaults to Sepolia. Valid only for ETH invocations. (optional, default to ethereum-sepolia)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of SignatureId</returns>
        public async System.Threading.Tasks.Task<SignatureId> MintMultiTokenAsync(MintMultiTokenKMS mintMultiTokenKMS, string xTestnetType = default(string), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            var localVarResponse = await MintMultiTokenWithHttpInfoAsync(mintMultiTokenKMS, xTestnetType, cancellationToken).ConfigureAwait(false);
            
            var exception = ExceptionFactory?.Invoke("MintMultiToken_0", localVarResponse);
            if (exception != null) throw exception;

            return localVarResponse.Data;
        }

        /// <summary>
        /// Mint a Multi Token 2 credits per API call Mint a fixed amount of Multi Token and transfer it to destination account. Create and transfer any Multi Token token from smart contract defined in contractAddress. It is possible to add Metadata to the created token with a more detailed information about instead. This API is supported for the following blockchains: BNB Smart Chain Celo Ethereum Harmony Klaytn KuCoin Community Chain Polygon Signing a transaction When minting a Multi Token, you are charged a fee for the transaction, and you must sign the transaction with the private key of the blockchain address from which the fee will be deducted. Providing the private key in the API is not a secure way of signing transactions, because the private key can be stolen or exposed. Your private keys should never leave your security perimeter. You should use the private keys only for testing a solution you are building on the testnet of a blockchain. For signing transactions on the mainnet, we strongly recommend that you use the Tatum Key Management System (KMS) and provide the signature ID instead of the private key in the API. Alternatively, you can use the Tatum JavaScript client.
        /// </summary>
        /// <exception cref="Tatum.CSharp.MultiTokens.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="mintMultiTokenKMS"></param>
        /// <param name="xTestnetType">Type of testnet. Defaults to Sepolia. Valid only for ETH invocations. (optional, default to ethereum-sepolia)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (SignatureId)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<SignatureId>> MintMultiTokenWithHttpInfoAsync(MintMultiTokenKMS mintMultiTokenKMS, string xTestnetType = default(string), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            // verify the required parameter 'mintMultiTokenKMS' is set
            if (mintMultiTokenKMS == null)
                throw new ApiException(400, "Missing required parameter 'mintMultiTokenKMS' when calling MultiTokensOneApi->MintMultiToken_0");

            var localVarRequestOptions = new RequestOptions();

            var contentTypes = new string[]{
                "application/json"
            };

            // to determine the Accept header
            var accepts = new string[]{
                "application/json"
            };


            var localVarContentType = ClientUtils.SelectHeaderContentType(contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = ClientUtils.SelectHeaderAccept(accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            if (xTestnetType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("x-testnet-type", ClientUtils.ParameterToString(xTestnetType)); // header parameter
            }
            localVarRequestOptions.Data = mintMultiTokenKMS;

            // authentication (X-API-Key) required
            if (!string.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("x-api-key")))
            {
                localVarRequestOptions.HeaderParameters.Add("x-api-key", Configuration.GetApiKeyWithPrefix("x-api-key"));
            }

            // make the HTTP request

            var localVarResponse = await AsynchronousClient.PostAsync<SignatureId>("/v3/multitoken/mint", localVarRequestOptions, Configuration, cancellationToken).ConfigureAwait(false);

            return localVarResponse;
        }

        /// <summary>
        /// Get the amount of a specific MultiToken that a blockchain address holds 1 credit per API call Get the amount of a specific Multi Token (minted on the smart contract specified by the contractAddress path parameter in the request endpoint URL) that a blockchain address holds. This API is supported for the following blockchains: BNB Smart Chain Celo Ethereum Harmony Klaytn KuCoin Community Chain Polygon
        /// </summary>
        /// <exception cref="Tatum.CSharp.MultiTokens.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="address">The blockchain address that you want to get the token balance of</param>
        /// <param name="contractAddress">The address of the Multi Token smart contract</param>
        /// <param name="tokenId">The ID of the Multi Token</param>
        /// <param name="xTestnetType">Type of testnet. Defaults to Sepolia. Valid only for ETH invocations. (optional, default to ethereum-sepolia)</param>
        /// <returns>MultiTokenBalanceValue</returns>
        public MultiTokenBalanceValue MultiTokenGetBalance(string address, string contractAddress, string tokenId, string xTestnetType = default(string))
        {
            var localVarResponse = MultiTokenGetBalanceWithHttpInfo(address, contractAddress, tokenId, xTestnetType);

            var exception = ExceptionFactory?.Invoke("MultiTokenGetBalance", localVarResponse);
            if (exception != null) throw exception;

            return localVarResponse.Data;
        }

        /// <summary>
        /// Get the amount of a specific MultiToken that a blockchain address holds 1 credit per API call Get the amount of a specific Multi Token (minted on the smart contract specified by the contractAddress path parameter in the request endpoint URL) that a blockchain address holds. This API is supported for the following blockchains: BNB Smart Chain Celo Ethereum Harmony Klaytn KuCoin Community Chain Polygon
        /// </summary>
        /// <exception cref="Tatum.CSharp.MultiTokens.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="address">The blockchain address that you want to get the token balance of</param>
        /// <param name="contractAddress">The address of the Multi Token smart contract</param>
        /// <param name="tokenId">The ID of the Multi Token</param>
        /// <param name="xTestnetType">Type of testnet. Defaults to Sepolia. Valid only for ETH invocations. (optional, default to ethereum-sepolia)</param>
        /// <returns>ApiResponse of MultiTokenBalanceValue</returns>
        public ApiResponse<MultiTokenBalanceValue> MultiTokenGetBalanceWithHttpInfo(string address, string contractAddress, string tokenId, string xTestnetType = default(string))
        {
            // verify the required parameter 'address' is set
            if (address == null)
                throw new ApiException(400, "Missing required parameter 'address' when calling MultiTokensOneApi->MultiTokenGetBalance");

            // verify the required parameter 'contractAddress' is set
            if (contractAddress == null)
                throw new ApiException(400, "Missing required parameter 'contractAddress' when calling MultiTokensOneApi->MultiTokenGetBalance");

            // verify the required parameter 'tokenId' is set
            if (tokenId == null)
                throw new ApiException(400, "Missing required parameter 'tokenId' when calling MultiTokensOneApi->MultiTokenGetBalance");

            var localVarRequestOptions = new RequestOptions();

            var contentTypes = new string[]{
            };

            // to determine the Accept header
            var accepts = new string[]{
                "application/json"
            };

            var localVarContentType = ClientUtils.SelectHeaderContentType(contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = ClientUtils.SelectHeaderAccept(accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.PathParameters.Add("address", ClientUtils.ParameterToString(address)); // path parameter
            localVarRequestOptions.PathParameters.Add("contractAddress", ClientUtils.ParameterToString(contractAddress)); // path parameter
            localVarRequestOptions.PathParameters.Add("tokenId", ClientUtils.ParameterToString(tokenId)); // path parameter
            if (xTestnetType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("x-testnet-type", ClientUtils.ParameterToString(xTestnetType)); // header parameter
            }

            // authentication (X-API-Key) required
            if (!string.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("x-api-key")))
            {
                localVarRequestOptions.HeaderParameters.Add("x-api-key", Configuration.GetApiKeyWithPrefix("x-api-key"));
            }

            // make the HTTP request
            var localVarResponse = Client.Get<MultiTokenBalanceValue>("/v3/multitoken/balance/ONE/{contractAddress}/{address}/{tokenId}", localVarRequestOptions, Configuration);

            return localVarResponse;
        }

        /// <summary>
        /// Get the amount of a specific MultiToken that a blockchain address holds 1 credit per API call Get the amount of a specific Multi Token (minted on the smart contract specified by the contractAddress path parameter in the request endpoint URL) that a blockchain address holds. This API is supported for the following blockchains: BNB Smart Chain Celo Ethereum Harmony Klaytn KuCoin Community Chain Polygon
        /// </summary>
        /// <exception cref="Tatum.CSharp.MultiTokens.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="address">The blockchain address that you want to get the token balance of</param>
        /// <param name="contractAddress">The address of the Multi Token smart contract</param>
        /// <param name="tokenId">The ID of the Multi Token</param>
        /// <param name="xTestnetType">Type of testnet. Defaults to Sepolia. Valid only for ETH invocations. (optional, default to ethereum-sepolia)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of MultiTokenBalanceValue</returns>
        public async System.Threading.Tasks.Task<MultiTokenBalanceValue> MultiTokenGetBalanceAsync(string address, string contractAddress, string tokenId, string xTestnetType = default(string), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            var localVarResponse = await MultiTokenGetBalanceWithHttpInfoAsync(address, contractAddress, tokenId, xTestnetType, cancellationToken).ConfigureAwait(false);
            
            var exception = ExceptionFactory?.Invoke("MultiTokenGetBalance", localVarResponse);
            if (exception != null) throw exception;

            return localVarResponse.Data;
        }

        /// <summary>
        /// Get the amount of a specific MultiToken that a blockchain address holds 1 credit per API call Get the amount of a specific Multi Token (minted on the smart contract specified by the contractAddress path parameter in the request endpoint URL) that a blockchain address holds. This API is supported for the following blockchains: BNB Smart Chain Celo Ethereum Harmony Klaytn KuCoin Community Chain Polygon
        /// </summary>
        /// <exception cref="Tatum.CSharp.MultiTokens.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="address">The blockchain address that you want to get the token balance of</param>
        /// <param name="contractAddress">The address of the Multi Token smart contract</param>
        /// <param name="tokenId">The ID of the Multi Token</param>
        /// <param name="xTestnetType">Type of testnet. Defaults to Sepolia. Valid only for ETH invocations. (optional, default to ethereum-sepolia)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (MultiTokenBalanceValue)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<MultiTokenBalanceValue>> MultiTokenGetBalanceWithHttpInfoAsync(string address, string contractAddress, string tokenId, string xTestnetType = default(string), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            // verify the required parameter 'address' is set
            if (address == null)
                throw new ApiException(400, "Missing required parameter 'address' when calling MultiTokensOneApi->MultiTokenGetBalance");

            // verify the required parameter 'contractAddress' is set
            if (contractAddress == null)
                throw new ApiException(400, "Missing required parameter 'contractAddress' when calling MultiTokensOneApi->MultiTokenGetBalance");

            // verify the required parameter 'tokenId' is set
            if (tokenId == null)
                throw new ApiException(400, "Missing required parameter 'tokenId' when calling MultiTokensOneApi->MultiTokenGetBalance");

            var localVarRequestOptions = new RequestOptions();

            var contentTypes = new string[]{
            };

            // to determine the Accept header
            var accepts = new string[]{
                "application/json"
            };


            var localVarContentType = ClientUtils.SelectHeaderContentType(contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = ClientUtils.SelectHeaderAccept(accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.PathParameters.Add("address", ClientUtils.ParameterToString(address)); // path parameter
            localVarRequestOptions.PathParameters.Add("contractAddress", ClientUtils.ParameterToString(contractAddress)); // path parameter
            localVarRequestOptions.PathParameters.Add("tokenId", ClientUtils.ParameterToString(tokenId)); // path parameter
            if (xTestnetType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("x-testnet-type", ClientUtils.ParameterToString(xTestnetType)); // header parameter
            }

            // authentication (X-API-Key) required
            if (!string.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("x-api-key")))
            {
                localVarRequestOptions.HeaderParameters.Add("x-api-key", Configuration.GetApiKeyWithPrefix("x-api-key"));
            }

            // make the HTTP request

            var localVarResponse = await AsynchronousClient.GetAsync<MultiTokenBalanceValue>("/v3/multitoken/balance/ONE/{contractAddress}/{address}/{tokenId}", localVarRequestOptions, Configuration, cancellationToken).ConfigureAwait(false);

            return localVarResponse;
        }

        /// <summary>
        /// Get the amount of one or multiple Multi Tokens for multiple blockchain addresses 1 credit per API call For multiple blockchain addresses, get the amount of one or multiple Multi Tokens (minted on the smart contract specified by the contractAddress path parameter in the request endpoint URL) that those addresses hold. This API is supported for the following blockchains: BNB Smart Chain Celo Ethereum Harmony Klaytn KuCoin Community Chain Polygon
        /// </summary>
        /// <exception cref="Tatum.CSharp.MultiTokens.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="contractAddress">The address of the Multi Token smart contract</param>
        /// <param name="tokenId">Comma-separated IDs of the Multi Tokens to get the amounts for</param>
        /// <param name="address">Comma-separated blockchain addresses to get the token balance for</param>
        /// <param name="xTestnetType">Type of testnet. Defaults to Sepolia. Valid only for ETH invocations. (optional, default to ethereum-sepolia)</param>
        /// <returns>MultiTokenBalanceBatch</returns>
        public MultiTokenBalanceBatch MultiTokenGetBalanceBatch(string contractAddress, string tokenId, string address, string xTestnetType = default(string))
        {
            var localVarResponse = MultiTokenGetBalanceBatchWithHttpInfo(contractAddress, tokenId, address, xTestnetType);

            var exception = ExceptionFactory?.Invoke("MultiTokenGetBalanceBatch", localVarResponse);
            if (exception != null) throw exception;

            return localVarResponse.Data;
        }

        /// <summary>
        /// Get the amount of one or multiple Multi Tokens for multiple blockchain addresses 1 credit per API call For multiple blockchain addresses, get the amount of one or multiple Multi Tokens (minted on the smart contract specified by the contractAddress path parameter in the request endpoint URL) that those addresses hold. This API is supported for the following blockchains: BNB Smart Chain Celo Ethereum Harmony Klaytn KuCoin Community Chain Polygon
        /// </summary>
        /// <exception cref="Tatum.CSharp.MultiTokens.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="contractAddress">The address of the Multi Token smart contract</param>
        /// <param name="tokenId">Comma-separated IDs of the Multi Tokens to get the amounts for</param>
        /// <param name="address">Comma-separated blockchain addresses to get the token balance for</param>
        /// <param name="xTestnetType">Type of testnet. Defaults to Sepolia. Valid only for ETH invocations. (optional, default to ethereum-sepolia)</param>
        /// <returns>ApiResponse of MultiTokenBalanceBatch</returns>
        public ApiResponse<MultiTokenBalanceBatch> MultiTokenGetBalanceBatchWithHttpInfo(string contractAddress, string tokenId, string address, string xTestnetType = default(string))
        {
            // verify the required parameter 'contractAddress' is set
            if (contractAddress == null)
                throw new ApiException(400, "Missing required parameter 'contractAddress' when calling MultiTokensOneApi->MultiTokenGetBalanceBatch");

            // verify the required parameter 'tokenId' is set
            if (tokenId == null)
                throw new ApiException(400, "Missing required parameter 'tokenId' when calling MultiTokensOneApi->MultiTokenGetBalanceBatch");

            // verify the required parameter 'address' is set
            if (address == null)
                throw new ApiException(400, "Missing required parameter 'address' when calling MultiTokensOneApi->MultiTokenGetBalanceBatch");

            var localVarRequestOptions = new RequestOptions();

            var contentTypes = new string[]{
            };

            // to determine the Accept header
            var accepts = new string[]{
                "application/json"
            };

            var localVarContentType = ClientUtils.SelectHeaderContentType(contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = ClientUtils.SelectHeaderAccept(accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.PathParameters.Add("contractAddress", ClientUtils.ParameterToString(contractAddress)); // path parameter
            localVarRequestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "tokenId", tokenId));
            localVarRequestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "address", address));
            if (xTestnetType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("x-testnet-type", ClientUtils.ParameterToString(xTestnetType)); // header parameter
            }

            // authentication (X-API-Key) required
            if (!string.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("x-api-key")))
            {
                localVarRequestOptions.HeaderParameters.Add("x-api-key", Configuration.GetApiKeyWithPrefix("x-api-key"));
            }

            // make the HTTP request
            var localVarResponse = Client.Get<MultiTokenBalanceBatch>("/v3/multitoken/balance/batch/ONE/{contractAddress}", localVarRequestOptions, Configuration);

            return localVarResponse;
        }

        /// <summary>
        /// Get the amount of one or multiple Multi Tokens for multiple blockchain addresses 1 credit per API call For multiple blockchain addresses, get the amount of one or multiple Multi Tokens (minted on the smart contract specified by the contractAddress path parameter in the request endpoint URL) that those addresses hold. This API is supported for the following blockchains: BNB Smart Chain Celo Ethereum Harmony Klaytn KuCoin Community Chain Polygon
        /// </summary>
        /// <exception cref="Tatum.CSharp.MultiTokens.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="contractAddress">The address of the Multi Token smart contract</param>
        /// <param name="tokenId">Comma-separated IDs of the Multi Tokens to get the amounts for</param>
        /// <param name="address">Comma-separated blockchain addresses to get the token balance for</param>
        /// <param name="xTestnetType">Type of testnet. Defaults to Sepolia. Valid only for ETH invocations. (optional, default to ethereum-sepolia)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of MultiTokenBalanceBatch</returns>
        public async System.Threading.Tasks.Task<MultiTokenBalanceBatch> MultiTokenGetBalanceBatchAsync(string contractAddress, string tokenId, string address, string xTestnetType = default(string), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            var localVarResponse = await MultiTokenGetBalanceBatchWithHttpInfoAsync(contractAddress, tokenId, address, xTestnetType, cancellationToken).ConfigureAwait(false);
            
            var exception = ExceptionFactory?.Invoke("MultiTokenGetBalanceBatch", localVarResponse);
            if (exception != null) throw exception;

            return localVarResponse.Data;
        }

        /// <summary>
        /// Get the amount of one or multiple Multi Tokens for multiple blockchain addresses 1 credit per API call For multiple blockchain addresses, get the amount of one or multiple Multi Tokens (minted on the smart contract specified by the contractAddress path parameter in the request endpoint URL) that those addresses hold. This API is supported for the following blockchains: BNB Smart Chain Celo Ethereum Harmony Klaytn KuCoin Community Chain Polygon
        /// </summary>
        /// <exception cref="Tatum.CSharp.MultiTokens.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="contractAddress">The address of the Multi Token smart contract</param>
        /// <param name="tokenId">Comma-separated IDs of the Multi Tokens to get the amounts for</param>
        /// <param name="address">Comma-separated blockchain addresses to get the token balance for</param>
        /// <param name="xTestnetType">Type of testnet. Defaults to Sepolia. Valid only for ETH invocations. (optional, default to ethereum-sepolia)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (MultiTokenBalanceBatch)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<MultiTokenBalanceBatch>> MultiTokenGetBalanceBatchWithHttpInfoAsync(string contractAddress, string tokenId, string address, string xTestnetType = default(string), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            // verify the required parameter 'contractAddress' is set
            if (contractAddress == null)
                throw new ApiException(400, "Missing required parameter 'contractAddress' when calling MultiTokensOneApi->MultiTokenGetBalanceBatch");

            // verify the required parameter 'tokenId' is set
            if (tokenId == null)
                throw new ApiException(400, "Missing required parameter 'tokenId' when calling MultiTokensOneApi->MultiTokenGetBalanceBatch");

            // verify the required parameter 'address' is set
            if (address == null)
                throw new ApiException(400, "Missing required parameter 'address' when calling MultiTokensOneApi->MultiTokenGetBalanceBatch");

            var localVarRequestOptions = new RequestOptions();

            var contentTypes = new string[]{
            };

            // to determine the Accept header
            var accepts = new string[]{
                "application/json"
            };


            var localVarContentType = ClientUtils.SelectHeaderContentType(contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = ClientUtils.SelectHeaderAccept(accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.PathParameters.Add("contractAddress", ClientUtils.ParameterToString(contractAddress)); // path parameter
            localVarRequestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "tokenId", tokenId));
            localVarRequestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "address", address));
            if (xTestnetType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("x-testnet-type", ClientUtils.ParameterToString(xTestnetType)); // header parameter
            }

            // authentication (X-API-Key) required
            if (!string.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("x-api-key")))
            {
                localVarRequestOptions.HeaderParameters.Add("x-api-key", Configuration.GetApiKeyWithPrefix("x-api-key"));
            }

            // make the HTTP request

            var localVarResponse = await AsynchronousClient.GetAsync<MultiTokenBalanceBatch>("/v3/multitoken/balance/batch/ONE/{contractAddress}", localVarRequestOptions, Configuration, cancellationToken).ConfigureAwait(false);

            return localVarResponse;
        }

        /// <summary>
        /// Get Multi Token metadata 1 credit per API call Get Multi Token metadata. This API is supported for the following blockchains: BNB Smart Chain Celo Ethereum Harmony Klaytn KuCoin Community Chain Polygon
        /// </summary>
        /// <exception cref="Tatum.CSharp.MultiTokens.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="token">Token ID</param>
        /// <param name="contractAddress">Multi Token contract address</param>
        /// <param name="xTestnetType">Type of testnet. Defaults to Sepolia. Valid only for ETH invocations. (optional, default to ethereum-sepolia)</param>
        /// <returns>MultiTokenMetadata</returns>
        public MultiTokenMetadata MultiTokenGetMetadata(string token, string contractAddress, string xTestnetType = default(string))
        {
            var localVarResponse = MultiTokenGetMetadataWithHttpInfo(token, contractAddress, xTestnetType);

            var exception = ExceptionFactory?.Invoke("MultiTokenGetMetadata", localVarResponse);
            if (exception != null) throw exception;

            return localVarResponse.Data;
        }

        /// <summary>
        /// Get Multi Token metadata 1 credit per API call Get Multi Token metadata. This API is supported for the following blockchains: BNB Smart Chain Celo Ethereum Harmony Klaytn KuCoin Community Chain Polygon
        /// </summary>
        /// <exception cref="Tatum.CSharp.MultiTokens.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="token">Token ID</param>
        /// <param name="contractAddress">Multi Token contract address</param>
        /// <param name="xTestnetType">Type of testnet. Defaults to Sepolia. Valid only for ETH invocations. (optional, default to ethereum-sepolia)</param>
        /// <returns>ApiResponse of MultiTokenMetadata</returns>
        public ApiResponse<MultiTokenMetadata> MultiTokenGetMetadataWithHttpInfo(string token, string contractAddress, string xTestnetType = default(string))
        {
            // verify the required parameter 'token' is set
            if (token == null)
                throw new ApiException(400, "Missing required parameter 'token' when calling MultiTokensOneApi->MultiTokenGetMetadata");

            // verify the required parameter 'contractAddress' is set
            if (contractAddress == null)
                throw new ApiException(400, "Missing required parameter 'contractAddress' when calling MultiTokensOneApi->MultiTokenGetMetadata");

            var localVarRequestOptions = new RequestOptions();

            var contentTypes = new string[]{
            };

            // to determine the Accept header
            var accepts = new string[]{
                "application/json"
            };

            var localVarContentType = ClientUtils.SelectHeaderContentType(contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = ClientUtils.SelectHeaderAccept(accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.PathParameters.Add("token", ClientUtils.ParameterToString(token)); // path parameter
            localVarRequestOptions.PathParameters.Add("contractAddress", ClientUtils.ParameterToString(contractAddress)); // path parameter
            if (xTestnetType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("x-testnet-type", ClientUtils.ParameterToString(xTestnetType)); // header parameter
            }

            // authentication (X-API-Key) required
            if (!string.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("x-api-key")))
            {
                localVarRequestOptions.HeaderParameters.Add("x-api-key", Configuration.GetApiKeyWithPrefix("x-api-key"));
            }

            // make the HTTP request
            var localVarResponse = Client.Get<MultiTokenMetadata>("/v3/multitoken/metadata/ONE/{contractAddress}/{token}", localVarRequestOptions, Configuration);

            return localVarResponse;
        }

        /// <summary>
        /// Get Multi Token metadata 1 credit per API call Get Multi Token metadata. This API is supported for the following blockchains: BNB Smart Chain Celo Ethereum Harmony Klaytn KuCoin Community Chain Polygon
        /// </summary>
        /// <exception cref="Tatum.CSharp.MultiTokens.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="token">Token ID</param>
        /// <param name="contractAddress">Multi Token contract address</param>
        /// <param name="xTestnetType">Type of testnet. Defaults to Sepolia. Valid only for ETH invocations. (optional, default to ethereum-sepolia)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of MultiTokenMetadata</returns>
        public async System.Threading.Tasks.Task<MultiTokenMetadata> MultiTokenGetMetadataAsync(string token, string contractAddress, string xTestnetType = default(string), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            var localVarResponse = await MultiTokenGetMetadataWithHttpInfoAsync(token, contractAddress, xTestnetType, cancellationToken).ConfigureAwait(false);
            
            var exception = ExceptionFactory?.Invoke("MultiTokenGetMetadata", localVarResponse);
            if (exception != null) throw exception;

            return localVarResponse.Data;
        }

        /// <summary>
        /// Get Multi Token metadata 1 credit per API call Get Multi Token metadata. This API is supported for the following blockchains: BNB Smart Chain Celo Ethereum Harmony Klaytn KuCoin Community Chain Polygon
        /// </summary>
        /// <exception cref="Tatum.CSharp.MultiTokens.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="token">Token ID</param>
        /// <param name="contractAddress">Multi Token contract address</param>
        /// <param name="xTestnetType">Type of testnet. Defaults to Sepolia. Valid only for ETH invocations. (optional, default to ethereum-sepolia)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (MultiTokenMetadata)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<MultiTokenMetadata>> MultiTokenGetMetadataWithHttpInfoAsync(string token, string contractAddress, string xTestnetType = default(string), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            // verify the required parameter 'token' is set
            if (token == null)
                throw new ApiException(400, "Missing required parameter 'token' when calling MultiTokensOneApi->MultiTokenGetMetadata");

            // verify the required parameter 'contractAddress' is set
            if (contractAddress == null)
                throw new ApiException(400, "Missing required parameter 'contractAddress' when calling MultiTokensOneApi->MultiTokenGetMetadata");

            var localVarRequestOptions = new RequestOptions();

            var contentTypes = new string[]{
            };

            // to determine the Accept header
            var accepts = new string[]{
                "application/json"
            };


            var localVarContentType = ClientUtils.SelectHeaderContentType(contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = ClientUtils.SelectHeaderAccept(accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.PathParameters.Add("token", ClientUtils.ParameterToString(token)); // path parameter
            localVarRequestOptions.PathParameters.Add("contractAddress", ClientUtils.ParameterToString(contractAddress)); // path parameter
            if (xTestnetType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("x-testnet-type", ClientUtils.ParameterToString(xTestnetType)); // header parameter
            }

            // authentication (X-API-Key) required
            if (!string.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("x-api-key")))
            {
                localVarRequestOptions.HeaderParameters.Add("x-api-key", Configuration.GetApiKeyWithPrefix("x-api-key"));
            }

            // make the HTTP request

            var localVarResponse = await AsynchronousClient.GetAsync<MultiTokenMetadata>("/v3/multitoken/metadata/ONE/{contractAddress}/{token}", localVarRequestOptions, Configuration, cancellationToken).ConfigureAwait(false);

            return localVarResponse;
        }

        /// <summary>
        /// Get a Multi Token transaction by its hash 1 credit per API call Get Multi Token transaction by transaction hash. This API is supported for the following blockchains: BNB Smart Chain Celo Ethereum Harmony Klaytn KuCoin Community Chain Polygon
        /// </summary>
        /// <exception cref="Tatum.CSharp.MultiTokens.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="hash">Transaction hash</param>
        /// <param name="xTestnetType">Type of testnet. Defaults to Sepolia. Valid only for ETH invocations. (optional, default to ethereum-sepolia)</param>
        /// <returns>EthTx</returns>
        public EthTx MultiTokenGetTransaction(string hash, string xTestnetType = default(string))
        {
            var localVarResponse = MultiTokenGetTransactionWithHttpInfo(hash, xTestnetType);

            var exception = ExceptionFactory?.Invoke("MultiTokenGetTransaction", localVarResponse);
            if (exception != null) throw exception;

            return localVarResponse.Data;
        }

        /// <summary>
        /// Get a Multi Token transaction by its hash 1 credit per API call Get Multi Token transaction by transaction hash. This API is supported for the following blockchains: BNB Smart Chain Celo Ethereum Harmony Klaytn KuCoin Community Chain Polygon
        /// </summary>
        /// <exception cref="Tatum.CSharp.MultiTokens.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="hash">Transaction hash</param>
        /// <param name="xTestnetType">Type of testnet. Defaults to Sepolia. Valid only for ETH invocations. (optional, default to ethereum-sepolia)</param>
        /// <returns>ApiResponse of EthTx</returns>
        public ApiResponse<EthTx> MultiTokenGetTransactionWithHttpInfo(string hash, string xTestnetType = default(string))
        {
            // verify the required parameter 'hash' is set
            if (hash == null)
                throw new ApiException(400, "Missing required parameter 'hash' when calling MultiTokensOneApi->MultiTokenGetTransaction");

            var localVarRequestOptions = new RequestOptions();

            var contentTypes = new string[]{
            };

            // to determine the Accept header
            var accepts = new string[]{
                "application/json"
            };

            var localVarContentType = ClientUtils.SelectHeaderContentType(contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = ClientUtils.SelectHeaderAccept(accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.PathParameters.Add("hash", ClientUtils.ParameterToString(hash)); // path parameter
            if (xTestnetType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("x-testnet-type", ClientUtils.ParameterToString(xTestnetType)); // header parameter
            }

            // authentication (X-API-Key) required
            if (!string.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("x-api-key")))
            {
                localVarRequestOptions.HeaderParameters.Add("x-api-key", Configuration.GetApiKeyWithPrefix("x-api-key"));
            }

            // make the HTTP request
            var localVarResponse = Client.Get<EthTx>("/v3/multitoken/transaction/ONE/{hash}", localVarRequestOptions, Configuration);

            return localVarResponse;
        }

        /// <summary>
        /// Get a Multi Token transaction by its hash 1 credit per API call Get Multi Token transaction by transaction hash. This API is supported for the following blockchains: BNB Smart Chain Celo Ethereum Harmony Klaytn KuCoin Community Chain Polygon
        /// </summary>
        /// <exception cref="Tatum.CSharp.MultiTokens.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="hash">Transaction hash</param>
        /// <param name="xTestnetType">Type of testnet. Defaults to Sepolia. Valid only for ETH invocations. (optional, default to ethereum-sepolia)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of EthTx</returns>
        public async System.Threading.Tasks.Task<EthTx> MultiTokenGetTransactionAsync(string hash, string xTestnetType = default(string), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            var localVarResponse = await MultiTokenGetTransactionWithHttpInfoAsync(hash, xTestnetType, cancellationToken).ConfigureAwait(false);
            
            var exception = ExceptionFactory?.Invoke("MultiTokenGetTransaction", localVarResponse);
            if (exception != null) throw exception;

            return localVarResponse.Data;
        }

        /// <summary>
        /// Get a Multi Token transaction by its hash 1 credit per API call Get Multi Token transaction by transaction hash. This API is supported for the following blockchains: BNB Smart Chain Celo Ethereum Harmony Klaytn KuCoin Community Chain Polygon
        /// </summary>
        /// <exception cref="Tatum.CSharp.MultiTokens.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="hash">Transaction hash</param>
        /// <param name="xTestnetType">Type of testnet. Defaults to Sepolia. Valid only for ETH invocations. (optional, default to ethereum-sepolia)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (EthTx)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<EthTx>> MultiTokenGetTransactionWithHttpInfoAsync(string hash, string xTestnetType = default(string), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            // verify the required parameter 'hash' is set
            if (hash == null)
                throw new ApiException(400, "Missing required parameter 'hash' when calling MultiTokensOneApi->MultiTokenGetTransaction");

            var localVarRequestOptions = new RequestOptions();

            var contentTypes = new string[]{
            };

            // to determine the Accept header
            var accepts = new string[]{
                "application/json"
            };


            var localVarContentType = ClientUtils.SelectHeaderContentType(contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = ClientUtils.SelectHeaderAccept(accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.PathParameters.Add("hash", ClientUtils.ParameterToString(hash)); // path parameter
            if (xTestnetType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("x-testnet-type", ClientUtils.ParameterToString(xTestnetType)); // header parameter
            }

            // authentication (X-API-Key) required
            if (!string.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("x-api-key")))
            {
                localVarRequestOptions.HeaderParameters.Add("x-api-key", Configuration.GetApiKeyWithPrefix("x-api-key"));
            }

            // make the HTTP request

            var localVarResponse = await AsynchronousClient.GetAsync<EthTx>("/v3/multitoken/transaction/ONE/{hash}", localVarRequestOptions, Configuration, cancellationToken).ConfigureAwait(false);

            return localVarResponse;
        }

        /// <summary>
        /// Transfer a Multi Token 2 credits per API call Transfer a certain amount of Multi Token from account to another account. Transfer Multi Tokens token from smart contract defined in contractAddress. Only 1 specific token with specified tokenId and value can be transferred. This method invokes ERC1155 method safeTransfer() to transfer the token in case of ETH, Celo and blockchains. This API is supported for the following blockchains: BNB Smart Chain Celo Ethereum Harmony Klaytn KuCoin Community Chain Polygon Signing a transaction When transferring a Multi Token, you are charged a fee for the transaction, and you must sign the transaction with the private key of the blockchain address from which the fee will be deducted. Providing the private key in the API is not a secure way of signing transactions, because the private key can be stolen or exposed. Your private keys should never leave your security perimeter. You should use the private keys only for testing a solution you are building on the testnet of a blockchain. For signing transactions on the mainnet, we strongly recommend that you use the Tatum Key Management System (KMS) and provide the signature ID instead of the private key in the API. Alternatively, you can use the Tatum JavaScript client.
        /// </summary>
        /// <exception cref="Tatum.CSharp.MultiTokens.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="transferMultiToken"></param>
        /// <param name="xTestnetType">Type of testnet. Defaults to Sepolia. Valid only for ETH invocations. (optional, default to ethereum-sepolia)</param>
        /// <returns>TransactionHash</returns>
        public TransactionHash TransferMultiToken(TransferMultiToken transferMultiToken, string xTestnetType = default(string))
        {
            var localVarResponse = TransferMultiTokenWithHttpInfo(transferMultiToken, xTestnetType);

            var exception = ExceptionFactory?.Invoke("TransferMultiToken", localVarResponse);
            if (exception != null) throw exception;

            return localVarResponse.Data;
        }

        /// <summary>
        /// Transfer a Multi Token 2 credits per API call Transfer a certain amount of Multi Token from account to another account. Transfer Multi Tokens token from smart contract defined in contractAddress. Only 1 specific token with specified tokenId and value can be transferred. This method invokes ERC1155 method safeTransfer() to transfer the token in case of ETH, Celo and blockchains. This API is supported for the following blockchains: BNB Smart Chain Celo Ethereum Harmony Klaytn KuCoin Community Chain Polygon Signing a transaction When transferring a Multi Token, you are charged a fee for the transaction, and you must sign the transaction with the private key of the blockchain address from which the fee will be deducted. Providing the private key in the API is not a secure way of signing transactions, because the private key can be stolen or exposed. Your private keys should never leave your security perimeter. You should use the private keys only for testing a solution you are building on the testnet of a blockchain. For signing transactions on the mainnet, we strongly recommend that you use the Tatum Key Management System (KMS) and provide the signature ID instead of the private key in the API. Alternatively, you can use the Tatum JavaScript client.
        /// </summary>
        /// <exception cref="Tatum.CSharp.MultiTokens.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="transferMultiToken"></param>
        /// <param name="xTestnetType">Type of testnet. Defaults to Sepolia. Valid only for ETH invocations. (optional, default to ethereum-sepolia)</param>
        /// <returns>ApiResponse of TransactionHash</returns>
        public ApiResponse<TransactionHash> TransferMultiTokenWithHttpInfo(TransferMultiToken transferMultiToken, string xTestnetType = default(string))
        {
            // verify the required parameter 'transferMultiToken' is set
            if (transferMultiToken == null)
                throw new ApiException(400, "Missing required parameter 'transferMultiToken' when calling MultiTokensOneApi->TransferMultiToken");

            var localVarRequestOptions = new RequestOptions();

            var contentTypes = new string[]{
                "application/json"
            };

            // to determine the Accept header
            var accepts = new string[]{
                "application/json"
            };

            var localVarContentType = ClientUtils.SelectHeaderContentType(contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = ClientUtils.SelectHeaderAccept(accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            if (xTestnetType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("x-testnet-type", ClientUtils.ParameterToString(xTestnetType)); // header parameter
            }
            localVarRequestOptions.Data = transferMultiToken;

            // authentication (X-API-Key) required
            if (!string.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("x-api-key")))
            {
                localVarRequestOptions.HeaderParameters.Add("x-api-key", Configuration.GetApiKeyWithPrefix("x-api-key"));
            }

            // make the HTTP request
            var localVarResponse = Client.Post<TransactionHash>("/v3/multitoken/transaction", localVarRequestOptions, Configuration);

            return localVarResponse;
        }

        /// <summary>
        /// Transfer a Multi Token 2 credits per API call Transfer a certain amount of Multi Token from account to another account. Transfer Multi Tokens token from smart contract defined in contractAddress. Only 1 specific token with specified tokenId and value can be transferred. This method invokes ERC1155 method safeTransfer() to transfer the token in case of ETH, Celo and blockchains. This API is supported for the following blockchains: BNB Smart Chain Celo Ethereum Harmony Klaytn KuCoin Community Chain Polygon Signing a transaction When transferring a Multi Token, you are charged a fee for the transaction, and you must sign the transaction with the private key of the blockchain address from which the fee will be deducted. Providing the private key in the API is not a secure way of signing transactions, because the private key can be stolen or exposed. Your private keys should never leave your security perimeter. You should use the private keys only for testing a solution you are building on the testnet of a blockchain. For signing transactions on the mainnet, we strongly recommend that you use the Tatum Key Management System (KMS) and provide the signature ID instead of the private key in the API. Alternatively, you can use the Tatum JavaScript client.
        /// </summary>
        /// <exception cref="Tatum.CSharp.MultiTokens.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="transferMultiToken"></param>
        /// <param name="xTestnetType">Type of testnet. Defaults to Sepolia. Valid only for ETH invocations. (optional, default to ethereum-sepolia)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of TransactionHash</returns>
        public async System.Threading.Tasks.Task<TransactionHash> TransferMultiTokenAsync(TransferMultiToken transferMultiToken, string xTestnetType = default(string), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            var localVarResponse = await TransferMultiTokenWithHttpInfoAsync(transferMultiToken, xTestnetType, cancellationToken).ConfigureAwait(false);
            
            var exception = ExceptionFactory?.Invoke("TransferMultiToken", localVarResponse);
            if (exception != null) throw exception;

            return localVarResponse.Data;
        }

        /// <summary>
        /// Transfer a Multi Token 2 credits per API call Transfer a certain amount of Multi Token from account to another account. Transfer Multi Tokens token from smart contract defined in contractAddress. Only 1 specific token with specified tokenId and value can be transferred. This method invokes ERC1155 method safeTransfer() to transfer the token in case of ETH, Celo and blockchains. This API is supported for the following blockchains: BNB Smart Chain Celo Ethereum Harmony Klaytn KuCoin Community Chain Polygon Signing a transaction When transferring a Multi Token, you are charged a fee for the transaction, and you must sign the transaction with the private key of the blockchain address from which the fee will be deducted. Providing the private key in the API is not a secure way of signing transactions, because the private key can be stolen or exposed. Your private keys should never leave your security perimeter. You should use the private keys only for testing a solution you are building on the testnet of a blockchain. For signing transactions on the mainnet, we strongly recommend that you use the Tatum Key Management System (KMS) and provide the signature ID instead of the private key in the API. Alternatively, you can use the Tatum JavaScript client.
        /// </summary>
        /// <exception cref="Tatum.CSharp.MultiTokens.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="transferMultiToken"></param>
        /// <param name="xTestnetType">Type of testnet. Defaults to Sepolia. Valid only for ETH invocations. (optional, default to ethereum-sepolia)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (TransactionHash)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<TransactionHash>> TransferMultiTokenWithHttpInfoAsync(TransferMultiToken transferMultiToken, string xTestnetType = default(string), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            // verify the required parameter 'transferMultiToken' is set
            if (transferMultiToken == null)
                throw new ApiException(400, "Missing required parameter 'transferMultiToken' when calling MultiTokensOneApi->TransferMultiToken");

            var localVarRequestOptions = new RequestOptions();

            var contentTypes = new string[]{
                "application/json"
            };

            // to determine the Accept header
            var accepts = new string[]{
                "application/json"
            };


            var localVarContentType = ClientUtils.SelectHeaderContentType(contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = ClientUtils.SelectHeaderAccept(accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            if (xTestnetType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("x-testnet-type", ClientUtils.ParameterToString(xTestnetType)); // header parameter
            }
            localVarRequestOptions.Data = transferMultiToken;

            // authentication (X-API-Key) required
            if (!string.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("x-api-key")))
            {
                localVarRequestOptions.HeaderParameters.Add("x-api-key", Configuration.GetApiKeyWithPrefix("x-api-key"));
            }

            // make the HTTP request

            var localVarResponse = await AsynchronousClient.PostAsync<TransactionHash>("/v3/multitoken/transaction", localVarRequestOptions, Configuration, cancellationToken).ConfigureAwait(false);

            return localVarResponse;
        }

        /// <summary>
        /// Transfer multiple Multi Tokens 2 credits per API call Transfer Multi Token Batch from account to various other accounts in one transaction. Transfer multiple Multi Tokens token from smart contract defined in contractAddress. Multiple token with specified tokenIds and values can be transferred. This method invokes ERC1155 method safeTransfer() to transfer the token in case of ETH, Celo and BSC. This API is supported for the following blockchains: BNB Smart Chain Celo Ethereum Harmony Klaytn KuCoin Community Chain Polygon Signing a transaction When transferring multiple Multi Tokens, you are charged a fee for the transaction, and you must sign the transaction with the private key of the blockchain address from which the fee will be deducted. Providing the private key in the API is not a secure way of signing transactions, because the private key can be stolen or exposed. Your private keys should never leave your security perimeter. You should use the private keys only for testing a solution you are building on the testnet of a blockchain. For signing transactions on the mainnet, we strongly recommend that you use the Tatum Key Management System (KMS) and provide the signature ID instead of the private key in the API. Alternatively, you can use the Tatum JavaScript client.
        /// </summary>
        /// <exception cref="Tatum.CSharp.MultiTokens.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="transferMultiTokenBatch"></param>
        /// <param name="xTestnetType">Type of testnet. Defaults to Sepolia. Valid only for ETH invocations. (optional, default to ethereum-sepolia)</param>
        /// <returns>TransactionHash</returns>
        public TransactionHash TransferMultiTokenBatch(TransferMultiTokenBatch transferMultiTokenBatch, string xTestnetType = default(string))
        {
            var localVarResponse = TransferMultiTokenBatchWithHttpInfo(transferMultiTokenBatch, xTestnetType);

            var exception = ExceptionFactory?.Invoke("TransferMultiTokenBatch", localVarResponse);
            if (exception != null) throw exception;

            return localVarResponse.Data;
        }

        /// <summary>
        /// Transfer multiple Multi Tokens 2 credits per API call Transfer Multi Token Batch from account to various other accounts in one transaction. Transfer multiple Multi Tokens token from smart contract defined in contractAddress. Multiple token with specified tokenIds and values can be transferred. This method invokes ERC1155 method safeTransfer() to transfer the token in case of ETH, Celo and BSC. This API is supported for the following blockchains: BNB Smart Chain Celo Ethereum Harmony Klaytn KuCoin Community Chain Polygon Signing a transaction When transferring multiple Multi Tokens, you are charged a fee for the transaction, and you must sign the transaction with the private key of the blockchain address from which the fee will be deducted. Providing the private key in the API is not a secure way of signing transactions, because the private key can be stolen or exposed. Your private keys should never leave your security perimeter. You should use the private keys only for testing a solution you are building on the testnet of a blockchain. For signing transactions on the mainnet, we strongly recommend that you use the Tatum Key Management System (KMS) and provide the signature ID instead of the private key in the API. Alternatively, you can use the Tatum JavaScript client.
        /// </summary>
        /// <exception cref="Tatum.CSharp.MultiTokens.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="transferMultiTokenBatch"></param>
        /// <param name="xTestnetType">Type of testnet. Defaults to Sepolia. Valid only for ETH invocations. (optional, default to ethereum-sepolia)</param>
        /// <returns>ApiResponse of TransactionHash</returns>
        public ApiResponse<TransactionHash> TransferMultiTokenBatchWithHttpInfo(TransferMultiTokenBatch transferMultiTokenBatch, string xTestnetType = default(string))
        {
            // verify the required parameter 'transferMultiTokenBatch' is set
            if (transferMultiTokenBatch == null)
                throw new ApiException(400, "Missing required parameter 'transferMultiTokenBatch' when calling MultiTokensOneApi->TransferMultiTokenBatch");

            var localVarRequestOptions = new RequestOptions();

            var contentTypes = new string[]{
                "application/json"
            };

            // to determine the Accept header
            var accepts = new string[]{
                "application/json"
            };

            var localVarContentType = ClientUtils.SelectHeaderContentType(contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = ClientUtils.SelectHeaderAccept(accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            if (xTestnetType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("x-testnet-type", ClientUtils.ParameterToString(xTestnetType)); // header parameter
            }
            localVarRequestOptions.Data = transferMultiTokenBatch;

            // authentication (X-API-Key) required
            if (!string.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("x-api-key")))
            {
                localVarRequestOptions.HeaderParameters.Add("x-api-key", Configuration.GetApiKeyWithPrefix("x-api-key"));
            }

            // make the HTTP request
            var localVarResponse = Client.Post<TransactionHash>("/v3/multitoken/transaction/batch", localVarRequestOptions, Configuration);

            return localVarResponse;
        }

        /// <summary>
        /// Transfer multiple Multi Tokens 2 credits per API call Transfer Multi Token Batch from account to various other accounts in one transaction. Transfer multiple Multi Tokens token from smart contract defined in contractAddress. Multiple token with specified tokenIds and values can be transferred. This method invokes ERC1155 method safeTransfer() to transfer the token in case of ETH, Celo and BSC. This API is supported for the following blockchains: BNB Smart Chain Celo Ethereum Harmony Klaytn KuCoin Community Chain Polygon Signing a transaction When transferring multiple Multi Tokens, you are charged a fee for the transaction, and you must sign the transaction with the private key of the blockchain address from which the fee will be deducted. Providing the private key in the API is not a secure way of signing transactions, because the private key can be stolen or exposed. Your private keys should never leave your security perimeter. You should use the private keys only for testing a solution you are building on the testnet of a blockchain. For signing transactions on the mainnet, we strongly recommend that you use the Tatum Key Management System (KMS) and provide the signature ID instead of the private key in the API. Alternatively, you can use the Tatum JavaScript client.
        /// </summary>
        /// <exception cref="Tatum.CSharp.MultiTokens.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="transferMultiTokenBatch"></param>
        /// <param name="xTestnetType">Type of testnet. Defaults to Sepolia. Valid only for ETH invocations. (optional, default to ethereum-sepolia)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of TransactionHash</returns>
        public async System.Threading.Tasks.Task<TransactionHash> TransferMultiTokenBatchAsync(TransferMultiTokenBatch transferMultiTokenBatch, string xTestnetType = default(string), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            var localVarResponse = await TransferMultiTokenBatchWithHttpInfoAsync(transferMultiTokenBatch, xTestnetType, cancellationToken).ConfigureAwait(false);
            
            var exception = ExceptionFactory?.Invoke("TransferMultiTokenBatch", localVarResponse);
            if (exception != null) throw exception;

            return localVarResponse.Data;
        }

        /// <summary>
        /// Transfer multiple Multi Tokens 2 credits per API call Transfer Multi Token Batch from account to various other accounts in one transaction. Transfer multiple Multi Tokens token from smart contract defined in contractAddress. Multiple token with specified tokenIds and values can be transferred. This method invokes ERC1155 method safeTransfer() to transfer the token in case of ETH, Celo and BSC. This API is supported for the following blockchains: BNB Smart Chain Celo Ethereum Harmony Klaytn KuCoin Community Chain Polygon Signing a transaction When transferring multiple Multi Tokens, you are charged a fee for the transaction, and you must sign the transaction with the private key of the blockchain address from which the fee will be deducted. Providing the private key in the API is not a secure way of signing transactions, because the private key can be stolen or exposed. Your private keys should never leave your security perimeter. You should use the private keys only for testing a solution you are building on the testnet of a blockchain. For signing transactions on the mainnet, we strongly recommend that you use the Tatum Key Management System (KMS) and provide the signature ID instead of the private key in the API. Alternatively, you can use the Tatum JavaScript client.
        /// </summary>
        /// <exception cref="Tatum.CSharp.MultiTokens.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="transferMultiTokenBatch"></param>
        /// <param name="xTestnetType">Type of testnet. Defaults to Sepolia. Valid only for ETH invocations. (optional, default to ethereum-sepolia)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (TransactionHash)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<TransactionHash>> TransferMultiTokenBatchWithHttpInfoAsync(TransferMultiTokenBatch transferMultiTokenBatch, string xTestnetType = default(string), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            // verify the required parameter 'transferMultiTokenBatch' is set
            if (transferMultiTokenBatch == null)
                throw new ApiException(400, "Missing required parameter 'transferMultiTokenBatch' when calling MultiTokensOneApi->TransferMultiTokenBatch");

            var localVarRequestOptions = new RequestOptions();

            var contentTypes = new string[]{
                "application/json"
            };

            // to determine the Accept header
            var accepts = new string[]{
                "application/json"
            };


            var localVarContentType = ClientUtils.SelectHeaderContentType(contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = ClientUtils.SelectHeaderAccept(accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            if (xTestnetType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("x-testnet-type", ClientUtils.ParameterToString(xTestnetType)); // header parameter
            }
            localVarRequestOptions.Data = transferMultiTokenBatch;

            // authentication (X-API-Key) required
            if (!string.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("x-api-key")))
            {
                localVarRequestOptions.HeaderParameters.Add("x-api-key", Configuration.GetApiKeyWithPrefix("x-api-key"));
            }

            // make the HTTP request

            var localVarResponse = await AsynchronousClient.PostAsync<TransactionHash>("/v3/multitoken/transaction/batch", localVarRequestOptions, Configuration, cancellationToken).ConfigureAwait(false);

            return localVarResponse;
        }

        /// <summary>
        /// Transfer multiple Multi Tokens 2 credits per API call Transfer Multi Token Batch from account to various other accounts in one transaction. Transfer multiple Multi Tokens token from smart contract defined in contractAddress. Multiple token with specified tokenIds and values can be transferred. This method invokes ERC1155 method safeTransfer() to transfer the token in case of ETH, Celo and BSC. This API is supported for the following blockchains: BNB Smart Chain Celo Ethereum Harmony Klaytn KuCoin Community Chain Polygon Signing a transaction When transferring multiple Multi Tokens, you are charged a fee for the transaction, and you must sign the transaction with the private key of the blockchain address from which the fee will be deducted. Providing the private key in the API is not a secure way of signing transactions, because the private key can be stolen or exposed. Your private keys should never leave your security perimeter. You should use the private keys only for testing a solution you are building on the testnet of a blockchain. For signing transactions on the mainnet, we strongly recommend that you use the Tatum Key Management System (KMS) and provide the signature ID instead of the private key in the API. Alternatively, you can use the Tatum JavaScript client.
        /// </summary>
        /// <exception cref="Tatum.CSharp.MultiTokens.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="transferMultiTokenBatchKMS"></param>
        /// <param name="xTestnetType">Type of testnet. Defaults to Sepolia. Valid only for ETH invocations. (optional, default to ethereum-sepolia)</param>
        /// <returns>SignatureId</returns>
        public SignatureId TransferMultiTokenBatch(TransferMultiTokenBatchKMS transferMultiTokenBatchKMS, string xTestnetType = default(string))
        {
            var localVarResponse = TransferMultiTokenBatchWithHttpInfo(transferMultiTokenBatchKMS, xTestnetType);

            var exception = ExceptionFactory?.Invoke("TransferMultiTokenBatch_0", localVarResponse);
            if (exception != null) throw exception;

            return localVarResponse.Data;
        }

        /// <summary>
        /// Transfer multiple Multi Tokens 2 credits per API call Transfer Multi Token Batch from account to various other accounts in one transaction. Transfer multiple Multi Tokens token from smart contract defined in contractAddress. Multiple token with specified tokenIds and values can be transferred. This method invokes ERC1155 method safeTransfer() to transfer the token in case of ETH, Celo and BSC. This API is supported for the following blockchains: BNB Smart Chain Celo Ethereum Harmony Klaytn KuCoin Community Chain Polygon Signing a transaction When transferring multiple Multi Tokens, you are charged a fee for the transaction, and you must sign the transaction with the private key of the blockchain address from which the fee will be deducted. Providing the private key in the API is not a secure way of signing transactions, because the private key can be stolen or exposed. Your private keys should never leave your security perimeter. You should use the private keys only for testing a solution you are building on the testnet of a blockchain. For signing transactions on the mainnet, we strongly recommend that you use the Tatum Key Management System (KMS) and provide the signature ID instead of the private key in the API. Alternatively, you can use the Tatum JavaScript client.
        /// </summary>
        /// <exception cref="Tatum.CSharp.MultiTokens.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="transferMultiTokenBatchKMS"></param>
        /// <param name="xTestnetType">Type of testnet. Defaults to Sepolia. Valid only for ETH invocations. (optional, default to ethereum-sepolia)</param>
        /// <returns>ApiResponse of SignatureId</returns>
        public ApiResponse<SignatureId> TransferMultiTokenBatchWithHttpInfo(TransferMultiTokenBatchKMS transferMultiTokenBatchKMS, string xTestnetType = default(string))
        {
            // verify the required parameter 'transferMultiTokenBatchKMS' is set
            if (transferMultiTokenBatchKMS == null)
                throw new ApiException(400, "Missing required parameter 'transferMultiTokenBatchKMS' when calling MultiTokensOneApi->TransferMultiTokenBatch_0");

            var localVarRequestOptions = new RequestOptions();

            var contentTypes = new string[]{
                "application/json"
            };

            // to determine the Accept header
            var accepts = new string[]{
                "application/json"
            };

            var localVarContentType = ClientUtils.SelectHeaderContentType(contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = ClientUtils.SelectHeaderAccept(accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            if (xTestnetType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("x-testnet-type", ClientUtils.ParameterToString(xTestnetType)); // header parameter
            }
            localVarRequestOptions.Data = transferMultiTokenBatchKMS;

            // authentication (X-API-Key) required
            if (!string.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("x-api-key")))
            {
                localVarRequestOptions.HeaderParameters.Add("x-api-key", Configuration.GetApiKeyWithPrefix("x-api-key"));
            }

            // make the HTTP request
            var localVarResponse = Client.Post<SignatureId>("/v3/multitoken/transaction/batch", localVarRequestOptions, Configuration);

            return localVarResponse;
        }

        /// <summary>
        /// Transfer multiple Multi Tokens 2 credits per API call Transfer Multi Token Batch from account to various other accounts in one transaction. Transfer multiple Multi Tokens token from smart contract defined in contractAddress. Multiple token with specified tokenIds and values can be transferred. This method invokes ERC1155 method safeTransfer() to transfer the token in case of ETH, Celo and BSC. This API is supported for the following blockchains: BNB Smart Chain Celo Ethereum Harmony Klaytn KuCoin Community Chain Polygon Signing a transaction When transferring multiple Multi Tokens, you are charged a fee for the transaction, and you must sign the transaction with the private key of the blockchain address from which the fee will be deducted. Providing the private key in the API is not a secure way of signing transactions, because the private key can be stolen or exposed. Your private keys should never leave your security perimeter. You should use the private keys only for testing a solution you are building on the testnet of a blockchain. For signing transactions on the mainnet, we strongly recommend that you use the Tatum Key Management System (KMS) and provide the signature ID instead of the private key in the API. Alternatively, you can use the Tatum JavaScript client.
        /// </summary>
        /// <exception cref="Tatum.CSharp.MultiTokens.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="transferMultiTokenBatchKMS"></param>
        /// <param name="xTestnetType">Type of testnet. Defaults to Sepolia. Valid only for ETH invocations. (optional, default to ethereum-sepolia)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of SignatureId</returns>
        public async System.Threading.Tasks.Task<SignatureId> TransferMultiTokenBatchAsync(TransferMultiTokenBatchKMS transferMultiTokenBatchKMS, string xTestnetType = default(string), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            var localVarResponse = await TransferMultiTokenBatchWithHttpInfoAsync(transferMultiTokenBatchKMS, xTestnetType, cancellationToken).ConfigureAwait(false);
            
            var exception = ExceptionFactory?.Invoke("TransferMultiTokenBatch_0", localVarResponse);
            if (exception != null) throw exception;

            return localVarResponse.Data;
        }

        /// <summary>
        /// Transfer multiple Multi Tokens 2 credits per API call Transfer Multi Token Batch from account to various other accounts in one transaction. Transfer multiple Multi Tokens token from smart contract defined in contractAddress. Multiple token with specified tokenIds and values can be transferred. This method invokes ERC1155 method safeTransfer() to transfer the token in case of ETH, Celo and BSC. This API is supported for the following blockchains: BNB Smart Chain Celo Ethereum Harmony Klaytn KuCoin Community Chain Polygon Signing a transaction When transferring multiple Multi Tokens, you are charged a fee for the transaction, and you must sign the transaction with the private key of the blockchain address from which the fee will be deducted. Providing the private key in the API is not a secure way of signing transactions, because the private key can be stolen or exposed. Your private keys should never leave your security perimeter. You should use the private keys only for testing a solution you are building on the testnet of a blockchain. For signing transactions on the mainnet, we strongly recommend that you use the Tatum Key Management System (KMS) and provide the signature ID instead of the private key in the API. Alternatively, you can use the Tatum JavaScript client.
        /// </summary>
        /// <exception cref="Tatum.CSharp.MultiTokens.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="transferMultiTokenBatchKMS"></param>
        /// <param name="xTestnetType">Type of testnet. Defaults to Sepolia. Valid only for ETH invocations. (optional, default to ethereum-sepolia)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (SignatureId)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<SignatureId>> TransferMultiTokenBatchWithHttpInfoAsync(TransferMultiTokenBatchKMS transferMultiTokenBatchKMS, string xTestnetType = default(string), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            // verify the required parameter 'transferMultiTokenBatchKMS' is set
            if (transferMultiTokenBatchKMS == null)
                throw new ApiException(400, "Missing required parameter 'transferMultiTokenBatchKMS' when calling MultiTokensOneApi->TransferMultiTokenBatch_0");

            var localVarRequestOptions = new RequestOptions();

            var contentTypes = new string[]{
                "application/json"
            };

            // to determine the Accept header
            var accepts = new string[]{
                "application/json"
            };


            var localVarContentType = ClientUtils.SelectHeaderContentType(contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = ClientUtils.SelectHeaderAccept(accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            if (xTestnetType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("x-testnet-type", ClientUtils.ParameterToString(xTestnetType)); // header parameter
            }
            localVarRequestOptions.Data = transferMultiTokenBatchKMS;

            // authentication (X-API-Key) required
            if (!string.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("x-api-key")))
            {
                localVarRequestOptions.HeaderParameters.Add("x-api-key", Configuration.GetApiKeyWithPrefix("x-api-key"));
            }

            // make the HTTP request

            var localVarResponse = await AsynchronousClient.PostAsync<SignatureId>("/v3/multitoken/transaction/batch", localVarRequestOptions, Configuration, cancellationToken).ConfigureAwait(false);

            return localVarResponse;
        }

        /// <summary>
        /// Transfer a Multi Token 2 credits per API call Transfer a certain amount of Multi Token from account to another account. Transfer Multi Tokens token from smart contract defined in contractAddress. Only 1 specific token with specified tokenId and value can be transferred. This method invokes ERC1155 method safeTransfer() to transfer the token in case of ETH, Celo and blockchains. This API is supported for the following blockchains: BNB Smart Chain Celo Ethereum Harmony Klaytn KuCoin Community Chain Polygon Signing a transaction When transferring a Multi Token, you are charged a fee for the transaction, and you must sign the transaction with the private key of the blockchain address from which the fee will be deducted. Providing the private key in the API is not a secure way of signing transactions, because the private key can be stolen or exposed. Your private keys should never leave your security perimeter. You should use the private keys only for testing a solution you are building on the testnet of a blockchain. For signing transactions on the mainnet, we strongly recommend that you use the Tatum Key Management System (KMS) and provide the signature ID instead of the private key in the API. Alternatively, you can use the Tatum JavaScript client.
        /// </summary>
        /// <exception cref="Tatum.CSharp.MultiTokens.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="transferMultiTokenKMS"></param>
        /// <param name="xTestnetType">Type of testnet. Defaults to Sepolia. Valid only for ETH invocations. (optional, default to ethereum-sepolia)</param>
        /// <returns>SignatureId</returns>
        public SignatureId TransferMultiToken(TransferMultiTokenKMS transferMultiTokenKMS, string xTestnetType = default(string))
        {
            var localVarResponse = TransferMultiTokenWithHttpInfo(transferMultiTokenKMS, xTestnetType);

            var exception = ExceptionFactory?.Invoke("TransferMultiToken_0", localVarResponse);
            if (exception != null) throw exception;

            return localVarResponse.Data;
        }

        /// <summary>
        /// Transfer a Multi Token 2 credits per API call Transfer a certain amount of Multi Token from account to another account. Transfer Multi Tokens token from smart contract defined in contractAddress. Only 1 specific token with specified tokenId and value can be transferred. This method invokes ERC1155 method safeTransfer() to transfer the token in case of ETH, Celo and blockchains. This API is supported for the following blockchains: BNB Smart Chain Celo Ethereum Harmony Klaytn KuCoin Community Chain Polygon Signing a transaction When transferring a Multi Token, you are charged a fee for the transaction, and you must sign the transaction with the private key of the blockchain address from which the fee will be deducted. Providing the private key in the API is not a secure way of signing transactions, because the private key can be stolen or exposed. Your private keys should never leave your security perimeter. You should use the private keys only for testing a solution you are building on the testnet of a blockchain. For signing transactions on the mainnet, we strongly recommend that you use the Tatum Key Management System (KMS) and provide the signature ID instead of the private key in the API. Alternatively, you can use the Tatum JavaScript client.
        /// </summary>
        /// <exception cref="Tatum.CSharp.MultiTokens.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="transferMultiTokenKMS"></param>
        /// <param name="xTestnetType">Type of testnet. Defaults to Sepolia. Valid only for ETH invocations. (optional, default to ethereum-sepolia)</param>
        /// <returns>ApiResponse of SignatureId</returns>
        public ApiResponse<SignatureId> TransferMultiTokenWithHttpInfo(TransferMultiTokenKMS transferMultiTokenKMS, string xTestnetType = default(string))
        {
            // verify the required parameter 'transferMultiTokenKMS' is set
            if (transferMultiTokenKMS == null)
                throw new ApiException(400, "Missing required parameter 'transferMultiTokenKMS' when calling MultiTokensOneApi->TransferMultiToken_0");

            var localVarRequestOptions = new RequestOptions();

            var contentTypes = new string[]{
                "application/json"
            };

            // to determine the Accept header
            var accepts = new string[]{
                "application/json"
            };

            var localVarContentType = ClientUtils.SelectHeaderContentType(contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = ClientUtils.SelectHeaderAccept(accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            if (xTestnetType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("x-testnet-type", ClientUtils.ParameterToString(xTestnetType)); // header parameter
            }
            localVarRequestOptions.Data = transferMultiTokenKMS;

            // authentication (X-API-Key) required
            if (!string.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("x-api-key")))
            {
                localVarRequestOptions.HeaderParameters.Add("x-api-key", Configuration.GetApiKeyWithPrefix("x-api-key"));
            }

            // make the HTTP request
            var localVarResponse = Client.Post<SignatureId>("/v3/multitoken/transaction", localVarRequestOptions, Configuration);

            return localVarResponse;
        }

        /// <summary>
        /// Transfer a Multi Token 2 credits per API call Transfer a certain amount of Multi Token from account to another account. Transfer Multi Tokens token from smart contract defined in contractAddress. Only 1 specific token with specified tokenId and value can be transferred. This method invokes ERC1155 method safeTransfer() to transfer the token in case of ETH, Celo and blockchains. This API is supported for the following blockchains: BNB Smart Chain Celo Ethereum Harmony Klaytn KuCoin Community Chain Polygon Signing a transaction When transferring a Multi Token, you are charged a fee for the transaction, and you must sign the transaction with the private key of the blockchain address from which the fee will be deducted. Providing the private key in the API is not a secure way of signing transactions, because the private key can be stolen or exposed. Your private keys should never leave your security perimeter. You should use the private keys only for testing a solution you are building on the testnet of a blockchain. For signing transactions on the mainnet, we strongly recommend that you use the Tatum Key Management System (KMS) and provide the signature ID instead of the private key in the API. Alternatively, you can use the Tatum JavaScript client.
        /// </summary>
        /// <exception cref="Tatum.CSharp.MultiTokens.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="transferMultiTokenKMS"></param>
        /// <param name="xTestnetType">Type of testnet. Defaults to Sepolia. Valid only for ETH invocations. (optional, default to ethereum-sepolia)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of SignatureId</returns>
        public async System.Threading.Tasks.Task<SignatureId> TransferMultiTokenAsync(TransferMultiTokenKMS transferMultiTokenKMS, string xTestnetType = default(string), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            var localVarResponse = await TransferMultiTokenWithHttpInfoAsync(transferMultiTokenKMS, xTestnetType, cancellationToken).ConfigureAwait(false);
            
            var exception = ExceptionFactory?.Invoke("TransferMultiToken_0", localVarResponse);
            if (exception != null) throw exception;

            return localVarResponse.Data;
        }

        /// <summary>
        /// Transfer a Multi Token 2 credits per API call Transfer a certain amount of Multi Token from account to another account. Transfer Multi Tokens token from smart contract defined in contractAddress. Only 1 specific token with specified tokenId and value can be transferred. This method invokes ERC1155 method safeTransfer() to transfer the token in case of ETH, Celo and blockchains. This API is supported for the following blockchains: BNB Smart Chain Celo Ethereum Harmony Klaytn KuCoin Community Chain Polygon Signing a transaction When transferring a Multi Token, you are charged a fee for the transaction, and you must sign the transaction with the private key of the blockchain address from which the fee will be deducted. Providing the private key in the API is not a secure way of signing transactions, because the private key can be stolen or exposed. Your private keys should never leave your security perimeter. You should use the private keys only for testing a solution you are building on the testnet of a blockchain. For signing transactions on the mainnet, we strongly recommend that you use the Tatum Key Management System (KMS) and provide the signature ID instead of the private key in the API. Alternatively, you can use the Tatum JavaScript client.
        /// </summary>
        /// <exception cref="Tatum.CSharp.MultiTokens.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="transferMultiTokenKMS"></param>
        /// <param name="xTestnetType">Type of testnet. Defaults to Sepolia. Valid only for ETH invocations. (optional, default to ethereum-sepolia)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (SignatureId)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<SignatureId>> TransferMultiTokenWithHttpInfoAsync(TransferMultiTokenKMS transferMultiTokenKMS, string xTestnetType = default(string), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            // verify the required parameter 'transferMultiTokenKMS' is set
            if (transferMultiTokenKMS == null)
                throw new ApiException(400, "Missing required parameter 'transferMultiTokenKMS' when calling MultiTokensOneApi->TransferMultiToken_0");

            var localVarRequestOptions = new RequestOptions();

            var contentTypes = new string[]{
                "application/json"
            };

            // to determine the Accept header
            var accepts = new string[]{
                "application/json"
            };


            var localVarContentType = ClientUtils.SelectHeaderContentType(contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = ClientUtils.SelectHeaderAccept(accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            if (xTestnetType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("x-testnet-type", ClientUtils.ParameterToString(xTestnetType)); // header parameter
            }
            localVarRequestOptions.Data = transferMultiTokenKMS;

            // authentication (X-API-Key) required
            if (!string.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("x-api-key")))
            {
                localVarRequestOptions.HeaderParameters.Add("x-api-key", Configuration.GetApiKeyWithPrefix("x-api-key"));
            }

            // make the HTTP request

            var localVarResponse = await AsynchronousClient.PostAsync<SignatureId>("/v3/multitoken/transaction", localVarRequestOptions, Configuration, cancellationToken).ConfigureAwait(false);

            return localVarResponse;
        }

    }
}
