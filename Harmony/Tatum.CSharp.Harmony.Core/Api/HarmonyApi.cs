/*
 * Tatum API Reference
 *
 * # Welcome to the Tatum API Reference!  ## What is Tatum?  Tatum offers a flexible framework to build, run, and scale blockchain apps fast. To learn more about the Tatum blockchain development framework, visit [our website](https://tatum.io/framework).  The Tatum API features powerful endpoints that simplify a complex blockchain into single API requests. Code for all supported blockchains using unified API calls.  ## Need help?  To chat with other developers, get help from the Support team, and engage with the thriving Tatum community, join  our [Discord server](https://discord.com/invite/tatum). For more information about how to work with Tatum, review the [online documentation](https://docs.tatum.io/).  ## About this API Reference  The Tatum API Reference is based on OpenAPI Specification v3.1.0 with a few [vendor extensions](https://github.com/Redocly/redoc/blob/master/docs/redoc-vendor-extensions.md) applied.  # Authentication  When using the Tatum API, you authenticate yourself with an **API key**. <SecurityDefinitions /> 
 *
 * The version of the OpenAPI document: 3.17.0
 * Generated by: https://github.com/openapitools/openapi-generator.git
 */


using System;
using System.Collections.Generic;
using System.Net.Http;
using Tatum.CSharp.Harmony.Core.Client;
using Tatum.CSharp.Harmony.Core.Model;

namespace Tatum.CSharp.Harmony.Core.Api
{

    /// <summary>
    /// Represents a collection of functions to interact with the API endpoints
    /// </summary>
    public interface IHarmonyApiSync : IApiAccessor
    {
        #region Synchronous Operations
        /// <summary>
        /// Invoke a method in a smart contract on Harmony
        /// </summary>
        /// <remarks>
        /// 2 credits per API call Invoke a method in an existing smart contract on Harmony. You can call a read-only or write method. For read-only methods, the output of the invoked method is returned. For write methods, the ID of the associated transaction is returned. Signing a transaction When invoking a method in a smart contract, you are charged a fee for the transaction, and you must sign the transaction with the private key of the blockchain address from which the fee will be deducted. Providing the private key in the API is not a secure way of signing transactions, because the private key can be stolen or exposed. Your private keys should never leave your security perimeter. You should use the private keys only for testing a solution you are building on the testnet of a blockchain. For signing transactions on the mainnet, we strongly recommend that you use the Tatum Key Management System (KMS) and provide the signature ID instead of the private key in the API. Alternatively, you can use the Tatum JavaScript client.
        /// </remarks>
        /// <exception cref="Tatum.CSharp.Harmony.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="callOneReadSmartContractMethod"></param>
        /// <param name="shardID">Shard to read data from (optional, default to 0M)</param>
        /// <returns>Data</returns>
        Data OneBlockchainSmartContractInvocation(CallOneReadSmartContractMethod callOneReadSmartContractMethod, decimal? shardID = default(decimal?));
        /// <summary>
        /// Invoke a method in a smart contract on Harmony
        /// </summary>
        /// <remarks>
        /// 2 credits per API call Invoke a method in an existing smart contract on Harmony. You can call a read-only or write method. For read-only methods, the output of the invoked method is returned. For write methods, the ID of the associated transaction is returned. Signing a transaction When invoking a method in a smart contract, you are charged a fee for the transaction, and you must sign the transaction with the private key of the blockchain address from which the fee will be deducted. Providing the private key in the API is not a secure way of signing transactions, because the private key can be stolen or exposed. Your private keys should never leave your security perimeter. You should use the private keys only for testing a solution you are building on the testnet of a blockchain. For signing transactions on the mainnet, we strongly recommend that you use the Tatum Key Management System (KMS) and provide the signature ID instead of the private key in the API. Alternatively, you can use the Tatum JavaScript client.
        /// </remarks>
        /// <exception cref="Tatum.CSharp.Harmony.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="callOneSmartContractMethod"></param>
        /// <param name="shardID">Shard to read data from (optional, default to 0M)</param>
        /// <returns>TransactionHash</returns>
        TransactionHash OneBlockchainSmartContractInvocation(CallOneSmartContractMethod callOneSmartContractMethod, decimal? shardID = default(decimal?));
        /// <summary>
        /// Invoke a method in a smart contract on Harmony
        /// </summary>
        /// <remarks>
        /// 2 credits per API call Invoke a method in an existing smart contract on Harmony. You can call a read-only or write method. For read-only methods, the output of the invoked method is returned. For write methods, the ID of the associated transaction is returned. Signing a transaction When invoking a method in a smart contract, you are charged a fee for the transaction, and you must sign the transaction with the private key of the blockchain address from which the fee will be deducted. Providing the private key in the API is not a secure way of signing transactions, because the private key can be stolen or exposed. Your private keys should never leave your security perimeter. You should use the private keys only for testing a solution you are building on the testnet of a blockchain. For signing transactions on the mainnet, we strongly recommend that you use the Tatum Key Management System (KMS) and provide the signature ID instead of the private key in the API. Alternatively, you can use the Tatum JavaScript client.
        /// </remarks>
        /// <exception cref="Tatum.CSharp.Harmony.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="callOneSmartContractMethodKMS"></param>
        /// <param name="shardID">Shard to read data from (optional, default to 0M)</param>
        /// <returns>SignatureId</returns>
        SignatureId OneBlockchainSmartContractInvocation(CallOneSmartContractMethodKMS callOneSmartContractMethodKMS, decimal? shardID = default(decimal?));
        /// <summary>
        /// Send ONE / HRM20 from account to account
        /// </summary>
        /// <remarks>
        /// 2 credits per API call Send ONE or Tatum supported HRM20 token from account to account. Default shard 0 is used for sender and recipient. Signing a transaction When sending ONE, you are charged a fee for the transaction, and you must sign the transaction with the private key of the blockchain address from which the fee will be deducted. Providing the private key in the API is not a secure way of signing transactions, because the private key can be stolen or exposed. Your private keys should never leave your security perimeter. You should use the private keys only for testing a solution you are building on the testnet of a blockchain. For signing transactions on the mainnet, we strongly recommend that you use the Tatum Key Management System (KMS) and provide the signature ID instead of the private key in the API. Alternatively, you can use the Tatum JavaScript client. Alternatively, using the Tatum client library for supported languages.
        /// </remarks>
        /// <exception cref="Tatum.CSharp.Harmony.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="transferOneBlockchain"></param>
        /// <param name="shardID">Shard to read data from (optional, default to 0M)</param>
        /// <returns>TransactionHash</returns>
        TransactionHash OneBlockchainTransfer(TransferOneBlockchain transferOneBlockchain, decimal? shardID = default(decimal?));
        /// <summary>
        /// Send ONE / HRM20 from account to account
        /// </summary>
        /// <remarks>
        /// 2 credits per API call Send ONE or Tatum supported HRM20 token from account to account. Default shard 0 is used for sender and recipient. Signing a transaction When sending ONE, you are charged a fee for the transaction, and you must sign the transaction with the private key of the blockchain address from which the fee will be deducted. Providing the private key in the API is not a secure way of signing transactions, because the private key can be stolen or exposed. Your private keys should never leave your security perimeter. You should use the private keys only for testing a solution you are building on the testnet of a blockchain. For signing transactions on the mainnet, we strongly recommend that you use the Tatum Key Management System (KMS) and provide the signature ID instead of the private key in the API. Alternatively, you can use the Tatum JavaScript client. Alternatively, using the Tatum client library for supported languages.
        /// </remarks>
        /// <exception cref="Tatum.CSharp.Harmony.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="transferOneBlockchainKMS"></param>
        /// <param name="shardID">Shard to read data from (optional, default to 0M)</param>
        /// <returns>SignatureId</returns>
        SignatureId OneBlockchainTransfer(TransferOneBlockchainKMS transferOneBlockchainKMS, decimal? shardID = default(decimal?));
        /// <summary>
        /// Broadcast signed ONE transaction
        /// </summary>
        /// <remarks>
        /// 2 credits per API call Broadcast signed transaction to ONE blockchain. This method is used internally from Tatum KMS or Tatum client libraries. It is possible to create custom signing mechanism and use this method only for broadcasting data to the blockchain.
        /// </remarks>
        /// <exception cref="Tatum.CSharp.Harmony.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="broadcastKMS"></param>
        /// <param name="shardID">Shard to read data from (optional, default to 0M)</param>
        /// <returns>TransactionHash</returns>
        TransactionHash OneBroadcast(BroadcastKMS broadcastKMS, decimal? shardID = default(decimal?));
        /// <summary>
        /// Transform HEX address to Bech32 ONE address format
        /// </summary>
        /// <remarks>
        /// 1 credit per API call Transform HEX address to Bech32 format with one prefix.
        /// </remarks>
        /// <exception cref="Tatum.CSharp.Harmony.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="address">Address in HEX (ETH compatible) format.</param>
        /// <returns>GeneratedAddressOne</returns>
        GeneratedAddressOne OneFormatAddress(string address);
        /// <summary>
        /// Generate ONE account address from Extended public key
        /// </summary>
        /// <remarks>
        /// 1 credit per API call Generate ONE account deposit address from Extended public key. Deposit address is generated for the specific index - each extended public key can generate up to 2^31 addresses starting from index 0 until 2^31.
        /// </remarks>
        /// <exception cref="Tatum.CSharp.Harmony.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="xpub">Extended public key of wallet.</param>
        /// <param name="index">Derivation index of desired address to be generated.</param>
        /// <returns>GeneratedAddressOne</returns>
        GeneratedAddressOne OneGenerateAddress(string xpub, decimal index);
        /// <summary>
        /// Generate ONE private key
        /// </summary>
        /// <remarks>
        /// 1 credit per API call Generate private key of address from mnemonic for given derivation path index. Private key is generated for the specific index - each mnemonic can generate up to 2^31 private keys starting from index 0 until 2^31.
        /// </remarks>
        /// <exception cref="Tatum.CSharp.Harmony.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="privKeyRequest"></param>
        /// <returns>PrivKey</returns>
        PrivKey OneGenerateAddressPrivateKey(PrivKeyRequest privKeyRequest);
        /// <summary>
        /// Generate ONE wallet
        /// </summary>
        /// <remarks>
        /// 1 credit per API call Tatum supports BIP44 HD wallets. It is very convenient and secure, since it can generate 2^31 addresses from 1 mnemonic phrase. Mnemonic phrase consists of 24 special words in defined order and can restore access to all generated addresses and private keys. Each address is identified by 3 main values: Private Key - your secret value, which should never be revealed Public Key - public address to be published Derivation index - index of generated address Tatum follows BIP44 specification and generates for ONE wallet with derivation path m&#39;/44&#39;/60&#39;/0&#39;/0. More about BIP44 HD wallets can be found here - https://github.com/bitcoin/bips/blob/master/bip-0044.mediawiki. Generate BIP44 compatible ONE wallet.
        /// </remarks>
        /// <exception cref="Tatum.CSharp.Harmony.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="mnemonic">Mnemonic to use for generation of extended public and private keys. (optional)</param>
        /// <returns>Wallet</returns>
        Wallet OneGenerateWallet(string mnemonic = default(string));
        /// <summary>
        /// Get ONE Account balance
        /// </summary>
        /// <remarks>
        /// 1 credit per API call Get ONE account balance in ONE. This method does not prints any balance of the HRM20 or HRM721 tokens on the account.
        /// </remarks>
        /// <exception cref="Tatum.CSharp.Harmony.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="address">Account address you want to get balance of</param>
        /// <param name="shardID">Shard to read data from (optional, default to 0M)</param>
        /// <returns>OneBalance</returns>
        OneBalance OneGetBalance(string address, decimal? shardID = default(decimal?));
        /// <summary>
        /// Get ONE block by hash
        /// </summary>
        /// <remarks>
        /// 1 credit per API call Get ONE block by block hash or block number.
        /// </remarks>
        /// <exception cref="Tatum.CSharp.Harmony.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="hash">Block hash or block number</param>
        /// <param name="shardID">Shard to read data from (optional, default to 0M)</param>
        /// <returns>EthBlock</returns>
        EthBlock OneGetBlock(string hash, decimal? shardID = default(decimal?));
        /// <summary>
        /// Get current block number
        /// </summary>
        /// <remarks>
        /// 1 credit per API call Get ONE current block number. This is the number of the latest block in the blockchain.
        /// </remarks>
        /// <exception cref="Tatum.CSharp.Harmony.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <returns>List&lt;OneBlockCurrent&gt;</returns>
        List<OneBlockCurrent> OneGetCurrentBlock();
        /// <summary>
        /// Get ONE Transaction
        /// </summary>
        /// <remarks>
        /// 2 credits per API call Get ONE transaction by transaction hash.
        /// </remarks>
        /// <exception cref="Tatum.CSharp.Harmony.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="hash">Transaction hash</param>
        /// <param name="shardID">Shard to read data from (optional, default to 0M)</param>
        /// <returns>OneTx</returns>
        OneTx OneGetTransaction(string hash, decimal? shardID = default(decimal?));
        /// <summary>
        /// Get count of outgoing ONE transactions
        /// </summary>
        /// <remarks>
        /// 1 credit per API call Get a number of outgoing ONE transactions for the address. When a transaction is sent, there can be multiple outgoing transactions, which are not yet processed by the blockchain. To distinguish between them, there is a counter called a nonce, which represents the order of the transaction in the list of outgoing transactions.
        /// </remarks>
        /// <exception cref="Tatum.CSharp.Harmony.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="address">address</param>
        /// <param name="shardID">Shard to read data from (optional, default to 0M)</param>
        /// <returns>decimal</returns>
        decimal OneGetTransactionCount(string address, decimal? shardID = default(decimal?));
        #endregion Synchronous Operations
    }

    /// <summary>
    /// Represents a collection of functions to interact with the API endpoints
    /// </summary>
    public interface IHarmonyApiWithHttpInfoSync : IApiAccessor
    {
        #region Synchronous Operations With Http Info
        /// <summary>
        /// Invoke a method in a smart contract on Harmony
        /// </summary>
        /// <remarks>
        /// 2 credits per API call Invoke a method in an existing smart contract on Harmony. You can call a read-only or write method. For read-only methods, the output of the invoked method is returned. For write methods, the ID of the associated transaction is returned. Signing a transaction When invoking a method in a smart contract, you are charged a fee for the transaction, and you must sign the transaction with the private key of the blockchain address from which the fee will be deducted. Providing the private key in the API is not a secure way of signing transactions, because the private key can be stolen or exposed. Your private keys should never leave your security perimeter. You should use the private keys only for testing a solution you are building on the testnet of a blockchain. For signing transactions on the mainnet, we strongly recommend that you use the Tatum Key Management System (KMS) and provide the signature ID instead of the private key in the API. Alternatively, you can use the Tatum JavaScript client.
        /// </remarks>
        /// <exception cref="Tatum.CSharp.Harmony.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="callOneReadSmartContractMethod"></param>
        /// <param name="shardID">Shard to read data from (optional, default to 0M)</param>
        /// <returns>ApiResponse of Data</returns>
        ApiResponse<Data> OneBlockchainSmartContractInvocationWithHttpInfo(CallOneReadSmartContractMethod callOneReadSmartContractMethod, decimal? shardID = default(decimal?));
        /// <summary>
        /// Invoke a method in a smart contract on Harmony
        /// </summary>
        /// <remarks>
        /// 2 credits per API call Invoke a method in an existing smart contract on Harmony. You can call a read-only or write method. For read-only methods, the output of the invoked method is returned. For write methods, the ID of the associated transaction is returned. Signing a transaction When invoking a method in a smart contract, you are charged a fee for the transaction, and you must sign the transaction with the private key of the blockchain address from which the fee will be deducted. Providing the private key in the API is not a secure way of signing transactions, because the private key can be stolen or exposed. Your private keys should never leave your security perimeter. You should use the private keys only for testing a solution you are building on the testnet of a blockchain. For signing transactions on the mainnet, we strongly recommend that you use the Tatum Key Management System (KMS) and provide the signature ID instead of the private key in the API. Alternatively, you can use the Tatum JavaScript client.
        /// </remarks>
        /// <exception cref="Tatum.CSharp.Harmony.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="callOneSmartContractMethod"></param>
        /// <param name="shardID">Shard to read data from (optional, default to 0M)</param>
        /// <returns>ApiResponse of TransactionHash</returns>
        ApiResponse<TransactionHash> OneBlockchainSmartContractInvocationWithHttpInfo(CallOneSmartContractMethod callOneSmartContractMethod, decimal? shardID = default(decimal?));
        /// <summary>
        /// Invoke a method in a smart contract on Harmony
        /// </summary>
        /// <remarks>
        /// 2 credits per API call Invoke a method in an existing smart contract on Harmony. You can call a read-only or write method. For read-only methods, the output of the invoked method is returned. For write methods, the ID of the associated transaction is returned. Signing a transaction When invoking a method in a smart contract, you are charged a fee for the transaction, and you must sign the transaction with the private key of the blockchain address from which the fee will be deducted. Providing the private key in the API is not a secure way of signing transactions, because the private key can be stolen or exposed. Your private keys should never leave your security perimeter. You should use the private keys only for testing a solution you are building on the testnet of a blockchain. For signing transactions on the mainnet, we strongly recommend that you use the Tatum Key Management System (KMS) and provide the signature ID instead of the private key in the API. Alternatively, you can use the Tatum JavaScript client.
        /// </remarks>
        /// <exception cref="Tatum.CSharp.Harmony.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="callOneSmartContractMethodKMS"></param>
        /// <param name="shardID">Shard to read data from (optional, default to 0M)</param>
        /// <returns>ApiResponse of SignatureId</returns>
        ApiResponse<SignatureId> OneBlockchainSmartContractInvocationWithHttpInfo(CallOneSmartContractMethodKMS callOneSmartContractMethodKMS, decimal? shardID = default(decimal?));
        /// <summary>
        /// Send ONE / HRM20 from account to account
        /// </summary>
        /// <remarks>
        /// 2 credits per API call Send ONE or Tatum supported HRM20 token from account to account. Default shard 0 is used for sender and recipient. Signing a transaction When sending ONE, you are charged a fee for the transaction, and you must sign the transaction with the private key of the blockchain address from which the fee will be deducted. Providing the private key in the API is not a secure way of signing transactions, because the private key can be stolen or exposed. Your private keys should never leave your security perimeter. You should use the private keys only for testing a solution you are building on the testnet of a blockchain. For signing transactions on the mainnet, we strongly recommend that you use the Tatum Key Management System (KMS) and provide the signature ID instead of the private key in the API. Alternatively, you can use the Tatum JavaScript client. Alternatively, using the Tatum client library for supported languages.
        /// </remarks>
        /// <exception cref="Tatum.CSharp.Harmony.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="transferOneBlockchain"></param>
        /// <param name="shardID">Shard to read data from (optional, default to 0M)</param>
        /// <returns>ApiResponse of TransactionHash</returns>
        ApiResponse<TransactionHash> OneBlockchainTransferWithHttpInfo(TransferOneBlockchain transferOneBlockchain, decimal? shardID = default(decimal?));
        /// <summary>
        /// Send ONE / HRM20 from account to account
        /// </summary>
        /// <remarks>
        /// 2 credits per API call Send ONE or Tatum supported HRM20 token from account to account. Default shard 0 is used for sender and recipient. Signing a transaction When sending ONE, you are charged a fee for the transaction, and you must sign the transaction with the private key of the blockchain address from which the fee will be deducted. Providing the private key in the API is not a secure way of signing transactions, because the private key can be stolen or exposed. Your private keys should never leave your security perimeter. You should use the private keys only for testing a solution you are building on the testnet of a blockchain. For signing transactions on the mainnet, we strongly recommend that you use the Tatum Key Management System (KMS) and provide the signature ID instead of the private key in the API. Alternatively, you can use the Tatum JavaScript client. Alternatively, using the Tatum client library for supported languages.
        /// </remarks>
        /// <exception cref="Tatum.CSharp.Harmony.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="transferOneBlockchainKMS"></param>
        /// <param name="shardID">Shard to read data from (optional, default to 0M)</param>
        /// <returns>ApiResponse of SignatureId</returns>
        ApiResponse<SignatureId> OneBlockchainTransferWithHttpInfo(TransferOneBlockchainKMS transferOneBlockchainKMS, decimal? shardID = default(decimal?));
        /// <summary>
        /// Broadcast signed ONE transaction
        /// </summary>
        /// <remarks>
        /// 2 credits per API call Broadcast signed transaction to ONE blockchain. This method is used internally from Tatum KMS or Tatum client libraries. It is possible to create custom signing mechanism and use this method only for broadcasting data to the blockchain.
        /// </remarks>
        /// <exception cref="Tatum.CSharp.Harmony.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="broadcastKMS"></param>
        /// <param name="shardID">Shard to read data from (optional, default to 0M)</param>
        /// <returns>ApiResponse of TransactionHash</returns>
        ApiResponse<TransactionHash> OneBroadcastWithHttpInfo(BroadcastKMS broadcastKMS, decimal? shardID = default(decimal?));
        /// <summary>
        /// Transform HEX address to Bech32 ONE address format
        /// </summary>
        /// <remarks>
        /// 1 credit per API call Transform HEX address to Bech32 format with one prefix.
        /// </remarks>
        /// <exception cref="Tatum.CSharp.Harmony.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="address">Address in HEX (ETH compatible) format.</param>
        /// <returns>ApiResponse of GeneratedAddressOne</returns>
        ApiResponse<GeneratedAddressOne> OneFormatAddressWithHttpInfo(string address);
        /// <summary>
        /// Generate ONE account address from Extended public key
        /// </summary>
        /// <remarks>
        /// 1 credit per API call Generate ONE account deposit address from Extended public key. Deposit address is generated for the specific index - each extended public key can generate up to 2^31 addresses starting from index 0 until 2^31.
        /// </remarks>
        /// <exception cref="Tatum.CSharp.Harmony.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="xpub">Extended public key of wallet.</param>
        /// <param name="index">Derivation index of desired address to be generated.</param>
        /// <returns>ApiResponse of GeneratedAddressOne</returns>
        ApiResponse<GeneratedAddressOne> OneGenerateAddressWithHttpInfo(string xpub, decimal index);
        /// <summary>
        /// Generate ONE private key
        /// </summary>
        /// <remarks>
        /// 1 credit per API call Generate private key of address from mnemonic for given derivation path index. Private key is generated for the specific index - each mnemonic can generate up to 2^31 private keys starting from index 0 until 2^31.
        /// </remarks>
        /// <exception cref="Tatum.CSharp.Harmony.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="privKeyRequest"></param>
        /// <returns>ApiResponse of PrivKey</returns>
        ApiResponse<PrivKey> OneGenerateAddressPrivateKeyWithHttpInfo(PrivKeyRequest privKeyRequest);
        /// <summary>
        /// Generate ONE wallet
        /// </summary>
        /// <remarks>
        /// 1 credit per API call Tatum supports BIP44 HD wallets. It is very convenient and secure, since it can generate 2^31 addresses from 1 mnemonic phrase. Mnemonic phrase consists of 24 special words in defined order and can restore access to all generated addresses and private keys. Each address is identified by 3 main values: Private Key - your secret value, which should never be revealed Public Key - public address to be published Derivation index - index of generated address Tatum follows BIP44 specification and generates for ONE wallet with derivation path m&#39;/44&#39;/60&#39;/0&#39;/0. More about BIP44 HD wallets can be found here - https://github.com/bitcoin/bips/blob/master/bip-0044.mediawiki. Generate BIP44 compatible ONE wallet.
        /// </remarks>
        /// <exception cref="Tatum.CSharp.Harmony.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="mnemonic">Mnemonic to use for generation of extended public and private keys. (optional)</param>
        /// <returns>ApiResponse of Wallet</returns>
        ApiResponse<Wallet> OneGenerateWalletWithHttpInfo(string mnemonic = default(string));
        /// <summary>
        /// Get ONE Account balance
        /// </summary>
        /// <remarks>
        /// 1 credit per API call Get ONE account balance in ONE. This method does not prints any balance of the HRM20 or HRM721 tokens on the account.
        /// </remarks>
        /// <exception cref="Tatum.CSharp.Harmony.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="address">Account address you want to get balance of</param>
        /// <param name="shardID">Shard to read data from (optional, default to 0M)</param>
        /// <returns>ApiResponse of OneBalance</returns>
        ApiResponse<OneBalance> OneGetBalanceWithHttpInfo(string address, decimal? shardID = default(decimal?));
        /// <summary>
        /// Get ONE block by hash
        /// </summary>
        /// <remarks>
        /// 1 credit per API call Get ONE block by block hash or block number.
        /// </remarks>
        /// <exception cref="Tatum.CSharp.Harmony.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="hash">Block hash or block number</param>
        /// <param name="shardID">Shard to read data from (optional, default to 0M)</param>
        /// <returns>ApiResponse of EthBlock</returns>
        ApiResponse<EthBlock> OneGetBlockWithHttpInfo(string hash, decimal? shardID = default(decimal?));
        /// <summary>
        /// Get current block number
        /// </summary>
        /// <remarks>
        /// 1 credit per API call Get ONE current block number. This is the number of the latest block in the blockchain.
        /// </remarks>
        /// <exception cref="Tatum.CSharp.Harmony.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <returns>ApiResponse of List&lt;OneBlockCurrent&gt;</returns>
        ApiResponse<List<OneBlockCurrent>> OneGetCurrentBlockWithHttpInfo();
        /// <summary>
        /// Get ONE Transaction
        /// </summary>
        /// <remarks>
        /// 2 credits per API call Get ONE transaction by transaction hash.
        /// </remarks>
        /// <exception cref="Tatum.CSharp.Harmony.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="hash">Transaction hash</param>
        /// <param name="shardID">Shard to read data from (optional, default to 0M)</param>
        /// <returns>ApiResponse of OneTx</returns>
        ApiResponse<OneTx> OneGetTransactionWithHttpInfo(string hash, decimal? shardID = default(decimal?));
        /// <summary>
        /// Get count of outgoing ONE transactions
        /// </summary>
        /// <remarks>
        /// 1 credit per API call Get a number of outgoing ONE transactions for the address. When a transaction is sent, there can be multiple outgoing transactions, which are not yet processed by the blockchain. To distinguish between them, there is a counter called a nonce, which represents the order of the transaction in the list of outgoing transactions.
        /// </remarks>
        /// <exception cref="Tatum.CSharp.Harmony.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="address">address</param>
        /// <param name="shardID">Shard to read data from (optional, default to 0M)</param>
        /// <returns>ApiResponse of decimal</returns>
        ApiResponse<decimal> OneGetTransactionCountWithHttpInfo(string address, decimal? shardID = default(decimal?));
        #endregion Synchronous Operations With Http Info
    }

    /// <summary>
    /// Represents a collection of functions to interact with the API endpoints
    /// </summary>
    public interface IHarmonyApiAsync : IApiAccessor
    {
        #region Asynchronous Operations
        /// <summary>
        /// Invoke a method in a smart contract on Harmony
        /// </summary>
        /// <remarks>
        /// 2 credits per API call Invoke a method in an existing smart contract on Harmony. You can call a read-only or write method. For read-only methods, the output of the invoked method is returned. For write methods, the ID of the associated transaction is returned. Signing a transaction When invoking a method in a smart contract, you are charged a fee for the transaction, and you must sign the transaction with the private key of the blockchain address from which the fee will be deducted. Providing the private key in the API is not a secure way of signing transactions, because the private key can be stolen or exposed. Your private keys should never leave your security perimeter. You should use the private keys only for testing a solution you are building on the testnet of a blockchain. For signing transactions on the mainnet, we strongly recommend that you use the Tatum Key Management System (KMS) and provide the signature ID instead of the private key in the API. Alternatively, you can use the Tatum JavaScript client.
        /// </remarks>
        /// <exception cref="Tatum.CSharp.Harmony.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="callOneReadSmartContractMethod"></param>
        /// <param name="shardID">Shard to read data from (optional, default to 0M)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of Data</returns>
        System.Threading.Tasks.Task<Data> OneBlockchainSmartContractInvocationAsync(CallOneReadSmartContractMethod callOneReadSmartContractMethod, decimal? shardID = default(decimal?), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        /// <summary>
        /// Invoke a method in a smart contract on Harmony
        /// </summary>
        /// <remarks>
        /// 2 credits per API call Invoke a method in an existing smart contract on Harmony. You can call a read-only or write method. For read-only methods, the output of the invoked method is returned. For write methods, the ID of the associated transaction is returned. Signing a transaction When invoking a method in a smart contract, you are charged a fee for the transaction, and you must sign the transaction with the private key of the blockchain address from which the fee will be deducted. Providing the private key in the API is not a secure way of signing transactions, because the private key can be stolen or exposed. Your private keys should never leave your security perimeter. You should use the private keys only for testing a solution you are building on the testnet of a blockchain. For signing transactions on the mainnet, we strongly recommend that you use the Tatum Key Management System (KMS) and provide the signature ID instead of the private key in the API. Alternatively, you can use the Tatum JavaScript client.
        /// </remarks>
        /// <exception cref="Tatum.CSharp.Harmony.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="callOneSmartContractMethod"></param>
        /// <param name="shardID">Shard to read data from (optional, default to 0M)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of TransactionHash</returns>
        System.Threading.Tasks.Task<TransactionHash> OneBlockchainSmartContractInvocationAsync(CallOneSmartContractMethod callOneSmartContractMethod, decimal? shardID = default(decimal?), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        /// <summary>
        /// Invoke a method in a smart contract on Harmony
        /// </summary>
        /// <remarks>
        /// 2 credits per API call Invoke a method in an existing smart contract on Harmony. You can call a read-only or write method. For read-only methods, the output of the invoked method is returned. For write methods, the ID of the associated transaction is returned. Signing a transaction When invoking a method in a smart contract, you are charged a fee for the transaction, and you must sign the transaction with the private key of the blockchain address from which the fee will be deducted. Providing the private key in the API is not a secure way of signing transactions, because the private key can be stolen or exposed. Your private keys should never leave your security perimeter. You should use the private keys only for testing a solution you are building on the testnet of a blockchain. For signing transactions on the mainnet, we strongly recommend that you use the Tatum Key Management System (KMS) and provide the signature ID instead of the private key in the API. Alternatively, you can use the Tatum JavaScript client.
        /// </remarks>
        /// <exception cref="Tatum.CSharp.Harmony.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="callOneSmartContractMethodKMS"></param>
        /// <param name="shardID">Shard to read data from (optional, default to 0M)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of SignatureId</returns>
        System.Threading.Tasks.Task<SignatureId> OneBlockchainSmartContractInvocationAsync(CallOneSmartContractMethodKMS callOneSmartContractMethodKMS, decimal? shardID = default(decimal?), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        /// <summary>
        /// Send ONE / HRM20 from account to account
        /// </summary>
        /// <remarks>
        /// 2 credits per API call Send ONE or Tatum supported HRM20 token from account to account. Default shard 0 is used for sender and recipient. Signing a transaction When sending ONE, you are charged a fee for the transaction, and you must sign the transaction with the private key of the blockchain address from which the fee will be deducted. Providing the private key in the API is not a secure way of signing transactions, because the private key can be stolen or exposed. Your private keys should never leave your security perimeter. You should use the private keys only for testing a solution you are building on the testnet of a blockchain. For signing transactions on the mainnet, we strongly recommend that you use the Tatum Key Management System (KMS) and provide the signature ID instead of the private key in the API. Alternatively, you can use the Tatum JavaScript client. Alternatively, using the Tatum client library for supported languages.
        /// </remarks>
        /// <exception cref="Tatum.CSharp.Harmony.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="transferOneBlockchain"></param>
        /// <param name="shardID">Shard to read data from (optional, default to 0M)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of TransactionHash</returns>
        System.Threading.Tasks.Task<TransactionHash> OneBlockchainTransferAsync(TransferOneBlockchain transferOneBlockchain, decimal? shardID = default(decimal?), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        /// <summary>
        /// Send ONE / HRM20 from account to account
        /// </summary>
        /// <remarks>
        /// 2 credits per API call Send ONE or Tatum supported HRM20 token from account to account. Default shard 0 is used for sender and recipient. Signing a transaction When sending ONE, you are charged a fee for the transaction, and you must sign the transaction with the private key of the blockchain address from which the fee will be deducted. Providing the private key in the API is not a secure way of signing transactions, because the private key can be stolen or exposed. Your private keys should never leave your security perimeter. You should use the private keys only for testing a solution you are building on the testnet of a blockchain. For signing transactions on the mainnet, we strongly recommend that you use the Tatum Key Management System (KMS) and provide the signature ID instead of the private key in the API. Alternatively, you can use the Tatum JavaScript client. Alternatively, using the Tatum client library for supported languages.
        /// </remarks>
        /// <exception cref="Tatum.CSharp.Harmony.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="transferOneBlockchainKMS"></param>
        /// <param name="shardID">Shard to read data from (optional, default to 0M)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of SignatureId</returns>
        System.Threading.Tasks.Task<SignatureId> OneBlockchainTransferAsync(TransferOneBlockchainKMS transferOneBlockchainKMS, decimal? shardID = default(decimal?), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        /// <summary>
        /// Broadcast signed ONE transaction
        /// </summary>
        /// <remarks>
        /// 2 credits per API call Broadcast signed transaction to ONE blockchain. This method is used internally from Tatum KMS or Tatum client libraries. It is possible to create custom signing mechanism and use this method only for broadcasting data to the blockchain.
        /// </remarks>
        /// <exception cref="Tatum.CSharp.Harmony.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="broadcastKMS"></param>
        /// <param name="shardID">Shard to read data from (optional, default to 0M)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of TransactionHash</returns>
        System.Threading.Tasks.Task<TransactionHash> OneBroadcastAsync(BroadcastKMS broadcastKMS, decimal? shardID = default(decimal?), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        /// <summary>
        /// Transform HEX address to Bech32 ONE address format
        /// </summary>
        /// <remarks>
        /// 1 credit per API call Transform HEX address to Bech32 format with one prefix.
        /// </remarks>
        /// <exception cref="Tatum.CSharp.Harmony.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="address">Address in HEX (ETH compatible) format.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of GeneratedAddressOne</returns>
        System.Threading.Tasks.Task<GeneratedAddressOne> OneFormatAddressAsync(string address, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        /// <summary>
        /// Generate ONE account address from Extended public key
        /// </summary>
        /// <remarks>
        /// 1 credit per API call Generate ONE account deposit address from Extended public key. Deposit address is generated for the specific index - each extended public key can generate up to 2^31 addresses starting from index 0 until 2^31.
        /// </remarks>
        /// <exception cref="Tatum.CSharp.Harmony.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="xpub">Extended public key of wallet.</param>
        /// <param name="index">Derivation index of desired address to be generated.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of GeneratedAddressOne</returns>
        System.Threading.Tasks.Task<GeneratedAddressOne> OneGenerateAddressAsync(string xpub, decimal index, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        /// <summary>
        /// Generate ONE private key
        /// </summary>
        /// <remarks>
        /// 1 credit per API call Generate private key of address from mnemonic for given derivation path index. Private key is generated for the specific index - each mnemonic can generate up to 2^31 private keys starting from index 0 until 2^31.
        /// </remarks>
        /// <exception cref="Tatum.CSharp.Harmony.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="privKeyRequest"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of PrivKey</returns>
        System.Threading.Tasks.Task<PrivKey> OneGenerateAddressPrivateKeyAsync(PrivKeyRequest privKeyRequest, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        /// <summary>
        /// Generate ONE wallet
        /// </summary>
        /// <remarks>
        /// 1 credit per API call Tatum supports BIP44 HD wallets. It is very convenient and secure, since it can generate 2^31 addresses from 1 mnemonic phrase. Mnemonic phrase consists of 24 special words in defined order and can restore access to all generated addresses and private keys. Each address is identified by 3 main values: Private Key - your secret value, which should never be revealed Public Key - public address to be published Derivation index - index of generated address Tatum follows BIP44 specification and generates for ONE wallet with derivation path m&#39;/44&#39;/60&#39;/0&#39;/0. More about BIP44 HD wallets can be found here - https://github.com/bitcoin/bips/blob/master/bip-0044.mediawiki. Generate BIP44 compatible ONE wallet.
        /// </remarks>
        /// <exception cref="Tatum.CSharp.Harmony.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="mnemonic">Mnemonic to use for generation of extended public and private keys. (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of Wallet</returns>
        System.Threading.Tasks.Task<Wallet> OneGenerateWalletAsync(string mnemonic = default(string), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        /// <summary>
        /// Get ONE Account balance
        /// </summary>
        /// <remarks>
        /// 1 credit per API call Get ONE account balance in ONE. This method does not prints any balance of the HRM20 or HRM721 tokens on the account.
        /// </remarks>
        /// <exception cref="Tatum.CSharp.Harmony.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="address">Account address you want to get balance of</param>
        /// <param name="shardID">Shard to read data from (optional, default to 0M)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of OneBalance</returns>
        System.Threading.Tasks.Task<OneBalance> OneGetBalanceAsync(string address, decimal? shardID = default(decimal?), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        /// <summary>
        /// Get ONE block by hash
        /// </summary>
        /// <remarks>
        /// 1 credit per API call Get ONE block by block hash or block number.
        /// </remarks>
        /// <exception cref="Tatum.CSharp.Harmony.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="hash">Block hash or block number</param>
        /// <param name="shardID">Shard to read data from (optional, default to 0M)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of EthBlock</returns>
        System.Threading.Tasks.Task<EthBlock> OneGetBlockAsync(string hash, decimal? shardID = default(decimal?), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        /// <summary>
        /// Get current block number
        /// </summary>
        /// <remarks>
        /// 1 credit per API call Get ONE current block number. This is the number of the latest block in the blockchain.
        /// </remarks>
        /// <exception cref="Tatum.CSharp.Harmony.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of List&lt;OneBlockCurrent&gt;</returns>
        System.Threading.Tasks.Task<List<OneBlockCurrent>> OneGetCurrentBlockAsync(System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        /// <summary>
        /// Get ONE Transaction
        /// </summary>
        /// <remarks>
        /// 2 credits per API call Get ONE transaction by transaction hash.
        /// </remarks>
        /// <exception cref="Tatum.CSharp.Harmony.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="hash">Transaction hash</param>
        /// <param name="shardID">Shard to read data from (optional, default to 0M)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of OneTx</returns>
        System.Threading.Tasks.Task<OneTx> OneGetTransactionAsync(string hash, decimal? shardID = default(decimal?), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        /// <summary>
        /// Get count of outgoing ONE transactions
        /// </summary>
        /// <remarks>
        /// 1 credit per API call Get a number of outgoing ONE transactions for the address. When a transaction is sent, there can be multiple outgoing transactions, which are not yet processed by the blockchain. To distinguish between them, there is a counter called a nonce, which represents the order of the transaction in the list of outgoing transactions.
        /// </remarks>
        /// <exception cref="Tatum.CSharp.Harmony.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="address">address</param>
        /// <param name="shardID">Shard to read data from (optional, default to 0M)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of decimal</returns>
        System.Threading.Tasks.Task<decimal> OneGetTransactionCountAsync(string address, decimal? shardID = default(decimal?), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        #endregion Asynchronous Operations
    }

    /// <summary>
    /// Represents a collection of functions to interact with the API endpoints
    /// </summary>
    public interface IHarmonyApiWithHttpInfoAsync : IApiAccessor
    {
        #region Asynchronous Operations With Http Info
        /// <summary>
        /// Invoke a method in a smart contract on Harmony
        /// </summary>
        /// <remarks>
        /// 2 credits per API call Invoke a method in an existing smart contract on Harmony. You can call a read-only or write method. For read-only methods, the output of the invoked method is returned. For write methods, the ID of the associated transaction is returned. Signing a transaction When invoking a method in a smart contract, you are charged a fee for the transaction, and you must sign the transaction with the private key of the blockchain address from which the fee will be deducted. Providing the private key in the API is not a secure way of signing transactions, because the private key can be stolen or exposed. Your private keys should never leave your security perimeter. You should use the private keys only for testing a solution you are building on the testnet of a blockchain. For signing transactions on the mainnet, we strongly recommend that you use the Tatum Key Management System (KMS) and provide the signature ID instead of the private key in the API. Alternatively, you can use the Tatum JavaScript client.
        /// </remarks>
        /// <exception cref="Tatum.CSharp.Harmony.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="callOneReadSmartContractMethod"></param>
        /// <param name="shardID">Shard to read data from (optional, default to 0M)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (Data)</returns>
        System.Threading.Tasks.Task<ApiResponse<Data>> OneBlockchainSmartContractInvocationWithHttpInfoAsync(CallOneReadSmartContractMethod callOneReadSmartContractMethod, decimal? shardID = default(decimal?), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        /// <summary>
        /// Invoke a method in a smart contract on Harmony
        /// </summary>
        /// <remarks>
        /// 2 credits per API call Invoke a method in an existing smart contract on Harmony. You can call a read-only or write method. For read-only methods, the output of the invoked method is returned. For write methods, the ID of the associated transaction is returned. Signing a transaction When invoking a method in a smart contract, you are charged a fee for the transaction, and you must sign the transaction with the private key of the blockchain address from which the fee will be deducted. Providing the private key in the API is not a secure way of signing transactions, because the private key can be stolen or exposed. Your private keys should never leave your security perimeter. You should use the private keys only for testing a solution you are building on the testnet of a blockchain. For signing transactions on the mainnet, we strongly recommend that you use the Tatum Key Management System (KMS) and provide the signature ID instead of the private key in the API. Alternatively, you can use the Tatum JavaScript client.
        /// </remarks>
        /// <exception cref="Tatum.CSharp.Harmony.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="callOneSmartContractMethod"></param>
        /// <param name="shardID">Shard to read data from (optional, default to 0M)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (TransactionHash)</returns>
        System.Threading.Tasks.Task<ApiResponse<TransactionHash>> OneBlockchainSmartContractInvocationWithHttpInfoAsync(CallOneSmartContractMethod callOneSmartContractMethod, decimal? shardID = default(decimal?), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        /// <summary>
        /// Invoke a method in a smart contract on Harmony
        /// </summary>
        /// <remarks>
        /// 2 credits per API call Invoke a method in an existing smart contract on Harmony. You can call a read-only or write method. For read-only methods, the output of the invoked method is returned. For write methods, the ID of the associated transaction is returned. Signing a transaction When invoking a method in a smart contract, you are charged a fee for the transaction, and you must sign the transaction with the private key of the blockchain address from which the fee will be deducted. Providing the private key in the API is not a secure way of signing transactions, because the private key can be stolen or exposed. Your private keys should never leave your security perimeter. You should use the private keys only for testing a solution you are building on the testnet of a blockchain. For signing transactions on the mainnet, we strongly recommend that you use the Tatum Key Management System (KMS) and provide the signature ID instead of the private key in the API. Alternatively, you can use the Tatum JavaScript client.
        /// </remarks>
        /// <exception cref="Tatum.CSharp.Harmony.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="callOneSmartContractMethodKMS"></param>
        /// <param name="shardID">Shard to read data from (optional, default to 0M)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (SignatureId)</returns>
        System.Threading.Tasks.Task<ApiResponse<SignatureId>> OneBlockchainSmartContractInvocationWithHttpInfoAsync(CallOneSmartContractMethodKMS callOneSmartContractMethodKMS, decimal? shardID = default(decimal?), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        /// <summary>
        /// Send ONE / HRM20 from account to account
        /// </summary>
        /// <remarks>
        /// 2 credits per API call Send ONE or Tatum supported HRM20 token from account to account. Default shard 0 is used for sender and recipient. Signing a transaction When sending ONE, you are charged a fee for the transaction, and you must sign the transaction with the private key of the blockchain address from which the fee will be deducted. Providing the private key in the API is not a secure way of signing transactions, because the private key can be stolen or exposed. Your private keys should never leave your security perimeter. You should use the private keys only for testing a solution you are building on the testnet of a blockchain. For signing transactions on the mainnet, we strongly recommend that you use the Tatum Key Management System (KMS) and provide the signature ID instead of the private key in the API. Alternatively, you can use the Tatum JavaScript client. Alternatively, using the Tatum client library for supported languages.
        /// </remarks>
        /// <exception cref="Tatum.CSharp.Harmony.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="transferOneBlockchain"></param>
        /// <param name="shardID">Shard to read data from (optional, default to 0M)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (TransactionHash)</returns>
        System.Threading.Tasks.Task<ApiResponse<TransactionHash>> OneBlockchainTransferWithHttpInfoAsync(TransferOneBlockchain transferOneBlockchain, decimal? shardID = default(decimal?), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        /// <summary>
        /// Send ONE / HRM20 from account to account
        /// </summary>
        /// <remarks>
        /// 2 credits per API call Send ONE or Tatum supported HRM20 token from account to account. Default shard 0 is used for sender and recipient. Signing a transaction When sending ONE, you are charged a fee for the transaction, and you must sign the transaction with the private key of the blockchain address from which the fee will be deducted. Providing the private key in the API is not a secure way of signing transactions, because the private key can be stolen or exposed. Your private keys should never leave your security perimeter. You should use the private keys only for testing a solution you are building on the testnet of a blockchain. For signing transactions on the mainnet, we strongly recommend that you use the Tatum Key Management System (KMS) and provide the signature ID instead of the private key in the API. Alternatively, you can use the Tatum JavaScript client. Alternatively, using the Tatum client library for supported languages.
        /// </remarks>
        /// <exception cref="Tatum.CSharp.Harmony.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="transferOneBlockchainKMS"></param>
        /// <param name="shardID">Shard to read data from (optional, default to 0M)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (SignatureId)</returns>
        System.Threading.Tasks.Task<ApiResponse<SignatureId>> OneBlockchainTransferWithHttpInfoAsync(TransferOneBlockchainKMS transferOneBlockchainKMS, decimal? shardID = default(decimal?), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        /// <summary>
        /// Broadcast signed ONE transaction
        /// </summary>
        /// <remarks>
        /// 2 credits per API call Broadcast signed transaction to ONE blockchain. This method is used internally from Tatum KMS or Tatum client libraries. It is possible to create custom signing mechanism and use this method only for broadcasting data to the blockchain.
        /// </remarks>
        /// <exception cref="Tatum.CSharp.Harmony.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="broadcastKMS"></param>
        /// <param name="shardID">Shard to read data from (optional, default to 0M)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (TransactionHash)</returns>
        System.Threading.Tasks.Task<ApiResponse<TransactionHash>> OneBroadcastWithHttpInfoAsync(BroadcastKMS broadcastKMS, decimal? shardID = default(decimal?), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        /// <summary>
        /// Transform HEX address to Bech32 ONE address format
        /// </summary>
        /// <remarks>
        /// 1 credit per API call Transform HEX address to Bech32 format with one prefix.
        /// </remarks>
        /// <exception cref="Tatum.CSharp.Harmony.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="address">Address in HEX (ETH compatible) format.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (GeneratedAddressOne)</returns>
        System.Threading.Tasks.Task<ApiResponse<GeneratedAddressOne>> OneFormatAddressWithHttpInfoAsync(string address, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        /// <summary>
        /// Generate ONE account address from Extended public key
        /// </summary>
        /// <remarks>
        /// 1 credit per API call Generate ONE account deposit address from Extended public key. Deposit address is generated for the specific index - each extended public key can generate up to 2^31 addresses starting from index 0 until 2^31.
        /// </remarks>
        /// <exception cref="Tatum.CSharp.Harmony.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="xpub">Extended public key of wallet.</param>
        /// <param name="index">Derivation index of desired address to be generated.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (GeneratedAddressOne)</returns>
        System.Threading.Tasks.Task<ApiResponse<GeneratedAddressOne>> OneGenerateAddressWithHttpInfoAsync(string xpub, decimal index, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        /// <summary>
        /// Generate ONE private key
        /// </summary>
        /// <remarks>
        /// 1 credit per API call Generate private key of address from mnemonic for given derivation path index. Private key is generated for the specific index - each mnemonic can generate up to 2^31 private keys starting from index 0 until 2^31.
        /// </remarks>
        /// <exception cref="Tatum.CSharp.Harmony.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="privKeyRequest"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (PrivKey)</returns>
        System.Threading.Tasks.Task<ApiResponse<PrivKey>> OneGenerateAddressPrivateKeyWithHttpInfoAsync(PrivKeyRequest privKeyRequest, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        /// <summary>
        /// Generate ONE wallet
        /// </summary>
        /// <remarks>
        /// 1 credit per API call Tatum supports BIP44 HD wallets. It is very convenient and secure, since it can generate 2^31 addresses from 1 mnemonic phrase. Mnemonic phrase consists of 24 special words in defined order and can restore access to all generated addresses and private keys. Each address is identified by 3 main values: Private Key - your secret value, which should never be revealed Public Key - public address to be published Derivation index - index of generated address Tatum follows BIP44 specification and generates for ONE wallet with derivation path m&#39;/44&#39;/60&#39;/0&#39;/0. More about BIP44 HD wallets can be found here - https://github.com/bitcoin/bips/blob/master/bip-0044.mediawiki. Generate BIP44 compatible ONE wallet.
        /// </remarks>
        /// <exception cref="Tatum.CSharp.Harmony.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="mnemonic">Mnemonic to use for generation of extended public and private keys. (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (Wallet)</returns>
        System.Threading.Tasks.Task<ApiResponse<Wallet>> OneGenerateWalletWithHttpInfoAsync(string mnemonic = default(string), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        /// <summary>
        /// Get ONE Account balance
        /// </summary>
        /// <remarks>
        /// 1 credit per API call Get ONE account balance in ONE. This method does not prints any balance of the HRM20 or HRM721 tokens on the account.
        /// </remarks>
        /// <exception cref="Tatum.CSharp.Harmony.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="address">Account address you want to get balance of</param>
        /// <param name="shardID">Shard to read data from (optional, default to 0M)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (OneBalance)</returns>
        System.Threading.Tasks.Task<ApiResponse<OneBalance>> OneGetBalanceWithHttpInfoAsync(string address, decimal? shardID = default(decimal?), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        /// <summary>
        /// Get ONE block by hash
        /// </summary>
        /// <remarks>
        /// 1 credit per API call Get ONE block by block hash or block number.
        /// </remarks>
        /// <exception cref="Tatum.CSharp.Harmony.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="hash">Block hash or block number</param>
        /// <param name="shardID">Shard to read data from (optional, default to 0M)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (EthBlock)</returns>
        System.Threading.Tasks.Task<ApiResponse<EthBlock>> OneGetBlockWithHttpInfoAsync(string hash, decimal? shardID = default(decimal?), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        /// <summary>
        /// Get current block number
        /// </summary>
        /// <remarks>
        /// 1 credit per API call Get ONE current block number. This is the number of the latest block in the blockchain.
        /// </remarks>
        /// <exception cref="Tatum.CSharp.Harmony.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (List&lt;OneBlockCurrent&gt;)</returns>
        System.Threading.Tasks.Task<ApiResponse<List<OneBlockCurrent>>> OneGetCurrentBlockWithHttpInfoAsync(System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        /// <summary>
        /// Get ONE Transaction
        /// </summary>
        /// <remarks>
        /// 2 credits per API call Get ONE transaction by transaction hash.
        /// </remarks>
        /// <exception cref="Tatum.CSharp.Harmony.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="hash">Transaction hash</param>
        /// <param name="shardID">Shard to read data from (optional, default to 0M)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (OneTx)</returns>
        System.Threading.Tasks.Task<ApiResponse<OneTx>> OneGetTransactionWithHttpInfoAsync(string hash, decimal? shardID = default(decimal?), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        /// <summary>
        /// Get count of outgoing ONE transactions
        /// </summary>
        /// <remarks>
        /// 1 credit per API call Get a number of outgoing ONE transactions for the address. When a transaction is sent, there can be multiple outgoing transactions, which are not yet processed by the blockchain. To distinguish between them, there is a counter called a nonce, which represents the order of the transaction in the list of outgoing transactions.
        /// </remarks>
        /// <exception cref="Tatum.CSharp.Harmony.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="address">address</param>
        /// <param name="shardID">Shard to read data from (optional, default to 0M)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (decimal)</returns>
        System.Threading.Tasks.Task<ApiResponse<decimal>> OneGetTransactionCountWithHttpInfoAsync(string address, decimal? shardID = default(decimal?), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        #endregion Asynchronous Operations With Http Info
    }


    /// <summary>
    /// Represents a collection of functions to interact with the API endpoints
    /// </summary>
    public interface IHarmonyApi : IHarmonyApiSync, IHarmonyApiWithHttpInfoSync, IHarmonyApiAsync, IHarmonyApiWithHttpInfoAsync
    {

    }

    /// <summary>
    /// Represents a collection of functions to interact with the API endpoints
    /// </summary>
    public partial class HarmonyApi : IHarmonyApi
    {
        private ExceptionFactory _exceptionFactory = (name, response) => null;

        /// <summary>
        /// Initializes a new instance of the <see cref="HarmonyApi"/> class.
        /// </summary>
        /// <param name="client">An instance of HttpClient.</param>
        /// <param name="handler">An optional instance of HttpClientHandler that is used by HttpClient.</param>
        /// <exception cref="ArgumentNullException"></exception>
        /// <returns></returns>
        /// <remarks>
        /// Some configuration settings will not be applied without passing an HttpClientHandler.
        /// The features affected are: Setting and Retrieving Cookies, Client Certificates, Proxy settings.
        /// </remarks>
        public HarmonyApi(HttpClient client, HttpClientHandler handler = null) : this(client, (string)null, handler)
        {
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="HarmonyApi"/> class.
        /// </summary>
        /// <param name="client">An instance of HttpClient.</param>
        /// <param name="basePath">The target service's base path in URL format.</param>
        /// <param name="handler">An optional instance of HttpClientHandler that is used by HttpClient.</param>
        /// <exception cref="ArgumentNullException"></exception>
        /// <exception cref="ArgumentException"></exception>
        /// <returns></returns>
        /// <remarks>
        /// Some configuration settings will not be applied without passing an HttpClientHandler.
        /// The features affected are: Setting and Retrieving Cookies, Client Certificates, Proxy settings.
        /// </remarks>
        public HarmonyApi(HttpClient client, string basePath, HttpClientHandler handler = null)
        {
            if (client == null) throw new ArgumentNullException(nameof(client));

            Configuration = Tatum.CSharp.Harmony.Core.Client.Configuration.MergeConfigurations(
                GlobalConfiguration.Instance,
                new Configuration { BasePath = basePath }
            );
            ApiClient = new ApiClient(client, Configuration.BasePath, handler);
            Client =  ApiClient;
            AsynchronousClient = ApiClient;
            ExceptionFactory = Tatum.CSharp.Harmony.Core.Client.Configuration.DefaultExceptionFactory;
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="HarmonyApi"/> class using Configuration object.
        /// </summary>
        /// <param name="client">An instance of HttpClient.</param>
        /// <param name="configuration">An instance of Configuration.</param>
        /// <param name="handler">An optional instance of HttpClientHandler that is used by HttpClient.</param>
        /// <exception cref="ArgumentNullException"></exception>
        /// <returns></returns>
        /// <remarks>
        /// Some configuration settings will not be applied without passing an HttpClientHandler.
        /// The features affected are: Setting and Retrieving Cookies, Client Certificates, Proxy settings.
        /// </remarks>
        public HarmonyApi(HttpClient client, Configuration configuration, HttpClientHandler handler = null)
        {
            if (configuration == null) throw new ArgumentNullException(nameof(configuration));
            if (client == null) throw new ArgumentNullException(nameof(client));

            Configuration = Tatum.CSharp.Harmony.Core.Client.Configuration.MergeConfigurations(
                GlobalConfiguration.Instance,
                configuration
            );
            ApiClient = new ApiClient(client, Configuration.BasePath, handler);
            Client = ApiClient;
            AsynchronousClient = ApiClient;
            ExceptionFactory = Tatum.CSharp.Harmony.Core.Client.Configuration.DefaultExceptionFactory;
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="HarmonyApi"/> class
        /// using a Configuration object and client instance.
        /// </summary>
        /// <param name="client">The client interface for synchronous API access.</param>
        /// <param name="asyncClient">The client interface for asynchronous API access.</param>
        /// <param name="configuration">The configuration object.</param>
        /// <exception cref="ArgumentNullException"></exception>
        public HarmonyApi(ISynchronousClient client, IAsynchronousClient asyncClient, IReadableConfiguration configuration)
        {
            Client = client ?? throw new ArgumentNullException(nameof(client));
            AsynchronousClient = asyncClient ?? throw new ArgumentNullException(nameof(asyncClient));
            Configuration = configuration ?? throw new ArgumentNullException(nameof(configuration));
            ExceptionFactory = Tatum.CSharp.Harmony.Core.Client.Configuration.DefaultExceptionFactory;
        }

        /// <summary>
        /// Holds the ApiClient if created
        /// </summary>
        public ApiClient ApiClient { get; set; }

        /// <summary>
        /// The client for accessing this underlying API asynchronously.
        /// </summary>
        public IAsynchronousClient AsynchronousClient { get; set; }

        /// <summary>
        /// The client for accessing this underlying API synchronously.
        /// </summary>
        public ISynchronousClient Client { get; set; }

        /// <summary>
        /// Gets the base path of the API client.
        /// </summary>
        /// <value>The base path</value>
        public string GetBasePath()
        {
            return Configuration.BasePath;
        }

        /// <summary>
        /// Gets or sets the configuration object
        /// </summary>
        /// <value>An instance of the Configuration</value>
        public IReadableConfiguration Configuration { get; set; }

        /// <summary>
        /// Provides a factory method hook for the creation of exceptions.
        /// </summary>
        public ExceptionFactory ExceptionFactory
        {
            get
            {
                if (_exceptionFactory != null && _exceptionFactory.GetInvocationList().Length > 1)
                {
                    throw new InvalidOperationException("Multicast delegate for ExceptionFactory is unsupported.");
                }
                return _exceptionFactory;
            }
            set => _exceptionFactory = value;
        }

        /// <summary>
        /// Invoke a method in a smart contract on Harmony 2 credits per API call Invoke a method in an existing smart contract on Harmony. You can call a read-only or write method. For read-only methods, the output of the invoked method is returned. For write methods, the ID of the associated transaction is returned. Signing a transaction When invoking a method in a smart contract, you are charged a fee for the transaction, and you must sign the transaction with the private key of the blockchain address from which the fee will be deducted. Providing the private key in the API is not a secure way of signing transactions, because the private key can be stolen or exposed. Your private keys should never leave your security perimeter. You should use the private keys only for testing a solution you are building on the testnet of a blockchain. For signing transactions on the mainnet, we strongly recommend that you use the Tatum Key Management System (KMS) and provide the signature ID instead of the private key in the API. Alternatively, you can use the Tatum JavaScript client.
        /// </summary>
        /// <exception cref="Tatum.CSharp.Harmony.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="callOneReadSmartContractMethod"></param>
        /// <param name="shardID">Shard to read data from (optional, default to 0M)</param>
        /// <returns>Data</returns>
        public Data OneBlockchainSmartContractInvocation(CallOneReadSmartContractMethod callOneReadSmartContractMethod, decimal? shardID = default(decimal?))
        {
            var localVarResponse = OneBlockchainSmartContractInvocationWithHttpInfo(callOneReadSmartContractMethod, shardID);

            var exception = ExceptionFactory?.Invoke("OneBlockchainSmartContractInvocation", localVarResponse);
            if (exception != null) throw exception;

            return localVarResponse.Data;
        }

        /// <summary>
        /// Invoke a method in a smart contract on Harmony 2 credits per API call Invoke a method in an existing smart contract on Harmony. You can call a read-only or write method. For read-only methods, the output of the invoked method is returned. For write methods, the ID of the associated transaction is returned. Signing a transaction When invoking a method in a smart contract, you are charged a fee for the transaction, and you must sign the transaction with the private key of the blockchain address from which the fee will be deducted. Providing the private key in the API is not a secure way of signing transactions, because the private key can be stolen or exposed. Your private keys should never leave your security perimeter. You should use the private keys only for testing a solution you are building on the testnet of a blockchain. For signing transactions on the mainnet, we strongly recommend that you use the Tatum Key Management System (KMS) and provide the signature ID instead of the private key in the API. Alternatively, you can use the Tatum JavaScript client.
        /// </summary>
        /// <exception cref="Tatum.CSharp.Harmony.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="callOneReadSmartContractMethod"></param>
        /// <param name="shardID">Shard to read data from (optional, default to 0M)</param>
        /// <returns>ApiResponse of Data</returns>
        public ApiResponse<Data> OneBlockchainSmartContractInvocationWithHttpInfo(CallOneReadSmartContractMethod callOneReadSmartContractMethod, decimal? shardID = default(decimal?))
        {
            // verify the required parameter 'callOneReadSmartContractMethod' is set
            if (callOneReadSmartContractMethod == null)
                throw new ApiException(400, "Missing required parameter 'callOneReadSmartContractMethod' when calling HarmonyApi->OneBlockchainSmartContractInvocation");

            var localVarRequestOptions = new RequestOptions();

            var contentTypes = new string[]{
                "application/json"
            };

            // to determine the Accept header
            var accepts = new string[]{
                "application/json"
            };

            var localVarContentType = ClientUtils.SelectHeaderContentType(contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = ClientUtils.SelectHeaderAccept(accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            if (shardID != null)
            {
                localVarRequestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "shardID", shardID));
            }
            localVarRequestOptions.Data = callOneReadSmartContractMethod;

            // authentication (X-API-Key) required
            if (!string.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("x-api-key")))
            {
                localVarRequestOptions.HeaderParameters.Add("x-api-key", Configuration.GetApiKeyWithPrefix("x-api-key"));
            }

            // make the HTTP request
            var localVarResponse = Client.Post<Data>("/v3/one/smartcontract", localVarRequestOptions, Configuration);

            return localVarResponse;
        }

        /// <summary>
        /// Invoke a method in a smart contract on Harmony 2 credits per API call Invoke a method in an existing smart contract on Harmony. You can call a read-only or write method. For read-only methods, the output of the invoked method is returned. For write methods, the ID of the associated transaction is returned. Signing a transaction When invoking a method in a smart contract, you are charged a fee for the transaction, and you must sign the transaction with the private key of the blockchain address from which the fee will be deducted. Providing the private key in the API is not a secure way of signing transactions, because the private key can be stolen or exposed. Your private keys should never leave your security perimeter. You should use the private keys only for testing a solution you are building on the testnet of a blockchain. For signing transactions on the mainnet, we strongly recommend that you use the Tatum Key Management System (KMS) and provide the signature ID instead of the private key in the API. Alternatively, you can use the Tatum JavaScript client.
        /// </summary>
        /// <exception cref="Tatum.CSharp.Harmony.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="callOneReadSmartContractMethod"></param>
        /// <param name="shardID">Shard to read data from (optional, default to 0M)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of Data</returns>
        public async System.Threading.Tasks.Task<Data> OneBlockchainSmartContractInvocationAsync(CallOneReadSmartContractMethod callOneReadSmartContractMethod, decimal? shardID = default(decimal?), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            var localVarResponse = await OneBlockchainSmartContractInvocationWithHttpInfoAsync(callOneReadSmartContractMethod, shardID, cancellationToken).ConfigureAwait(false);
            
            var exception = ExceptionFactory?.Invoke("OneBlockchainSmartContractInvocation", localVarResponse);
            if (exception != null) throw exception;

            return localVarResponse.Data;
        }

        /// <summary>
        /// Invoke a method in a smart contract on Harmony 2 credits per API call Invoke a method in an existing smart contract on Harmony. You can call a read-only or write method. For read-only methods, the output of the invoked method is returned. For write methods, the ID of the associated transaction is returned. Signing a transaction When invoking a method in a smart contract, you are charged a fee for the transaction, and you must sign the transaction with the private key of the blockchain address from which the fee will be deducted. Providing the private key in the API is not a secure way of signing transactions, because the private key can be stolen or exposed. Your private keys should never leave your security perimeter. You should use the private keys only for testing a solution you are building on the testnet of a blockchain. For signing transactions on the mainnet, we strongly recommend that you use the Tatum Key Management System (KMS) and provide the signature ID instead of the private key in the API. Alternatively, you can use the Tatum JavaScript client.
        /// </summary>
        /// <exception cref="Tatum.CSharp.Harmony.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="callOneReadSmartContractMethod"></param>
        /// <param name="shardID">Shard to read data from (optional, default to 0M)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (Data)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<Data>> OneBlockchainSmartContractInvocationWithHttpInfoAsync(CallOneReadSmartContractMethod callOneReadSmartContractMethod, decimal? shardID = default(decimal?), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            // verify the required parameter 'callOneReadSmartContractMethod' is set
            if (callOneReadSmartContractMethod == null)
                throw new ApiException(400, "Missing required parameter 'callOneReadSmartContractMethod' when calling HarmonyApi->OneBlockchainSmartContractInvocation");

            var localVarRequestOptions = new RequestOptions();

            var contentTypes = new string[]{
                "application/json"
            };

            // to determine the Accept header
            var accepts = new string[]{
                "application/json"
            };


            var localVarContentType = ClientUtils.SelectHeaderContentType(contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = ClientUtils.SelectHeaderAccept(accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            if (shardID != null)
            {
                localVarRequestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "shardID", shardID));
            }
            localVarRequestOptions.Data = callOneReadSmartContractMethod;

            // authentication (X-API-Key) required
            if (!string.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("x-api-key")))
            {
                localVarRequestOptions.HeaderParameters.Add("x-api-key", Configuration.GetApiKeyWithPrefix("x-api-key"));
            }

            // make the HTTP request

            var localVarResponse = await AsynchronousClient.PostAsync<Data>("/v3/one/smartcontract", localVarRequestOptions, Configuration, cancellationToken).ConfigureAwait(false);

            return localVarResponse;
        }

        /// <summary>
        /// Invoke a method in a smart contract on Harmony 2 credits per API call Invoke a method in an existing smart contract on Harmony. You can call a read-only or write method. For read-only methods, the output of the invoked method is returned. For write methods, the ID of the associated transaction is returned. Signing a transaction When invoking a method in a smart contract, you are charged a fee for the transaction, and you must sign the transaction with the private key of the blockchain address from which the fee will be deducted. Providing the private key in the API is not a secure way of signing transactions, because the private key can be stolen or exposed. Your private keys should never leave your security perimeter. You should use the private keys only for testing a solution you are building on the testnet of a blockchain. For signing transactions on the mainnet, we strongly recommend that you use the Tatum Key Management System (KMS) and provide the signature ID instead of the private key in the API. Alternatively, you can use the Tatum JavaScript client.
        /// </summary>
        /// <exception cref="Tatum.CSharp.Harmony.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="callOneSmartContractMethod"></param>
        /// <param name="shardID">Shard to read data from (optional, default to 0M)</param>
        /// <returns>TransactionHash</returns>
        public TransactionHash OneBlockchainSmartContractInvocation(CallOneSmartContractMethod callOneSmartContractMethod, decimal? shardID = default(decimal?))
        {
            var localVarResponse = OneBlockchainSmartContractInvocationWithHttpInfo(callOneSmartContractMethod, shardID);

            var exception = ExceptionFactory?.Invoke("OneBlockchainSmartContractInvocation_0", localVarResponse);
            if (exception != null) throw exception;

            return localVarResponse.Data;
        }

        /// <summary>
        /// Invoke a method in a smart contract on Harmony 2 credits per API call Invoke a method in an existing smart contract on Harmony. You can call a read-only or write method. For read-only methods, the output of the invoked method is returned. For write methods, the ID of the associated transaction is returned. Signing a transaction When invoking a method in a smart contract, you are charged a fee for the transaction, and you must sign the transaction with the private key of the blockchain address from which the fee will be deducted. Providing the private key in the API is not a secure way of signing transactions, because the private key can be stolen or exposed. Your private keys should never leave your security perimeter. You should use the private keys only for testing a solution you are building on the testnet of a blockchain. For signing transactions on the mainnet, we strongly recommend that you use the Tatum Key Management System (KMS) and provide the signature ID instead of the private key in the API. Alternatively, you can use the Tatum JavaScript client.
        /// </summary>
        /// <exception cref="Tatum.CSharp.Harmony.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="callOneSmartContractMethod"></param>
        /// <param name="shardID">Shard to read data from (optional, default to 0M)</param>
        /// <returns>ApiResponse of TransactionHash</returns>
        public ApiResponse<TransactionHash> OneBlockchainSmartContractInvocationWithHttpInfo(CallOneSmartContractMethod callOneSmartContractMethod, decimal? shardID = default(decimal?))
        {
            // verify the required parameter 'callOneSmartContractMethod' is set
            if (callOneSmartContractMethod == null)
                throw new ApiException(400, "Missing required parameter 'callOneSmartContractMethod' when calling HarmonyApi->OneBlockchainSmartContractInvocation_0");

            var localVarRequestOptions = new RequestOptions();

            var contentTypes = new string[]{
                "application/json"
            };

            // to determine the Accept header
            var accepts = new string[]{
                "application/json"
            };

            var localVarContentType = ClientUtils.SelectHeaderContentType(contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = ClientUtils.SelectHeaderAccept(accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            if (shardID != null)
            {
                localVarRequestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "shardID", shardID));
            }
            localVarRequestOptions.Data = callOneSmartContractMethod;

            // authentication (X-API-Key) required
            if (!string.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("x-api-key")))
            {
                localVarRequestOptions.HeaderParameters.Add("x-api-key", Configuration.GetApiKeyWithPrefix("x-api-key"));
            }

            // make the HTTP request
            var localVarResponse = Client.Post<TransactionHash>("/v3/one/smartcontract", localVarRequestOptions, Configuration);

            return localVarResponse;
        }

        /// <summary>
        /// Invoke a method in a smart contract on Harmony 2 credits per API call Invoke a method in an existing smart contract on Harmony. You can call a read-only or write method. For read-only methods, the output of the invoked method is returned. For write methods, the ID of the associated transaction is returned. Signing a transaction When invoking a method in a smart contract, you are charged a fee for the transaction, and you must sign the transaction with the private key of the blockchain address from which the fee will be deducted. Providing the private key in the API is not a secure way of signing transactions, because the private key can be stolen or exposed. Your private keys should never leave your security perimeter. You should use the private keys only for testing a solution you are building on the testnet of a blockchain. For signing transactions on the mainnet, we strongly recommend that you use the Tatum Key Management System (KMS) and provide the signature ID instead of the private key in the API. Alternatively, you can use the Tatum JavaScript client.
        /// </summary>
        /// <exception cref="Tatum.CSharp.Harmony.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="callOneSmartContractMethod"></param>
        /// <param name="shardID">Shard to read data from (optional, default to 0M)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of TransactionHash</returns>
        public async System.Threading.Tasks.Task<TransactionHash> OneBlockchainSmartContractInvocationAsync(CallOneSmartContractMethod callOneSmartContractMethod, decimal? shardID = default(decimal?), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            var localVarResponse = await OneBlockchainSmartContractInvocationWithHttpInfoAsync(callOneSmartContractMethod, shardID, cancellationToken).ConfigureAwait(false);
            
            var exception = ExceptionFactory?.Invoke("OneBlockchainSmartContractInvocation_0", localVarResponse);
            if (exception != null) throw exception;

            return localVarResponse.Data;
        }

        /// <summary>
        /// Invoke a method in a smart contract on Harmony 2 credits per API call Invoke a method in an existing smart contract on Harmony. You can call a read-only or write method. For read-only methods, the output of the invoked method is returned. For write methods, the ID of the associated transaction is returned. Signing a transaction When invoking a method in a smart contract, you are charged a fee for the transaction, and you must sign the transaction with the private key of the blockchain address from which the fee will be deducted. Providing the private key in the API is not a secure way of signing transactions, because the private key can be stolen or exposed. Your private keys should never leave your security perimeter. You should use the private keys only for testing a solution you are building on the testnet of a blockchain. For signing transactions on the mainnet, we strongly recommend that you use the Tatum Key Management System (KMS) and provide the signature ID instead of the private key in the API. Alternatively, you can use the Tatum JavaScript client.
        /// </summary>
        /// <exception cref="Tatum.CSharp.Harmony.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="callOneSmartContractMethod"></param>
        /// <param name="shardID">Shard to read data from (optional, default to 0M)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (TransactionHash)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<TransactionHash>> OneBlockchainSmartContractInvocationWithHttpInfoAsync(CallOneSmartContractMethod callOneSmartContractMethod, decimal? shardID = default(decimal?), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            // verify the required parameter 'callOneSmartContractMethod' is set
            if (callOneSmartContractMethod == null)
                throw new ApiException(400, "Missing required parameter 'callOneSmartContractMethod' when calling HarmonyApi->OneBlockchainSmartContractInvocation_0");

            var localVarRequestOptions = new RequestOptions();

            var contentTypes = new string[]{
                "application/json"
            };

            // to determine the Accept header
            var accepts = new string[]{
                "application/json"
            };


            var localVarContentType = ClientUtils.SelectHeaderContentType(contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = ClientUtils.SelectHeaderAccept(accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            if (shardID != null)
            {
                localVarRequestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "shardID", shardID));
            }
            localVarRequestOptions.Data = callOneSmartContractMethod;

            // authentication (X-API-Key) required
            if (!string.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("x-api-key")))
            {
                localVarRequestOptions.HeaderParameters.Add("x-api-key", Configuration.GetApiKeyWithPrefix("x-api-key"));
            }

            // make the HTTP request

            var localVarResponse = await AsynchronousClient.PostAsync<TransactionHash>("/v3/one/smartcontract", localVarRequestOptions, Configuration, cancellationToken).ConfigureAwait(false);

            return localVarResponse;
        }

        /// <summary>
        /// Invoke a method in a smart contract on Harmony 2 credits per API call Invoke a method in an existing smart contract on Harmony. You can call a read-only or write method. For read-only methods, the output of the invoked method is returned. For write methods, the ID of the associated transaction is returned. Signing a transaction When invoking a method in a smart contract, you are charged a fee for the transaction, and you must sign the transaction with the private key of the blockchain address from which the fee will be deducted. Providing the private key in the API is not a secure way of signing transactions, because the private key can be stolen or exposed. Your private keys should never leave your security perimeter. You should use the private keys only for testing a solution you are building on the testnet of a blockchain. For signing transactions on the mainnet, we strongly recommend that you use the Tatum Key Management System (KMS) and provide the signature ID instead of the private key in the API. Alternatively, you can use the Tatum JavaScript client.
        /// </summary>
        /// <exception cref="Tatum.CSharp.Harmony.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="callOneSmartContractMethodKMS"></param>
        /// <param name="shardID">Shard to read data from (optional, default to 0M)</param>
        /// <returns>SignatureId</returns>
        public SignatureId OneBlockchainSmartContractInvocation(CallOneSmartContractMethodKMS callOneSmartContractMethodKMS, decimal? shardID = default(decimal?))
        {
            var localVarResponse = OneBlockchainSmartContractInvocationWithHttpInfo(callOneSmartContractMethodKMS, shardID);

            var exception = ExceptionFactory?.Invoke("OneBlockchainSmartContractInvocation_1", localVarResponse);
            if (exception != null) throw exception;

            return localVarResponse.Data;
        }

        /// <summary>
        /// Invoke a method in a smart contract on Harmony 2 credits per API call Invoke a method in an existing smart contract on Harmony. You can call a read-only or write method. For read-only methods, the output of the invoked method is returned. For write methods, the ID of the associated transaction is returned. Signing a transaction When invoking a method in a smart contract, you are charged a fee for the transaction, and you must sign the transaction with the private key of the blockchain address from which the fee will be deducted. Providing the private key in the API is not a secure way of signing transactions, because the private key can be stolen or exposed. Your private keys should never leave your security perimeter. You should use the private keys only for testing a solution you are building on the testnet of a blockchain. For signing transactions on the mainnet, we strongly recommend that you use the Tatum Key Management System (KMS) and provide the signature ID instead of the private key in the API. Alternatively, you can use the Tatum JavaScript client.
        /// </summary>
        /// <exception cref="Tatum.CSharp.Harmony.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="callOneSmartContractMethodKMS"></param>
        /// <param name="shardID">Shard to read data from (optional, default to 0M)</param>
        /// <returns>ApiResponse of SignatureId</returns>
        public ApiResponse<SignatureId> OneBlockchainSmartContractInvocationWithHttpInfo(CallOneSmartContractMethodKMS callOneSmartContractMethodKMS, decimal? shardID = default(decimal?))
        {
            // verify the required parameter 'callOneSmartContractMethodKMS' is set
            if (callOneSmartContractMethodKMS == null)
                throw new ApiException(400, "Missing required parameter 'callOneSmartContractMethodKMS' when calling HarmonyApi->OneBlockchainSmartContractInvocation_1");

            var localVarRequestOptions = new RequestOptions();

            var contentTypes = new string[]{
                "application/json"
            };

            // to determine the Accept header
            var accepts = new string[]{
                "application/json"
            };

            var localVarContentType = ClientUtils.SelectHeaderContentType(contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = ClientUtils.SelectHeaderAccept(accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            if (shardID != null)
            {
                localVarRequestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "shardID", shardID));
            }
            localVarRequestOptions.Data = callOneSmartContractMethodKMS;

            // authentication (X-API-Key) required
            if (!string.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("x-api-key")))
            {
                localVarRequestOptions.HeaderParameters.Add("x-api-key", Configuration.GetApiKeyWithPrefix("x-api-key"));
            }

            // make the HTTP request
            var localVarResponse = Client.Post<SignatureId>("/v3/one/smartcontract", localVarRequestOptions, Configuration);

            return localVarResponse;
        }

        /// <summary>
        /// Invoke a method in a smart contract on Harmony 2 credits per API call Invoke a method in an existing smart contract on Harmony. You can call a read-only or write method. For read-only methods, the output of the invoked method is returned. For write methods, the ID of the associated transaction is returned. Signing a transaction When invoking a method in a smart contract, you are charged a fee for the transaction, and you must sign the transaction with the private key of the blockchain address from which the fee will be deducted. Providing the private key in the API is not a secure way of signing transactions, because the private key can be stolen or exposed. Your private keys should never leave your security perimeter. You should use the private keys only for testing a solution you are building on the testnet of a blockchain. For signing transactions on the mainnet, we strongly recommend that you use the Tatum Key Management System (KMS) and provide the signature ID instead of the private key in the API. Alternatively, you can use the Tatum JavaScript client.
        /// </summary>
        /// <exception cref="Tatum.CSharp.Harmony.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="callOneSmartContractMethodKMS"></param>
        /// <param name="shardID">Shard to read data from (optional, default to 0M)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of SignatureId</returns>
        public async System.Threading.Tasks.Task<SignatureId> OneBlockchainSmartContractInvocationAsync(CallOneSmartContractMethodKMS callOneSmartContractMethodKMS, decimal? shardID = default(decimal?), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            var localVarResponse = await OneBlockchainSmartContractInvocationWithHttpInfoAsync(callOneSmartContractMethodKMS, shardID, cancellationToken).ConfigureAwait(false);
            
            var exception = ExceptionFactory?.Invoke("OneBlockchainSmartContractInvocation_1", localVarResponse);
            if (exception != null) throw exception;

            return localVarResponse.Data;
        }

        /// <summary>
        /// Invoke a method in a smart contract on Harmony 2 credits per API call Invoke a method in an existing smart contract on Harmony. You can call a read-only or write method. For read-only methods, the output of the invoked method is returned. For write methods, the ID of the associated transaction is returned. Signing a transaction When invoking a method in a smart contract, you are charged a fee for the transaction, and you must sign the transaction with the private key of the blockchain address from which the fee will be deducted. Providing the private key in the API is not a secure way of signing transactions, because the private key can be stolen or exposed. Your private keys should never leave your security perimeter. You should use the private keys only for testing a solution you are building on the testnet of a blockchain. For signing transactions on the mainnet, we strongly recommend that you use the Tatum Key Management System (KMS) and provide the signature ID instead of the private key in the API. Alternatively, you can use the Tatum JavaScript client.
        /// </summary>
        /// <exception cref="Tatum.CSharp.Harmony.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="callOneSmartContractMethodKMS"></param>
        /// <param name="shardID">Shard to read data from (optional, default to 0M)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (SignatureId)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<SignatureId>> OneBlockchainSmartContractInvocationWithHttpInfoAsync(CallOneSmartContractMethodKMS callOneSmartContractMethodKMS, decimal? shardID = default(decimal?), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            // verify the required parameter 'callOneSmartContractMethodKMS' is set
            if (callOneSmartContractMethodKMS == null)
                throw new ApiException(400, "Missing required parameter 'callOneSmartContractMethodKMS' when calling HarmonyApi->OneBlockchainSmartContractInvocation_1");

            var localVarRequestOptions = new RequestOptions();

            var contentTypes = new string[]{
                "application/json"
            };

            // to determine the Accept header
            var accepts = new string[]{
                "application/json"
            };


            var localVarContentType = ClientUtils.SelectHeaderContentType(contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = ClientUtils.SelectHeaderAccept(accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            if (shardID != null)
            {
                localVarRequestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "shardID", shardID));
            }
            localVarRequestOptions.Data = callOneSmartContractMethodKMS;

            // authentication (X-API-Key) required
            if (!string.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("x-api-key")))
            {
                localVarRequestOptions.HeaderParameters.Add("x-api-key", Configuration.GetApiKeyWithPrefix("x-api-key"));
            }

            // make the HTTP request

            var localVarResponse = await AsynchronousClient.PostAsync<SignatureId>("/v3/one/smartcontract", localVarRequestOptions, Configuration, cancellationToken).ConfigureAwait(false);

            return localVarResponse;
        }

        /// <summary>
        /// Send ONE / HRM20 from account to account 2 credits per API call Send ONE or Tatum supported HRM20 token from account to account. Default shard 0 is used for sender and recipient. Signing a transaction When sending ONE, you are charged a fee for the transaction, and you must sign the transaction with the private key of the blockchain address from which the fee will be deducted. Providing the private key in the API is not a secure way of signing transactions, because the private key can be stolen or exposed. Your private keys should never leave your security perimeter. You should use the private keys only for testing a solution you are building on the testnet of a blockchain. For signing transactions on the mainnet, we strongly recommend that you use the Tatum Key Management System (KMS) and provide the signature ID instead of the private key in the API. Alternatively, you can use the Tatum JavaScript client. Alternatively, using the Tatum client library for supported languages.
        /// </summary>
        /// <exception cref="Tatum.CSharp.Harmony.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="transferOneBlockchain"></param>
        /// <param name="shardID">Shard to read data from (optional, default to 0M)</param>
        /// <returns>TransactionHash</returns>
        public TransactionHash OneBlockchainTransfer(TransferOneBlockchain transferOneBlockchain, decimal? shardID = default(decimal?))
        {
            var localVarResponse = OneBlockchainTransferWithHttpInfo(transferOneBlockchain, shardID);

            var exception = ExceptionFactory?.Invoke("OneBlockchainTransfer", localVarResponse);
            if (exception != null) throw exception;

            return localVarResponse.Data;
        }

        /// <summary>
        /// Send ONE / HRM20 from account to account 2 credits per API call Send ONE or Tatum supported HRM20 token from account to account. Default shard 0 is used for sender and recipient. Signing a transaction When sending ONE, you are charged a fee for the transaction, and you must sign the transaction with the private key of the blockchain address from which the fee will be deducted. Providing the private key in the API is not a secure way of signing transactions, because the private key can be stolen or exposed. Your private keys should never leave your security perimeter. You should use the private keys only for testing a solution you are building on the testnet of a blockchain. For signing transactions on the mainnet, we strongly recommend that you use the Tatum Key Management System (KMS) and provide the signature ID instead of the private key in the API. Alternatively, you can use the Tatum JavaScript client. Alternatively, using the Tatum client library for supported languages.
        /// </summary>
        /// <exception cref="Tatum.CSharp.Harmony.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="transferOneBlockchain"></param>
        /// <param name="shardID">Shard to read data from (optional, default to 0M)</param>
        /// <returns>ApiResponse of TransactionHash</returns>
        public ApiResponse<TransactionHash> OneBlockchainTransferWithHttpInfo(TransferOneBlockchain transferOneBlockchain, decimal? shardID = default(decimal?))
        {
            // verify the required parameter 'transferOneBlockchain' is set
            if (transferOneBlockchain == null)
                throw new ApiException(400, "Missing required parameter 'transferOneBlockchain' when calling HarmonyApi->OneBlockchainTransfer");

            var localVarRequestOptions = new RequestOptions();

            var contentTypes = new string[]{
                "application/json"
            };

            // to determine the Accept header
            var accepts = new string[]{
                "application/json"
            };

            var localVarContentType = ClientUtils.SelectHeaderContentType(contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = ClientUtils.SelectHeaderAccept(accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            if (shardID != null)
            {
                localVarRequestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "shardID", shardID));
            }
            localVarRequestOptions.Data = transferOneBlockchain;

            // authentication (X-API-Key) required
            if (!string.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("x-api-key")))
            {
                localVarRequestOptions.HeaderParameters.Add("x-api-key", Configuration.GetApiKeyWithPrefix("x-api-key"));
            }

            // make the HTTP request
            var localVarResponse = Client.Post<TransactionHash>("/v3/one/transaction", localVarRequestOptions, Configuration);

            return localVarResponse;
        }

        /// <summary>
        /// Send ONE / HRM20 from account to account 2 credits per API call Send ONE or Tatum supported HRM20 token from account to account. Default shard 0 is used for sender and recipient. Signing a transaction When sending ONE, you are charged a fee for the transaction, and you must sign the transaction with the private key of the blockchain address from which the fee will be deducted. Providing the private key in the API is not a secure way of signing transactions, because the private key can be stolen or exposed. Your private keys should never leave your security perimeter. You should use the private keys only for testing a solution you are building on the testnet of a blockchain. For signing transactions on the mainnet, we strongly recommend that you use the Tatum Key Management System (KMS) and provide the signature ID instead of the private key in the API. Alternatively, you can use the Tatum JavaScript client. Alternatively, using the Tatum client library for supported languages.
        /// </summary>
        /// <exception cref="Tatum.CSharp.Harmony.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="transferOneBlockchain"></param>
        /// <param name="shardID">Shard to read data from (optional, default to 0M)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of TransactionHash</returns>
        public async System.Threading.Tasks.Task<TransactionHash> OneBlockchainTransferAsync(TransferOneBlockchain transferOneBlockchain, decimal? shardID = default(decimal?), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            var localVarResponse = await OneBlockchainTransferWithHttpInfoAsync(transferOneBlockchain, shardID, cancellationToken).ConfigureAwait(false);
            
            var exception = ExceptionFactory?.Invoke("OneBlockchainTransfer", localVarResponse);
            if (exception != null) throw exception;

            return localVarResponse.Data;
        }

        /// <summary>
        /// Send ONE / HRM20 from account to account 2 credits per API call Send ONE or Tatum supported HRM20 token from account to account. Default shard 0 is used for sender and recipient. Signing a transaction When sending ONE, you are charged a fee for the transaction, and you must sign the transaction with the private key of the blockchain address from which the fee will be deducted. Providing the private key in the API is not a secure way of signing transactions, because the private key can be stolen or exposed. Your private keys should never leave your security perimeter. You should use the private keys only for testing a solution you are building on the testnet of a blockchain. For signing transactions on the mainnet, we strongly recommend that you use the Tatum Key Management System (KMS) and provide the signature ID instead of the private key in the API. Alternatively, you can use the Tatum JavaScript client. Alternatively, using the Tatum client library for supported languages.
        /// </summary>
        /// <exception cref="Tatum.CSharp.Harmony.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="transferOneBlockchain"></param>
        /// <param name="shardID">Shard to read data from (optional, default to 0M)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (TransactionHash)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<TransactionHash>> OneBlockchainTransferWithHttpInfoAsync(TransferOneBlockchain transferOneBlockchain, decimal? shardID = default(decimal?), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            // verify the required parameter 'transferOneBlockchain' is set
            if (transferOneBlockchain == null)
                throw new ApiException(400, "Missing required parameter 'transferOneBlockchain' when calling HarmonyApi->OneBlockchainTransfer");

            var localVarRequestOptions = new RequestOptions();

            var contentTypes = new string[]{
                "application/json"
            };

            // to determine the Accept header
            var accepts = new string[]{
                "application/json"
            };


            var localVarContentType = ClientUtils.SelectHeaderContentType(contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = ClientUtils.SelectHeaderAccept(accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            if (shardID != null)
            {
                localVarRequestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "shardID", shardID));
            }
            localVarRequestOptions.Data = transferOneBlockchain;

            // authentication (X-API-Key) required
            if (!string.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("x-api-key")))
            {
                localVarRequestOptions.HeaderParameters.Add("x-api-key", Configuration.GetApiKeyWithPrefix("x-api-key"));
            }

            // make the HTTP request

            var localVarResponse = await AsynchronousClient.PostAsync<TransactionHash>("/v3/one/transaction", localVarRequestOptions, Configuration, cancellationToken).ConfigureAwait(false);

            return localVarResponse;
        }

        /// <summary>
        /// Send ONE / HRM20 from account to account 2 credits per API call Send ONE or Tatum supported HRM20 token from account to account. Default shard 0 is used for sender and recipient. Signing a transaction When sending ONE, you are charged a fee for the transaction, and you must sign the transaction with the private key of the blockchain address from which the fee will be deducted. Providing the private key in the API is not a secure way of signing transactions, because the private key can be stolen or exposed. Your private keys should never leave your security perimeter. You should use the private keys only for testing a solution you are building on the testnet of a blockchain. For signing transactions on the mainnet, we strongly recommend that you use the Tatum Key Management System (KMS) and provide the signature ID instead of the private key in the API. Alternatively, you can use the Tatum JavaScript client. Alternatively, using the Tatum client library for supported languages.
        /// </summary>
        /// <exception cref="Tatum.CSharp.Harmony.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="transferOneBlockchainKMS"></param>
        /// <param name="shardID">Shard to read data from (optional, default to 0M)</param>
        /// <returns>SignatureId</returns>
        public SignatureId OneBlockchainTransfer(TransferOneBlockchainKMS transferOneBlockchainKMS, decimal? shardID = default(decimal?))
        {
            var localVarResponse = OneBlockchainTransferWithHttpInfo(transferOneBlockchainKMS, shardID);

            var exception = ExceptionFactory?.Invoke("OneBlockchainTransfer_0", localVarResponse);
            if (exception != null) throw exception;

            return localVarResponse.Data;
        }

        /// <summary>
        /// Send ONE / HRM20 from account to account 2 credits per API call Send ONE or Tatum supported HRM20 token from account to account. Default shard 0 is used for sender and recipient. Signing a transaction When sending ONE, you are charged a fee for the transaction, and you must sign the transaction with the private key of the blockchain address from which the fee will be deducted. Providing the private key in the API is not a secure way of signing transactions, because the private key can be stolen or exposed. Your private keys should never leave your security perimeter. You should use the private keys only for testing a solution you are building on the testnet of a blockchain. For signing transactions on the mainnet, we strongly recommend that you use the Tatum Key Management System (KMS) and provide the signature ID instead of the private key in the API. Alternatively, you can use the Tatum JavaScript client. Alternatively, using the Tatum client library for supported languages.
        /// </summary>
        /// <exception cref="Tatum.CSharp.Harmony.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="transferOneBlockchainKMS"></param>
        /// <param name="shardID">Shard to read data from (optional, default to 0M)</param>
        /// <returns>ApiResponse of SignatureId</returns>
        public ApiResponse<SignatureId> OneBlockchainTransferWithHttpInfo(TransferOneBlockchainKMS transferOneBlockchainKMS, decimal? shardID = default(decimal?))
        {
            // verify the required parameter 'transferOneBlockchainKMS' is set
            if (transferOneBlockchainKMS == null)
                throw new ApiException(400, "Missing required parameter 'transferOneBlockchainKMS' when calling HarmonyApi->OneBlockchainTransfer_0");

            var localVarRequestOptions = new RequestOptions();

            var contentTypes = new string[]{
                "application/json"
            };

            // to determine the Accept header
            var accepts = new string[]{
                "application/json"
            };

            var localVarContentType = ClientUtils.SelectHeaderContentType(contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = ClientUtils.SelectHeaderAccept(accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            if (shardID != null)
            {
                localVarRequestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "shardID", shardID));
            }
            localVarRequestOptions.Data = transferOneBlockchainKMS;

            // authentication (X-API-Key) required
            if (!string.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("x-api-key")))
            {
                localVarRequestOptions.HeaderParameters.Add("x-api-key", Configuration.GetApiKeyWithPrefix("x-api-key"));
            }

            // make the HTTP request
            var localVarResponse = Client.Post<SignatureId>("/v3/one/transaction", localVarRequestOptions, Configuration);

            return localVarResponse;
        }

        /// <summary>
        /// Send ONE / HRM20 from account to account 2 credits per API call Send ONE or Tatum supported HRM20 token from account to account. Default shard 0 is used for sender and recipient. Signing a transaction When sending ONE, you are charged a fee for the transaction, and you must sign the transaction with the private key of the blockchain address from which the fee will be deducted. Providing the private key in the API is not a secure way of signing transactions, because the private key can be stolen or exposed. Your private keys should never leave your security perimeter. You should use the private keys only for testing a solution you are building on the testnet of a blockchain. For signing transactions on the mainnet, we strongly recommend that you use the Tatum Key Management System (KMS) and provide the signature ID instead of the private key in the API. Alternatively, you can use the Tatum JavaScript client. Alternatively, using the Tatum client library for supported languages.
        /// </summary>
        /// <exception cref="Tatum.CSharp.Harmony.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="transferOneBlockchainKMS"></param>
        /// <param name="shardID">Shard to read data from (optional, default to 0M)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of SignatureId</returns>
        public async System.Threading.Tasks.Task<SignatureId> OneBlockchainTransferAsync(TransferOneBlockchainKMS transferOneBlockchainKMS, decimal? shardID = default(decimal?), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            var localVarResponse = await OneBlockchainTransferWithHttpInfoAsync(transferOneBlockchainKMS, shardID, cancellationToken).ConfigureAwait(false);
            
            var exception = ExceptionFactory?.Invoke("OneBlockchainTransfer_0", localVarResponse);
            if (exception != null) throw exception;

            return localVarResponse.Data;
        }

        /// <summary>
        /// Send ONE / HRM20 from account to account 2 credits per API call Send ONE or Tatum supported HRM20 token from account to account. Default shard 0 is used for sender and recipient. Signing a transaction When sending ONE, you are charged a fee for the transaction, and you must sign the transaction with the private key of the blockchain address from which the fee will be deducted. Providing the private key in the API is not a secure way of signing transactions, because the private key can be stolen or exposed. Your private keys should never leave your security perimeter. You should use the private keys only for testing a solution you are building on the testnet of a blockchain. For signing transactions on the mainnet, we strongly recommend that you use the Tatum Key Management System (KMS) and provide the signature ID instead of the private key in the API. Alternatively, you can use the Tatum JavaScript client. Alternatively, using the Tatum client library for supported languages.
        /// </summary>
        /// <exception cref="Tatum.CSharp.Harmony.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="transferOneBlockchainKMS"></param>
        /// <param name="shardID">Shard to read data from (optional, default to 0M)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (SignatureId)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<SignatureId>> OneBlockchainTransferWithHttpInfoAsync(TransferOneBlockchainKMS transferOneBlockchainKMS, decimal? shardID = default(decimal?), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            // verify the required parameter 'transferOneBlockchainKMS' is set
            if (transferOneBlockchainKMS == null)
                throw new ApiException(400, "Missing required parameter 'transferOneBlockchainKMS' when calling HarmonyApi->OneBlockchainTransfer_0");

            var localVarRequestOptions = new RequestOptions();

            var contentTypes = new string[]{
                "application/json"
            };

            // to determine the Accept header
            var accepts = new string[]{
                "application/json"
            };


            var localVarContentType = ClientUtils.SelectHeaderContentType(contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = ClientUtils.SelectHeaderAccept(accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            if (shardID != null)
            {
                localVarRequestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "shardID", shardID));
            }
            localVarRequestOptions.Data = transferOneBlockchainKMS;

            // authentication (X-API-Key) required
            if (!string.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("x-api-key")))
            {
                localVarRequestOptions.HeaderParameters.Add("x-api-key", Configuration.GetApiKeyWithPrefix("x-api-key"));
            }

            // make the HTTP request

            var localVarResponse = await AsynchronousClient.PostAsync<SignatureId>("/v3/one/transaction", localVarRequestOptions, Configuration, cancellationToken).ConfigureAwait(false);

            return localVarResponse;
        }

        /// <summary>
        /// Broadcast signed ONE transaction 2 credits per API call Broadcast signed transaction to ONE blockchain. This method is used internally from Tatum KMS or Tatum client libraries. It is possible to create custom signing mechanism and use this method only for broadcasting data to the blockchain.
        /// </summary>
        /// <exception cref="Tatum.CSharp.Harmony.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="broadcastKMS"></param>
        /// <param name="shardID">Shard to read data from (optional, default to 0M)</param>
        /// <returns>TransactionHash</returns>
        public TransactionHash OneBroadcast(BroadcastKMS broadcastKMS, decimal? shardID = default(decimal?))
        {
            var localVarResponse = OneBroadcastWithHttpInfo(broadcastKMS, shardID);

            var exception = ExceptionFactory?.Invoke("OneBroadcast", localVarResponse);
            if (exception != null) throw exception;

            return localVarResponse.Data;
        }

        /// <summary>
        /// Broadcast signed ONE transaction 2 credits per API call Broadcast signed transaction to ONE blockchain. This method is used internally from Tatum KMS or Tatum client libraries. It is possible to create custom signing mechanism and use this method only for broadcasting data to the blockchain.
        /// </summary>
        /// <exception cref="Tatum.CSharp.Harmony.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="broadcastKMS"></param>
        /// <param name="shardID">Shard to read data from (optional, default to 0M)</param>
        /// <returns>ApiResponse of TransactionHash</returns>
        public ApiResponse<TransactionHash> OneBroadcastWithHttpInfo(BroadcastKMS broadcastKMS, decimal? shardID = default(decimal?))
        {
            // verify the required parameter 'broadcastKMS' is set
            if (broadcastKMS == null)
                throw new ApiException(400, "Missing required parameter 'broadcastKMS' when calling HarmonyApi->OneBroadcast");

            var localVarRequestOptions = new RequestOptions();

            var contentTypes = new string[]{
                "application/json"
            };

            // to determine the Accept header
            var accepts = new string[]{
                "application/json"
            };

            var localVarContentType = ClientUtils.SelectHeaderContentType(contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = ClientUtils.SelectHeaderAccept(accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            if (shardID != null)
            {
                localVarRequestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "shardID", shardID));
            }
            localVarRequestOptions.Data = broadcastKMS;

            // authentication (X-API-Key) required
            if (!string.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("x-api-key")))
            {
                localVarRequestOptions.HeaderParameters.Add("x-api-key", Configuration.GetApiKeyWithPrefix("x-api-key"));
            }

            // make the HTTP request
            var localVarResponse = Client.Post<TransactionHash>("/v3/one/broadcast", localVarRequestOptions, Configuration);

            return localVarResponse;
        }

        /// <summary>
        /// Broadcast signed ONE transaction 2 credits per API call Broadcast signed transaction to ONE blockchain. This method is used internally from Tatum KMS or Tatum client libraries. It is possible to create custom signing mechanism and use this method only for broadcasting data to the blockchain.
        /// </summary>
        /// <exception cref="Tatum.CSharp.Harmony.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="broadcastKMS"></param>
        /// <param name="shardID">Shard to read data from (optional, default to 0M)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of TransactionHash</returns>
        public async System.Threading.Tasks.Task<TransactionHash> OneBroadcastAsync(BroadcastKMS broadcastKMS, decimal? shardID = default(decimal?), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            var localVarResponse = await OneBroadcastWithHttpInfoAsync(broadcastKMS, shardID, cancellationToken).ConfigureAwait(false);
            
            var exception = ExceptionFactory?.Invoke("OneBroadcast", localVarResponse);
            if (exception != null) throw exception;

            return localVarResponse.Data;
        }

        /// <summary>
        /// Broadcast signed ONE transaction 2 credits per API call Broadcast signed transaction to ONE blockchain. This method is used internally from Tatum KMS or Tatum client libraries. It is possible to create custom signing mechanism and use this method only for broadcasting data to the blockchain.
        /// </summary>
        /// <exception cref="Tatum.CSharp.Harmony.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="broadcastKMS"></param>
        /// <param name="shardID">Shard to read data from (optional, default to 0M)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (TransactionHash)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<TransactionHash>> OneBroadcastWithHttpInfoAsync(BroadcastKMS broadcastKMS, decimal? shardID = default(decimal?), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            // verify the required parameter 'broadcastKMS' is set
            if (broadcastKMS == null)
                throw new ApiException(400, "Missing required parameter 'broadcastKMS' when calling HarmonyApi->OneBroadcast");

            var localVarRequestOptions = new RequestOptions();

            var contentTypes = new string[]{
                "application/json"
            };

            // to determine the Accept header
            var accepts = new string[]{
                "application/json"
            };


            var localVarContentType = ClientUtils.SelectHeaderContentType(contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = ClientUtils.SelectHeaderAccept(accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            if (shardID != null)
            {
                localVarRequestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "shardID", shardID));
            }
            localVarRequestOptions.Data = broadcastKMS;

            // authentication (X-API-Key) required
            if (!string.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("x-api-key")))
            {
                localVarRequestOptions.HeaderParameters.Add("x-api-key", Configuration.GetApiKeyWithPrefix("x-api-key"));
            }

            // make the HTTP request

            var localVarResponse = await AsynchronousClient.PostAsync<TransactionHash>("/v3/one/broadcast", localVarRequestOptions, Configuration, cancellationToken).ConfigureAwait(false);

            return localVarResponse;
        }

        /// <summary>
        /// Transform HEX address to Bech32 ONE address format 1 credit per API call Transform HEX address to Bech32 format with one prefix.
        /// </summary>
        /// <exception cref="Tatum.CSharp.Harmony.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="address">Address in HEX (ETH compatible) format.</param>
        /// <returns>GeneratedAddressOne</returns>
        public GeneratedAddressOne OneFormatAddress(string address)
        {
            var localVarResponse = OneFormatAddressWithHttpInfo(address);

            var exception = ExceptionFactory?.Invoke("OneFormatAddress", localVarResponse);
            if (exception != null) throw exception;

            return localVarResponse.Data;
        }

        /// <summary>
        /// Transform HEX address to Bech32 ONE address format 1 credit per API call Transform HEX address to Bech32 format with one prefix.
        /// </summary>
        /// <exception cref="Tatum.CSharp.Harmony.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="address">Address in HEX (ETH compatible) format.</param>
        /// <returns>ApiResponse of GeneratedAddressOne</returns>
        public ApiResponse<GeneratedAddressOne> OneFormatAddressWithHttpInfo(string address)
        {
            // verify the required parameter 'address' is set
            if (address == null)
                throw new ApiException(400, "Missing required parameter 'address' when calling HarmonyApi->OneFormatAddress");

            var localVarRequestOptions = new RequestOptions();

            var contentTypes = new string[]{
            };

            // to determine the Accept header
            var accepts = new string[]{
                "application/json"
            };

            var localVarContentType = ClientUtils.SelectHeaderContentType(contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = ClientUtils.SelectHeaderAccept(accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.PathParameters.Add("address", ClientUtils.ParameterToString(address)); // path parameter

            // authentication (X-API-Key) required
            if (!string.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("x-api-key")))
            {
                localVarRequestOptions.HeaderParameters.Add("x-api-key", Configuration.GetApiKeyWithPrefix("x-api-key"));
            }

            // make the HTTP request
            var localVarResponse = Client.Get<GeneratedAddressOne>("/v3/one/address/format/{address}", localVarRequestOptions, Configuration);

            return localVarResponse;
        }

        /// <summary>
        /// Transform HEX address to Bech32 ONE address format 1 credit per API call Transform HEX address to Bech32 format with one prefix.
        /// </summary>
        /// <exception cref="Tatum.CSharp.Harmony.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="address">Address in HEX (ETH compatible) format.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of GeneratedAddressOne</returns>
        public async System.Threading.Tasks.Task<GeneratedAddressOne> OneFormatAddressAsync(string address, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            var localVarResponse = await OneFormatAddressWithHttpInfoAsync(address, cancellationToken).ConfigureAwait(false);
            
            var exception = ExceptionFactory?.Invoke("OneFormatAddress", localVarResponse);
            if (exception != null) throw exception;

            return localVarResponse.Data;
        }

        /// <summary>
        /// Transform HEX address to Bech32 ONE address format 1 credit per API call Transform HEX address to Bech32 format with one prefix.
        /// </summary>
        /// <exception cref="Tatum.CSharp.Harmony.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="address">Address in HEX (ETH compatible) format.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (GeneratedAddressOne)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<GeneratedAddressOne>> OneFormatAddressWithHttpInfoAsync(string address, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            // verify the required parameter 'address' is set
            if (address == null)
                throw new ApiException(400, "Missing required parameter 'address' when calling HarmonyApi->OneFormatAddress");

            var localVarRequestOptions = new RequestOptions();

            var contentTypes = new string[]{
            };

            // to determine the Accept header
            var accepts = new string[]{
                "application/json"
            };


            var localVarContentType = ClientUtils.SelectHeaderContentType(contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = ClientUtils.SelectHeaderAccept(accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.PathParameters.Add("address", ClientUtils.ParameterToString(address)); // path parameter

            // authentication (X-API-Key) required
            if (!string.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("x-api-key")))
            {
                localVarRequestOptions.HeaderParameters.Add("x-api-key", Configuration.GetApiKeyWithPrefix("x-api-key"));
            }

            // make the HTTP request

            var localVarResponse = await AsynchronousClient.GetAsync<GeneratedAddressOne>("/v3/one/address/format/{address}", localVarRequestOptions, Configuration, cancellationToken).ConfigureAwait(false);

            return localVarResponse;
        }

        /// <summary>
        /// Generate ONE account address from Extended public key 1 credit per API call Generate ONE account deposit address from Extended public key. Deposit address is generated for the specific index - each extended public key can generate up to 2^31 addresses starting from index 0 until 2^31.
        /// </summary>
        /// <exception cref="Tatum.CSharp.Harmony.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="xpub">Extended public key of wallet.</param>
        /// <param name="index">Derivation index of desired address to be generated.</param>
        /// <returns>GeneratedAddressOne</returns>
        public GeneratedAddressOne OneGenerateAddress(string xpub, decimal index)
        {
            var localVarResponse = OneGenerateAddressWithHttpInfo(xpub, index);

            var exception = ExceptionFactory?.Invoke("OneGenerateAddress", localVarResponse);
            if (exception != null) throw exception;

            return localVarResponse.Data;
        }

        /// <summary>
        /// Generate ONE account address from Extended public key 1 credit per API call Generate ONE account deposit address from Extended public key. Deposit address is generated for the specific index - each extended public key can generate up to 2^31 addresses starting from index 0 until 2^31.
        /// </summary>
        /// <exception cref="Tatum.CSharp.Harmony.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="xpub">Extended public key of wallet.</param>
        /// <param name="index">Derivation index of desired address to be generated.</param>
        /// <returns>ApiResponse of GeneratedAddressOne</returns>
        public ApiResponse<GeneratedAddressOne> OneGenerateAddressWithHttpInfo(string xpub, decimal index)
        {
            // verify the required parameter 'xpub' is set
            if (xpub == null)
                throw new ApiException(400, "Missing required parameter 'xpub' when calling HarmonyApi->OneGenerateAddress");

            var localVarRequestOptions = new RequestOptions();

            var contentTypes = new string[]{
            };

            // to determine the Accept header
            var accepts = new string[]{
                "application/json"
            };

            var localVarContentType = ClientUtils.SelectHeaderContentType(contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = ClientUtils.SelectHeaderAccept(accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.PathParameters.Add("xpub", ClientUtils.ParameterToString(xpub)); // path parameter
            localVarRequestOptions.PathParameters.Add("index", ClientUtils.ParameterToString(index)); // path parameter

            // authentication (X-API-Key) required
            if (!string.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("x-api-key")))
            {
                localVarRequestOptions.HeaderParameters.Add("x-api-key", Configuration.GetApiKeyWithPrefix("x-api-key"));
            }

            // make the HTTP request
            var localVarResponse = Client.Get<GeneratedAddressOne>("/v3/one/address/{xpub}/{index}", localVarRequestOptions, Configuration);

            return localVarResponse;
        }

        /// <summary>
        /// Generate ONE account address from Extended public key 1 credit per API call Generate ONE account deposit address from Extended public key. Deposit address is generated for the specific index - each extended public key can generate up to 2^31 addresses starting from index 0 until 2^31.
        /// </summary>
        /// <exception cref="Tatum.CSharp.Harmony.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="xpub">Extended public key of wallet.</param>
        /// <param name="index">Derivation index of desired address to be generated.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of GeneratedAddressOne</returns>
        public async System.Threading.Tasks.Task<GeneratedAddressOne> OneGenerateAddressAsync(string xpub, decimal index, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            var localVarResponse = await OneGenerateAddressWithHttpInfoAsync(xpub, index, cancellationToken).ConfigureAwait(false);
            
            var exception = ExceptionFactory?.Invoke("OneGenerateAddress", localVarResponse);
            if (exception != null) throw exception;

            return localVarResponse.Data;
        }

        /// <summary>
        /// Generate ONE account address from Extended public key 1 credit per API call Generate ONE account deposit address from Extended public key. Deposit address is generated for the specific index - each extended public key can generate up to 2^31 addresses starting from index 0 until 2^31.
        /// </summary>
        /// <exception cref="Tatum.CSharp.Harmony.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="xpub">Extended public key of wallet.</param>
        /// <param name="index">Derivation index of desired address to be generated.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (GeneratedAddressOne)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<GeneratedAddressOne>> OneGenerateAddressWithHttpInfoAsync(string xpub, decimal index, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            // verify the required parameter 'xpub' is set
            if (xpub == null)
                throw new ApiException(400, "Missing required parameter 'xpub' when calling HarmonyApi->OneGenerateAddress");

            var localVarRequestOptions = new RequestOptions();

            var contentTypes = new string[]{
            };

            // to determine the Accept header
            var accepts = new string[]{
                "application/json"
            };


            var localVarContentType = ClientUtils.SelectHeaderContentType(contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = ClientUtils.SelectHeaderAccept(accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.PathParameters.Add("xpub", ClientUtils.ParameterToString(xpub)); // path parameter
            localVarRequestOptions.PathParameters.Add("index", ClientUtils.ParameterToString(index)); // path parameter

            // authentication (X-API-Key) required
            if (!string.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("x-api-key")))
            {
                localVarRequestOptions.HeaderParameters.Add("x-api-key", Configuration.GetApiKeyWithPrefix("x-api-key"));
            }

            // make the HTTP request

            var localVarResponse = await AsynchronousClient.GetAsync<GeneratedAddressOne>("/v3/one/address/{xpub}/{index}", localVarRequestOptions, Configuration, cancellationToken).ConfigureAwait(false);

            return localVarResponse;
        }

        /// <summary>
        /// Generate ONE private key 1 credit per API call Generate private key of address from mnemonic for given derivation path index. Private key is generated for the specific index - each mnemonic can generate up to 2^31 private keys starting from index 0 until 2^31.
        /// </summary>
        /// <exception cref="Tatum.CSharp.Harmony.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="privKeyRequest"></param>
        /// <returns>PrivKey</returns>
        public PrivKey OneGenerateAddressPrivateKey(PrivKeyRequest privKeyRequest)
        {
            var localVarResponse = OneGenerateAddressPrivateKeyWithHttpInfo(privKeyRequest);

            var exception = ExceptionFactory?.Invoke("OneGenerateAddressPrivateKey", localVarResponse);
            if (exception != null) throw exception;

            return localVarResponse.Data;
        }

        /// <summary>
        /// Generate ONE private key 1 credit per API call Generate private key of address from mnemonic for given derivation path index. Private key is generated for the specific index - each mnemonic can generate up to 2^31 private keys starting from index 0 until 2^31.
        /// </summary>
        /// <exception cref="Tatum.CSharp.Harmony.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="privKeyRequest"></param>
        /// <returns>ApiResponse of PrivKey</returns>
        public ApiResponse<PrivKey> OneGenerateAddressPrivateKeyWithHttpInfo(PrivKeyRequest privKeyRequest)
        {
            // verify the required parameter 'privKeyRequest' is set
            if (privKeyRequest == null)
                throw new ApiException(400, "Missing required parameter 'privKeyRequest' when calling HarmonyApi->OneGenerateAddressPrivateKey");

            var localVarRequestOptions = new RequestOptions();

            var contentTypes = new string[]{
                "application/json"
            };

            // to determine the Accept header
            var accepts = new string[]{
                "application/json"
            };

            var localVarContentType = ClientUtils.SelectHeaderContentType(contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = ClientUtils.SelectHeaderAccept(accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.Data = privKeyRequest;

            // authentication (X-API-Key) required
            if (!string.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("x-api-key")))
            {
                localVarRequestOptions.HeaderParameters.Add("x-api-key", Configuration.GetApiKeyWithPrefix("x-api-key"));
            }

            // make the HTTP request
            var localVarResponse = Client.Post<PrivKey>("/v3/one/wallet/priv", localVarRequestOptions, Configuration);

            return localVarResponse;
        }

        /// <summary>
        /// Generate ONE private key 1 credit per API call Generate private key of address from mnemonic for given derivation path index. Private key is generated for the specific index - each mnemonic can generate up to 2^31 private keys starting from index 0 until 2^31.
        /// </summary>
        /// <exception cref="Tatum.CSharp.Harmony.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="privKeyRequest"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of PrivKey</returns>
        public async System.Threading.Tasks.Task<PrivKey> OneGenerateAddressPrivateKeyAsync(PrivKeyRequest privKeyRequest, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            var localVarResponse = await OneGenerateAddressPrivateKeyWithHttpInfoAsync(privKeyRequest, cancellationToken).ConfigureAwait(false);
            
            var exception = ExceptionFactory?.Invoke("OneGenerateAddressPrivateKey", localVarResponse);
            if (exception != null) throw exception;

            return localVarResponse.Data;
        }

        /// <summary>
        /// Generate ONE private key 1 credit per API call Generate private key of address from mnemonic for given derivation path index. Private key is generated for the specific index - each mnemonic can generate up to 2^31 private keys starting from index 0 until 2^31.
        /// </summary>
        /// <exception cref="Tatum.CSharp.Harmony.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="privKeyRequest"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (PrivKey)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<PrivKey>> OneGenerateAddressPrivateKeyWithHttpInfoAsync(PrivKeyRequest privKeyRequest, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            // verify the required parameter 'privKeyRequest' is set
            if (privKeyRequest == null)
                throw new ApiException(400, "Missing required parameter 'privKeyRequest' when calling HarmonyApi->OneGenerateAddressPrivateKey");

            var localVarRequestOptions = new RequestOptions();

            var contentTypes = new string[]{
                "application/json"
            };

            // to determine the Accept header
            var accepts = new string[]{
                "application/json"
            };


            var localVarContentType = ClientUtils.SelectHeaderContentType(contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = ClientUtils.SelectHeaderAccept(accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.Data = privKeyRequest;

            // authentication (X-API-Key) required
            if (!string.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("x-api-key")))
            {
                localVarRequestOptions.HeaderParameters.Add("x-api-key", Configuration.GetApiKeyWithPrefix("x-api-key"));
            }

            // make the HTTP request

            var localVarResponse = await AsynchronousClient.PostAsync<PrivKey>("/v3/one/wallet/priv", localVarRequestOptions, Configuration, cancellationToken).ConfigureAwait(false);

            return localVarResponse;
        }

        /// <summary>
        /// Generate ONE wallet 1 credit per API call Tatum supports BIP44 HD wallets. It is very convenient and secure, since it can generate 2^31 addresses from 1 mnemonic phrase. Mnemonic phrase consists of 24 special words in defined order and can restore access to all generated addresses and private keys. Each address is identified by 3 main values: Private Key - your secret value, which should never be revealed Public Key - public address to be published Derivation index - index of generated address Tatum follows BIP44 specification and generates for ONE wallet with derivation path m&#39;/44&#39;/60&#39;/0&#39;/0. More about BIP44 HD wallets can be found here - https://github.com/bitcoin/bips/blob/master/bip-0044.mediawiki. Generate BIP44 compatible ONE wallet.
        /// </summary>
        /// <exception cref="Tatum.CSharp.Harmony.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="mnemonic">Mnemonic to use for generation of extended public and private keys. (optional)</param>
        /// <returns>Wallet</returns>
        public Wallet OneGenerateWallet(string mnemonic = default(string))
        {
            var localVarResponse = OneGenerateWalletWithHttpInfo(mnemonic);

            var exception = ExceptionFactory?.Invoke("OneGenerateWallet", localVarResponse);
            if (exception != null) throw exception;

            return localVarResponse.Data;
        }

        /// <summary>
        /// Generate ONE wallet 1 credit per API call Tatum supports BIP44 HD wallets. It is very convenient and secure, since it can generate 2^31 addresses from 1 mnemonic phrase. Mnemonic phrase consists of 24 special words in defined order and can restore access to all generated addresses and private keys. Each address is identified by 3 main values: Private Key - your secret value, which should never be revealed Public Key - public address to be published Derivation index - index of generated address Tatum follows BIP44 specification and generates for ONE wallet with derivation path m&#39;/44&#39;/60&#39;/0&#39;/0. More about BIP44 HD wallets can be found here - https://github.com/bitcoin/bips/blob/master/bip-0044.mediawiki. Generate BIP44 compatible ONE wallet.
        /// </summary>
        /// <exception cref="Tatum.CSharp.Harmony.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="mnemonic">Mnemonic to use for generation of extended public and private keys. (optional)</param>
        /// <returns>ApiResponse of Wallet</returns>
        public ApiResponse<Wallet> OneGenerateWalletWithHttpInfo(string mnemonic = default(string))
        {
            var localVarRequestOptions = new RequestOptions();

            var contentTypes = new string[]{
            };

            // to determine the Accept header
            var accepts = new string[]{
                "application/json"
            };

            var localVarContentType = ClientUtils.SelectHeaderContentType(contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = ClientUtils.SelectHeaderAccept(accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            if (mnemonic != null)
            {
                localVarRequestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "mnemonic", mnemonic));
            }

            // authentication (X-API-Key) required
            if (!string.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("x-api-key")))
            {
                localVarRequestOptions.HeaderParameters.Add("x-api-key", Configuration.GetApiKeyWithPrefix("x-api-key"));
            }

            // make the HTTP request
            var localVarResponse = Client.Get<Wallet>("/v3/one/wallet", localVarRequestOptions, Configuration);

            return localVarResponse;
        }

        /// <summary>
        /// Generate ONE wallet 1 credit per API call Tatum supports BIP44 HD wallets. It is very convenient and secure, since it can generate 2^31 addresses from 1 mnemonic phrase. Mnemonic phrase consists of 24 special words in defined order and can restore access to all generated addresses and private keys. Each address is identified by 3 main values: Private Key - your secret value, which should never be revealed Public Key - public address to be published Derivation index - index of generated address Tatum follows BIP44 specification and generates for ONE wallet with derivation path m&#39;/44&#39;/60&#39;/0&#39;/0. More about BIP44 HD wallets can be found here - https://github.com/bitcoin/bips/blob/master/bip-0044.mediawiki. Generate BIP44 compatible ONE wallet.
        /// </summary>
        /// <exception cref="Tatum.CSharp.Harmony.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="mnemonic">Mnemonic to use for generation of extended public and private keys. (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of Wallet</returns>
        public async System.Threading.Tasks.Task<Wallet> OneGenerateWalletAsync(string mnemonic = default(string), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            var localVarResponse = await OneGenerateWalletWithHttpInfoAsync(mnemonic, cancellationToken).ConfigureAwait(false);
            
            var exception = ExceptionFactory?.Invoke("OneGenerateWallet", localVarResponse);
            if (exception != null) throw exception;

            return localVarResponse.Data;
        }

        /// <summary>
        /// Generate ONE wallet 1 credit per API call Tatum supports BIP44 HD wallets. It is very convenient and secure, since it can generate 2^31 addresses from 1 mnemonic phrase. Mnemonic phrase consists of 24 special words in defined order and can restore access to all generated addresses and private keys. Each address is identified by 3 main values: Private Key - your secret value, which should never be revealed Public Key - public address to be published Derivation index - index of generated address Tatum follows BIP44 specification and generates for ONE wallet with derivation path m&#39;/44&#39;/60&#39;/0&#39;/0. More about BIP44 HD wallets can be found here - https://github.com/bitcoin/bips/blob/master/bip-0044.mediawiki. Generate BIP44 compatible ONE wallet.
        /// </summary>
        /// <exception cref="Tatum.CSharp.Harmony.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="mnemonic">Mnemonic to use for generation of extended public and private keys. (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (Wallet)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<Wallet>> OneGenerateWalletWithHttpInfoAsync(string mnemonic = default(string), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            var localVarRequestOptions = new RequestOptions();

            var contentTypes = new string[]{
            };

            // to determine the Accept header
            var accepts = new string[]{
                "application/json"
            };


            var localVarContentType = ClientUtils.SelectHeaderContentType(contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = ClientUtils.SelectHeaderAccept(accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            if (mnemonic != null)
            {
                localVarRequestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "mnemonic", mnemonic));
            }

            // authentication (X-API-Key) required
            if (!string.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("x-api-key")))
            {
                localVarRequestOptions.HeaderParameters.Add("x-api-key", Configuration.GetApiKeyWithPrefix("x-api-key"));
            }

            // make the HTTP request

            var localVarResponse = await AsynchronousClient.GetAsync<Wallet>("/v3/one/wallet", localVarRequestOptions, Configuration, cancellationToken).ConfigureAwait(false);

            return localVarResponse;
        }

        /// <summary>
        /// Get ONE Account balance 1 credit per API call Get ONE account balance in ONE. This method does not prints any balance of the HRM20 or HRM721 tokens on the account.
        /// </summary>
        /// <exception cref="Tatum.CSharp.Harmony.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="address">Account address you want to get balance of</param>
        /// <param name="shardID">Shard to read data from (optional, default to 0M)</param>
        /// <returns>OneBalance</returns>
        public OneBalance OneGetBalance(string address, decimal? shardID = default(decimal?))
        {
            var localVarResponse = OneGetBalanceWithHttpInfo(address, shardID);

            var exception = ExceptionFactory?.Invoke("OneGetBalance", localVarResponse);
            if (exception != null) throw exception;

            return localVarResponse.Data;
        }

        /// <summary>
        /// Get ONE Account balance 1 credit per API call Get ONE account balance in ONE. This method does not prints any balance of the HRM20 or HRM721 tokens on the account.
        /// </summary>
        /// <exception cref="Tatum.CSharp.Harmony.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="address">Account address you want to get balance of</param>
        /// <param name="shardID">Shard to read data from (optional, default to 0M)</param>
        /// <returns>ApiResponse of OneBalance</returns>
        public ApiResponse<OneBalance> OneGetBalanceWithHttpInfo(string address, decimal? shardID = default(decimal?))
        {
            // verify the required parameter 'address' is set
            if (address == null)
                throw new ApiException(400, "Missing required parameter 'address' when calling HarmonyApi->OneGetBalance");

            var localVarRequestOptions = new RequestOptions();

            var contentTypes = new string[]{
            };

            // to determine the Accept header
            var accepts = new string[]{
                "application/json"
            };

            var localVarContentType = ClientUtils.SelectHeaderContentType(contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = ClientUtils.SelectHeaderAccept(accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.PathParameters.Add("address", ClientUtils.ParameterToString(address)); // path parameter
            if (shardID != null)
            {
                localVarRequestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "shardID", shardID));
            }

            // authentication (X-API-Key) required
            if (!string.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("x-api-key")))
            {
                localVarRequestOptions.HeaderParameters.Add("x-api-key", Configuration.GetApiKeyWithPrefix("x-api-key"));
            }

            // make the HTTP request
            var localVarResponse = Client.Get<OneBalance>("/v3/one/account/balance/{address}", localVarRequestOptions, Configuration);

            return localVarResponse;
        }

        /// <summary>
        /// Get ONE Account balance 1 credit per API call Get ONE account balance in ONE. This method does not prints any balance of the HRM20 or HRM721 tokens on the account.
        /// </summary>
        /// <exception cref="Tatum.CSharp.Harmony.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="address">Account address you want to get balance of</param>
        /// <param name="shardID">Shard to read data from (optional, default to 0M)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of OneBalance</returns>
        public async System.Threading.Tasks.Task<OneBalance> OneGetBalanceAsync(string address, decimal? shardID = default(decimal?), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            var localVarResponse = await OneGetBalanceWithHttpInfoAsync(address, shardID, cancellationToken).ConfigureAwait(false);
            
            var exception = ExceptionFactory?.Invoke("OneGetBalance", localVarResponse);
            if (exception != null) throw exception;

            return localVarResponse.Data;
        }

        /// <summary>
        /// Get ONE Account balance 1 credit per API call Get ONE account balance in ONE. This method does not prints any balance of the HRM20 or HRM721 tokens on the account.
        /// </summary>
        /// <exception cref="Tatum.CSharp.Harmony.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="address">Account address you want to get balance of</param>
        /// <param name="shardID">Shard to read data from (optional, default to 0M)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (OneBalance)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<OneBalance>> OneGetBalanceWithHttpInfoAsync(string address, decimal? shardID = default(decimal?), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            // verify the required parameter 'address' is set
            if (address == null)
                throw new ApiException(400, "Missing required parameter 'address' when calling HarmonyApi->OneGetBalance");

            var localVarRequestOptions = new RequestOptions();

            var contentTypes = new string[]{
            };

            // to determine the Accept header
            var accepts = new string[]{
                "application/json"
            };


            var localVarContentType = ClientUtils.SelectHeaderContentType(contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = ClientUtils.SelectHeaderAccept(accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.PathParameters.Add("address", ClientUtils.ParameterToString(address)); // path parameter
            if (shardID != null)
            {
                localVarRequestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "shardID", shardID));
            }

            // authentication (X-API-Key) required
            if (!string.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("x-api-key")))
            {
                localVarRequestOptions.HeaderParameters.Add("x-api-key", Configuration.GetApiKeyWithPrefix("x-api-key"));
            }

            // make the HTTP request

            var localVarResponse = await AsynchronousClient.GetAsync<OneBalance>("/v3/one/account/balance/{address}", localVarRequestOptions, Configuration, cancellationToken).ConfigureAwait(false);

            return localVarResponse;
        }

        /// <summary>
        /// Get ONE block by hash 1 credit per API call Get ONE block by block hash or block number.
        /// </summary>
        /// <exception cref="Tatum.CSharp.Harmony.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="hash">Block hash or block number</param>
        /// <param name="shardID">Shard to read data from (optional, default to 0M)</param>
        /// <returns>EthBlock</returns>
        public EthBlock OneGetBlock(string hash, decimal? shardID = default(decimal?))
        {
            var localVarResponse = OneGetBlockWithHttpInfo(hash, shardID);

            var exception = ExceptionFactory?.Invoke("OneGetBlock", localVarResponse);
            if (exception != null) throw exception;

            return localVarResponse.Data;
        }

        /// <summary>
        /// Get ONE block by hash 1 credit per API call Get ONE block by block hash or block number.
        /// </summary>
        /// <exception cref="Tatum.CSharp.Harmony.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="hash">Block hash or block number</param>
        /// <param name="shardID">Shard to read data from (optional, default to 0M)</param>
        /// <returns>ApiResponse of EthBlock</returns>
        public ApiResponse<EthBlock> OneGetBlockWithHttpInfo(string hash, decimal? shardID = default(decimal?))
        {
            // verify the required parameter 'hash' is set
            if (hash == null)
                throw new ApiException(400, "Missing required parameter 'hash' when calling HarmonyApi->OneGetBlock");

            var localVarRequestOptions = new RequestOptions();

            var contentTypes = new string[]{
            };

            // to determine the Accept header
            var accepts = new string[]{
                "application/json"
            };

            var localVarContentType = ClientUtils.SelectHeaderContentType(contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = ClientUtils.SelectHeaderAccept(accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.PathParameters.Add("hash", ClientUtils.ParameterToString(hash)); // path parameter
            if (shardID != null)
            {
                localVarRequestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "shardID", shardID));
            }

            // authentication (X-API-Key) required
            if (!string.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("x-api-key")))
            {
                localVarRequestOptions.HeaderParameters.Add("x-api-key", Configuration.GetApiKeyWithPrefix("x-api-key"));
            }

            // make the HTTP request
            var localVarResponse = Client.Get<EthBlock>("/v3/one/block/{hash}", localVarRequestOptions, Configuration);

            return localVarResponse;
        }

        /// <summary>
        /// Get ONE block by hash 1 credit per API call Get ONE block by block hash or block number.
        /// </summary>
        /// <exception cref="Tatum.CSharp.Harmony.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="hash">Block hash or block number</param>
        /// <param name="shardID">Shard to read data from (optional, default to 0M)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of EthBlock</returns>
        public async System.Threading.Tasks.Task<EthBlock> OneGetBlockAsync(string hash, decimal? shardID = default(decimal?), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            var localVarResponse = await OneGetBlockWithHttpInfoAsync(hash, shardID, cancellationToken).ConfigureAwait(false);
            
            var exception = ExceptionFactory?.Invoke("OneGetBlock", localVarResponse);
            if (exception != null) throw exception;

            return localVarResponse.Data;
        }

        /// <summary>
        /// Get ONE block by hash 1 credit per API call Get ONE block by block hash or block number.
        /// </summary>
        /// <exception cref="Tatum.CSharp.Harmony.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="hash">Block hash or block number</param>
        /// <param name="shardID">Shard to read data from (optional, default to 0M)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (EthBlock)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<EthBlock>> OneGetBlockWithHttpInfoAsync(string hash, decimal? shardID = default(decimal?), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            // verify the required parameter 'hash' is set
            if (hash == null)
                throw new ApiException(400, "Missing required parameter 'hash' when calling HarmonyApi->OneGetBlock");

            var localVarRequestOptions = new RequestOptions();

            var contentTypes = new string[]{
            };

            // to determine the Accept header
            var accepts = new string[]{
                "application/json"
            };


            var localVarContentType = ClientUtils.SelectHeaderContentType(contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = ClientUtils.SelectHeaderAccept(accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.PathParameters.Add("hash", ClientUtils.ParameterToString(hash)); // path parameter
            if (shardID != null)
            {
                localVarRequestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "shardID", shardID));
            }

            // authentication (X-API-Key) required
            if (!string.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("x-api-key")))
            {
                localVarRequestOptions.HeaderParameters.Add("x-api-key", Configuration.GetApiKeyWithPrefix("x-api-key"));
            }

            // make the HTTP request

            var localVarResponse = await AsynchronousClient.GetAsync<EthBlock>("/v3/one/block/{hash}", localVarRequestOptions, Configuration, cancellationToken).ConfigureAwait(false);

            return localVarResponse;
        }

        /// <summary>
        /// Get current block number 1 credit per API call Get ONE current block number. This is the number of the latest block in the blockchain.
        /// </summary>
        /// <exception cref="Tatum.CSharp.Harmony.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <returns>List&lt;OneBlockCurrent&gt;</returns>
        public List<OneBlockCurrent> OneGetCurrentBlock()
        {
            var localVarResponse = OneGetCurrentBlockWithHttpInfo();

            var exception = ExceptionFactory?.Invoke("OneGetCurrentBlock", localVarResponse);
            if (exception != null) throw exception;

            return localVarResponse.Data;
        }

        /// <summary>
        /// Get current block number 1 credit per API call Get ONE current block number. This is the number of the latest block in the blockchain.
        /// </summary>
        /// <exception cref="Tatum.CSharp.Harmony.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <returns>ApiResponse of List&lt;OneBlockCurrent&gt;</returns>
        public ApiResponse<List<OneBlockCurrent>> OneGetCurrentBlockWithHttpInfo()
        {
            var localVarRequestOptions = new RequestOptions();

            var contentTypes = new string[]{
            };

            // to determine the Accept header
            var accepts = new string[]{
                "application/json"
            };

            var localVarContentType = ClientUtils.SelectHeaderContentType(contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = ClientUtils.SelectHeaderAccept(accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);


            // authentication (X-API-Key) required
            if (!string.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("x-api-key")))
            {
                localVarRequestOptions.HeaderParameters.Add("x-api-key", Configuration.GetApiKeyWithPrefix("x-api-key"));
            }

            // make the HTTP request
            var localVarResponse = Client.Get<List<OneBlockCurrent>>("/v3/one/block/current", localVarRequestOptions, Configuration);

            return localVarResponse;
        }

        /// <summary>
        /// Get current block number 1 credit per API call Get ONE current block number. This is the number of the latest block in the blockchain.
        /// </summary>
        /// <exception cref="Tatum.CSharp.Harmony.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of List&lt;OneBlockCurrent&gt;</returns>
        public async System.Threading.Tasks.Task<List<OneBlockCurrent>> OneGetCurrentBlockAsync(System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            var localVarResponse = await OneGetCurrentBlockWithHttpInfoAsync(cancellationToken).ConfigureAwait(false);
            
            var exception = ExceptionFactory?.Invoke("OneGetCurrentBlock", localVarResponse);
            if (exception != null) throw exception;

            return localVarResponse.Data;
        }

        /// <summary>
        /// Get current block number 1 credit per API call Get ONE current block number. This is the number of the latest block in the blockchain.
        /// </summary>
        /// <exception cref="Tatum.CSharp.Harmony.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (List&lt;OneBlockCurrent&gt;)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<List<OneBlockCurrent>>> OneGetCurrentBlockWithHttpInfoAsync(System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            var localVarRequestOptions = new RequestOptions();

            var contentTypes = new string[]{
            };

            // to determine the Accept header
            var accepts = new string[]{
                "application/json"
            };


            var localVarContentType = ClientUtils.SelectHeaderContentType(contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = ClientUtils.SelectHeaderAccept(accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);


            // authentication (X-API-Key) required
            if (!string.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("x-api-key")))
            {
                localVarRequestOptions.HeaderParameters.Add("x-api-key", Configuration.GetApiKeyWithPrefix("x-api-key"));
            }

            // make the HTTP request

            var localVarResponse = await AsynchronousClient.GetAsync<List<OneBlockCurrent>>("/v3/one/block/current", localVarRequestOptions, Configuration, cancellationToken).ConfigureAwait(false);

            return localVarResponse;
        }

        /// <summary>
        /// Get ONE Transaction 2 credits per API call Get ONE transaction by transaction hash.
        /// </summary>
        /// <exception cref="Tatum.CSharp.Harmony.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="hash">Transaction hash</param>
        /// <param name="shardID">Shard to read data from (optional, default to 0M)</param>
        /// <returns>OneTx</returns>
        public OneTx OneGetTransaction(string hash, decimal? shardID = default(decimal?))
        {
            var localVarResponse = OneGetTransactionWithHttpInfo(hash, shardID);

            var exception = ExceptionFactory?.Invoke("OneGetTransaction", localVarResponse);
            if (exception != null) throw exception;

            return localVarResponse.Data;
        }

        /// <summary>
        /// Get ONE Transaction 2 credits per API call Get ONE transaction by transaction hash.
        /// </summary>
        /// <exception cref="Tatum.CSharp.Harmony.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="hash">Transaction hash</param>
        /// <param name="shardID">Shard to read data from (optional, default to 0M)</param>
        /// <returns>ApiResponse of OneTx</returns>
        public ApiResponse<OneTx> OneGetTransactionWithHttpInfo(string hash, decimal? shardID = default(decimal?))
        {
            // verify the required parameter 'hash' is set
            if (hash == null)
                throw new ApiException(400, "Missing required parameter 'hash' when calling HarmonyApi->OneGetTransaction");

            var localVarRequestOptions = new RequestOptions();

            var contentTypes = new string[]{
            };

            // to determine the Accept header
            var accepts = new string[]{
                "application/json"
            };

            var localVarContentType = ClientUtils.SelectHeaderContentType(contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = ClientUtils.SelectHeaderAccept(accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.PathParameters.Add("hash", ClientUtils.ParameterToString(hash)); // path parameter
            if (shardID != null)
            {
                localVarRequestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "shardID", shardID));
            }

            // authentication (X-API-Key) required
            if (!string.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("x-api-key")))
            {
                localVarRequestOptions.HeaderParameters.Add("x-api-key", Configuration.GetApiKeyWithPrefix("x-api-key"));
            }

            // make the HTTP request
            var localVarResponse = Client.Get<OneTx>("/v3/one/transaction/{hash}", localVarRequestOptions, Configuration);

            return localVarResponse;
        }

        /// <summary>
        /// Get ONE Transaction 2 credits per API call Get ONE transaction by transaction hash.
        /// </summary>
        /// <exception cref="Tatum.CSharp.Harmony.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="hash">Transaction hash</param>
        /// <param name="shardID">Shard to read data from (optional, default to 0M)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of OneTx</returns>
        public async System.Threading.Tasks.Task<OneTx> OneGetTransactionAsync(string hash, decimal? shardID = default(decimal?), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            var localVarResponse = await OneGetTransactionWithHttpInfoAsync(hash, shardID, cancellationToken).ConfigureAwait(false);
            
            var exception = ExceptionFactory?.Invoke("OneGetTransaction", localVarResponse);
            if (exception != null) throw exception;

            return localVarResponse.Data;
        }

        /// <summary>
        /// Get ONE Transaction 2 credits per API call Get ONE transaction by transaction hash.
        /// </summary>
        /// <exception cref="Tatum.CSharp.Harmony.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="hash">Transaction hash</param>
        /// <param name="shardID">Shard to read data from (optional, default to 0M)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (OneTx)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<OneTx>> OneGetTransactionWithHttpInfoAsync(string hash, decimal? shardID = default(decimal?), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            // verify the required parameter 'hash' is set
            if (hash == null)
                throw new ApiException(400, "Missing required parameter 'hash' when calling HarmonyApi->OneGetTransaction");

            var localVarRequestOptions = new RequestOptions();

            var contentTypes = new string[]{
            };

            // to determine the Accept header
            var accepts = new string[]{
                "application/json"
            };


            var localVarContentType = ClientUtils.SelectHeaderContentType(contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = ClientUtils.SelectHeaderAccept(accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.PathParameters.Add("hash", ClientUtils.ParameterToString(hash)); // path parameter
            if (shardID != null)
            {
                localVarRequestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "shardID", shardID));
            }

            // authentication (X-API-Key) required
            if (!string.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("x-api-key")))
            {
                localVarRequestOptions.HeaderParameters.Add("x-api-key", Configuration.GetApiKeyWithPrefix("x-api-key"));
            }

            // make the HTTP request

            var localVarResponse = await AsynchronousClient.GetAsync<OneTx>("/v3/one/transaction/{hash}", localVarRequestOptions, Configuration, cancellationToken).ConfigureAwait(false);

            return localVarResponse;
        }

        /// <summary>
        /// Get count of outgoing ONE transactions 1 credit per API call Get a number of outgoing ONE transactions for the address. When a transaction is sent, there can be multiple outgoing transactions, which are not yet processed by the blockchain. To distinguish between them, there is a counter called a nonce, which represents the order of the transaction in the list of outgoing transactions.
        /// </summary>
        /// <exception cref="Tatum.CSharp.Harmony.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="address">address</param>
        /// <param name="shardID">Shard to read data from (optional, default to 0M)</param>
        /// <returns>decimal</returns>
        public decimal OneGetTransactionCount(string address, decimal? shardID = default(decimal?))
        {
            var localVarResponse = OneGetTransactionCountWithHttpInfo(address, shardID);

            var exception = ExceptionFactory?.Invoke("OneGetTransactionCount", localVarResponse);
            if (exception != null) throw exception;

            return localVarResponse.Data;
        }

        /// <summary>
        /// Get count of outgoing ONE transactions 1 credit per API call Get a number of outgoing ONE transactions for the address. When a transaction is sent, there can be multiple outgoing transactions, which are not yet processed by the blockchain. To distinguish between them, there is a counter called a nonce, which represents the order of the transaction in the list of outgoing transactions.
        /// </summary>
        /// <exception cref="Tatum.CSharp.Harmony.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="address">address</param>
        /// <param name="shardID">Shard to read data from (optional, default to 0M)</param>
        /// <returns>ApiResponse of decimal</returns>
        public ApiResponse<decimal> OneGetTransactionCountWithHttpInfo(string address, decimal? shardID = default(decimal?))
        {
            // verify the required parameter 'address' is set
            if (address == null)
                throw new ApiException(400, "Missing required parameter 'address' when calling HarmonyApi->OneGetTransactionCount");

            var localVarRequestOptions = new RequestOptions();

            var contentTypes = new string[]{
            };

            // to determine the Accept header
            var accepts = new string[]{
                "application/json"
            };

            var localVarContentType = ClientUtils.SelectHeaderContentType(contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = ClientUtils.SelectHeaderAccept(accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.PathParameters.Add("address", ClientUtils.ParameterToString(address)); // path parameter
            if (shardID != null)
            {
                localVarRequestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "shardID", shardID));
            }

            // authentication (X-API-Key) required
            if (!string.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("x-api-key")))
            {
                localVarRequestOptions.HeaderParameters.Add("x-api-key", Configuration.GetApiKeyWithPrefix("x-api-key"));
            }

            // make the HTTP request
            var localVarResponse = Client.Get<decimal>("/v3/one/transaction/count/{address}", localVarRequestOptions, Configuration);

            return localVarResponse;
        }

        /// <summary>
        /// Get count of outgoing ONE transactions 1 credit per API call Get a number of outgoing ONE transactions for the address. When a transaction is sent, there can be multiple outgoing transactions, which are not yet processed by the blockchain. To distinguish between them, there is a counter called a nonce, which represents the order of the transaction in the list of outgoing transactions.
        /// </summary>
        /// <exception cref="Tatum.CSharp.Harmony.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="address">address</param>
        /// <param name="shardID">Shard to read data from (optional, default to 0M)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of decimal</returns>
        public async System.Threading.Tasks.Task<decimal> OneGetTransactionCountAsync(string address, decimal? shardID = default(decimal?), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            var localVarResponse = await OneGetTransactionCountWithHttpInfoAsync(address, shardID, cancellationToken).ConfigureAwait(false);
            
            var exception = ExceptionFactory?.Invoke("OneGetTransactionCount", localVarResponse);
            if (exception != null) throw exception;

            return localVarResponse.Data;
        }

        /// <summary>
        /// Get count of outgoing ONE transactions 1 credit per API call Get a number of outgoing ONE transactions for the address. When a transaction is sent, there can be multiple outgoing transactions, which are not yet processed by the blockchain. To distinguish between them, there is a counter called a nonce, which represents the order of the transaction in the list of outgoing transactions.
        /// </summary>
        /// <exception cref="Tatum.CSharp.Harmony.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="address">address</param>
        /// <param name="shardID">Shard to read data from (optional, default to 0M)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (decimal)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<decimal>> OneGetTransactionCountWithHttpInfoAsync(string address, decimal? shardID = default(decimal?), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            // verify the required parameter 'address' is set
            if (address == null)
                throw new ApiException(400, "Missing required parameter 'address' when calling HarmonyApi->OneGetTransactionCount");

            var localVarRequestOptions = new RequestOptions();

            var contentTypes = new string[]{
            };

            // to determine the Accept header
            var accepts = new string[]{
                "application/json"
            };


            var localVarContentType = ClientUtils.SelectHeaderContentType(contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = ClientUtils.SelectHeaderAccept(accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.PathParameters.Add("address", ClientUtils.ParameterToString(address)); // path parameter
            if (shardID != null)
            {
                localVarRequestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "shardID", shardID));
            }

            // authentication (X-API-Key) required
            if (!string.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("x-api-key")))
            {
                localVarRequestOptions.HeaderParameters.Add("x-api-key", Configuration.GetApiKeyWithPrefix("x-api-key"));
            }

            // make the HTTP request

            var localVarResponse = await AsynchronousClient.GetAsync<decimal>("/v3/one/transaction/count/{address}", localVarRequestOptions, Configuration, cancellationToken).ConfigureAwait(false);

            return localVarResponse;
        }

    }
}
