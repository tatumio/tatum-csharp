/*
 * Tatum API Reference
 *
 * # Welcome to the Tatum API Reference!  ## What is Tatum?  Tatum offers a flexible framework to build, run, and scale blockchain apps fast. To learn more about the Tatum blockchain development framework, visit [our website](https://tatum.io/framework).  The Tatum API features powerful endpoints that simplify a complex blockchain into single API requests. Code for all supported blockchains using unified API calls.  ## Need help?  To chat with other developers, get help from the Support team, and engage with the thriving Tatum community, join  our [Discord server](https://discord.com/invite/tatum). For more information about how to work with Tatum, review the [online documentation](https://docs.tatum.io/).  ## About this API Reference  The Tatum API Reference is based on OpenAPI Specification v3.1.0 with a few [vendor extensions](https://github.com/Redocly/redoc/blob/master/docs/redoc-vendor-extensions.md) applied.  # Authentication  When using the Tatum API, you authenticate yourself with an **API key**. <SecurityDefinitions /> 
 *
 * The version of the OpenAPI document: 3.17.0
 * Generated by: https://github.com/openapitools/openapi-generator.git
 */


using System;
using System.Collections.Generic;
using System.Net.Http;
using Tatum.CSharp.FungibleTokens.Core.Client;
using Tatum.CSharp.FungibleTokens.Core.Model;

namespace Tatum.CSharp.FungibleTokens.Core.Api
{

    /// <summary>
    /// Represents a collection of functions to interact with the API endpoints
    /// </summary>
    public interface IFungibleTokensEthApiSync : IApiAccessor
    {
        #region Synchronous Operations
        /// <summary>
        /// Approve spending of fungible tokens
        /// </summary>
        /// <remarks>
        /// 2 credits per API call Allow another blockchain address (the spender parameter in the request body) to spend and burn fungible tokens on behalf of the smart contract owner. This API is supported for the following blockchains: BNB Smart Chain Celo Ethereum Harmony Klaytn Polygon Signing a transaction When approving spending of fungible tokens, you are charged a fee for the transaction, and you must sign the transaction with the private key of the blockchain address from which the fee will be deducted. Providing the private key in the API is not a secure way of signing transactions, because the private key can be stolen or exposed. Your private keys should never leave your security perimeter. You should use the private keys only for testing a solution you are building on the testnet of a blockchain. For signing transactions on the mainnet, we strongly recommend that you use the Tatum Key Management System (KMS) and provide the signature ID instead of the private key in the API. Alternatively, you can use the Tatum JavaScript client.
        /// </remarks>
        /// <exception cref="Tatum.CSharp.FungibleTokens.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="approveErc20"></param>
        /// <param name="xTestnetType">Type of Ethereum testnet. Defaults to Sepolia. Valid only for ETH invocations for testnet API Key. For mainnet API Key, this value is ignored. (optional, default to ethereum-sepolia)</param>
        /// <returns>TransactionHash</returns>
        TransactionHash Erc20Approve(ApproveErc20 approveErc20, string xTestnetType = default(string));
        /// <summary>
        /// Approve spending of fungible tokens
        /// </summary>
        /// <remarks>
        /// 2 credits per API call Allow another blockchain address (the spender parameter in the request body) to spend and burn fungible tokens on behalf of the smart contract owner. This API is supported for the following blockchains: BNB Smart Chain Celo Ethereum Harmony Klaytn Polygon Signing a transaction When approving spending of fungible tokens, you are charged a fee for the transaction, and you must sign the transaction with the private key of the blockchain address from which the fee will be deducted. Providing the private key in the API is not a secure way of signing transactions, because the private key can be stolen or exposed. Your private keys should never leave your security perimeter. You should use the private keys only for testing a solution you are building on the testnet of a blockchain. For signing transactions on the mainnet, we strongly recommend that you use the Tatum Key Management System (KMS) and provide the signature ID instead of the private key in the API. Alternatively, you can use the Tatum JavaScript client.
        /// </remarks>
        /// <exception cref="Tatum.CSharp.FungibleTokens.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="approveErc20KMS"></param>
        /// <param name="xTestnetType">Type of Ethereum testnet. Defaults to Sepolia. Valid only for ETH invocations for testnet API Key. For mainnet API Key, this value is ignored. (optional, default to ethereum-sepolia)</param>
        /// <returns>SignatureId</returns>
        SignatureId Erc20Approve(ApproveErc20KMS approveErc20KMS, string xTestnetType = default(string));
        /// <summary>
        /// Burn fungible tokens
        /// </summary>
        /// <remarks>
        /// 2 credits per API call Burn fungible tokens. Burning fungible tokens deletes the specified supply of the tokens (the amount parameter in the request body) from the smart contract (the contractAddress parameter in the request body). This API is supported for the following blockchains: Algorand BNB Smart Chain Celo Ethereum Harmony Klaytn KuCoin Community Chain Polygon XinFin Signing a transaction When burning fungible tokens, you are charged a fee for the transaction, and you must sign the transaction with the private key of the blockchain address from which the fee will be deducted. Providing the private key in the API is not a secure way of signing transactions, because the private key can be stolen or exposed. Your private keys should never leave your security perimeter. You should use the private keys only for testing a solution you are building on the testnet of a blockchain. For signing transactions on the mainnet, we strongly recommend that you use the Tatum Key Management System (KMS) and provide the signature ID instead of the private key in the API. Alternatively, you can use the Tatum JavaScript client.
        /// </remarks>
        /// <exception cref="Tatum.CSharp.FungibleTokens.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="chainBurnErc20"></param>
        /// <param name="xTestnetType">Type of Ethereum testnet. Defaults to Sepolia. Valid only for ETH invocations for testnet API Key. For mainnet API Key, this value is ignored. (optional, default to ethereum-sepolia)</param>
        /// <returns>TransactionHash</returns>
        TransactionHash Erc20Burn(ChainBurnErc20 chainBurnErc20, string xTestnetType = default(string));
        /// <summary>
        /// Burn fungible tokens
        /// </summary>
        /// <remarks>
        /// 2 credits per API call Burn fungible tokens. Burning fungible tokens deletes the specified supply of the tokens (the amount parameter in the request body) from the smart contract (the contractAddress parameter in the request body). This API is supported for the following blockchains: Algorand BNB Smart Chain Celo Ethereum Harmony Klaytn KuCoin Community Chain Polygon XinFin Signing a transaction When burning fungible tokens, you are charged a fee for the transaction, and you must sign the transaction with the private key of the blockchain address from which the fee will be deducted. Providing the private key in the API is not a secure way of signing transactions, because the private key can be stolen or exposed. Your private keys should never leave your security perimeter. You should use the private keys only for testing a solution you are building on the testnet of a blockchain. For signing transactions on the mainnet, we strongly recommend that you use the Tatum Key Management System (KMS) and provide the signature ID instead of the private key in the API. Alternatively, you can use the Tatum JavaScript client.
        /// </remarks>
        /// <exception cref="Tatum.CSharp.FungibleTokens.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="chainBurnErc20KMS"></param>
        /// <param name="xTestnetType">Type of Ethereum testnet. Defaults to Sepolia. Valid only for ETH invocations for testnet API Key. For mainnet API Key, this value is ignored. (optional, default to ethereum-sepolia)</param>
        /// <returns>SignatureId</returns>
        SignatureId Erc20Burn(ChainBurnErc20KMS chainBurnErc20KMS, string xTestnetType = default(string));
        /// <summary>
        /// Deploy a fungible token smart contract
        /// </summary>
        /// <remarks>
        /// 2 credits per API call Deploy a fungible token smart contract on the blockchain. In a deployed smart contract, you can mint and burn fungible tokens. The whole supply of fungible tokens (the supply parameter in the request body) will be transferred to the specified blockchain address (the address parameter in the request body). Smart contracts are standardized and audited. This API is supported for the following blockchains: Algorand BNB Smart Chain Celo Ethereum Harmony Klaytn KuCoin Community Chain Polygon Solana XinFin You can review the code of a deployed smart contract here. Signing a transaction When deploying a fungible token smart contract, you are charged a fee for the transaction, and you must sign the transaction with the private key of the blockchain address from which the fee will be deducted. Providing the private key in the API is not a secure way of signing transactions, because the private key can be stolen or exposed. Your private keys should never leave your security perimeter. You should use the private keys only for testing a solution you are building on the testnet of a blockchain. For signing transactions on the mainnet, we strongly recommend that you use the Tatum Key Management System (KMS) and provide the signature ID instead of the private key in the API. Alternatively, you can use the Tatum JavaScript client.
        /// </remarks>
        /// <exception cref="Tatum.CSharp.FungibleTokens.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="chainDeployErc20"></param>
        /// <param name="xTestnetType">Type of Ethereum testnet. Defaults to Sepolia. Valid only for ETH invocations for testnet API Key. For mainnet API Key, this value is ignored. (optional, default to ethereum-sepolia)</param>
        /// <returns>TransactionHash</returns>
        TransactionHash Erc20Deploy(ChainDeployErc20 chainDeployErc20, string xTestnetType = default(string));
        /// <summary>
        /// Deploy a fungible token smart contract
        /// </summary>
        /// <remarks>
        /// 2 credits per API call Deploy a fungible token smart contract on the blockchain. In a deployed smart contract, you can mint and burn fungible tokens. The whole supply of fungible tokens (the supply parameter in the request body) will be transferred to the specified blockchain address (the address parameter in the request body). Smart contracts are standardized and audited. This API is supported for the following blockchains: Algorand BNB Smart Chain Celo Ethereum Harmony Klaytn KuCoin Community Chain Polygon Solana XinFin You can review the code of a deployed smart contract here. Signing a transaction When deploying a fungible token smart contract, you are charged a fee for the transaction, and you must sign the transaction with the private key of the blockchain address from which the fee will be deducted. Providing the private key in the API is not a secure way of signing transactions, because the private key can be stolen or exposed. Your private keys should never leave your security perimeter. You should use the private keys only for testing a solution you are building on the testnet of a blockchain. For signing transactions on the mainnet, we strongly recommend that you use the Tatum Key Management System (KMS) and provide the signature ID instead of the private key in the API. Alternatively, you can use the Tatum JavaScript client.
        /// </remarks>
        /// <exception cref="Tatum.CSharp.FungibleTokens.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="chainDeployErc20KMS"></param>
        /// <param name="xTestnetType">Type of Ethereum testnet. Defaults to Sepolia. Valid only for ETH invocations for testnet API Key. For mainnet API Key, this value is ignored. (optional, default to ethereum-sepolia)</param>
        /// <returns>SignatureId</returns>
        SignatureId Erc20Deploy(ChainDeployErc20KMS chainDeployErc20KMS, string xTestnetType = default(string));
        /// <summary>
        /// Get the number of fungible tokens from a specific smart contract that a blockchain address holds
        /// </summary>
        /// <remarks>
        /// 1 credit per API call Get the number of the fungible tokens minted on a specific smart contract (the contractAddress path parameter in the request endpoint URL) that a blockchain address holds. This API is supported for the following blockchains: Algorand BNB Smart Chain Celo Elrond Ethereum Harmony Klaytn KuCoin Community Chain Polygon Solana XinFin
        /// </remarks>
        /// <exception cref="Tatum.CSharp.FungibleTokens.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="address">The blockchain address that you want to get the token balance of</param>
        /// <param name="contractAddress">The address of the fungible token smart contract</param>
        /// <param name="xTestnetType">Type of Ethereum testnet. Defaults to Sepolia. Valid only for ETH invocations for testnet API Key. For mainnet API Key, this value is ignored. (optional, default to ethereum-sepolia)</param>
        /// <returns>Erc20Balance</returns>
        Erc20Balance Erc20GetBalance(string address, string contractAddress, string xTestnetType = default(string));
        /// <summary>
        /// Get the number of fungible tokens that a blockchain address holds across a blockchain
        /// </summary>
        /// <remarks>
        /// 1 credit per API call Get the number of fungible tokens that a blockchain address holds across a blockchain. The tokens are returned grouped by the smart contracts they were minted on. This API is supported for the following blockchains: Algorand Celo Ethereum Polygon Solana
        /// </remarks>
        /// <exception cref="Tatum.CSharp.FungibleTokens.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="address">The blockchain address that you want to get the token balance of</param>
        /// <returns>List&lt;Erc20BalanceForAddress&gt;</returns>
        List<Erc20BalanceForAddress> Erc20GetBalanceAddress(string address);
        /// <summary>
        /// Get fungible token transactions on a blockchain address
        /// </summary>
        /// <remarks>
        /// 1 credit per API call Get incoming and outgoing transactions related to fungible tokens on a blockchain address. This API is supported for the following blockchains: Algorand Celo Ethereum Polygon
        /// </remarks>
        /// <exception cref="Tatum.CSharp.FungibleTokens.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="address">Account address you want to get balance of</param>
        /// <param name="tokenAddress">Address of the token smart contract</param>
        /// <param name="pageSize">Max number of items per page is 50.</param>
        /// <param name="offset">Offset to obtain next page of the data. (optional)</param>
        /// <param name="from">Transactions from this block onwards will be included. (optional)</param>
        /// <param name="to">Transactions up to this block will be included. (optional)</param>
        /// <param name="sort">Sorting of the data. ASC - oldest first, DESC - newest first. (optional, default to DESC)</param>
        /// <returns>List&lt;FungibleTx&gt;</returns>
        List<FungibleTx> Erc20GetTransactionByAddress(string address, string tokenAddress, decimal pageSize, decimal? offset = default(decimal?), decimal? from = default(decimal?), decimal? to = default(decimal?), string sort = default(string));
        /// <summary>
        /// Mint fungible tokens
        /// </summary>
        /// <remarks>
        /// 2 credits per API call Create new fungible tokens in the smart contract (the contractAddress parameter in the request body) and transfer them to the specified blockchain address (the to parameter in the request body). You can mint new fungible tokens only if the current supply of tokens in the smart contract is lower than the total supply set for this contract. This API is supported for the following blockchains: BNB Smart Chain Celo Ethereum Harmony Klaytn KuCoin Community Chain Polygon XinFin Signing a transaction When minting fungible tokens, you are charged a fee for the transaction, and you must sign the transaction with the private key of the blockchain address from which the fee will be deducted. Providing the private key in the API is not a secure way of signing transactions, because the private key can be stolen or exposed. Your private keys should never leave your security perimeter. You should use the private keys only for testing a solution you are building on the testnet of a blockchain. For signing transactions on the mainnet, we strongly recommend that you use the Tatum Key Management System (KMS) and provide the signature ID instead of the private key in the API. Alternatively, you can use the Tatum JavaScript client.
        /// </remarks>
        /// <exception cref="Tatum.CSharp.FungibleTokens.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="chainMintErc20"></param>
        /// <param name="xTestnetType">Type of Ethereum testnet. Defaults to Sepolia. Valid only for ETH invocations for testnet API Key. For mainnet API Key, this value is ignored. (optional, default to ethereum-sepolia)</param>
        /// <returns>TransactionHash</returns>
        TransactionHash Erc20Mint(ChainMintErc20 chainMintErc20, string xTestnetType = default(string));
        /// <summary>
        /// Mint fungible tokens
        /// </summary>
        /// <remarks>
        /// 2 credits per API call Create new fungible tokens in the smart contract (the contractAddress parameter in the request body) and transfer them to the specified blockchain address (the to parameter in the request body). You can mint new fungible tokens only if the current supply of tokens in the smart contract is lower than the total supply set for this contract. This API is supported for the following blockchains: BNB Smart Chain Celo Ethereum Harmony Klaytn KuCoin Community Chain Polygon XinFin Signing a transaction When minting fungible tokens, you are charged a fee for the transaction, and you must sign the transaction with the private key of the blockchain address from which the fee will be deducted. Providing the private key in the API is not a secure way of signing transactions, because the private key can be stolen or exposed. Your private keys should never leave your security perimeter. You should use the private keys only for testing a solution you are building on the testnet of a blockchain. For signing transactions on the mainnet, we strongly recommend that you use the Tatum Key Management System (KMS) and provide the signature ID instead of the private key in the API. Alternatively, you can use the Tatum JavaScript client.
        /// </remarks>
        /// <exception cref="Tatum.CSharp.FungibleTokens.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="chainMintErc20KMS"></param>
        /// <param name="xTestnetType">Type of Ethereum testnet. Defaults to Sepolia. Valid only for ETH invocations for testnet API Key. For mainnet API Key, this value is ignored. (optional, default to ethereum-sepolia)</param>
        /// <returns>SignatureId</returns>
        SignatureId Erc20Mint(ChainMintErc20KMS chainMintErc20KMS, string xTestnetType = default(string));
        /// <summary>
        /// Transfer fungible tokens
        /// </summary>
        /// <remarks>
        /// 2 credits per API call Transfer a supply of fungible tokens existing in the smart contract (the contractAddress parameter in the request body) to the specified blockchain address (the to parameter in the request body). Transferring fungible tokens invokes the transfer() method. This API is supported for the following blockchains: Algorand BNB Smart Chain Celo Ethereum Harmony Klaytn KuCoin Community Chain Polygon Solana XinFin Transferring fungible tokens on Algorand On Algorand, the recipient has to agree in advance to receive your fungible tokens because Algorand charges users for storing the tokens on their addresses, and an Algorand blockchain address by default does not receive the tokens unless explicitly agreed. Before transferring the fungible tokens, make sure that the recipient has agreed to receive the NFT to their address. Blockchain-specific APIs to transfer fungible tokens You can also use blockchain-specific APIs for transferring fungible tokens on the following blockchains: BNB Smart Chain Celo Ethereum Harmony KuCoin Community Chain Polygon XinFin Signing a transaction When transferring fungible tokens, you are charged a fee for the transaction, and you must sign the transaction with the private key of the blockchain address from which the fee will be deducted. Providing the private key in the API is not a secure way of signing transactions, because the private key can be stolen or exposed. Your private keys should never leave your security perimeter. You should use the private keys only for testing a solution you are building on the testnet of a blockchain. For signing transactions on the mainnet, we strongly recommend that you use the Tatum Key Management System (KMS) and provide the signature ID instead of the private key in the API. Alternatively, you can use the Tatum JavaScript client.
        /// </remarks>
        /// <exception cref="Tatum.CSharp.FungibleTokens.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="chainTransferEthErc20"></param>
        /// <param name="xTestnetType">Type of Ethereum testnet. Defaults to Sepolia. Valid only for ETH invocations for testnet API Key. For mainnet API Key, this value is ignored. (optional, default to ethereum-sepolia)</param>
        /// <returns>TransactionHash</returns>
        TransactionHash Erc20Transfer(ChainTransferEthErc20 chainTransferEthErc20, string xTestnetType = default(string));
        /// <summary>
        /// Transfer fungible tokens
        /// </summary>
        /// <remarks>
        /// 2 credits per API call Transfer a supply of fungible tokens existing in the smart contract (the contractAddress parameter in the request body) to the specified blockchain address (the to parameter in the request body). Transferring fungible tokens invokes the transfer() method. This API is supported for the following blockchains: Algorand BNB Smart Chain Celo Ethereum Harmony Klaytn KuCoin Community Chain Polygon Solana XinFin Transferring fungible tokens on Algorand On Algorand, the recipient has to agree in advance to receive your fungible tokens because Algorand charges users for storing the tokens on their addresses, and an Algorand blockchain address by default does not receive the tokens unless explicitly agreed. Before transferring the fungible tokens, make sure that the recipient has agreed to receive the NFT to their address. Blockchain-specific APIs to transfer fungible tokens You can also use blockchain-specific APIs for transferring fungible tokens on the following blockchains: BNB Smart Chain Celo Ethereum Harmony KuCoin Community Chain Polygon XinFin Signing a transaction When transferring fungible tokens, you are charged a fee for the transaction, and you must sign the transaction with the private key of the blockchain address from which the fee will be deducted. Providing the private key in the API is not a secure way of signing transactions, because the private key can be stolen or exposed. Your private keys should never leave your security perimeter. You should use the private keys only for testing a solution you are building on the testnet of a blockchain. For signing transactions on the mainnet, we strongly recommend that you use the Tatum Key Management System (KMS) and provide the signature ID instead of the private key in the API. Alternatively, you can use the Tatum JavaScript client.
        /// </remarks>
        /// <exception cref="Tatum.CSharp.FungibleTokens.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="chainTransferEthErc20KMS"></param>
        /// <param name="xTestnetType">Type of Ethereum testnet. Defaults to Sepolia. Valid only for ETH invocations for testnet API Key. For mainnet API Key, this value is ignored. (optional, default to ethereum-sepolia)</param>
        /// <returns>SignatureId</returns>
        SignatureId Erc20Transfer(ChainTransferEthErc20KMS chainTransferEthErc20KMS, string xTestnetType = default(string));
        #endregion Synchronous Operations
    }

    /// <summary>
    /// Represents a collection of functions to interact with the API endpoints
    /// </summary>
    public interface IFungibleTokensEthApiWithHttpInfoSync : IApiAccessor
    {
        #region Synchronous Operations With Http Info
        /// <summary>
        /// Approve spending of fungible tokens
        /// </summary>
        /// <remarks>
        /// 2 credits per API call Allow another blockchain address (the spender parameter in the request body) to spend and burn fungible tokens on behalf of the smart contract owner. This API is supported for the following blockchains: BNB Smart Chain Celo Ethereum Harmony Klaytn Polygon Signing a transaction When approving spending of fungible tokens, you are charged a fee for the transaction, and you must sign the transaction with the private key of the blockchain address from which the fee will be deducted. Providing the private key in the API is not a secure way of signing transactions, because the private key can be stolen or exposed. Your private keys should never leave your security perimeter. You should use the private keys only for testing a solution you are building on the testnet of a blockchain. For signing transactions on the mainnet, we strongly recommend that you use the Tatum Key Management System (KMS) and provide the signature ID instead of the private key in the API. Alternatively, you can use the Tatum JavaScript client.
        /// </remarks>
        /// <exception cref="Tatum.CSharp.FungibleTokens.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="approveErc20"></param>
        /// <param name="xTestnetType">Type of Ethereum testnet. Defaults to Sepolia. Valid only for ETH invocations for testnet API Key. For mainnet API Key, this value is ignored. (optional, default to ethereum-sepolia)</param>
        /// <returns>ApiResponse of TransactionHash</returns>
        ApiResponse<TransactionHash> Erc20ApproveWithHttpInfo(ApproveErc20 approveErc20, string xTestnetType = default(string));
        /// <summary>
        /// Approve spending of fungible tokens
        /// </summary>
        /// <remarks>
        /// 2 credits per API call Allow another blockchain address (the spender parameter in the request body) to spend and burn fungible tokens on behalf of the smart contract owner. This API is supported for the following blockchains: BNB Smart Chain Celo Ethereum Harmony Klaytn Polygon Signing a transaction When approving spending of fungible tokens, you are charged a fee for the transaction, and you must sign the transaction with the private key of the blockchain address from which the fee will be deducted. Providing the private key in the API is not a secure way of signing transactions, because the private key can be stolen or exposed. Your private keys should never leave your security perimeter. You should use the private keys only for testing a solution you are building on the testnet of a blockchain. For signing transactions on the mainnet, we strongly recommend that you use the Tatum Key Management System (KMS) and provide the signature ID instead of the private key in the API. Alternatively, you can use the Tatum JavaScript client.
        /// </remarks>
        /// <exception cref="Tatum.CSharp.FungibleTokens.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="approveErc20KMS"></param>
        /// <param name="xTestnetType">Type of Ethereum testnet. Defaults to Sepolia. Valid only for ETH invocations for testnet API Key. For mainnet API Key, this value is ignored. (optional, default to ethereum-sepolia)</param>
        /// <returns>ApiResponse of SignatureId</returns>
        ApiResponse<SignatureId> Erc20ApproveWithHttpInfo(ApproveErc20KMS approveErc20KMS, string xTestnetType = default(string));
        /// <summary>
        /// Burn fungible tokens
        /// </summary>
        /// <remarks>
        /// 2 credits per API call Burn fungible tokens. Burning fungible tokens deletes the specified supply of the tokens (the amount parameter in the request body) from the smart contract (the contractAddress parameter in the request body). This API is supported for the following blockchains: Algorand BNB Smart Chain Celo Ethereum Harmony Klaytn KuCoin Community Chain Polygon XinFin Signing a transaction When burning fungible tokens, you are charged a fee for the transaction, and you must sign the transaction with the private key of the blockchain address from which the fee will be deducted. Providing the private key in the API is not a secure way of signing transactions, because the private key can be stolen or exposed. Your private keys should never leave your security perimeter. You should use the private keys only for testing a solution you are building on the testnet of a blockchain. For signing transactions on the mainnet, we strongly recommend that you use the Tatum Key Management System (KMS) and provide the signature ID instead of the private key in the API. Alternatively, you can use the Tatum JavaScript client.
        /// </remarks>
        /// <exception cref="Tatum.CSharp.FungibleTokens.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="chainBurnErc20"></param>
        /// <param name="xTestnetType">Type of Ethereum testnet. Defaults to Sepolia. Valid only for ETH invocations for testnet API Key. For mainnet API Key, this value is ignored. (optional, default to ethereum-sepolia)</param>
        /// <returns>ApiResponse of TransactionHash</returns>
        ApiResponse<TransactionHash> Erc20BurnWithHttpInfo(ChainBurnErc20 chainBurnErc20, string xTestnetType = default(string));
        /// <summary>
        /// Burn fungible tokens
        /// </summary>
        /// <remarks>
        /// 2 credits per API call Burn fungible tokens. Burning fungible tokens deletes the specified supply of the tokens (the amount parameter in the request body) from the smart contract (the contractAddress parameter in the request body). This API is supported for the following blockchains: Algorand BNB Smart Chain Celo Ethereum Harmony Klaytn KuCoin Community Chain Polygon XinFin Signing a transaction When burning fungible tokens, you are charged a fee for the transaction, and you must sign the transaction with the private key of the blockchain address from which the fee will be deducted. Providing the private key in the API is not a secure way of signing transactions, because the private key can be stolen or exposed. Your private keys should never leave your security perimeter. You should use the private keys only for testing a solution you are building on the testnet of a blockchain. For signing transactions on the mainnet, we strongly recommend that you use the Tatum Key Management System (KMS) and provide the signature ID instead of the private key in the API. Alternatively, you can use the Tatum JavaScript client.
        /// </remarks>
        /// <exception cref="Tatum.CSharp.FungibleTokens.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="chainBurnErc20KMS"></param>
        /// <param name="xTestnetType">Type of Ethereum testnet. Defaults to Sepolia. Valid only for ETH invocations for testnet API Key. For mainnet API Key, this value is ignored. (optional, default to ethereum-sepolia)</param>
        /// <returns>ApiResponse of SignatureId</returns>
        ApiResponse<SignatureId> Erc20BurnWithHttpInfo(ChainBurnErc20KMS chainBurnErc20KMS, string xTestnetType = default(string));
        /// <summary>
        /// Deploy a fungible token smart contract
        /// </summary>
        /// <remarks>
        /// 2 credits per API call Deploy a fungible token smart contract on the blockchain. In a deployed smart contract, you can mint and burn fungible tokens. The whole supply of fungible tokens (the supply parameter in the request body) will be transferred to the specified blockchain address (the address parameter in the request body). Smart contracts are standardized and audited. This API is supported for the following blockchains: Algorand BNB Smart Chain Celo Ethereum Harmony Klaytn KuCoin Community Chain Polygon Solana XinFin You can review the code of a deployed smart contract here. Signing a transaction When deploying a fungible token smart contract, you are charged a fee for the transaction, and you must sign the transaction with the private key of the blockchain address from which the fee will be deducted. Providing the private key in the API is not a secure way of signing transactions, because the private key can be stolen or exposed. Your private keys should never leave your security perimeter. You should use the private keys only for testing a solution you are building on the testnet of a blockchain. For signing transactions on the mainnet, we strongly recommend that you use the Tatum Key Management System (KMS) and provide the signature ID instead of the private key in the API. Alternatively, you can use the Tatum JavaScript client.
        /// </remarks>
        /// <exception cref="Tatum.CSharp.FungibleTokens.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="chainDeployErc20"></param>
        /// <param name="xTestnetType">Type of Ethereum testnet. Defaults to Sepolia. Valid only for ETH invocations for testnet API Key. For mainnet API Key, this value is ignored. (optional, default to ethereum-sepolia)</param>
        /// <returns>ApiResponse of TransactionHash</returns>
        ApiResponse<TransactionHash> Erc20DeployWithHttpInfo(ChainDeployErc20 chainDeployErc20, string xTestnetType = default(string));
        /// <summary>
        /// Deploy a fungible token smart contract
        /// </summary>
        /// <remarks>
        /// 2 credits per API call Deploy a fungible token smart contract on the blockchain. In a deployed smart contract, you can mint and burn fungible tokens. The whole supply of fungible tokens (the supply parameter in the request body) will be transferred to the specified blockchain address (the address parameter in the request body). Smart contracts are standardized and audited. This API is supported for the following blockchains: Algorand BNB Smart Chain Celo Ethereum Harmony Klaytn KuCoin Community Chain Polygon Solana XinFin You can review the code of a deployed smart contract here. Signing a transaction When deploying a fungible token smart contract, you are charged a fee for the transaction, and you must sign the transaction with the private key of the blockchain address from which the fee will be deducted. Providing the private key in the API is not a secure way of signing transactions, because the private key can be stolen or exposed. Your private keys should never leave your security perimeter. You should use the private keys only for testing a solution you are building on the testnet of a blockchain. For signing transactions on the mainnet, we strongly recommend that you use the Tatum Key Management System (KMS) and provide the signature ID instead of the private key in the API. Alternatively, you can use the Tatum JavaScript client.
        /// </remarks>
        /// <exception cref="Tatum.CSharp.FungibleTokens.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="chainDeployErc20KMS"></param>
        /// <param name="xTestnetType">Type of Ethereum testnet. Defaults to Sepolia. Valid only for ETH invocations for testnet API Key. For mainnet API Key, this value is ignored. (optional, default to ethereum-sepolia)</param>
        /// <returns>ApiResponse of SignatureId</returns>
        ApiResponse<SignatureId> Erc20DeployWithHttpInfo(ChainDeployErc20KMS chainDeployErc20KMS, string xTestnetType = default(string));
        /// <summary>
        /// Get the number of fungible tokens from a specific smart contract that a blockchain address holds
        /// </summary>
        /// <remarks>
        /// 1 credit per API call Get the number of the fungible tokens minted on a specific smart contract (the contractAddress path parameter in the request endpoint URL) that a blockchain address holds. This API is supported for the following blockchains: Algorand BNB Smart Chain Celo Elrond Ethereum Harmony Klaytn KuCoin Community Chain Polygon Solana XinFin
        /// </remarks>
        /// <exception cref="Tatum.CSharp.FungibleTokens.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="address">The blockchain address that you want to get the token balance of</param>
        /// <param name="contractAddress">The address of the fungible token smart contract</param>
        /// <param name="xTestnetType">Type of Ethereum testnet. Defaults to Sepolia. Valid only for ETH invocations for testnet API Key. For mainnet API Key, this value is ignored. (optional, default to ethereum-sepolia)</param>
        /// <returns>ApiResponse of Erc20Balance</returns>
        ApiResponse<Erc20Balance> Erc20GetBalanceWithHttpInfo(string address, string contractAddress, string xTestnetType = default(string));
        /// <summary>
        /// Get the number of fungible tokens that a blockchain address holds across a blockchain
        /// </summary>
        /// <remarks>
        /// 1 credit per API call Get the number of fungible tokens that a blockchain address holds across a blockchain. The tokens are returned grouped by the smart contracts they were minted on. This API is supported for the following blockchains: Algorand Celo Ethereum Polygon Solana
        /// </remarks>
        /// <exception cref="Tatum.CSharp.FungibleTokens.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="address">The blockchain address that you want to get the token balance of</param>
        /// <returns>ApiResponse of List&lt;Erc20BalanceForAddress&gt;</returns>
        ApiResponse<List<Erc20BalanceForAddress>> Erc20GetBalanceAddressWithHttpInfo(string address);
        /// <summary>
        /// Get fungible token transactions on a blockchain address
        /// </summary>
        /// <remarks>
        /// 1 credit per API call Get incoming and outgoing transactions related to fungible tokens on a blockchain address. This API is supported for the following blockchains: Algorand Celo Ethereum Polygon
        /// </remarks>
        /// <exception cref="Tatum.CSharp.FungibleTokens.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="address">Account address you want to get balance of</param>
        /// <param name="tokenAddress">Address of the token smart contract</param>
        /// <param name="pageSize">Max number of items per page is 50.</param>
        /// <param name="offset">Offset to obtain next page of the data. (optional)</param>
        /// <param name="from">Transactions from this block onwards will be included. (optional)</param>
        /// <param name="to">Transactions up to this block will be included. (optional)</param>
        /// <param name="sort">Sorting of the data. ASC - oldest first, DESC - newest first. (optional, default to DESC)</param>
        /// <returns>ApiResponse of List&lt;FungibleTx&gt;</returns>
        ApiResponse<List<FungibleTx>> Erc20GetTransactionByAddressWithHttpInfo(string address, string tokenAddress, decimal pageSize, decimal? offset = default(decimal?), decimal? from = default(decimal?), decimal? to = default(decimal?), string sort = default(string));
        /// <summary>
        /// Mint fungible tokens
        /// </summary>
        /// <remarks>
        /// 2 credits per API call Create new fungible tokens in the smart contract (the contractAddress parameter in the request body) and transfer them to the specified blockchain address (the to parameter in the request body). You can mint new fungible tokens only if the current supply of tokens in the smart contract is lower than the total supply set for this contract. This API is supported for the following blockchains: BNB Smart Chain Celo Ethereum Harmony Klaytn KuCoin Community Chain Polygon XinFin Signing a transaction When minting fungible tokens, you are charged a fee for the transaction, and you must sign the transaction with the private key of the blockchain address from which the fee will be deducted. Providing the private key in the API is not a secure way of signing transactions, because the private key can be stolen or exposed. Your private keys should never leave your security perimeter. You should use the private keys only for testing a solution you are building on the testnet of a blockchain. For signing transactions on the mainnet, we strongly recommend that you use the Tatum Key Management System (KMS) and provide the signature ID instead of the private key in the API. Alternatively, you can use the Tatum JavaScript client.
        /// </remarks>
        /// <exception cref="Tatum.CSharp.FungibleTokens.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="chainMintErc20"></param>
        /// <param name="xTestnetType">Type of Ethereum testnet. Defaults to Sepolia. Valid only for ETH invocations for testnet API Key. For mainnet API Key, this value is ignored. (optional, default to ethereum-sepolia)</param>
        /// <returns>ApiResponse of TransactionHash</returns>
        ApiResponse<TransactionHash> Erc20MintWithHttpInfo(ChainMintErc20 chainMintErc20, string xTestnetType = default(string));
        /// <summary>
        /// Mint fungible tokens
        /// </summary>
        /// <remarks>
        /// 2 credits per API call Create new fungible tokens in the smart contract (the contractAddress parameter in the request body) and transfer them to the specified blockchain address (the to parameter in the request body). You can mint new fungible tokens only if the current supply of tokens in the smart contract is lower than the total supply set for this contract. This API is supported for the following blockchains: BNB Smart Chain Celo Ethereum Harmony Klaytn KuCoin Community Chain Polygon XinFin Signing a transaction When minting fungible tokens, you are charged a fee for the transaction, and you must sign the transaction with the private key of the blockchain address from which the fee will be deducted. Providing the private key in the API is not a secure way of signing transactions, because the private key can be stolen or exposed. Your private keys should never leave your security perimeter. You should use the private keys only for testing a solution you are building on the testnet of a blockchain. For signing transactions on the mainnet, we strongly recommend that you use the Tatum Key Management System (KMS) and provide the signature ID instead of the private key in the API. Alternatively, you can use the Tatum JavaScript client.
        /// </remarks>
        /// <exception cref="Tatum.CSharp.FungibleTokens.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="chainMintErc20KMS"></param>
        /// <param name="xTestnetType">Type of Ethereum testnet. Defaults to Sepolia. Valid only for ETH invocations for testnet API Key. For mainnet API Key, this value is ignored. (optional, default to ethereum-sepolia)</param>
        /// <returns>ApiResponse of SignatureId</returns>
        ApiResponse<SignatureId> Erc20MintWithHttpInfo(ChainMintErc20KMS chainMintErc20KMS, string xTestnetType = default(string));
        /// <summary>
        /// Transfer fungible tokens
        /// </summary>
        /// <remarks>
        /// 2 credits per API call Transfer a supply of fungible tokens existing in the smart contract (the contractAddress parameter in the request body) to the specified blockchain address (the to parameter in the request body). Transferring fungible tokens invokes the transfer() method. This API is supported for the following blockchains: Algorand BNB Smart Chain Celo Ethereum Harmony Klaytn KuCoin Community Chain Polygon Solana XinFin Transferring fungible tokens on Algorand On Algorand, the recipient has to agree in advance to receive your fungible tokens because Algorand charges users for storing the tokens on their addresses, and an Algorand blockchain address by default does not receive the tokens unless explicitly agreed. Before transferring the fungible tokens, make sure that the recipient has agreed to receive the NFT to their address. Blockchain-specific APIs to transfer fungible tokens You can also use blockchain-specific APIs for transferring fungible tokens on the following blockchains: BNB Smart Chain Celo Ethereum Harmony KuCoin Community Chain Polygon XinFin Signing a transaction When transferring fungible tokens, you are charged a fee for the transaction, and you must sign the transaction with the private key of the blockchain address from which the fee will be deducted. Providing the private key in the API is not a secure way of signing transactions, because the private key can be stolen or exposed. Your private keys should never leave your security perimeter. You should use the private keys only for testing a solution you are building on the testnet of a blockchain. For signing transactions on the mainnet, we strongly recommend that you use the Tatum Key Management System (KMS) and provide the signature ID instead of the private key in the API. Alternatively, you can use the Tatum JavaScript client.
        /// </remarks>
        /// <exception cref="Tatum.CSharp.FungibleTokens.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="chainTransferEthErc20"></param>
        /// <param name="xTestnetType">Type of Ethereum testnet. Defaults to Sepolia. Valid only for ETH invocations for testnet API Key. For mainnet API Key, this value is ignored. (optional, default to ethereum-sepolia)</param>
        /// <returns>ApiResponse of TransactionHash</returns>
        ApiResponse<TransactionHash> Erc20TransferWithHttpInfo(ChainTransferEthErc20 chainTransferEthErc20, string xTestnetType = default(string));
        /// <summary>
        /// Transfer fungible tokens
        /// </summary>
        /// <remarks>
        /// 2 credits per API call Transfer a supply of fungible tokens existing in the smart contract (the contractAddress parameter in the request body) to the specified blockchain address (the to parameter in the request body). Transferring fungible tokens invokes the transfer() method. This API is supported for the following blockchains: Algorand BNB Smart Chain Celo Ethereum Harmony Klaytn KuCoin Community Chain Polygon Solana XinFin Transferring fungible tokens on Algorand On Algorand, the recipient has to agree in advance to receive your fungible tokens because Algorand charges users for storing the tokens on their addresses, and an Algorand blockchain address by default does not receive the tokens unless explicitly agreed. Before transferring the fungible tokens, make sure that the recipient has agreed to receive the NFT to their address. Blockchain-specific APIs to transfer fungible tokens You can also use blockchain-specific APIs for transferring fungible tokens on the following blockchains: BNB Smart Chain Celo Ethereum Harmony KuCoin Community Chain Polygon XinFin Signing a transaction When transferring fungible tokens, you are charged a fee for the transaction, and you must sign the transaction with the private key of the blockchain address from which the fee will be deducted. Providing the private key in the API is not a secure way of signing transactions, because the private key can be stolen or exposed. Your private keys should never leave your security perimeter. You should use the private keys only for testing a solution you are building on the testnet of a blockchain. For signing transactions on the mainnet, we strongly recommend that you use the Tatum Key Management System (KMS) and provide the signature ID instead of the private key in the API. Alternatively, you can use the Tatum JavaScript client.
        /// </remarks>
        /// <exception cref="Tatum.CSharp.FungibleTokens.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="chainTransferEthErc20KMS"></param>
        /// <param name="xTestnetType">Type of Ethereum testnet. Defaults to Sepolia. Valid only for ETH invocations for testnet API Key. For mainnet API Key, this value is ignored. (optional, default to ethereum-sepolia)</param>
        /// <returns>ApiResponse of SignatureId</returns>
        ApiResponse<SignatureId> Erc20TransferWithHttpInfo(ChainTransferEthErc20KMS chainTransferEthErc20KMS, string xTestnetType = default(string));
        #endregion Synchronous Operations With Http Info
    }

    /// <summary>
    /// Represents a collection of functions to interact with the API endpoints
    /// </summary>
    public interface IFungibleTokensEthApiAsync : IApiAccessor
    {
        #region Asynchronous Operations
        /// <summary>
        /// Approve spending of fungible tokens
        /// </summary>
        /// <remarks>
        /// 2 credits per API call Allow another blockchain address (the spender parameter in the request body) to spend and burn fungible tokens on behalf of the smart contract owner. This API is supported for the following blockchains: BNB Smart Chain Celo Ethereum Harmony Klaytn Polygon Signing a transaction When approving spending of fungible tokens, you are charged a fee for the transaction, and you must sign the transaction with the private key of the blockchain address from which the fee will be deducted. Providing the private key in the API is not a secure way of signing transactions, because the private key can be stolen or exposed. Your private keys should never leave your security perimeter. You should use the private keys only for testing a solution you are building on the testnet of a blockchain. For signing transactions on the mainnet, we strongly recommend that you use the Tatum Key Management System (KMS) and provide the signature ID instead of the private key in the API. Alternatively, you can use the Tatum JavaScript client.
        /// </remarks>
        /// <exception cref="Tatum.CSharp.FungibleTokens.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="approveErc20"></param>
        /// <param name="xTestnetType">Type of Ethereum testnet. Defaults to Sepolia. Valid only for ETH invocations for testnet API Key. For mainnet API Key, this value is ignored. (optional, default to ethereum-sepolia)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of TransactionHash</returns>
        System.Threading.Tasks.Task<TransactionHash> Erc20ApproveAsync(ApproveErc20 approveErc20, string xTestnetType = default(string), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        /// <summary>
        /// Approve spending of fungible tokens
        /// </summary>
        /// <remarks>
        /// 2 credits per API call Allow another blockchain address (the spender parameter in the request body) to spend and burn fungible tokens on behalf of the smart contract owner. This API is supported for the following blockchains: BNB Smart Chain Celo Ethereum Harmony Klaytn Polygon Signing a transaction When approving spending of fungible tokens, you are charged a fee for the transaction, and you must sign the transaction with the private key of the blockchain address from which the fee will be deducted. Providing the private key in the API is not a secure way of signing transactions, because the private key can be stolen or exposed. Your private keys should never leave your security perimeter. You should use the private keys only for testing a solution you are building on the testnet of a blockchain. For signing transactions on the mainnet, we strongly recommend that you use the Tatum Key Management System (KMS) and provide the signature ID instead of the private key in the API. Alternatively, you can use the Tatum JavaScript client.
        /// </remarks>
        /// <exception cref="Tatum.CSharp.FungibleTokens.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="approveErc20KMS"></param>
        /// <param name="xTestnetType">Type of Ethereum testnet. Defaults to Sepolia. Valid only for ETH invocations for testnet API Key. For mainnet API Key, this value is ignored. (optional, default to ethereum-sepolia)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of SignatureId</returns>
        System.Threading.Tasks.Task<SignatureId> Erc20ApproveAsync(ApproveErc20KMS approveErc20KMS, string xTestnetType = default(string), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        /// <summary>
        /// Burn fungible tokens
        /// </summary>
        /// <remarks>
        /// 2 credits per API call Burn fungible tokens. Burning fungible tokens deletes the specified supply of the tokens (the amount parameter in the request body) from the smart contract (the contractAddress parameter in the request body). This API is supported for the following blockchains: Algorand BNB Smart Chain Celo Ethereum Harmony Klaytn KuCoin Community Chain Polygon XinFin Signing a transaction When burning fungible tokens, you are charged a fee for the transaction, and you must sign the transaction with the private key of the blockchain address from which the fee will be deducted. Providing the private key in the API is not a secure way of signing transactions, because the private key can be stolen or exposed. Your private keys should never leave your security perimeter. You should use the private keys only for testing a solution you are building on the testnet of a blockchain. For signing transactions on the mainnet, we strongly recommend that you use the Tatum Key Management System (KMS) and provide the signature ID instead of the private key in the API. Alternatively, you can use the Tatum JavaScript client.
        /// </remarks>
        /// <exception cref="Tatum.CSharp.FungibleTokens.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="chainBurnErc20"></param>
        /// <param name="xTestnetType">Type of Ethereum testnet. Defaults to Sepolia. Valid only for ETH invocations for testnet API Key. For mainnet API Key, this value is ignored. (optional, default to ethereum-sepolia)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of TransactionHash</returns>
        System.Threading.Tasks.Task<TransactionHash> Erc20BurnAsync(ChainBurnErc20 chainBurnErc20, string xTestnetType = default(string), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        /// <summary>
        /// Burn fungible tokens
        /// </summary>
        /// <remarks>
        /// 2 credits per API call Burn fungible tokens. Burning fungible tokens deletes the specified supply of the tokens (the amount parameter in the request body) from the smart contract (the contractAddress parameter in the request body). This API is supported for the following blockchains: Algorand BNB Smart Chain Celo Ethereum Harmony Klaytn KuCoin Community Chain Polygon XinFin Signing a transaction When burning fungible tokens, you are charged a fee for the transaction, and you must sign the transaction with the private key of the blockchain address from which the fee will be deducted. Providing the private key in the API is not a secure way of signing transactions, because the private key can be stolen or exposed. Your private keys should never leave your security perimeter. You should use the private keys only for testing a solution you are building on the testnet of a blockchain. For signing transactions on the mainnet, we strongly recommend that you use the Tatum Key Management System (KMS) and provide the signature ID instead of the private key in the API. Alternatively, you can use the Tatum JavaScript client.
        /// </remarks>
        /// <exception cref="Tatum.CSharp.FungibleTokens.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="chainBurnErc20KMS"></param>
        /// <param name="xTestnetType">Type of Ethereum testnet. Defaults to Sepolia. Valid only for ETH invocations for testnet API Key. For mainnet API Key, this value is ignored. (optional, default to ethereum-sepolia)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of SignatureId</returns>
        System.Threading.Tasks.Task<SignatureId> Erc20BurnAsync(ChainBurnErc20KMS chainBurnErc20KMS, string xTestnetType = default(string), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        /// <summary>
        /// Deploy a fungible token smart contract
        /// </summary>
        /// <remarks>
        /// 2 credits per API call Deploy a fungible token smart contract on the blockchain. In a deployed smart contract, you can mint and burn fungible tokens. The whole supply of fungible tokens (the supply parameter in the request body) will be transferred to the specified blockchain address (the address parameter in the request body). Smart contracts are standardized and audited. This API is supported for the following blockchains: Algorand BNB Smart Chain Celo Ethereum Harmony Klaytn KuCoin Community Chain Polygon Solana XinFin You can review the code of a deployed smart contract here. Signing a transaction When deploying a fungible token smart contract, you are charged a fee for the transaction, and you must sign the transaction with the private key of the blockchain address from which the fee will be deducted. Providing the private key in the API is not a secure way of signing transactions, because the private key can be stolen or exposed. Your private keys should never leave your security perimeter. You should use the private keys only for testing a solution you are building on the testnet of a blockchain. For signing transactions on the mainnet, we strongly recommend that you use the Tatum Key Management System (KMS) and provide the signature ID instead of the private key in the API. Alternatively, you can use the Tatum JavaScript client.
        /// </remarks>
        /// <exception cref="Tatum.CSharp.FungibleTokens.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="chainDeployErc20"></param>
        /// <param name="xTestnetType">Type of Ethereum testnet. Defaults to Sepolia. Valid only for ETH invocations for testnet API Key. For mainnet API Key, this value is ignored. (optional, default to ethereum-sepolia)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of TransactionHash</returns>
        System.Threading.Tasks.Task<TransactionHash> Erc20DeployAsync(ChainDeployErc20 chainDeployErc20, string xTestnetType = default(string), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        /// <summary>
        /// Deploy a fungible token smart contract
        /// </summary>
        /// <remarks>
        /// 2 credits per API call Deploy a fungible token smart contract on the blockchain. In a deployed smart contract, you can mint and burn fungible tokens. The whole supply of fungible tokens (the supply parameter in the request body) will be transferred to the specified blockchain address (the address parameter in the request body). Smart contracts are standardized and audited. This API is supported for the following blockchains: Algorand BNB Smart Chain Celo Ethereum Harmony Klaytn KuCoin Community Chain Polygon Solana XinFin You can review the code of a deployed smart contract here. Signing a transaction When deploying a fungible token smart contract, you are charged a fee for the transaction, and you must sign the transaction with the private key of the blockchain address from which the fee will be deducted. Providing the private key in the API is not a secure way of signing transactions, because the private key can be stolen or exposed. Your private keys should never leave your security perimeter. You should use the private keys only for testing a solution you are building on the testnet of a blockchain. For signing transactions on the mainnet, we strongly recommend that you use the Tatum Key Management System (KMS) and provide the signature ID instead of the private key in the API. Alternatively, you can use the Tatum JavaScript client.
        /// </remarks>
        /// <exception cref="Tatum.CSharp.FungibleTokens.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="chainDeployErc20KMS"></param>
        /// <param name="xTestnetType">Type of Ethereum testnet. Defaults to Sepolia. Valid only for ETH invocations for testnet API Key. For mainnet API Key, this value is ignored. (optional, default to ethereum-sepolia)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of SignatureId</returns>
        System.Threading.Tasks.Task<SignatureId> Erc20DeployAsync(ChainDeployErc20KMS chainDeployErc20KMS, string xTestnetType = default(string), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        /// <summary>
        /// Get the number of fungible tokens from a specific smart contract that a blockchain address holds
        /// </summary>
        /// <remarks>
        /// 1 credit per API call Get the number of the fungible tokens minted on a specific smart contract (the contractAddress path parameter in the request endpoint URL) that a blockchain address holds. This API is supported for the following blockchains: Algorand BNB Smart Chain Celo Elrond Ethereum Harmony Klaytn KuCoin Community Chain Polygon Solana XinFin
        /// </remarks>
        /// <exception cref="Tatum.CSharp.FungibleTokens.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="address">The blockchain address that you want to get the token balance of</param>
        /// <param name="contractAddress">The address of the fungible token smart contract</param>
        /// <param name="xTestnetType">Type of Ethereum testnet. Defaults to Sepolia. Valid only for ETH invocations for testnet API Key. For mainnet API Key, this value is ignored. (optional, default to ethereum-sepolia)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of Erc20Balance</returns>
        System.Threading.Tasks.Task<Erc20Balance> Erc20GetBalanceAsync(string address, string contractAddress, string xTestnetType = default(string), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        /// <summary>
        /// Get the number of fungible tokens that a blockchain address holds across a blockchain
        /// </summary>
        /// <remarks>
        /// 1 credit per API call Get the number of fungible tokens that a blockchain address holds across a blockchain. The tokens are returned grouped by the smart contracts they were minted on. This API is supported for the following blockchains: Algorand Celo Ethereum Polygon Solana
        /// </remarks>
        /// <exception cref="Tatum.CSharp.FungibleTokens.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="address">The blockchain address that you want to get the token balance of</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of List&lt;Erc20BalanceForAddress&gt;</returns>
        System.Threading.Tasks.Task<List<Erc20BalanceForAddress>> Erc20GetBalanceAddressAsync(string address, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        /// <summary>
        /// Get fungible token transactions on a blockchain address
        /// </summary>
        /// <remarks>
        /// 1 credit per API call Get incoming and outgoing transactions related to fungible tokens on a blockchain address. This API is supported for the following blockchains: Algorand Celo Ethereum Polygon
        /// </remarks>
        /// <exception cref="Tatum.CSharp.FungibleTokens.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="address">Account address you want to get balance of</param>
        /// <param name="tokenAddress">Address of the token smart contract</param>
        /// <param name="pageSize">Max number of items per page is 50.</param>
        /// <param name="offset">Offset to obtain next page of the data. (optional)</param>
        /// <param name="from">Transactions from this block onwards will be included. (optional)</param>
        /// <param name="to">Transactions up to this block will be included. (optional)</param>
        /// <param name="sort">Sorting of the data. ASC - oldest first, DESC - newest first. (optional, default to DESC)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of List&lt;FungibleTx&gt;</returns>
        System.Threading.Tasks.Task<List<FungibleTx>> Erc20GetTransactionByAddressAsync(string address, string tokenAddress, decimal pageSize, decimal? offset = default(decimal?), decimal? from = default(decimal?), decimal? to = default(decimal?), string sort = default(string), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        /// <summary>
        /// Mint fungible tokens
        /// </summary>
        /// <remarks>
        /// 2 credits per API call Create new fungible tokens in the smart contract (the contractAddress parameter in the request body) and transfer them to the specified blockchain address (the to parameter in the request body). You can mint new fungible tokens only if the current supply of tokens in the smart contract is lower than the total supply set for this contract. This API is supported for the following blockchains: BNB Smart Chain Celo Ethereum Harmony Klaytn KuCoin Community Chain Polygon XinFin Signing a transaction When minting fungible tokens, you are charged a fee for the transaction, and you must sign the transaction with the private key of the blockchain address from which the fee will be deducted. Providing the private key in the API is not a secure way of signing transactions, because the private key can be stolen or exposed. Your private keys should never leave your security perimeter. You should use the private keys only for testing a solution you are building on the testnet of a blockchain. For signing transactions on the mainnet, we strongly recommend that you use the Tatum Key Management System (KMS) and provide the signature ID instead of the private key in the API. Alternatively, you can use the Tatum JavaScript client.
        /// </remarks>
        /// <exception cref="Tatum.CSharp.FungibleTokens.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="chainMintErc20"></param>
        /// <param name="xTestnetType">Type of Ethereum testnet. Defaults to Sepolia. Valid only for ETH invocations for testnet API Key. For mainnet API Key, this value is ignored. (optional, default to ethereum-sepolia)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of TransactionHash</returns>
        System.Threading.Tasks.Task<TransactionHash> Erc20MintAsync(ChainMintErc20 chainMintErc20, string xTestnetType = default(string), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        /// <summary>
        /// Mint fungible tokens
        /// </summary>
        /// <remarks>
        /// 2 credits per API call Create new fungible tokens in the smart contract (the contractAddress parameter in the request body) and transfer them to the specified blockchain address (the to parameter in the request body). You can mint new fungible tokens only if the current supply of tokens in the smart contract is lower than the total supply set for this contract. This API is supported for the following blockchains: BNB Smart Chain Celo Ethereum Harmony Klaytn KuCoin Community Chain Polygon XinFin Signing a transaction When minting fungible tokens, you are charged a fee for the transaction, and you must sign the transaction with the private key of the blockchain address from which the fee will be deducted. Providing the private key in the API is not a secure way of signing transactions, because the private key can be stolen or exposed. Your private keys should never leave your security perimeter. You should use the private keys only for testing a solution you are building on the testnet of a blockchain. For signing transactions on the mainnet, we strongly recommend that you use the Tatum Key Management System (KMS) and provide the signature ID instead of the private key in the API. Alternatively, you can use the Tatum JavaScript client.
        /// </remarks>
        /// <exception cref="Tatum.CSharp.FungibleTokens.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="chainMintErc20KMS"></param>
        /// <param name="xTestnetType">Type of Ethereum testnet. Defaults to Sepolia. Valid only for ETH invocations for testnet API Key. For mainnet API Key, this value is ignored. (optional, default to ethereum-sepolia)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of SignatureId</returns>
        System.Threading.Tasks.Task<SignatureId> Erc20MintAsync(ChainMintErc20KMS chainMintErc20KMS, string xTestnetType = default(string), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        /// <summary>
        /// Transfer fungible tokens
        /// </summary>
        /// <remarks>
        /// 2 credits per API call Transfer a supply of fungible tokens existing in the smart contract (the contractAddress parameter in the request body) to the specified blockchain address (the to parameter in the request body). Transferring fungible tokens invokes the transfer() method. This API is supported for the following blockchains: Algorand BNB Smart Chain Celo Ethereum Harmony Klaytn KuCoin Community Chain Polygon Solana XinFin Transferring fungible tokens on Algorand On Algorand, the recipient has to agree in advance to receive your fungible tokens because Algorand charges users for storing the tokens on their addresses, and an Algorand blockchain address by default does not receive the tokens unless explicitly agreed. Before transferring the fungible tokens, make sure that the recipient has agreed to receive the NFT to their address. Blockchain-specific APIs to transfer fungible tokens You can also use blockchain-specific APIs for transferring fungible tokens on the following blockchains: BNB Smart Chain Celo Ethereum Harmony KuCoin Community Chain Polygon XinFin Signing a transaction When transferring fungible tokens, you are charged a fee for the transaction, and you must sign the transaction with the private key of the blockchain address from which the fee will be deducted. Providing the private key in the API is not a secure way of signing transactions, because the private key can be stolen or exposed. Your private keys should never leave your security perimeter. You should use the private keys only for testing a solution you are building on the testnet of a blockchain. For signing transactions on the mainnet, we strongly recommend that you use the Tatum Key Management System (KMS) and provide the signature ID instead of the private key in the API. Alternatively, you can use the Tatum JavaScript client.
        /// </remarks>
        /// <exception cref="Tatum.CSharp.FungibleTokens.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="chainTransferEthErc20"></param>
        /// <param name="xTestnetType">Type of Ethereum testnet. Defaults to Sepolia. Valid only for ETH invocations for testnet API Key. For mainnet API Key, this value is ignored. (optional, default to ethereum-sepolia)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of TransactionHash</returns>
        System.Threading.Tasks.Task<TransactionHash> Erc20TransferAsync(ChainTransferEthErc20 chainTransferEthErc20, string xTestnetType = default(string), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        /// <summary>
        /// Transfer fungible tokens
        /// </summary>
        /// <remarks>
        /// 2 credits per API call Transfer a supply of fungible tokens existing in the smart contract (the contractAddress parameter in the request body) to the specified blockchain address (the to parameter in the request body). Transferring fungible tokens invokes the transfer() method. This API is supported for the following blockchains: Algorand BNB Smart Chain Celo Ethereum Harmony Klaytn KuCoin Community Chain Polygon Solana XinFin Transferring fungible tokens on Algorand On Algorand, the recipient has to agree in advance to receive your fungible tokens because Algorand charges users for storing the tokens on their addresses, and an Algorand blockchain address by default does not receive the tokens unless explicitly agreed. Before transferring the fungible tokens, make sure that the recipient has agreed to receive the NFT to their address. Blockchain-specific APIs to transfer fungible tokens You can also use blockchain-specific APIs for transferring fungible tokens on the following blockchains: BNB Smart Chain Celo Ethereum Harmony KuCoin Community Chain Polygon XinFin Signing a transaction When transferring fungible tokens, you are charged a fee for the transaction, and you must sign the transaction with the private key of the blockchain address from which the fee will be deducted. Providing the private key in the API is not a secure way of signing transactions, because the private key can be stolen or exposed. Your private keys should never leave your security perimeter. You should use the private keys only for testing a solution you are building on the testnet of a blockchain. For signing transactions on the mainnet, we strongly recommend that you use the Tatum Key Management System (KMS) and provide the signature ID instead of the private key in the API. Alternatively, you can use the Tatum JavaScript client.
        /// </remarks>
        /// <exception cref="Tatum.CSharp.FungibleTokens.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="chainTransferEthErc20KMS"></param>
        /// <param name="xTestnetType">Type of Ethereum testnet. Defaults to Sepolia. Valid only for ETH invocations for testnet API Key. For mainnet API Key, this value is ignored. (optional, default to ethereum-sepolia)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of SignatureId</returns>
        System.Threading.Tasks.Task<SignatureId> Erc20TransferAsync(ChainTransferEthErc20KMS chainTransferEthErc20KMS, string xTestnetType = default(string), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        #endregion Asynchronous Operations
    }

    /// <summary>
    /// Represents a collection of functions to interact with the API endpoints
    /// </summary>
    public interface IFungibleTokensEthApiWithHttpInfoAsync : IApiAccessor
    {
        #region Asynchronous Operations With Http Info
        /// <summary>
        /// Approve spending of fungible tokens
        /// </summary>
        /// <remarks>
        /// 2 credits per API call Allow another blockchain address (the spender parameter in the request body) to spend and burn fungible tokens on behalf of the smart contract owner. This API is supported for the following blockchains: BNB Smart Chain Celo Ethereum Harmony Klaytn Polygon Signing a transaction When approving spending of fungible tokens, you are charged a fee for the transaction, and you must sign the transaction with the private key of the blockchain address from which the fee will be deducted. Providing the private key in the API is not a secure way of signing transactions, because the private key can be stolen or exposed. Your private keys should never leave your security perimeter. You should use the private keys only for testing a solution you are building on the testnet of a blockchain. For signing transactions on the mainnet, we strongly recommend that you use the Tatum Key Management System (KMS) and provide the signature ID instead of the private key in the API. Alternatively, you can use the Tatum JavaScript client.
        /// </remarks>
        /// <exception cref="Tatum.CSharp.FungibleTokens.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="approveErc20"></param>
        /// <param name="xTestnetType">Type of Ethereum testnet. Defaults to Sepolia. Valid only for ETH invocations for testnet API Key. For mainnet API Key, this value is ignored. (optional, default to ethereum-sepolia)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (TransactionHash)</returns>
        System.Threading.Tasks.Task<ApiResponse<TransactionHash>> Erc20ApproveWithHttpInfoAsync(ApproveErc20 approveErc20, string xTestnetType = default(string), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        /// <summary>
        /// Approve spending of fungible tokens
        /// </summary>
        /// <remarks>
        /// 2 credits per API call Allow another blockchain address (the spender parameter in the request body) to spend and burn fungible tokens on behalf of the smart contract owner. This API is supported for the following blockchains: BNB Smart Chain Celo Ethereum Harmony Klaytn Polygon Signing a transaction When approving spending of fungible tokens, you are charged a fee for the transaction, and you must sign the transaction with the private key of the blockchain address from which the fee will be deducted. Providing the private key in the API is not a secure way of signing transactions, because the private key can be stolen or exposed. Your private keys should never leave your security perimeter. You should use the private keys only for testing a solution you are building on the testnet of a blockchain. For signing transactions on the mainnet, we strongly recommend that you use the Tatum Key Management System (KMS) and provide the signature ID instead of the private key in the API. Alternatively, you can use the Tatum JavaScript client.
        /// </remarks>
        /// <exception cref="Tatum.CSharp.FungibleTokens.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="approveErc20KMS"></param>
        /// <param name="xTestnetType">Type of Ethereum testnet. Defaults to Sepolia. Valid only for ETH invocations for testnet API Key. For mainnet API Key, this value is ignored. (optional, default to ethereum-sepolia)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (SignatureId)</returns>
        System.Threading.Tasks.Task<ApiResponse<SignatureId>> Erc20ApproveWithHttpInfoAsync(ApproveErc20KMS approveErc20KMS, string xTestnetType = default(string), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        /// <summary>
        /// Burn fungible tokens
        /// </summary>
        /// <remarks>
        /// 2 credits per API call Burn fungible tokens. Burning fungible tokens deletes the specified supply of the tokens (the amount parameter in the request body) from the smart contract (the contractAddress parameter in the request body). This API is supported for the following blockchains: Algorand BNB Smart Chain Celo Ethereum Harmony Klaytn KuCoin Community Chain Polygon XinFin Signing a transaction When burning fungible tokens, you are charged a fee for the transaction, and you must sign the transaction with the private key of the blockchain address from which the fee will be deducted. Providing the private key in the API is not a secure way of signing transactions, because the private key can be stolen or exposed. Your private keys should never leave your security perimeter. You should use the private keys only for testing a solution you are building on the testnet of a blockchain. For signing transactions on the mainnet, we strongly recommend that you use the Tatum Key Management System (KMS) and provide the signature ID instead of the private key in the API. Alternatively, you can use the Tatum JavaScript client.
        /// </remarks>
        /// <exception cref="Tatum.CSharp.FungibleTokens.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="chainBurnErc20"></param>
        /// <param name="xTestnetType">Type of Ethereum testnet. Defaults to Sepolia. Valid only for ETH invocations for testnet API Key. For mainnet API Key, this value is ignored. (optional, default to ethereum-sepolia)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (TransactionHash)</returns>
        System.Threading.Tasks.Task<ApiResponse<TransactionHash>> Erc20BurnWithHttpInfoAsync(ChainBurnErc20 chainBurnErc20, string xTestnetType = default(string), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        /// <summary>
        /// Burn fungible tokens
        /// </summary>
        /// <remarks>
        /// 2 credits per API call Burn fungible tokens. Burning fungible tokens deletes the specified supply of the tokens (the amount parameter in the request body) from the smart contract (the contractAddress parameter in the request body). This API is supported for the following blockchains: Algorand BNB Smart Chain Celo Ethereum Harmony Klaytn KuCoin Community Chain Polygon XinFin Signing a transaction When burning fungible tokens, you are charged a fee for the transaction, and you must sign the transaction with the private key of the blockchain address from which the fee will be deducted. Providing the private key in the API is not a secure way of signing transactions, because the private key can be stolen or exposed. Your private keys should never leave your security perimeter. You should use the private keys only for testing a solution you are building on the testnet of a blockchain. For signing transactions on the mainnet, we strongly recommend that you use the Tatum Key Management System (KMS) and provide the signature ID instead of the private key in the API. Alternatively, you can use the Tatum JavaScript client.
        /// </remarks>
        /// <exception cref="Tatum.CSharp.FungibleTokens.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="chainBurnErc20KMS"></param>
        /// <param name="xTestnetType">Type of Ethereum testnet. Defaults to Sepolia. Valid only for ETH invocations for testnet API Key. For mainnet API Key, this value is ignored. (optional, default to ethereum-sepolia)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (SignatureId)</returns>
        System.Threading.Tasks.Task<ApiResponse<SignatureId>> Erc20BurnWithHttpInfoAsync(ChainBurnErc20KMS chainBurnErc20KMS, string xTestnetType = default(string), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        /// <summary>
        /// Deploy a fungible token smart contract
        /// </summary>
        /// <remarks>
        /// 2 credits per API call Deploy a fungible token smart contract on the blockchain. In a deployed smart contract, you can mint and burn fungible tokens. The whole supply of fungible tokens (the supply parameter in the request body) will be transferred to the specified blockchain address (the address parameter in the request body). Smart contracts are standardized and audited. This API is supported for the following blockchains: Algorand BNB Smart Chain Celo Ethereum Harmony Klaytn KuCoin Community Chain Polygon Solana XinFin You can review the code of a deployed smart contract here. Signing a transaction When deploying a fungible token smart contract, you are charged a fee for the transaction, and you must sign the transaction with the private key of the blockchain address from which the fee will be deducted. Providing the private key in the API is not a secure way of signing transactions, because the private key can be stolen or exposed. Your private keys should never leave your security perimeter. You should use the private keys only for testing a solution you are building on the testnet of a blockchain. For signing transactions on the mainnet, we strongly recommend that you use the Tatum Key Management System (KMS) and provide the signature ID instead of the private key in the API. Alternatively, you can use the Tatum JavaScript client.
        /// </remarks>
        /// <exception cref="Tatum.CSharp.FungibleTokens.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="chainDeployErc20"></param>
        /// <param name="xTestnetType">Type of Ethereum testnet. Defaults to Sepolia. Valid only for ETH invocations for testnet API Key. For mainnet API Key, this value is ignored. (optional, default to ethereum-sepolia)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (TransactionHash)</returns>
        System.Threading.Tasks.Task<ApiResponse<TransactionHash>> Erc20DeployWithHttpInfoAsync(ChainDeployErc20 chainDeployErc20, string xTestnetType = default(string), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        /// <summary>
        /// Deploy a fungible token smart contract
        /// </summary>
        /// <remarks>
        /// 2 credits per API call Deploy a fungible token smart contract on the blockchain. In a deployed smart contract, you can mint and burn fungible tokens. The whole supply of fungible tokens (the supply parameter in the request body) will be transferred to the specified blockchain address (the address parameter in the request body). Smart contracts are standardized and audited. This API is supported for the following blockchains: Algorand BNB Smart Chain Celo Ethereum Harmony Klaytn KuCoin Community Chain Polygon Solana XinFin You can review the code of a deployed smart contract here. Signing a transaction When deploying a fungible token smart contract, you are charged a fee for the transaction, and you must sign the transaction with the private key of the blockchain address from which the fee will be deducted. Providing the private key in the API is not a secure way of signing transactions, because the private key can be stolen or exposed. Your private keys should never leave your security perimeter. You should use the private keys only for testing a solution you are building on the testnet of a blockchain. For signing transactions on the mainnet, we strongly recommend that you use the Tatum Key Management System (KMS) and provide the signature ID instead of the private key in the API. Alternatively, you can use the Tatum JavaScript client.
        /// </remarks>
        /// <exception cref="Tatum.CSharp.FungibleTokens.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="chainDeployErc20KMS"></param>
        /// <param name="xTestnetType">Type of Ethereum testnet. Defaults to Sepolia. Valid only for ETH invocations for testnet API Key. For mainnet API Key, this value is ignored. (optional, default to ethereum-sepolia)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (SignatureId)</returns>
        System.Threading.Tasks.Task<ApiResponse<SignatureId>> Erc20DeployWithHttpInfoAsync(ChainDeployErc20KMS chainDeployErc20KMS, string xTestnetType = default(string), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        /// <summary>
        /// Get the number of fungible tokens from a specific smart contract that a blockchain address holds
        /// </summary>
        /// <remarks>
        /// 1 credit per API call Get the number of the fungible tokens minted on a specific smart contract (the contractAddress path parameter in the request endpoint URL) that a blockchain address holds. This API is supported for the following blockchains: Algorand BNB Smart Chain Celo Elrond Ethereum Harmony Klaytn KuCoin Community Chain Polygon Solana XinFin
        /// </remarks>
        /// <exception cref="Tatum.CSharp.FungibleTokens.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="address">The blockchain address that you want to get the token balance of</param>
        /// <param name="contractAddress">The address of the fungible token smart contract</param>
        /// <param name="xTestnetType">Type of Ethereum testnet. Defaults to Sepolia. Valid only for ETH invocations for testnet API Key. For mainnet API Key, this value is ignored. (optional, default to ethereum-sepolia)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (Erc20Balance)</returns>
        System.Threading.Tasks.Task<ApiResponse<Erc20Balance>> Erc20GetBalanceWithHttpInfoAsync(string address, string contractAddress, string xTestnetType = default(string), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        /// <summary>
        /// Get the number of fungible tokens that a blockchain address holds across a blockchain
        /// </summary>
        /// <remarks>
        /// 1 credit per API call Get the number of fungible tokens that a blockchain address holds across a blockchain. The tokens are returned grouped by the smart contracts they were minted on. This API is supported for the following blockchains: Algorand Celo Ethereum Polygon Solana
        /// </remarks>
        /// <exception cref="Tatum.CSharp.FungibleTokens.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="address">The blockchain address that you want to get the token balance of</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (List&lt;Erc20BalanceForAddress&gt;)</returns>
        System.Threading.Tasks.Task<ApiResponse<List<Erc20BalanceForAddress>>> Erc20GetBalanceAddressWithHttpInfoAsync(string address, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        /// <summary>
        /// Get fungible token transactions on a blockchain address
        /// </summary>
        /// <remarks>
        /// 1 credit per API call Get incoming and outgoing transactions related to fungible tokens on a blockchain address. This API is supported for the following blockchains: Algorand Celo Ethereum Polygon
        /// </remarks>
        /// <exception cref="Tatum.CSharp.FungibleTokens.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="address">Account address you want to get balance of</param>
        /// <param name="tokenAddress">Address of the token smart contract</param>
        /// <param name="pageSize">Max number of items per page is 50.</param>
        /// <param name="offset">Offset to obtain next page of the data. (optional)</param>
        /// <param name="from">Transactions from this block onwards will be included. (optional)</param>
        /// <param name="to">Transactions up to this block will be included. (optional)</param>
        /// <param name="sort">Sorting of the data. ASC - oldest first, DESC - newest first. (optional, default to DESC)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (List&lt;FungibleTx&gt;)</returns>
        System.Threading.Tasks.Task<ApiResponse<List<FungibleTx>>> Erc20GetTransactionByAddressWithHttpInfoAsync(string address, string tokenAddress, decimal pageSize, decimal? offset = default(decimal?), decimal? from = default(decimal?), decimal? to = default(decimal?), string sort = default(string), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        /// <summary>
        /// Mint fungible tokens
        /// </summary>
        /// <remarks>
        /// 2 credits per API call Create new fungible tokens in the smart contract (the contractAddress parameter in the request body) and transfer them to the specified blockchain address (the to parameter in the request body). You can mint new fungible tokens only if the current supply of tokens in the smart contract is lower than the total supply set for this contract. This API is supported for the following blockchains: BNB Smart Chain Celo Ethereum Harmony Klaytn KuCoin Community Chain Polygon XinFin Signing a transaction When minting fungible tokens, you are charged a fee for the transaction, and you must sign the transaction with the private key of the blockchain address from which the fee will be deducted. Providing the private key in the API is not a secure way of signing transactions, because the private key can be stolen or exposed. Your private keys should never leave your security perimeter. You should use the private keys only for testing a solution you are building on the testnet of a blockchain. For signing transactions on the mainnet, we strongly recommend that you use the Tatum Key Management System (KMS) and provide the signature ID instead of the private key in the API. Alternatively, you can use the Tatum JavaScript client.
        /// </remarks>
        /// <exception cref="Tatum.CSharp.FungibleTokens.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="chainMintErc20"></param>
        /// <param name="xTestnetType">Type of Ethereum testnet. Defaults to Sepolia. Valid only for ETH invocations for testnet API Key. For mainnet API Key, this value is ignored. (optional, default to ethereum-sepolia)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (TransactionHash)</returns>
        System.Threading.Tasks.Task<ApiResponse<TransactionHash>> Erc20MintWithHttpInfoAsync(ChainMintErc20 chainMintErc20, string xTestnetType = default(string), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        /// <summary>
        /// Mint fungible tokens
        /// </summary>
        /// <remarks>
        /// 2 credits per API call Create new fungible tokens in the smart contract (the contractAddress parameter in the request body) and transfer them to the specified blockchain address (the to parameter in the request body). You can mint new fungible tokens only if the current supply of tokens in the smart contract is lower than the total supply set for this contract. This API is supported for the following blockchains: BNB Smart Chain Celo Ethereum Harmony Klaytn KuCoin Community Chain Polygon XinFin Signing a transaction When minting fungible tokens, you are charged a fee for the transaction, and you must sign the transaction with the private key of the blockchain address from which the fee will be deducted. Providing the private key in the API is not a secure way of signing transactions, because the private key can be stolen or exposed. Your private keys should never leave your security perimeter. You should use the private keys only for testing a solution you are building on the testnet of a blockchain. For signing transactions on the mainnet, we strongly recommend that you use the Tatum Key Management System (KMS) and provide the signature ID instead of the private key in the API. Alternatively, you can use the Tatum JavaScript client.
        /// </remarks>
        /// <exception cref="Tatum.CSharp.FungibleTokens.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="chainMintErc20KMS"></param>
        /// <param name="xTestnetType">Type of Ethereum testnet. Defaults to Sepolia. Valid only for ETH invocations for testnet API Key. For mainnet API Key, this value is ignored. (optional, default to ethereum-sepolia)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (SignatureId)</returns>
        System.Threading.Tasks.Task<ApiResponse<SignatureId>> Erc20MintWithHttpInfoAsync(ChainMintErc20KMS chainMintErc20KMS, string xTestnetType = default(string), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        /// <summary>
        /// Transfer fungible tokens
        /// </summary>
        /// <remarks>
        /// 2 credits per API call Transfer a supply of fungible tokens existing in the smart contract (the contractAddress parameter in the request body) to the specified blockchain address (the to parameter in the request body). Transferring fungible tokens invokes the transfer() method. This API is supported for the following blockchains: Algorand BNB Smart Chain Celo Ethereum Harmony Klaytn KuCoin Community Chain Polygon Solana XinFin Transferring fungible tokens on Algorand On Algorand, the recipient has to agree in advance to receive your fungible tokens because Algorand charges users for storing the tokens on their addresses, and an Algorand blockchain address by default does not receive the tokens unless explicitly agreed. Before transferring the fungible tokens, make sure that the recipient has agreed to receive the NFT to their address. Blockchain-specific APIs to transfer fungible tokens You can also use blockchain-specific APIs for transferring fungible tokens on the following blockchains: BNB Smart Chain Celo Ethereum Harmony KuCoin Community Chain Polygon XinFin Signing a transaction When transferring fungible tokens, you are charged a fee for the transaction, and you must sign the transaction with the private key of the blockchain address from which the fee will be deducted. Providing the private key in the API is not a secure way of signing transactions, because the private key can be stolen or exposed. Your private keys should never leave your security perimeter. You should use the private keys only for testing a solution you are building on the testnet of a blockchain. For signing transactions on the mainnet, we strongly recommend that you use the Tatum Key Management System (KMS) and provide the signature ID instead of the private key in the API. Alternatively, you can use the Tatum JavaScript client.
        /// </remarks>
        /// <exception cref="Tatum.CSharp.FungibleTokens.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="chainTransferEthErc20"></param>
        /// <param name="xTestnetType">Type of Ethereum testnet. Defaults to Sepolia. Valid only for ETH invocations for testnet API Key. For mainnet API Key, this value is ignored. (optional, default to ethereum-sepolia)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (TransactionHash)</returns>
        System.Threading.Tasks.Task<ApiResponse<TransactionHash>> Erc20TransferWithHttpInfoAsync(ChainTransferEthErc20 chainTransferEthErc20, string xTestnetType = default(string), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        /// <summary>
        /// Transfer fungible tokens
        /// </summary>
        /// <remarks>
        /// 2 credits per API call Transfer a supply of fungible tokens existing in the smart contract (the contractAddress parameter in the request body) to the specified blockchain address (the to parameter in the request body). Transferring fungible tokens invokes the transfer() method. This API is supported for the following blockchains: Algorand BNB Smart Chain Celo Ethereum Harmony Klaytn KuCoin Community Chain Polygon Solana XinFin Transferring fungible tokens on Algorand On Algorand, the recipient has to agree in advance to receive your fungible tokens because Algorand charges users for storing the tokens on their addresses, and an Algorand blockchain address by default does not receive the tokens unless explicitly agreed. Before transferring the fungible tokens, make sure that the recipient has agreed to receive the NFT to their address. Blockchain-specific APIs to transfer fungible tokens You can also use blockchain-specific APIs for transferring fungible tokens on the following blockchains: BNB Smart Chain Celo Ethereum Harmony KuCoin Community Chain Polygon XinFin Signing a transaction When transferring fungible tokens, you are charged a fee for the transaction, and you must sign the transaction with the private key of the blockchain address from which the fee will be deducted. Providing the private key in the API is not a secure way of signing transactions, because the private key can be stolen or exposed. Your private keys should never leave your security perimeter. You should use the private keys only for testing a solution you are building on the testnet of a blockchain. For signing transactions on the mainnet, we strongly recommend that you use the Tatum Key Management System (KMS) and provide the signature ID instead of the private key in the API. Alternatively, you can use the Tatum JavaScript client.
        /// </remarks>
        /// <exception cref="Tatum.CSharp.FungibleTokens.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="chainTransferEthErc20KMS"></param>
        /// <param name="xTestnetType">Type of Ethereum testnet. Defaults to Sepolia. Valid only for ETH invocations for testnet API Key. For mainnet API Key, this value is ignored. (optional, default to ethereum-sepolia)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (SignatureId)</returns>
        System.Threading.Tasks.Task<ApiResponse<SignatureId>> Erc20TransferWithHttpInfoAsync(ChainTransferEthErc20KMS chainTransferEthErc20KMS, string xTestnetType = default(string), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        #endregion Asynchronous Operations With Http Info
    }


    /// <summary>
    /// Represents a collection of functions to interact with the API endpoints
    /// </summary>
    public interface IFungibleTokensEthApi : IFungibleTokensEthApiSync, IFungibleTokensEthApiWithHttpInfoSync, IFungibleTokensEthApiAsync, IFungibleTokensEthApiWithHttpInfoAsync
    {

    }

    /// <summary>
    /// Represents a collection of functions to interact with the API endpoints
    /// </summary>
    public partial class FungibleTokensEthApi : IFungibleTokensEthApi
    {
        private ExceptionFactory _exceptionFactory = (name, response) => null;

        /// <summary>
        /// Initializes a new instance of the <see cref="FungibleTokensEthApi"/> class.
        /// </summary>
        /// <param name="client">An instance of HttpClient.</param>
        /// <param name="handler">An optional instance of HttpClientHandler that is used by HttpClient.</param>
        /// <exception cref="ArgumentNullException"></exception>
        /// <returns></returns>
        /// <remarks>
        /// Some configuration settings will not be applied without passing an HttpClientHandler.
        /// The features affected are: Setting and Retrieving Cookies, Client Certificates, Proxy settings.
        /// </remarks>
        public FungibleTokensEthApi(HttpClient client, HttpClientHandler handler = null) : this(client, (string)null, handler)
        {
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="FungibleTokensEthApi"/> class.
        /// </summary>
        /// <param name="client">An instance of HttpClient.</param>
        /// <param name="basePath">The target service's base path in URL format.</param>
        /// <param name="handler">An optional instance of HttpClientHandler that is used by HttpClient.</param>
        /// <exception cref="ArgumentNullException"></exception>
        /// <exception cref="ArgumentException"></exception>
        /// <returns></returns>
        /// <remarks>
        /// Some configuration settings will not be applied without passing an HttpClientHandler.
        /// The features affected are: Setting and Retrieving Cookies, Client Certificates, Proxy settings.
        /// </remarks>
        public FungibleTokensEthApi(HttpClient client, string basePath, HttpClientHandler handler = null)
        {
            if (client == null) throw new ArgumentNullException(nameof(client));

            Configuration = Tatum.CSharp.FungibleTokens.Core.Client.Configuration.MergeConfigurations(
                GlobalConfiguration.Instance,
                new Configuration { BasePath = basePath }
            );
            ApiClient = new ApiClient(client, Configuration.BasePath, handler);
            Client =  ApiClient;
            AsynchronousClient = ApiClient;
            ExceptionFactory = Tatum.CSharp.FungibleTokens.Core.Client.Configuration.DefaultExceptionFactory;
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="FungibleTokensEthApi"/> class using Configuration object.
        /// </summary>
        /// <param name="client">An instance of HttpClient.</param>
        /// <param name="configuration">An instance of Configuration.</param>
        /// <param name="handler">An optional instance of HttpClientHandler that is used by HttpClient.</param>
        /// <exception cref="ArgumentNullException"></exception>
        /// <returns></returns>
        /// <remarks>
        /// Some configuration settings will not be applied without passing an HttpClientHandler.
        /// The features affected are: Setting and Retrieving Cookies, Client Certificates, Proxy settings.
        /// </remarks>
        public FungibleTokensEthApi(HttpClient client, Configuration configuration, HttpClientHandler handler = null)
        {
            if (configuration == null) throw new ArgumentNullException(nameof(configuration));
            if (client == null) throw new ArgumentNullException(nameof(client));

            Configuration = Tatum.CSharp.FungibleTokens.Core.Client.Configuration.MergeConfigurations(
                GlobalConfiguration.Instance,
                configuration
            );
            ApiClient = new ApiClient(client, Configuration.BasePath, handler);
            Client = ApiClient;
            AsynchronousClient = ApiClient;
            ExceptionFactory = Tatum.CSharp.FungibleTokens.Core.Client.Configuration.DefaultExceptionFactory;
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="FungibleTokensEthApi"/> class
        /// using a Configuration object and client instance.
        /// </summary>
        /// <param name="client">The client interface for synchronous API access.</param>
        /// <param name="asyncClient">The client interface for asynchronous API access.</param>
        /// <param name="configuration">The configuration object.</param>
        /// <exception cref="ArgumentNullException"></exception>
        public FungibleTokensEthApi(ISynchronousClient client, IAsynchronousClient asyncClient, IReadableConfiguration configuration)
        {
            Client = client ?? throw new ArgumentNullException(nameof(client));
            AsynchronousClient = asyncClient ?? throw new ArgumentNullException(nameof(asyncClient));
            Configuration = configuration ?? throw new ArgumentNullException(nameof(configuration));
            ExceptionFactory = Tatum.CSharp.FungibleTokens.Core.Client.Configuration.DefaultExceptionFactory;
        }

        /// <summary>
        /// Holds the ApiClient if created
        /// </summary>
        public ApiClient ApiClient { get; set; }

        /// <summary>
        /// The client for accessing this underlying API asynchronously.
        /// </summary>
        public IAsynchronousClient AsynchronousClient { get; set; }

        /// <summary>
        /// The client for accessing this underlying API synchronously.
        /// </summary>
        public ISynchronousClient Client { get; set; }

        /// <summary>
        /// Gets the base path of the API client.
        /// </summary>
        /// <value>The base path</value>
        public string GetBasePath()
        {
            return Configuration.BasePath;
        }

        /// <summary>
        /// Gets or sets the configuration object
        /// </summary>
        /// <value>An instance of the Configuration</value>
        public IReadableConfiguration Configuration { get; set; }

        /// <summary>
        /// Provides a factory method hook for the creation of exceptions.
        /// </summary>
        public ExceptionFactory ExceptionFactory
        {
            get
            {
                if (_exceptionFactory != null && _exceptionFactory.GetInvocationList().Length > 1)
                {
                    throw new InvalidOperationException("Multicast delegate for ExceptionFactory is unsupported.");
                }
                return _exceptionFactory;
            }
            set => _exceptionFactory = value;
        }

        /// <summary>
        /// Approve spending of fungible tokens 2 credits per API call Allow another blockchain address (the spender parameter in the request body) to spend and burn fungible tokens on behalf of the smart contract owner. This API is supported for the following blockchains: BNB Smart Chain Celo Ethereum Harmony Klaytn Polygon Signing a transaction When approving spending of fungible tokens, you are charged a fee for the transaction, and you must sign the transaction with the private key of the blockchain address from which the fee will be deducted. Providing the private key in the API is not a secure way of signing transactions, because the private key can be stolen or exposed. Your private keys should never leave your security perimeter. You should use the private keys only for testing a solution you are building on the testnet of a blockchain. For signing transactions on the mainnet, we strongly recommend that you use the Tatum Key Management System (KMS) and provide the signature ID instead of the private key in the API. Alternatively, you can use the Tatum JavaScript client.
        /// </summary>
        /// <exception cref="Tatum.CSharp.FungibleTokens.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="approveErc20"></param>
        /// <param name="xTestnetType">Type of Ethereum testnet. Defaults to Sepolia. Valid only for ETH invocations for testnet API Key. For mainnet API Key, this value is ignored. (optional, default to ethereum-sepolia)</param>
        /// <returns>TransactionHash</returns>
        public TransactionHash Erc20Approve(ApproveErc20 approveErc20, string xTestnetType = default(string))
        {
            var localVarResponse = Erc20ApproveWithHttpInfo(approveErc20, xTestnetType);

            var exception = ExceptionFactory?.Invoke("Erc20Approve", localVarResponse);
            if (exception != null) throw exception;

            return localVarResponse.Data;
        }

        /// <summary>
        /// Approve spending of fungible tokens 2 credits per API call Allow another blockchain address (the spender parameter in the request body) to spend and burn fungible tokens on behalf of the smart contract owner. This API is supported for the following blockchains: BNB Smart Chain Celo Ethereum Harmony Klaytn Polygon Signing a transaction When approving spending of fungible tokens, you are charged a fee for the transaction, and you must sign the transaction with the private key of the blockchain address from which the fee will be deducted. Providing the private key in the API is not a secure way of signing transactions, because the private key can be stolen or exposed. Your private keys should never leave your security perimeter. You should use the private keys only for testing a solution you are building on the testnet of a blockchain. For signing transactions on the mainnet, we strongly recommend that you use the Tatum Key Management System (KMS) and provide the signature ID instead of the private key in the API. Alternatively, you can use the Tatum JavaScript client.
        /// </summary>
        /// <exception cref="Tatum.CSharp.FungibleTokens.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="approveErc20"></param>
        /// <param name="xTestnetType">Type of Ethereum testnet. Defaults to Sepolia. Valid only for ETH invocations for testnet API Key. For mainnet API Key, this value is ignored. (optional, default to ethereum-sepolia)</param>
        /// <returns>ApiResponse of TransactionHash</returns>
        public ApiResponse<TransactionHash> Erc20ApproveWithHttpInfo(ApproveErc20 approveErc20, string xTestnetType = default(string))
        {
            // verify the required parameter 'approveErc20' is set
            if (approveErc20 == null)
                throw new ApiException(400, "Missing required parameter 'approveErc20' when calling FungibleTokensEthApi->Erc20Approve");

            var localVarRequestOptions = new RequestOptions();

            var contentTypes = new string[]{
                "application/json"
            };

            // to determine the Accept header
            var accepts = new string[]{
                "application/json"
            };

            var localVarContentType = ClientUtils.SelectHeaderContentType(contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = ClientUtils.SelectHeaderAccept(accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            if (xTestnetType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("x-testnet-type", ClientUtils.ParameterToString(xTestnetType)); // header parameter
            }
            localVarRequestOptions.Data = approveErc20;

            // authentication (X-API-Key) required
            if (!string.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("x-api-key")))
            {
                localVarRequestOptions.HeaderParameters.Add("x-api-key", Configuration.GetApiKeyWithPrefix("x-api-key"));
            }

            // make the HTTP request
            var localVarResponse = Client.Post<TransactionHash>("/v3/blockchain/token/approve", localVarRequestOptions, Configuration);

            return localVarResponse;
        }

        /// <summary>
        /// Approve spending of fungible tokens 2 credits per API call Allow another blockchain address (the spender parameter in the request body) to spend and burn fungible tokens on behalf of the smart contract owner. This API is supported for the following blockchains: BNB Smart Chain Celo Ethereum Harmony Klaytn Polygon Signing a transaction When approving spending of fungible tokens, you are charged a fee for the transaction, and you must sign the transaction with the private key of the blockchain address from which the fee will be deducted. Providing the private key in the API is not a secure way of signing transactions, because the private key can be stolen or exposed. Your private keys should never leave your security perimeter. You should use the private keys only for testing a solution you are building on the testnet of a blockchain. For signing transactions on the mainnet, we strongly recommend that you use the Tatum Key Management System (KMS) and provide the signature ID instead of the private key in the API. Alternatively, you can use the Tatum JavaScript client.
        /// </summary>
        /// <exception cref="Tatum.CSharp.FungibleTokens.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="approveErc20"></param>
        /// <param name="xTestnetType">Type of Ethereum testnet. Defaults to Sepolia. Valid only for ETH invocations for testnet API Key. For mainnet API Key, this value is ignored. (optional, default to ethereum-sepolia)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of TransactionHash</returns>
        public async System.Threading.Tasks.Task<TransactionHash> Erc20ApproveAsync(ApproveErc20 approveErc20, string xTestnetType = default(string), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            var localVarResponse = await Erc20ApproveWithHttpInfoAsync(approveErc20, xTestnetType, cancellationToken).ConfigureAwait(false);
            
            var exception = ExceptionFactory?.Invoke("Erc20Approve", localVarResponse);
            if (exception != null) throw exception;

            return localVarResponse.Data;
        }

        /// <summary>
        /// Approve spending of fungible tokens 2 credits per API call Allow another blockchain address (the spender parameter in the request body) to spend and burn fungible tokens on behalf of the smart contract owner. This API is supported for the following blockchains: BNB Smart Chain Celo Ethereum Harmony Klaytn Polygon Signing a transaction When approving spending of fungible tokens, you are charged a fee for the transaction, and you must sign the transaction with the private key of the blockchain address from which the fee will be deducted. Providing the private key in the API is not a secure way of signing transactions, because the private key can be stolen or exposed. Your private keys should never leave your security perimeter. You should use the private keys only for testing a solution you are building on the testnet of a blockchain. For signing transactions on the mainnet, we strongly recommend that you use the Tatum Key Management System (KMS) and provide the signature ID instead of the private key in the API. Alternatively, you can use the Tatum JavaScript client.
        /// </summary>
        /// <exception cref="Tatum.CSharp.FungibleTokens.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="approveErc20"></param>
        /// <param name="xTestnetType">Type of Ethereum testnet. Defaults to Sepolia. Valid only for ETH invocations for testnet API Key. For mainnet API Key, this value is ignored. (optional, default to ethereum-sepolia)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (TransactionHash)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<TransactionHash>> Erc20ApproveWithHttpInfoAsync(ApproveErc20 approveErc20, string xTestnetType = default(string), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            // verify the required parameter 'approveErc20' is set
            if (approveErc20 == null)
                throw new ApiException(400, "Missing required parameter 'approveErc20' when calling FungibleTokensEthApi->Erc20Approve");

            var localVarRequestOptions = new RequestOptions();

            var contentTypes = new string[]{
                "application/json"
            };

            // to determine the Accept header
            var accepts = new string[]{
                "application/json"
            };


            var localVarContentType = ClientUtils.SelectHeaderContentType(contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = ClientUtils.SelectHeaderAccept(accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            if (xTestnetType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("x-testnet-type", ClientUtils.ParameterToString(xTestnetType)); // header parameter
            }
            localVarRequestOptions.Data = approveErc20;

            // authentication (X-API-Key) required
            if (!string.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("x-api-key")))
            {
                localVarRequestOptions.HeaderParameters.Add("x-api-key", Configuration.GetApiKeyWithPrefix("x-api-key"));
            }

            // make the HTTP request

            var localVarResponse = await AsynchronousClient.PostAsync<TransactionHash>("/v3/blockchain/token/approve", localVarRequestOptions, Configuration, cancellationToken).ConfigureAwait(false);

            return localVarResponse;
        }

        /// <summary>
        /// Approve spending of fungible tokens 2 credits per API call Allow another blockchain address (the spender parameter in the request body) to spend and burn fungible tokens on behalf of the smart contract owner. This API is supported for the following blockchains: BNB Smart Chain Celo Ethereum Harmony Klaytn Polygon Signing a transaction When approving spending of fungible tokens, you are charged a fee for the transaction, and you must sign the transaction with the private key of the blockchain address from which the fee will be deducted. Providing the private key in the API is not a secure way of signing transactions, because the private key can be stolen or exposed. Your private keys should never leave your security perimeter. You should use the private keys only for testing a solution you are building on the testnet of a blockchain. For signing transactions on the mainnet, we strongly recommend that you use the Tatum Key Management System (KMS) and provide the signature ID instead of the private key in the API. Alternatively, you can use the Tatum JavaScript client.
        /// </summary>
        /// <exception cref="Tatum.CSharp.FungibleTokens.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="approveErc20KMS"></param>
        /// <param name="xTestnetType">Type of Ethereum testnet. Defaults to Sepolia. Valid only for ETH invocations for testnet API Key. For mainnet API Key, this value is ignored. (optional, default to ethereum-sepolia)</param>
        /// <returns>SignatureId</returns>
        public SignatureId Erc20Approve(ApproveErc20KMS approveErc20KMS, string xTestnetType = default(string))
        {
            var localVarResponse = Erc20ApproveWithHttpInfo(approveErc20KMS, xTestnetType);

            var exception = ExceptionFactory?.Invoke("Erc20Approve_0", localVarResponse);
            if (exception != null) throw exception;

            return localVarResponse.Data;
        }

        /// <summary>
        /// Approve spending of fungible tokens 2 credits per API call Allow another blockchain address (the spender parameter in the request body) to spend and burn fungible tokens on behalf of the smart contract owner. This API is supported for the following blockchains: BNB Smart Chain Celo Ethereum Harmony Klaytn Polygon Signing a transaction When approving spending of fungible tokens, you are charged a fee for the transaction, and you must sign the transaction with the private key of the blockchain address from which the fee will be deducted. Providing the private key in the API is not a secure way of signing transactions, because the private key can be stolen or exposed. Your private keys should never leave your security perimeter. You should use the private keys only for testing a solution you are building on the testnet of a blockchain. For signing transactions on the mainnet, we strongly recommend that you use the Tatum Key Management System (KMS) and provide the signature ID instead of the private key in the API. Alternatively, you can use the Tatum JavaScript client.
        /// </summary>
        /// <exception cref="Tatum.CSharp.FungibleTokens.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="approveErc20KMS"></param>
        /// <param name="xTestnetType">Type of Ethereum testnet. Defaults to Sepolia. Valid only for ETH invocations for testnet API Key. For mainnet API Key, this value is ignored. (optional, default to ethereum-sepolia)</param>
        /// <returns>ApiResponse of SignatureId</returns>
        public ApiResponse<SignatureId> Erc20ApproveWithHttpInfo(ApproveErc20KMS approveErc20KMS, string xTestnetType = default(string))
        {
            // verify the required parameter 'approveErc20KMS' is set
            if (approveErc20KMS == null)
                throw new ApiException(400, "Missing required parameter 'approveErc20KMS' when calling FungibleTokensEthApi->Erc20Approve_0");

            var localVarRequestOptions = new RequestOptions();

            var contentTypes = new string[]{
                "application/json"
            };

            // to determine the Accept header
            var accepts = new string[]{
                "application/json"
            };

            var localVarContentType = ClientUtils.SelectHeaderContentType(contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = ClientUtils.SelectHeaderAccept(accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            if (xTestnetType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("x-testnet-type", ClientUtils.ParameterToString(xTestnetType)); // header parameter
            }
            localVarRequestOptions.Data = approveErc20KMS;

            // authentication (X-API-Key) required
            if (!string.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("x-api-key")))
            {
                localVarRequestOptions.HeaderParameters.Add("x-api-key", Configuration.GetApiKeyWithPrefix("x-api-key"));
            }

            // make the HTTP request
            var localVarResponse = Client.Post<SignatureId>("/v3/blockchain/token/approve", localVarRequestOptions, Configuration);

            return localVarResponse;
        }

        /// <summary>
        /// Approve spending of fungible tokens 2 credits per API call Allow another blockchain address (the spender parameter in the request body) to spend and burn fungible tokens on behalf of the smart contract owner. This API is supported for the following blockchains: BNB Smart Chain Celo Ethereum Harmony Klaytn Polygon Signing a transaction When approving spending of fungible tokens, you are charged a fee for the transaction, and you must sign the transaction with the private key of the blockchain address from which the fee will be deducted. Providing the private key in the API is not a secure way of signing transactions, because the private key can be stolen or exposed. Your private keys should never leave your security perimeter. You should use the private keys only for testing a solution you are building on the testnet of a blockchain. For signing transactions on the mainnet, we strongly recommend that you use the Tatum Key Management System (KMS) and provide the signature ID instead of the private key in the API. Alternatively, you can use the Tatum JavaScript client.
        /// </summary>
        /// <exception cref="Tatum.CSharp.FungibleTokens.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="approveErc20KMS"></param>
        /// <param name="xTestnetType">Type of Ethereum testnet. Defaults to Sepolia. Valid only for ETH invocations for testnet API Key. For mainnet API Key, this value is ignored. (optional, default to ethereum-sepolia)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of SignatureId</returns>
        public async System.Threading.Tasks.Task<SignatureId> Erc20ApproveAsync(ApproveErc20KMS approveErc20KMS, string xTestnetType = default(string), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            var localVarResponse = await Erc20ApproveWithHttpInfoAsync(approveErc20KMS, xTestnetType, cancellationToken).ConfigureAwait(false);
            
            var exception = ExceptionFactory?.Invoke("Erc20Approve_0", localVarResponse);
            if (exception != null) throw exception;

            return localVarResponse.Data;
        }

        /// <summary>
        /// Approve spending of fungible tokens 2 credits per API call Allow another blockchain address (the spender parameter in the request body) to spend and burn fungible tokens on behalf of the smart contract owner. This API is supported for the following blockchains: BNB Smart Chain Celo Ethereum Harmony Klaytn Polygon Signing a transaction When approving spending of fungible tokens, you are charged a fee for the transaction, and you must sign the transaction with the private key of the blockchain address from which the fee will be deducted. Providing the private key in the API is not a secure way of signing transactions, because the private key can be stolen or exposed. Your private keys should never leave your security perimeter. You should use the private keys only for testing a solution you are building on the testnet of a blockchain. For signing transactions on the mainnet, we strongly recommend that you use the Tatum Key Management System (KMS) and provide the signature ID instead of the private key in the API. Alternatively, you can use the Tatum JavaScript client.
        /// </summary>
        /// <exception cref="Tatum.CSharp.FungibleTokens.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="approveErc20KMS"></param>
        /// <param name="xTestnetType">Type of Ethereum testnet. Defaults to Sepolia. Valid only for ETH invocations for testnet API Key. For mainnet API Key, this value is ignored. (optional, default to ethereum-sepolia)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (SignatureId)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<SignatureId>> Erc20ApproveWithHttpInfoAsync(ApproveErc20KMS approveErc20KMS, string xTestnetType = default(string), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            // verify the required parameter 'approveErc20KMS' is set
            if (approveErc20KMS == null)
                throw new ApiException(400, "Missing required parameter 'approveErc20KMS' when calling FungibleTokensEthApi->Erc20Approve_0");

            var localVarRequestOptions = new RequestOptions();

            var contentTypes = new string[]{
                "application/json"
            };

            // to determine the Accept header
            var accepts = new string[]{
                "application/json"
            };


            var localVarContentType = ClientUtils.SelectHeaderContentType(contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = ClientUtils.SelectHeaderAccept(accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            if (xTestnetType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("x-testnet-type", ClientUtils.ParameterToString(xTestnetType)); // header parameter
            }
            localVarRequestOptions.Data = approveErc20KMS;

            // authentication (X-API-Key) required
            if (!string.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("x-api-key")))
            {
                localVarRequestOptions.HeaderParameters.Add("x-api-key", Configuration.GetApiKeyWithPrefix("x-api-key"));
            }

            // make the HTTP request

            var localVarResponse = await AsynchronousClient.PostAsync<SignatureId>("/v3/blockchain/token/approve", localVarRequestOptions, Configuration, cancellationToken).ConfigureAwait(false);

            return localVarResponse;
        }

        /// <summary>
        /// Burn fungible tokens 2 credits per API call Burn fungible tokens. Burning fungible tokens deletes the specified supply of the tokens (the amount parameter in the request body) from the smart contract (the contractAddress parameter in the request body). This API is supported for the following blockchains: Algorand BNB Smart Chain Celo Ethereum Harmony Klaytn KuCoin Community Chain Polygon XinFin Signing a transaction When burning fungible tokens, you are charged a fee for the transaction, and you must sign the transaction with the private key of the blockchain address from which the fee will be deducted. Providing the private key in the API is not a secure way of signing transactions, because the private key can be stolen or exposed. Your private keys should never leave your security perimeter. You should use the private keys only for testing a solution you are building on the testnet of a blockchain. For signing transactions on the mainnet, we strongly recommend that you use the Tatum Key Management System (KMS) and provide the signature ID instead of the private key in the API. Alternatively, you can use the Tatum JavaScript client.
        /// </summary>
        /// <exception cref="Tatum.CSharp.FungibleTokens.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="chainBurnErc20"></param>
        /// <param name="xTestnetType">Type of Ethereum testnet. Defaults to Sepolia. Valid only for ETH invocations for testnet API Key. For mainnet API Key, this value is ignored. (optional, default to ethereum-sepolia)</param>
        /// <returns>TransactionHash</returns>
        public TransactionHash Erc20Burn(ChainBurnErc20 chainBurnErc20, string xTestnetType = default(string))
        {
            var localVarResponse = Erc20BurnWithHttpInfo(chainBurnErc20, xTestnetType);

            var exception = ExceptionFactory?.Invoke("Erc20Burn", localVarResponse);
            if (exception != null) throw exception;

            return localVarResponse.Data;
        }

        /// <summary>
        /// Burn fungible tokens 2 credits per API call Burn fungible tokens. Burning fungible tokens deletes the specified supply of the tokens (the amount parameter in the request body) from the smart contract (the contractAddress parameter in the request body). This API is supported for the following blockchains: Algorand BNB Smart Chain Celo Ethereum Harmony Klaytn KuCoin Community Chain Polygon XinFin Signing a transaction When burning fungible tokens, you are charged a fee for the transaction, and you must sign the transaction with the private key of the blockchain address from which the fee will be deducted. Providing the private key in the API is not a secure way of signing transactions, because the private key can be stolen or exposed. Your private keys should never leave your security perimeter. You should use the private keys only for testing a solution you are building on the testnet of a blockchain. For signing transactions on the mainnet, we strongly recommend that you use the Tatum Key Management System (KMS) and provide the signature ID instead of the private key in the API. Alternatively, you can use the Tatum JavaScript client.
        /// </summary>
        /// <exception cref="Tatum.CSharp.FungibleTokens.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="chainBurnErc20"></param>
        /// <param name="xTestnetType">Type of Ethereum testnet. Defaults to Sepolia. Valid only for ETH invocations for testnet API Key. For mainnet API Key, this value is ignored. (optional, default to ethereum-sepolia)</param>
        /// <returns>ApiResponse of TransactionHash</returns>
        public ApiResponse<TransactionHash> Erc20BurnWithHttpInfo(ChainBurnErc20 chainBurnErc20, string xTestnetType = default(string))
        {
            // verify the required parameter 'chainBurnErc20' is set
            if (chainBurnErc20 == null)
                throw new ApiException(400, "Missing required parameter 'chainBurnErc20' when calling FungibleTokensEthApi->Erc20Burn");

            var localVarRequestOptions = new RequestOptions();

            var contentTypes = new string[]{
                "application/json"
            };

            // to determine the Accept header
            var accepts = new string[]{
                "application/json"
            };

            var localVarContentType = ClientUtils.SelectHeaderContentType(contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = ClientUtils.SelectHeaderAccept(accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            if (xTestnetType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("x-testnet-type", ClientUtils.ParameterToString(xTestnetType)); // header parameter
            }
            localVarRequestOptions.Data = chainBurnErc20;

            // authentication (X-API-Key) required
            if (!string.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("x-api-key")))
            {
                localVarRequestOptions.HeaderParameters.Add("x-api-key", Configuration.GetApiKeyWithPrefix("x-api-key"));
            }

            // make the HTTP request
            var localVarResponse = Client.Post<TransactionHash>("/v3/blockchain/token/burn", localVarRequestOptions, Configuration);

            return localVarResponse;
        }

        /// <summary>
        /// Burn fungible tokens 2 credits per API call Burn fungible tokens. Burning fungible tokens deletes the specified supply of the tokens (the amount parameter in the request body) from the smart contract (the contractAddress parameter in the request body). This API is supported for the following blockchains: Algorand BNB Smart Chain Celo Ethereum Harmony Klaytn KuCoin Community Chain Polygon XinFin Signing a transaction When burning fungible tokens, you are charged a fee for the transaction, and you must sign the transaction with the private key of the blockchain address from which the fee will be deducted. Providing the private key in the API is not a secure way of signing transactions, because the private key can be stolen or exposed. Your private keys should never leave your security perimeter. You should use the private keys only for testing a solution you are building on the testnet of a blockchain. For signing transactions on the mainnet, we strongly recommend that you use the Tatum Key Management System (KMS) and provide the signature ID instead of the private key in the API. Alternatively, you can use the Tatum JavaScript client.
        /// </summary>
        /// <exception cref="Tatum.CSharp.FungibleTokens.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="chainBurnErc20"></param>
        /// <param name="xTestnetType">Type of Ethereum testnet. Defaults to Sepolia. Valid only for ETH invocations for testnet API Key. For mainnet API Key, this value is ignored. (optional, default to ethereum-sepolia)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of TransactionHash</returns>
        public async System.Threading.Tasks.Task<TransactionHash> Erc20BurnAsync(ChainBurnErc20 chainBurnErc20, string xTestnetType = default(string), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            var localVarResponse = await Erc20BurnWithHttpInfoAsync(chainBurnErc20, xTestnetType, cancellationToken).ConfigureAwait(false);
            
            var exception = ExceptionFactory?.Invoke("Erc20Burn", localVarResponse);
            if (exception != null) throw exception;

            return localVarResponse.Data;
        }

        /// <summary>
        /// Burn fungible tokens 2 credits per API call Burn fungible tokens. Burning fungible tokens deletes the specified supply of the tokens (the amount parameter in the request body) from the smart contract (the contractAddress parameter in the request body). This API is supported for the following blockchains: Algorand BNB Smart Chain Celo Ethereum Harmony Klaytn KuCoin Community Chain Polygon XinFin Signing a transaction When burning fungible tokens, you are charged a fee for the transaction, and you must sign the transaction with the private key of the blockchain address from which the fee will be deducted. Providing the private key in the API is not a secure way of signing transactions, because the private key can be stolen or exposed. Your private keys should never leave your security perimeter. You should use the private keys only for testing a solution you are building on the testnet of a blockchain. For signing transactions on the mainnet, we strongly recommend that you use the Tatum Key Management System (KMS) and provide the signature ID instead of the private key in the API. Alternatively, you can use the Tatum JavaScript client.
        /// </summary>
        /// <exception cref="Tatum.CSharp.FungibleTokens.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="chainBurnErc20"></param>
        /// <param name="xTestnetType">Type of Ethereum testnet. Defaults to Sepolia. Valid only for ETH invocations for testnet API Key. For mainnet API Key, this value is ignored. (optional, default to ethereum-sepolia)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (TransactionHash)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<TransactionHash>> Erc20BurnWithHttpInfoAsync(ChainBurnErc20 chainBurnErc20, string xTestnetType = default(string), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            // verify the required parameter 'chainBurnErc20' is set
            if (chainBurnErc20 == null)
                throw new ApiException(400, "Missing required parameter 'chainBurnErc20' when calling FungibleTokensEthApi->Erc20Burn");

            var localVarRequestOptions = new RequestOptions();

            var contentTypes = new string[]{
                "application/json"
            };

            // to determine the Accept header
            var accepts = new string[]{
                "application/json"
            };


            var localVarContentType = ClientUtils.SelectHeaderContentType(contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = ClientUtils.SelectHeaderAccept(accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            if (xTestnetType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("x-testnet-type", ClientUtils.ParameterToString(xTestnetType)); // header parameter
            }
            localVarRequestOptions.Data = chainBurnErc20;

            // authentication (X-API-Key) required
            if (!string.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("x-api-key")))
            {
                localVarRequestOptions.HeaderParameters.Add("x-api-key", Configuration.GetApiKeyWithPrefix("x-api-key"));
            }

            // make the HTTP request

            var localVarResponse = await AsynchronousClient.PostAsync<TransactionHash>("/v3/blockchain/token/burn", localVarRequestOptions, Configuration, cancellationToken).ConfigureAwait(false);

            return localVarResponse;
        }

        /// <summary>
        /// Burn fungible tokens 2 credits per API call Burn fungible tokens. Burning fungible tokens deletes the specified supply of the tokens (the amount parameter in the request body) from the smart contract (the contractAddress parameter in the request body). This API is supported for the following blockchains: Algorand BNB Smart Chain Celo Ethereum Harmony Klaytn KuCoin Community Chain Polygon XinFin Signing a transaction When burning fungible tokens, you are charged a fee for the transaction, and you must sign the transaction with the private key of the blockchain address from which the fee will be deducted. Providing the private key in the API is not a secure way of signing transactions, because the private key can be stolen or exposed. Your private keys should never leave your security perimeter. You should use the private keys only for testing a solution you are building on the testnet of a blockchain. For signing transactions on the mainnet, we strongly recommend that you use the Tatum Key Management System (KMS) and provide the signature ID instead of the private key in the API. Alternatively, you can use the Tatum JavaScript client.
        /// </summary>
        /// <exception cref="Tatum.CSharp.FungibleTokens.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="chainBurnErc20KMS"></param>
        /// <param name="xTestnetType">Type of Ethereum testnet. Defaults to Sepolia. Valid only for ETH invocations for testnet API Key. For mainnet API Key, this value is ignored. (optional, default to ethereum-sepolia)</param>
        /// <returns>SignatureId</returns>
        public SignatureId Erc20Burn(ChainBurnErc20KMS chainBurnErc20KMS, string xTestnetType = default(string))
        {
            var localVarResponse = Erc20BurnWithHttpInfo(chainBurnErc20KMS, xTestnetType);

            var exception = ExceptionFactory?.Invoke("Erc20Burn_0", localVarResponse);
            if (exception != null) throw exception;

            return localVarResponse.Data;
        }

        /// <summary>
        /// Burn fungible tokens 2 credits per API call Burn fungible tokens. Burning fungible tokens deletes the specified supply of the tokens (the amount parameter in the request body) from the smart contract (the contractAddress parameter in the request body). This API is supported for the following blockchains: Algorand BNB Smart Chain Celo Ethereum Harmony Klaytn KuCoin Community Chain Polygon XinFin Signing a transaction When burning fungible tokens, you are charged a fee for the transaction, and you must sign the transaction with the private key of the blockchain address from which the fee will be deducted. Providing the private key in the API is not a secure way of signing transactions, because the private key can be stolen or exposed. Your private keys should never leave your security perimeter. You should use the private keys only for testing a solution you are building on the testnet of a blockchain. For signing transactions on the mainnet, we strongly recommend that you use the Tatum Key Management System (KMS) and provide the signature ID instead of the private key in the API. Alternatively, you can use the Tatum JavaScript client.
        /// </summary>
        /// <exception cref="Tatum.CSharp.FungibleTokens.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="chainBurnErc20KMS"></param>
        /// <param name="xTestnetType">Type of Ethereum testnet. Defaults to Sepolia. Valid only for ETH invocations for testnet API Key. For mainnet API Key, this value is ignored. (optional, default to ethereum-sepolia)</param>
        /// <returns>ApiResponse of SignatureId</returns>
        public ApiResponse<SignatureId> Erc20BurnWithHttpInfo(ChainBurnErc20KMS chainBurnErc20KMS, string xTestnetType = default(string))
        {
            // verify the required parameter 'chainBurnErc20KMS' is set
            if (chainBurnErc20KMS == null)
                throw new ApiException(400, "Missing required parameter 'chainBurnErc20KMS' when calling FungibleTokensEthApi->Erc20Burn_0");

            var localVarRequestOptions = new RequestOptions();

            var contentTypes = new string[]{
                "application/json"
            };

            // to determine the Accept header
            var accepts = new string[]{
                "application/json"
            };

            var localVarContentType = ClientUtils.SelectHeaderContentType(contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = ClientUtils.SelectHeaderAccept(accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            if (xTestnetType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("x-testnet-type", ClientUtils.ParameterToString(xTestnetType)); // header parameter
            }
            localVarRequestOptions.Data = chainBurnErc20KMS;

            // authentication (X-API-Key) required
            if (!string.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("x-api-key")))
            {
                localVarRequestOptions.HeaderParameters.Add("x-api-key", Configuration.GetApiKeyWithPrefix("x-api-key"));
            }

            // make the HTTP request
            var localVarResponse = Client.Post<SignatureId>("/v3/blockchain/token/burn", localVarRequestOptions, Configuration);

            return localVarResponse;
        }

        /// <summary>
        /// Burn fungible tokens 2 credits per API call Burn fungible tokens. Burning fungible tokens deletes the specified supply of the tokens (the amount parameter in the request body) from the smart contract (the contractAddress parameter in the request body). This API is supported for the following blockchains: Algorand BNB Smart Chain Celo Ethereum Harmony Klaytn KuCoin Community Chain Polygon XinFin Signing a transaction When burning fungible tokens, you are charged a fee for the transaction, and you must sign the transaction with the private key of the blockchain address from which the fee will be deducted. Providing the private key in the API is not a secure way of signing transactions, because the private key can be stolen or exposed. Your private keys should never leave your security perimeter. You should use the private keys only for testing a solution you are building on the testnet of a blockchain. For signing transactions on the mainnet, we strongly recommend that you use the Tatum Key Management System (KMS) and provide the signature ID instead of the private key in the API. Alternatively, you can use the Tatum JavaScript client.
        /// </summary>
        /// <exception cref="Tatum.CSharp.FungibleTokens.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="chainBurnErc20KMS"></param>
        /// <param name="xTestnetType">Type of Ethereum testnet. Defaults to Sepolia. Valid only for ETH invocations for testnet API Key. For mainnet API Key, this value is ignored. (optional, default to ethereum-sepolia)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of SignatureId</returns>
        public async System.Threading.Tasks.Task<SignatureId> Erc20BurnAsync(ChainBurnErc20KMS chainBurnErc20KMS, string xTestnetType = default(string), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            var localVarResponse = await Erc20BurnWithHttpInfoAsync(chainBurnErc20KMS, xTestnetType, cancellationToken).ConfigureAwait(false);
            
            var exception = ExceptionFactory?.Invoke("Erc20Burn_0", localVarResponse);
            if (exception != null) throw exception;

            return localVarResponse.Data;
        }

        /// <summary>
        /// Burn fungible tokens 2 credits per API call Burn fungible tokens. Burning fungible tokens deletes the specified supply of the tokens (the amount parameter in the request body) from the smart contract (the contractAddress parameter in the request body). This API is supported for the following blockchains: Algorand BNB Smart Chain Celo Ethereum Harmony Klaytn KuCoin Community Chain Polygon XinFin Signing a transaction When burning fungible tokens, you are charged a fee for the transaction, and you must sign the transaction with the private key of the blockchain address from which the fee will be deducted. Providing the private key in the API is not a secure way of signing transactions, because the private key can be stolen or exposed. Your private keys should never leave your security perimeter. You should use the private keys only for testing a solution you are building on the testnet of a blockchain. For signing transactions on the mainnet, we strongly recommend that you use the Tatum Key Management System (KMS) and provide the signature ID instead of the private key in the API. Alternatively, you can use the Tatum JavaScript client.
        /// </summary>
        /// <exception cref="Tatum.CSharp.FungibleTokens.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="chainBurnErc20KMS"></param>
        /// <param name="xTestnetType">Type of Ethereum testnet. Defaults to Sepolia. Valid only for ETH invocations for testnet API Key. For mainnet API Key, this value is ignored. (optional, default to ethereum-sepolia)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (SignatureId)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<SignatureId>> Erc20BurnWithHttpInfoAsync(ChainBurnErc20KMS chainBurnErc20KMS, string xTestnetType = default(string), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            // verify the required parameter 'chainBurnErc20KMS' is set
            if (chainBurnErc20KMS == null)
                throw new ApiException(400, "Missing required parameter 'chainBurnErc20KMS' when calling FungibleTokensEthApi->Erc20Burn_0");

            var localVarRequestOptions = new RequestOptions();

            var contentTypes = new string[]{
                "application/json"
            };

            // to determine the Accept header
            var accepts = new string[]{
                "application/json"
            };


            var localVarContentType = ClientUtils.SelectHeaderContentType(contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = ClientUtils.SelectHeaderAccept(accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            if (xTestnetType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("x-testnet-type", ClientUtils.ParameterToString(xTestnetType)); // header parameter
            }
            localVarRequestOptions.Data = chainBurnErc20KMS;

            // authentication (X-API-Key) required
            if (!string.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("x-api-key")))
            {
                localVarRequestOptions.HeaderParameters.Add("x-api-key", Configuration.GetApiKeyWithPrefix("x-api-key"));
            }

            // make the HTTP request

            var localVarResponse = await AsynchronousClient.PostAsync<SignatureId>("/v3/blockchain/token/burn", localVarRequestOptions, Configuration, cancellationToken).ConfigureAwait(false);

            return localVarResponse;
        }

        /// <summary>
        /// Deploy a fungible token smart contract 2 credits per API call Deploy a fungible token smart contract on the blockchain. In a deployed smart contract, you can mint and burn fungible tokens. The whole supply of fungible tokens (the supply parameter in the request body) will be transferred to the specified blockchain address (the address parameter in the request body). Smart contracts are standardized and audited. This API is supported for the following blockchains: Algorand BNB Smart Chain Celo Ethereum Harmony Klaytn KuCoin Community Chain Polygon Solana XinFin You can review the code of a deployed smart contract here. Signing a transaction When deploying a fungible token smart contract, you are charged a fee for the transaction, and you must sign the transaction with the private key of the blockchain address from which the fee will be deducted. Providing the private key in the API is not a secure way of signing transactions, because the private key can be stolen or exposed. Your private keys should never leave your security perimeter. You should use the private keys only for testing a solution you are building on the testnet of a blockchain. For signing transactions on the mainnet, we strongly recommend that you use the Tatum Key Management System (KMS) and provide the signature ID instead of the private key in the API. Alternatively, you can use the Tatum JavaScript client.
        /// </summary>
        /// <exception cref="Tatum.CSharp.FungibleTokens.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="chainDeployErc20"></param>
        /// <param name="xTestnetType">Type of Ethereum testnet. Defaults to Sepolia. Valid only for ETH invocations for testnet API Key. For mainnet API Key, this value is ignored. (optional, default to ethereum-sepolia)</param>
        /// <returns>TransactionHash</returns>
        public TransactionHash Erc20Deploy(ChainDeployErc20 chainDeployErc20, string xTestnetType = default(string))
        {
            var localVarResponse = Erc20DeployWithHttpInfo(chainDeployErc20, xTestnetType);

            var exception = ExceptionFactory?.Invoke("Erc20Deploy", localVarResponse);
            if (exception != null) throw exception;

            return localVarResponse.Data;
        }

        /// <summary>
        /// Deploy a fungible token smart contract 2 credits per API call Deploy a fungible token smart contract on the blockchain. In a deployed smart contract, you can mint and burn fungible tokens. The whole supply of fungible tokens (the supply parameter in the request body) will be transferred to the specified blockchain address (the address parameter in the request body). Smart contracts are standardized and audited. This API is supported for the following blockchains: Algorand BNB Smart Chain Celo Ethereum Harmony Klaytn KuCoin Community Chain Polygon Solana XinFin You can review the code of a deployed smart contract here. Signing a transaction When deploying a fungible token smart contract, you are charged a fee for the transaction, and you must sign the transaction with the private key of the blockchain address from which the fee will be deducted. Providing the private key in the API is not a secure way of signing transactions, because the private key can be stolen or exposed. Your private keys should never leave your security perimeter. You should use the private keys only for testing a solution you are building on the testnet of a blockchain. For signing transactions on the mainnet, we strongly recommend that you use the Tatum Key Management System (KMS) and provide the signature ID instead of the private key in the API. Alternatively, you can use the Tatum JavaScript client.
        /// </summary>
        /// <exception cref="Tatum.CSharp.FungibleTokens.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="chainDeployErc20"></param>
        /// <param name="xTestnetType">Type of Ethereum testnet. Defaults to Sepolia. Valid only for ETH invocations for testnet API Key. For mainnet API Key, this value is ignored. (optional, default to ethereum-sepolia)</param>
        /// <returns>ApiResponse of TransactionHash</returns>
        public ApiResponse<TransactionHash> Erc20DeployWithHttpInfo(ChainDeployErc20 chainDeployErc20, string xTestnetType = default(string))
        {
            // verify the required parameter 'chainDeployErc20' is set
            if (chainDeployErc20 == null)
                throw new ApiException(400, "Missing required parameter 'chainDeployErc20' when calling FungibleTokensEthApi->Erc20Deploy");

            var localVarRequestOptions = new RequestOptions();

            var contentTypes = new string[]{
                "application/json"
            };

            // to determine the Accept header
            var accepts = new string[]{
                "application/json"
            };

            var localVarContentType = ClientUtils.SelectHeaderContentType(contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = ClientUtils.SelectHeaderAccept(accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            if (xTestnetType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("x-testnet-type", ClientUtils.ParameterToString(xTestnetType)); // header parameter
            }
            localVarRequestOptions.Data = chainDeployErc20;

            // authentication (X-API-Key) required
            if (!string.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("x-api-key")))
            {
                localVarRequestOptions.HeaderParameters.Add("x-api-key", Configuration.GetApiKeyWithPrefix("x-api-key"));
            }

            // make the HTTP request
            var localVarResponse = Client.Post<TransactionHash>("/v3/blockchain/token/deploy", localVarRequestOptions, Configuration);

            return localVarResponse;
        }

        /// <summary>
        /// Deploy a fungible token smart contract 2 credits per API call Deploy a fungible token smart contract on the blockchain. In a deployed smart contract, you can mint and burn fungible tokens. The whole supply of fungible tokens (the supply parameter in the request body) will be transferred to the specified blockchain address (the address parameter in the request body). Smart contracts are standardized and audited. This API is supported for the following blockchains: Algorand BNB Smart Chain Celo Ethereum Harmony Klaytn KuCoin Community Chain Polygon Solana XinFin You can review the code of a deployed smart contract here. Signing a transaction When deploying a fungible token smart contract, you are charged a fee for the transaction, and you must sign the transaction with the private key of the blockchain address from which the fee will be deducted. Providing the private key in the API is not a secure way of signing transactions, because the private key can be stolen or exposed. Your private keys should never leave your security perimeter. You should use the private keys only for testing a solution you are building on the testnet of a blockchain. For signing transactions on the mainnet, we strongly recommend that you use the Tatum Key Management System (KMS) and provide the signature ID instead of the private key in the API. Alternatively, you can use the Tatum JavaScript client.
        /// </summary>
        /// <exception cref="Tatum.CSharp.FungibleTokens.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="chainDeployErc20"></param>
        /// <param name="xTestnetType">Type of Ethereum testnet. Defaults to Sepolia. Valid only for ETH invocations for testnet API Key. For mainnet API Key, this value is ignored. (optional, default to ethereum-sepolia)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of TransactionHash</returns>
        public async System.Threading.Tasks.Task<TransactionHash> Erc20DeployAsync(ChainDeployErc20 chainDeployErc20, string xTestnetType = default(string), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            var localVarResponse = await Erc20DeployWithHttpInfoAsync(chainDeployErc20, xTestnetType, cancellationToken).ConfigureAwait(false);
            
            var exception = ExceptionFactory?.Invoke("Erc20Deploy", localVarResponse);
            if (exception != null) throw exception;

            return localVarResponse.Data;
        }

        /// <summary>
        /// Deploy a fungible token smart contract 2 credits per API call Deploy a fungible token smart contract on the blockchain. In a deployed smart contract, you can mint and burn fungible tokens. The whole supply of fungible tokens (the supply parameter in the request body) will be transferred to the specified blockchain address (the address parameter in the request body). Smart contracts are standardized and audited. This API is supported for the following blockchains: Algorand BNB Smart Chain Celo Ethereum Harmony Klaytn KuCoin Community Chain Polygon Solana XinFin You can review the code of a deployed smart contract here. Signing a transaction When deploying a fungible token smart contract, you are charged a fee for the transaction, and you must sign the transaction with the private key of the blockchain address from which the fee will be deducted. Providing the private key in the API is not a secure way of signing transactions, because the private key can be stolen or exposed. Your private keys should never leave your security perimeter. You should use the private keys only for testing a solution you are building on the testnet of a blockchain. For signing transactions on the mainnet, we strongly recommend that you use the Tatum Key Management System (KMS) and provide the signature ID instead of the private key in the API. Alternatively, you can use the Tatum JavaScript client.
        /// </summary>
        /// <exception cref="Tatum.CSharp.FungibleTokens.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="chainDeployErc20"></param>
        /// <param name="xTestnetType">Type of Ethereum testnet. Defaults to Sepolia. Valid only for ETH invocations for testnet API Key. For mainnet API Key, this value is ignored. (optional, default to ethereum-sepolia)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (TransactionHash)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<TransactionHash>> Erc20DeployWithHttpInfoAsync(ChainDeployErc20 chainDeployErc20, string xTestnetType = default(string), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            // verify the required parameter 'chainDeployErc20' is set
            if (chainDeployErc20 == null)
                throw new ApiException(400, "Missing required parameter 'chainDeployErc20' when calling FungibleTokensEthApi->Erc20Deploy");

            var localVarRequestOptions = new RequestOptions();

            var contentTypes = new string[]{
                "application/json"
            };

            // to determine the Accept header
            var accepts = new string[]{
                "application/json"
            };


            var localVarContentType = ClientUtils.SelectHeaderContentType(contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = ClientUtils.SelectHeaderAccept(accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            if (xTestnetType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("x-testnet-type", ClientUtils.ParameterToString(xTestnetType)); // header parameter
            }
            localVarRequestOptions.Data = chainDeployErc20;

            // authentication (X-API-Key) required
            if (!string.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("x-api-key")))
            {
                localVarRequestOptions.HeaderParameters.Add("x-api-key", Configuration.GetApiKeyWithPrefix("x-api-key"));
            }

            // make the HTTP request

            var localVarResponse = await AsynchronousClient.PostAsync<TransactionHash>("/v3/blockchain/token/deploy", localVarRequestOptions, Configuration, cancellationToken).ConfigureAwait(false);

            return localVarResponse;
        }

        /// <summary>
        /// Deploy a fungible token smart contract 2 credits per API call Deploy a fungible token smart contract on the blockchain. In a deployed smart contract, you can mint and burn fungible tokens. The whole supply of fungible tokens (the supply parameter in the request body) will be transferred to the specified blockchain address (the address parameter in the request body). Smart contracts are standardized and audited. This API is supported for the following blockchains: Algorand BNB Smart Chain Celo Ethereum Harmony Klaytn KuCoin Community Chain Polygon Solana XinFin You can review the code of a deployed smart contract here. Signing a transaction When deploying a fungible token smart contract, you are charged a fee for the transaction, and you must sign the transaction with the private key of the blockchain address from which the fee will be deducted. Providing the private key in the API is not a secure way of signing transactions, because the private key can be stolen or exposed. Your private keys should never leave your security perimeter. You should use the private keys only for testing a solution you are building on the testnet of a blockchain. For signing transactions on the mainnet, we strongly recommend that you use the Tatum Key Management System (KMS) and provide the signature ID instead of the private key in the API. Alternatively, you can use the Tatum JavaScript client.
        /// </summary>
        /// <exception cref="Tatum.CSharp.FungibleTokens.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="chainDeployErc20KMS"></param>
        /// <param name="xTestnetType">Type of Ethereum testnet. Defaults to Sepolia. Valid only for ETH invocations for testnet API Key. For mainnet API Key, this value is ignored. (optional, default to ethereum-sepolia)</param>
        /// <returns>SignatureId</returns>
        public SignatureId Erc20Deploy(ChainDeployErc20KMS chainDeployErc20KMS, string xTestnetType = default(string))
        {
            var localVarResponse = Erc20DeployWithHttpInfo(chainDeployErc20KMS, xTestnetType);

            var exception = ExceptionFactory?.Invoke("Erc20Deploy_0", localVarResponse);
            if (exception != null) throw exception;

            return localVarResponse.Data;
        }

        /// <summary>
        /// Deploy a fungible token smart contract 2 credits per API call Deploy a fungible token smart contract on the blockchain. In a deployed smart contract, you can mint and burn fungible tokens. The whole supply of fungible tokens (the supply parameter in the request body) will be transferred to the specified blockchain address (the address parameter in the request body). Smart contracts are standardized and audited. This API is supported for the following blockchains: Algorand BNB Smart Chain Celo Ethereum Harmony Klaytn KuCoin Community Chain Polygon Solana XinFin You can review the code of a deployed smart contract here. Signing a transaction When deploying a fungible token smart contract, you are charged a fee for the transaction, and you must sign the transaction with the private key of the blockchain address from which the fee will be deducted. Providing the private key in the API is not a secure way of signing transactions, because the private key can be stolen or exposed. Your private keys should never leave your security perimeter. You should use the private keys only for testing a solution you are building on the testnet of a blockchain. For signing transactions on the mainnet, we strongly recommend that you use the Tatum Key Management System (KMS) and provide the signature ID instead of the private key in the API. Alternatively, you can use the Tatum JavaScript client.
        /// </summary>
        /// <exception cref="Tatum.CSharp.FungibleTokens.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="chainDeployErc20KMS"></param>
        /// <param name="xTestnetType">Type of Ethereum testnet. Defaults to Sepolia. Valid only for ETH invocations for testnet API Key. For mainnet API Key, this value is ignored. (optional, default to ethereum-sepolia)</param>
        /// <returns>ApiResponse of SignatureId</returns>
        public ApiResponse<SignatureId> Erc20DeployWithHttpInfo(ChainDeployErc20KMS chainDeployErc20KMS, string xTestnetType = default(string))
        {
            // verify the required parameter 'chainDeployErc20KMS' is set
            if (chainDeployErc20KMS == null)
                throw new ApiException(400, "Missing required parameter 'chainDeployErc20KMS' when calling FungibleTokensEthApi->Erc20Deploy_0");

            var localVarRequestOptions = new RequestOptions();

            var contentTypes = new string[]{
                "application/json"
            };

            // to determine the Accept header
            var accepts = new string[]{
                "application/json"
            };

            var localVarContentType = ClientUtils.SelectHeaderContentType(contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = ClientUtils.SelectHeaderAccept(accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            if (xTestnetType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("x-testnet-type", ClientUtils.ParameterToString(xTestnetType)); // header parameter
            }
            localVarRequestOptions.Data = chainDeployErc20KMS;

            // authentication (X-API-Key) required
            if (!string.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("x-api-key")))
            {
                localVarRequestOptions.HeaderParameters.Add("x-api-key", Configuration.GetApiKeyWithPrefix("x-api-key"));
            }

            // make the HTTP request
            var localVarResponse = Client.Post<SignatureId>("/v3/blockchain/token/deploy", localVarRequestOptions, Configuration);

            return localVarResponse;
        }

        /// <summary>
        /// Deploy a fungible token smart contract 2 credits per API call Deploy a fungible token smart contract on the blockchain. In a deployed smart contract, you can mint and burn fungible tokens. The whole supply of fungible tokens (the supply parameter in the request body) will be transferred to the specified blockchain address (the address parameter in the request body). Smart contracts are standardized and audited. This API is supported for the following blockchains: Algorand BNB Smart Chain Celo Ethereum Harmony Klaytn KuCoin Community Chain Polygon Solana XinFin You can review the code of a deployed smart contract here. Signing a transaction When deploying a fungible token smart contract, you are charged a fee for the transaction, and you must sign the transaction with the private key of the blockchain address from which the fee will be deducted. Providing the private key in the API is not a secure way of signing transactions, because the private key can be stolen or exposed. Your private keys should never leave your security perimeter. You should use the private keys only for testing a solution you are building on the testnet of a blockchain. For signing transactions on the mainnet, we strongly recommend that you use the Tatum Key Management System (KMS) and provide the signature ID instead of the private key in the API. Alternatively, you can use the Tatum JavaScript client.
        /// </summary>
        /// <exception cref="Tatum.CSharp.FungibleTokens.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="chainDeployErc20KMS"></param>
        /// <param name="xTestnetType">Type of Ethereum testnet. Defaults to Sepolia. Valid only for ETH invocations for testnet API Key. For mainnet API Key, this value is ignored. (optional, default to ethereum-sepolia)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of SignatureId</returns>
        public async System.Threading.Tasks.Task<SignatureId> Erc20DeployAsync(ChainDeployErc20KMS chainDeployErc20KMS, string xTestnetType = default(string), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            var localVarResponse = await Erc20DeployWithHttpInfoAsync(chainDeployErc20KMS, xTestnetType, cancellationToken).ConfigureAwait(false);
            
            var exception = ExceptionFactory?.Invoke("Erc20Deploy_0", localVarResponse);
            if (exception != null) throw exception;

            return localVarResponse.Data;
        }

        /// <summary>
        /// Deploy a fungible token smart contract 2 credits per API call Deploy a fungible token smart contract on the blockchain. In a deployed smart contract, you can mint and burn fungible tokens. The whole supply of fungible tokens (the supply parameter in the request body) will be transferred to the specified blockchain address (the address parameter in the request body). Smart contracts are standardized and audited. This API is supported for the following blockchains: Algorand BNB Smart Chain Celo Ethereum Harmony Klaytn KuCoin Community Chain Polygon Solana XinFin You can review the code of a deployed smart contract here. Signing a transaction When deploying a fungible token smart contract, you are charged a fee for the transaction, and you must sign the transaction with the private key of the blockchain address from which the fee will be deducted. Providing the private key in the API is not a secure way of signing transactions, because the private key can be stolen or exposed. Your private keys should never leave your security perimeter. You should use the private keys only for testing a solution you are building on the testnet of a blockchain. For signing transactions on the mainnet, we strongly recommend that you use the Tatum Key Management System (KMS) and provide the signature ID instead of the private key in the API. Alternatively, you can use the Tatum JavaScript client.
        /// </summary>
        /// <exception cref="Tatum.CSharp.FungibleTokens.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="chainDeployErc20KMS"></param>
        /// <param name="xTestnetType">Type of Ethereum testnet. Defaults to Sepolia. Valid only for ETH invocations for testnet API Key. For mainnet API Key, this value is ignored. (optional, default to ethereum-sepolia)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (SignatureId)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<SignatureId>> Erc20DeployWithHttpInfoAsync(ChainDeployErc20KMS chainDeployErc20KMS, string xTestnetType = default(string), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            // verify the required parameter 'chainDeployErc20KMS' is set
            if (chainDeployErc20KMS == null)
                throw new ApiException(400, "Missing required parameter 'chainDeployErc20KMS' when calling FungibleTokensEthApi->Erc20Deploy_0");

            var localVarRequestOptions = new RequestOptions();

            var contentTypes = new string[]{
                "application/json"
            };

            // to determine the Accept header
            var accepts = new string[]{
                "application/json"
            };


            var localVarContentType = ClientUtils.SelectHeaderContentType(contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = ClientUtils.SelectHeaderAccept(accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            if (xTestnetType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("x-testnet-type", ClientUtils.ParameterToString(xTestnetType)); // header parameter
            }
            localVarRequestOptions.Data = chainDeployErc20KMS;

            // authentication (X-API-Key) required
            if (!string.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("x-api-key")))
            {
                localVarRequestOptions.HeaderParameters.Add("x-api-key", Configuration.GetApiKeyWithPrefix("x-api-key"));
            }

            // make the HTTP request

            var localVarResponse = await AsynchronousClient.PostAsync<SignatureId>("/v3/blockchain/token/deploy", localVarRequestOptions, Configuration, cancellationToken).ConfigureAwait(false);

            return localVarResponse;
        }

        /// <summary>
        /// Get the number of fungible tokens from a specific smart contract that a blockchain address holds 1 credit per API call Get the number of the fungible tokens minted on a specific smart contract (the contractAddress path parameter in the request endpoint URL) that a blockchain address holds. This API is supported for the following blockchains: Algorand BNB Smart Chain Celo Elrond Ethereum Harmony Klaytn KuCoin Community Chain Polygon Solana XinFin
        /// </summary>
        /// <exception cref="Tatum.CSharp.FungibleTokens.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="address">The blockchain address that you want to get the token balance of</param>
        /// <param name="contractAddress">The address of the fungible token smart contract</param>
        /// <param name="xTestnetType">Type of Ethereum testnet. Defaults to Sepolia. Valid only for ETH invocations for testnet API Key. For mainnet API Key, this value is ignored. (optional, default to ethereum-sepolia)</param>
        /// <returns>Erc20Balance</returns>
        public Erc20Balance Erc20GetBalance(string address, string contractAddress, string xTestnetType = default(string))
        {
            var localVarResponse = Erc20GetBalanceWithHttpInfo(address, contractAddress, xTestnetType);

            var exception = ExceptionFactory?.Invoke("Erc20GetBalance", localVarResponse);
            if (exception != null) throw exception;

            return localVarResponse.Data;
        }

        /// <summary>
        /// Get the number of fungible tokens from a specific smart contract that a blockchain address holds 1 credit per API call Get the number of the fungible tokens minted on a specific smart contract (the contractAddress path parameter in the request endpoint URL) that a blockchain address holds. This API is supported for the following blockchains: Algorand BNB Smart Chain Celo Elrond Ethereum Harmony Klaytn KuCoin Community Chain Polygon Solana XinFin
        /// </summary>
        /// <exception cref="Tatum.CSharp.FungibleTokens.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="address">The blockchain address that you want to get the token balance of</param>
        /// <param name="contractAddress">The address of the fungible token smart contract</param>
        /// <param name="xTestnetType">Type of Ethereum testnet. Defaults to Sepolia. Valid only for ETH invocations for testnet API Key. For mainnet API Key, this value is ignored. (optional, default to ethereum-sepolia)</param>
        /// <returns>ApiResponse of Erc20Balance</returns>
        public ApiResponse<Erc20Balance> Erc20GetBalanceWithHttpInfo(string address, string contractAddress, string xTestnetType = default(string))
        {
            // verify the required parameter 'address' is set
            if (address == null)
                throw new ApiException(400, "Missing required parameter 'address' when calling FungibleTokensEthApi->Erc20GetBalance");

            // verify the required parameter 'contractAddress' is set
            if (contractAddress == null)
                throw new ApiException(400, "Missing required parameter 'contractAddress' when calling FungibleTokensEthApi->Erc20GetBalance");

            var localVarRequestOptions = new RequestOptions();

            var contentTypes = new string[]{
            };

            // to determine the Accept header
            var accepts = new string[]{
                "application/json"
            };

            var localVarContentType = ClientUtils.SelectHeaderContentType(contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = ClientUtils.SelectHeaderAccept(accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.PathParameters.Add("address", ClientUtils.ParameterToString(address)); // path parameter
            localVarRequestOptions.PathParameters.Add("contractAddress", ClientUtils.ParameterToString(contractAddress)); // path parameter
            if (xTestnetType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("x-testnet-type", ClientUtils.ParameterToString(xTestnetType)); // header parameter
            }

            // authentication (X-API-Key) required
            if (!string.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("x-api-key")))
            {
                localVarRequestOptions.HeaderParameters.Add("x-api-key", Configuration.GetApiKeyWithPrefix("x-api-key"));
            }

            // make the HTTP request
            var localVarResponse = Client.Get<Erc20Balance>("/v3/blockchain/token/balance/ETH/{contractAddress}/{address}", localVarRequestOptions, Configuration);

            return localVarResponse;
        }

        /// <summary>
        /// Get the number of fungible tokens from a specific smart contract that a blockchain address holds 1 credit per API call Get the number of the fungible tokens minted on a specific smart contract (the contractAddress path parameter in the request endpoint URL) that a blockchain address holds. This API is supported for the following blockchains: Algorand BNB Smart Chain Celo Elrond Ethereum Harmony Klaytn KuCoin Community Chain Polygon Solana XinFin
        /// </summary>
        /// <exception cref="Tatum.CSharp.FungibleTokens.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="address">The blockchain address that you want to get the token balance of</param>
        /// <param name="contractAddress">The address of the fungible token smart contract</param>
        /// <param name="xTestnetType">Type of Ethereum testnet. Defaults to Sepolia. Valid only for ETH invocations for testnet API Key. For mainnet API Key, this value is ignored. (optional, default to ethereum-sepolia)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of Erc20Balance</returns>
        public async System.Threading.Tasks.Task<Erc20Balance> Erc20GetBalanceAsync(string address, string contractAddress, string xTestnetType = default(string), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            var localVarResponse = await Erc20GetBalanceWithHttpInfoAsync(address, contractAddress, xTestnetType, cancellationToken).ConfigureAwait(false);
            
            var exception = ExceptionFactory?.Invoke("Erc20GetBalance", localVarResponse);
            if (exception != null) throw exception;

            return localVarResponse.Data;
        }

        /// <summary>
        /// Get the number of fungible tokens from a specific smart contract that a blockchain address holds 1 credit per API call Get the number of the fungible tokens minted on a specific smart contract (the contractAddress path parameter in the request endpoint URL) that a blockchain address holds. This API is supported for the following blockchains: Algorand BNB Smart Chain Celo Elrond Ethereum Harmony Klaytn KuCoin Community Chain Polygon Solana XinFin
        /// </summary>
        /// <exception cref="Tatum.CSharp.FungibleTokens.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="address">The blockchain address that you want to get the token balance of</param>
        /// <param name="contractAddress">The address of the fungible token smart contract</param>
        /// <param name="xTestnetType">Type of Ethereum testnet. Defaults to Sepolia. Valid only for ETH invocations for testnet API Key. For mainnet API Key, this value is ignored. (optional, default to ethereum-sepolia)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (Erc20Balance)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<Erc20Balance>> Erc20GetBalanceWithHttpInfoAsync(string address, string contractAddress, string xTestnetType = default(string), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            // verify the required parameter 'address' is set
            if (address == null)
                throw new ApiException(400, "Missing required parameter 'address' when calling FungibleTokensEthApi->Erc20GetBalance");

            // verify the required parameter 'contractAddress' is set
            if (contractAddress == null)
                throw new ApiException(400, "Missing required parameter 'contractAddress' when calling FungibleTokensEthApi->Erc20GetBalance");

            var localVarRequestOptions = new RequestOptions();

            var contentTypes = new string[]{
            };

            // to determine the Accept header
            var accepts = new string[]{
                "application/json"
            };


            var localVarContentType = ClientUtils.SelectHeaderContentType(contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = ClientUtils.SelectHeaderAccept(accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.PathParameters.Add("address", ClientUtils.ParameterToString(address)); // path parameter
            localVarRequestOptions.PathParameters.Add("contractAddress", ClientUtils.ParameterToString(contractAddress)); // path parameter
            if (xTestnetType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("x-testnet-type", ClientUtils.ParameterToString(xTestnetType)); // header parameter
            }

            // authentication (X-API-Key) required
            if (!string.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("x-api-key")))
            {
                localVarRequestOptions.HeaderParameters.Add("x-api-key", Configuration.GetApiKeyWithPrefix("x-api-key"));
            }

            // make the HTTP request

            var localVarResponse = await AsynchronousClient.GetAsync<Erc20Balance>("/v3/blockchain/token/balance/ETH/{contractAddress}/{address}", localVarRequestOptions, Configuration, cancellationToken).ConfigureAwait(false);

            return localVarResponse;
        }

        /// <summary>
        /// Get the number of fungible tokens that a blockchain address holds across a blockchain 1 credit per API call Get the number of fungible tokens that a blockchain address holds across a blockchain. The tokens are returned grouped by the smart contracts they were minted on. This API is supported for the following blockchains: Algorand Celo Ethereum Polygon Solana
        /// </summary>
        /// <exception cref="Tatum.CSharp.FungibleTokens.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="address">The blockchain address that you want to get the token balance of</param>
        /// <returns>List&lt;Erc20BalanceForAddress&gt;</returns>
        public List<Erc20BalanceForAddress> Erc20GetBalanceAddress(string address)
        {
            var localVarResponse = Erc20GetBalanceAddressWithHttpInfo(address);

            var exception = ExceptionFactory?.Invoke("Erc20GetBalanceAddress", localVarResponse);
            if (exception != null) throw exception;

            return localVarResponse.Data;
        }

        /// <summary>
        /// Get the number of fungible tokens that a blockchain address holds across a blockchain 1 credit per API call Get the number of fungible tokens that a blockchain address holds across a blockchain. The tokens are returned grouped by the smart contracts they were minted on. This API is supported for the following blockchains: Algorand Celo Ethereum Polygon Solana
        /// </summary>
        /// <exception cref="Tatum.CSharp.FungibleTokens.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="address">The blockchain address that you want to get the token balance of</param>
        /// <returns>ApiResponse of List&lt;Erc20BalanceForAddress&gt;</returns>
        public ApiResponse<List<Erc20BalanceForAddress>> Erc20GetBalanceAddressWithHttpInfo(string address)
        {
            // verify the required parameter 'address' is set
            if (address == null)
                throw new ApiException(400, "Missing required parameter 'address' when calling FungibleTokensEthApi->Erc20GetBalanceAddress");

            var localVarRequestOptions = new RequestOptions();

            var contentTypes = new string[]{
            };

            // to determine the Accept header
            var accepts = new string[]{
                "application/json"
            };

            var localVarContentType = ClientUtils.SelectHeaderContentType(contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = ClientUtils.SelectHeaderAccept(accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.PathParameters.Add("address", ClientUtils.ParameterToString(address)); // path parameter

            // authentication (X-API-Key) required
            if (!string.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("x-api-key")))
            {
                localVarRequestOptions.HeaderParameters.Add("x-api-key", Configuration.GetApiKeyWithPrefix("x-api-key"));
            }

            // make the HTTP request
            var localVarResponse = Client.Get<List<Erc20BalanceForAddress>>("/v3/blockchain/token/address/ETH/{address}", localVarRequestOptions, Configuration);

            return localVarResponse;
        }

        /// <summary>
        /// Get the number of fungible tokens that a blockchain address holds across a blockchain 1 credit per API call Get the number of fungible tokens that a blockchain address holds across a blockchain. The tokens are returned grouped by the smart contracts they were minted on. This API is supported for the following blockchains: Algorand Celo Ethereum Polygon Solana
        /// </summary>
        /// <exception cref="Tatum.CSharp.FungibleTokens.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="address">The blockchain address that you want to get the token balance of</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of List&lt;Erc20BalanceForAddress&gt;</returns>
        public async System.Threading.Tasks.Task<List<Erc20BalanceForAddress>> Erc20GetBalanceAddressAsync(string address, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            var localVarResponse = await Erc20GetBalanceAddressWithHttpInfoAsync(address, cancellationToken).ConfigureAwait(false);
            
            var exception = ExceptionFactory?.Invoke("Erc20GetBalanceAddress", localVarResponse);
            if (exception != null) throw exception;

            return localVarResponse.Data;
        }

        /// <summary>
        /// Get the number of fungible tokens that a blockchain address holds across a blockchain 1 credit per API call Get the number of fungible tokens that a blockchain address holds across a blockchain. The tokens are returned grouped by the smart contracts they were minted on. This API is supported for the following blockchains: Algorand Celo Ethereum Polygon Solana
        /// </summary>
        /// <exception cref="Tatum.CSharp.FungibleTokens.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="address">The blockchain address that you want to get the token balance of</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (List&lt;Erc20BalanceForAddress&gt;)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<List<Erc20BalanceForAddress>>> Erc20GetBalanceAddressWithHttpInfoAsync(string address, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            // verify the required parameter 'address' is set
            if (address == null)
                throw new ApiException(400, "Missing required parameter 'address' when calling FungibleTokensEthApi->Erc20GetBalanceAddress");

            var localVarRequestOptions = new RequestOptions();

            var contentTypes = new string[]{
            };

            // to determine the Accept header
            var accepts = new string[]{
                "application/json"
            };


            var localVarContentType = ClientUtils.SelectHeaderContentType(contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = ClientUtils.SelectHeaderAccept(accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.PathParameters.Add("address", ClientUtils.ParameterToString(address)); // path parameter

            // authentication (X-API-Key) required
            if (!string.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("x-api-key")))
            {
                localVarRequestOptions.HeaderParameters.Add("x-api-key", Configuration.GetApiKeyWithPrefix("x-api-key"));
            }

            // make the HTTP request

            var localVarResponse = await AsynchronousClient.GetAsync<List<Erc20BalanceForAddress>>("/v3/blockchain/token/address/ETH/{address}", localVarRequestOptions, Configuration, cancellationToken).ConfigureAwait(false);

            return localVarResponse;
        }

        /// <summary>
        /// Get fungible token transactions on a blockchain address 1 credit per API call Get incoming and outgoing transactions related to fungible tokens on a blockchain address. This API is supported for the following blockchains: Algorand Celo Ethereum Polygon
        /// </summary>
        /// <exception cref="Tatum.CSharp.FungibleTokens.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="address">Account address you want to get balance of</param>
        /// <param name="tokenAddress">Address of the token smart contract</param>
        /// <param name="pageSize">Max number of items per page is 50.</param>
        /// <param name="offset">Offset to obtain next page of the data. (optional)</param>
        /// <param name="from">Transactions from this block onwards will be included. (optional)</param>
        /// <param name="to">Transactions up to this block will be included. (optional)</param>
        /// <param name="sort">Sorting of the data. ASC - oldest first, DESC - newest first. (optional, default to DESC)</param>
        /// <returns>List&lt;FungibleTx&gt;</returns>
        public List<FungibleTx> Erc20GetTransactionByAddress(string address, string tokenAddress, decimal pageSize, decimal? offset = default(decimal?), decimal? from = default(decimal?), decimal? to = default(decimal?), string sort = default(string))
        {
            var localVarResponse = Erc20GetTransactionByAddressWithHttpInfo(address, tokenAddress, pageSize, offset, from, to, sort);

            var exception = ExceptionFactory?.Invoke("Erc20GetTransactionByAddress", localVarResponse);
            if (exception != null) throw exception;

            return localVarResponse.Data;
        }

        /// <summary>
        /// Get fungible token transactions on a blockchain address 1 credit per API call Get incoming and outgoing transactions related to fungible tokens on a blockchain address. This API is supported for the following blockchains: Algorand Celo Ethereum Polygon
        /// </summary>
        /// <exception cref="Tatum.CSharp.FungibleTokens.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="address">Account address you want to get balance of</param>
        /// <param name="tokenAddress">Address of the token smart contract</param>
        /// <param name="pageSize">Max number of items per page is 50.</param>
        /// <param name="offset">Offset to obtain next page of the data. (optional)</param>
        /// <param name="from">Transactions from this block onwards will be included. (optional)</param>
        /// <param name="to">Transactions up to this block will be included. (optional)</param>
        /// <param name="sort">Sorting of the data. ASC - oldest first, DESC - newest first. (optional, default to DESC)</param>
        /// <returns>ApiResponse of List&lt;FungibleTx&gt;</returns>
        public ApiResponse<List<FungibleTx>> Erc20GetTransactionByAddressWithHttpInfo(string address, string tokenAddress, decimal pageSize, decimal? offset = default(decimal?), decimal? from = default(decimal?), decimal? to = default(decimal?), string sort = default(string))
        {
            // verify the required parameter 'address' is set
            if (address == null)
                throw new ApiException(400, "Missing required parameter 'address' when calling FungibleTokensEthApi->Erc20GetTransactionByAddress");

            // verify the required parameter 'tokenAddress' is set
            if (tokenAddress == null)
                throw new ApiException(400, "Missing required parameter 'tokenAddress' when calling FungibleTokensEthApi->Erc20GetTransactionByAddress");

            var localVarRequestOptions = new RequestOptions();

            var contentTypes = new string[]{
            };

            // to determine the Accept header
            var accepts = new string[]{
                "application/json"
            };

            var localVarContentType = ClientUtils.SelectHeaderContentType(contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = ClientUtils.SelectHeaderAccept(accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.PathParameters.Add("address", ClientUtils.ParameterToString(address)); // path parameter
            localVarRequestOptions.PathParameters.Add("tokenAddress", ClientUtils.ParameterToString(tokenAddress)); // path parameter
            localVarRequestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "pageSize", pageSize));
            if (offset != null)
            {
                localVarRequestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "offset", offset));
            }
            if (from != null)
            {
                localVarRequestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "from", from));
            }
            if (to != null)
            {
                localVarRequestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "to", to));
            }
            if (sort != null)
            {
                localVarRequestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "sort", sort));
            }

            // authentication (X-API-Key) required
            if (!string.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("x-api-key")))
            {
                localVarRequestOptions.HeaderParameters.Add("x-api-key", Configuration.GetApiKeyWithPrefix("x-api-key"));
            }

            // make the HTTP request
            var localVarResponse = Client.Get<List<FungibleTx>>("/v3/blockchain/token/transaction/ETH/{address}/{tokenAddress}", localVarRequestOptions, Configuration);

            return localVarResponse;
        }

        /// <summary>
        /// Get fungible token transactions on a blockchain address 1 credit per API call Get incoming and outgoing transactions related to fungible tokens on a blockchain address. This API is supported for the following blockchains: Algorand Celo Ethereum Polygon
        /// </summary>
        /// <exception cref="Tatum.CSharp.FungibleTokens.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="address">Account address you want to get balance of</param>
        /// <param name="tokenAddress">Address of the token smart contract</param>
        /// <param name="pageSize">Max number of items per page is 50.</param>
        /// <param name="offset">Offset to obtain next page of the data. (optional)</param>
        /// <param name="from">Transactions from this block onwards will be included. (optional)</param>
        /// <param name="to">Transactions up to this block will be included. (optional)</param>
        /// <param name="sort">Sorting of the data. ASC - oldest first, DESC - newest first. (optional, default to DESC)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of List&lt;FungibleTx&gt;</returns>
        public async System.Threading.Tasks.Task<List<FungibleTx>> Erc20GetTransactionByAddressAsync(string address, string tokenAddress, decimal pageSize, decimal? offset = default(decimal?), decimal? from = default(decimal?), decimal? to = default(decimal?), string sort = default(string), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            var localVarResponse = await Erc20GetTransactionByAddressWithHttpInfoAsync(address, tokenAddress, pageSize, offset, from, to, sort, cancellationToken).ConfigureAwait(false);
            
            var exception = ExceptionFactory?.Invoke("Erc20GetTransactionByAddress", localVarResponse);
            if (exception != null) throw exception;

            return localVarResponse.Data;
        }

        /// <summary>
        /// Get fungible token transactions on a blockchain address 1 credit per API call Get incoming and outgoing transactions related to fungible tokens on a blockchain address. This API is supported for the following blockchains: Algorand Celo Ethereum Polygon
        /// </summary>
        /// <exception cref="Tatum.CSharp.FungibleTokens.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="address">Account address you want to get balance of</param>
        /// <param name="tokenAddress">Address of the token smart contract</param>
        /// <param name="pageSize">Max number of items per page is 50.</param>
        /// <param name="offset">Offset to obtain next page of the data. (optional)</param>
        /// <param name="from">Transactions from this block onwards will be included. (optional)</param>
        /// <param name="to">Transactions up to this block will be included. (optional)</param>
        /// <param name="sort">Sorting of the data. ASC - oldest first, DESC - newest first. (optional, default to DESC)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (List&lt;FungibleTx&gt;)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<List<FungibleTx>>> Erc20GetTransactionByAddressWithHttpInfoAsync(string address, string tokenAddress, decimal pageSize, decimal? offset = default(decimal?), decimal? from = default(decimal?), decimal? to = default(decimal?), string sort = default(string), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            // verify the required parameter 'address' is set
            if (address == null)
                throw new ApiException(400, "Missing required parameter 'address' when calling FungibleTokensEthApi->Erc20GetTransactionByAddress");

            // verify the required parameter 'tokenAddress' is set
            if (tokenAddress == null)
                throw new ApiException(400, "Missing required parameter 'tokenAddress' when calling FungibleTokensEthApi->Erc20GetTransactionByAddress");

            var localVarRequestOptions = new RequestOptions();

            var contentTypes = new string[]{
            };

            // to determine the Accept header
            var accepts = new string[]{
                "application/json"
            };


            var localVarContentType = ClientUtils.SelectHeaderContentType(contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = ClientUtils.SelectHeaderAccept(accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.PathParameters.Add("address", ClientUtils.ParameterToString(address)); // path parameter
            localVarRequestOptions.PathParameters.Add("tokenAddress", ClientUtils.ParameterToString(tokenAddress)); // path parameter
            localVarRequestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "pageSize", pageSize));
            if (offset != null)
            {
                localVarRequestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "offset", offset));
            }
            if (from != null)
            {
                localVarRequestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "from", from));
            }
            if (to != null)
            {
                localVarRequestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "to", to));
            }
            if (sort != null)
            {
                localVarRequestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "sort", sort));
            }

            // authentication (X-API-Key) required
            if (!string.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("x-api-key")))
            {
                localVarRequestOptions.HeaderParameters.Add("x-api-key", Configuration.GetApiKeyWithPrefix("x-api-key"));
            }

            // make the HTTP request

            var localVarResponse = await AsynchronousClient.GetAsync<List<FungibleTx>>("/v3/blockchain/token/transaction/ETH/{address}/{tokenAddress}", localVarRequestOptions, Configuration, cancellationToken).ConfigureAwait(false);

            return localVarResponse;
        }

        /// <summary>
        /// Mint fungible tokens 2 credits per API call Create new fungible tokens in the smart contract (the contractAddress parameter in the request body) and transfer them to the specified blockchain address (the to parameter in the request body). You can mint new fungible tokens only if the current supply of tokens in the smart contract is lower than the total supply set for this contract. This API is supported for the following blockchains: BNB Smart Chain Celo Ethereum Harmony Klaytn KuCoin Community Chain Polygon XinFin Signing a transaction When minting fungible tokens, you are charged a fee for the transaction, and you must sign the transaction with the private key of the blockchain address from which the fee will be deducted. Providing the private key in the API is not a secure way of signing transactions, because the private key can be stolen or exposed. Your private keys should never leave your security perimeter. You should use the private keys only for testing a solution you are building on the testnet of a blockchain. For signing transactions on the mainnet, we strongly recommend that you use the Tatum Key Management System (KMS) and provide the signature ID instead of the private key in the API. Alternatively, you can use the Tatum JavaScript client.
        /// </summary>
        /// <exception cref="Tatum.CSharp.FungibleTokens.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="chainMintErc20"></param>
        /// <param name="xTestnetType">Type of Ethereum testnet. Defaults to Sepolia. Valid only for ETH invocations for testnet API Key. For mainnet API Key, this value is ignored. (optional, default to ethereum-sepolia)</param>
        /// <returns>TransactionHash</returns>
        public TransactionHash Erc20Mint(ChainMintErc20 chainMintErc20, string xTestnetType = default(string))
        {
            var localVarResponse = Erc20MintWithHttpInfo(chainMintErc20, xTestnetType);

            var exception = ExceptionFactory?.Invoke("Erc20Mint", localVarResponse);
            if (exception != null) throw exception;

            return localVarResponse.Data;
        }

        /// <summary>
        /// Mint fungible tokens 2 credits per API call Create new fungible tokens in the smart contract (the contractAddress parameter in the request body) and transfer them to the specified blockchain address (the to parameter in the request body). You can mint new fungible tokens only if the current supply of tokens in the smart contract is lower than the total supply set for this contract. This API is supported for the following blockchains: BNB Smart Chain Celo Ethereum Harmony Klaytn KuCoin Community Chain Polygon XinFin Signing a transaction When minting fungible tokens, you are charged a fee for the transaction, and you must sign the transaction with the private key of the blockchain address from which the fee will be deducted. Providing the private key in the API is not a secure way of signing transactions, because the private key can be stolen or exposed. Your private keys should never leave your security perimeter. You should use the private keys only for testing a solution you are building on the testnet of a blockchain. For signing transactions on the mainnet, we strongly recommend that you use the Tatum Key Management System (KMS) and provide the signature ID instead of the private key in the API. Alternatively, you can use the Tatum JavaScript client.
        /// </summary>
        /// <exception cref="Tatum.CSharp.FungibleTokens.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="chainMintErc20"></param>
        /// <param name="xTestnetType">Type of Ethereum testnet. Defaults to Sepolia. Valid only for ETH invocations for testnet API Key. For mainnet API Key, this value is ignored. (optional, default to ethereum-sepolia)</param>
        /// <returns>ApiResponse of TransactionHash</returns>
        public ApiResponse<TransactionHash> Erc20MintWithHttpInfo(ChainMintErc20 chainMintErc20, string xTestnetType = default(string))
        {
            // verify the required parameter 'chainMintErc20' is set
            if (chainMintErc20 == null)
                throw new ApiException(400, "Missing required parameter 'chainMintErc20' when calling FungibleTokensEthApi->Erc20Mint");

            var localVarRequestOptions = new RequestOptions();

            var contentTypes = new string[]{
                "application/json"
            };

            // to determine the Accept header
            var accepts = new string[]{
                "application/json"
            };

            var localVarContentType = ClientUtils.SelectHeaderContentType(contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = ClientUtils.SelectHeaderAccept(accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            if (xTestnetType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("x-testnet-type", ClientUtils.ParameterToString(xTestnetType)); // header parameter
            }
            localVarRequestOptions.Data = chainMintErc20;

            // authentication (X-API-Key) required
            if (!string.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("x-api-key")))
            {
                localVarRequestOptions.HeaderParameters.Add("x-api-key", Configuration.GetApiKeyWithPrefix("x-api-key"));
            }

            // make the HTTP request
            var localVarResponse = Client.Post<TransactionHash>("/v3/blockchain/token/mint", localVarRequestOptions, Configuration);

            return localVarResponse;
        }

        /// <summary>
        /// Mint fungible tokens 2 credits per API call Create new fungible tokens in the smart contract (the contractAddress parameter in the request body) and transfer them to the specified blockchain address (the to parameter in the request body). You can mint new fungible tokens only if the current supply of tokens in the smart contract is lower than the total supply set for this contract. This API is supported for the following blockchains: BNB Smart Chain Celo Ethereum Harmony Klaytn KuCoin Community Chain Polygon XinFin Signing a transaction When minting fungible tokens, you are charged a fee for the transaction, and you must sign the transaction with the private key of the blockchain address from which the fee will be deducted. Providing the private key in the API is not a secure way of signing transactions, because the private key can be stolen or exposed. Your private keys should never leave your security perimeter. You should use the private keys only for testing a solution you are building on the testnet of a blockchain. For signing transactions on the mainnet, we strongly recommend that you use the Tatum Key Management System (KMS) and provide the signature ID instead of the private key in the API. Alternatively, you can use the Tatum JavaScript client.
        /// </summary>
        /// <exception cref="Tatum.CSharp.FungibleTokens.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="chainMintErc20"></param>
        /// <param name="xTestnetType">Type of Ethereum testnet. Defaults to Sepolia. Valid only for ETH invocations for testnet API Key. For mainnet API Key, this value is ignored. (optional, default to ethereum-sepolia)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of TransactionHash</returns>
        public async System.Threading.Tasks.Task<TransactionHash> Erc20MintAsync(ChainMintErc20 chainMintErc20, string xTestnetType = default(string), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            var localVarResponse = await Erc20MintWithHttpInfoAsync(chainMintErc20, xTestnetType, cancellationToken).ConfigureAwait(false);
            
            var exception = ExceptionFactory?.Invoke("Erc20Mint", localVarResponse);
            if (exception != null) throw exception;

            return localVarResponse.Data;
        }

        /// <summary>
        /// Mint fungible tokens 2 credits per API call Create new fungible tokens in the smart contract (the contractAddress parameter in the request body) and transfer them to the specified blockchain address (the to parameter in the request body). You can mint new fungible tokens only if the current supply of tokens in the smart contract is lower than the total supply set for this contract. This API is supported for the following blockchains: BNB Smart Chain Celo Ethereum Harmony Klaytn KuCoin Community Chain Polygon XinFin Signing a transaction When minting fungible tokens, you are charged a fee for the transaction, and you must sign the transaction with the private key of the blockchain address from which the fee will be deducted. Providing the private key in the API is not a secure way of signing transactions, because the private key can be stolen or exposed. Your private keys should never leave your security perimeter. You should use the private keys only for testing a solution you are building on the testnet of a blockchain. For signing transactions on the mainnet, we strongly recommend that you use the Tatum Key Management System (KMS) and provide the signature ID instead of the private key in the API. Alternatively, you can use the Tatum JavaScript client.
        /// </summary>
        /// <exception cref="Tatum.CSharp.FungibleTokens.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="chainMintErc20"></param>
        /// <param name="xTestnetType">Type of Ethereum testnet. Defaults to Sepolia. Valid only for ETH invocations for testnet API Key. For mainnet API Key, this value is ignored. (optional, default to ethereum-sepolia)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (TransactionHash)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<TransactionHash>> Erc20MintWithHttpInfoAsync(ChainMintErc20 chainMintErc20, string xTestnetType = default(string), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            // verify the required parameter 'chainMintErc20' is set
            if (chainMintErc20 == null)
                throw new ApiException(400, "Missing required parameter 'chainMintErc20' when calling FungibleTokensEthApi->Erc20Mint");

            var localVarRequestOptions = new RequestOptions();

            var contentTypes = new string[]{
                "application/json"
            };

            // to determine the Accept header
            var accepts = new string[]{
                "application/json"
            };


            var localVarContentType = ClientUtils.SelectHeaderContentType(contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = ClientUtils.SelectHeaderAccept(accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            if (xTestnetType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("x-testnet-type", ClientUtils.ParameterToString(xTestnetType)); // header parameter
            }
            localVarRequestOptions.Data = chainMintErc20;

            // authentication (X-API-Key) required
            if (!string.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("x-api-key")))
            {
                localVarRequestOptions.HeaderParameters.Add("x-api-key", Configuration.GetApiKeyWithPrefix("x-api-key"));
            }

            // make the HTTP request

            var localVarResponse = await AsynchronousClient.PostAsync<TransactionHash>("/v3/blockchain/token/mint", localVarRequestOptions, Configuration, cancellationToken).ConfigureAwait(false);

            return localVarResponse;
        }

        /// <summary>
        /// Mint fungible tokens 2 credits per API call Create new fungible tokens in the smart contract (the contractAddress parameter in the request body) and transfer them to the specified blockchain address (the to parameter in the request body). You can mint new fungible tokens only if the current supply of tokens in the smart contract is lower than the total supply set for this contract. This API is supported for the following blockchains: BNB Smart Chain Celo Ethereum Harmony Klaytn KuCoin Community Chain Polygon XinFin Signing a transaction When minting fungible tokens, you are charged a fee for the transaction, and you must sign the transaction with the private key of the blockchain address from which the fee will be deducted. Providing the private key in the API is not a secure way of signing transactions, because the private key can be stolen or exposed. Your private keys should never leave your security perimeter. You should use the private keys only for testing a solution you are building on the testnet of a blockchain. For signing transactions on the mainnet, we strongly recommend that you use the Tatum Key Management System (KMS) and provide the signature ID instead of the private key in the API. Alternatively, you can use the Tatum JavaScript client.
        /// </summary>
        /// <exception cref="Tatum.CSharp.FungibleTokens.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="chainMintErc20KMS"></param>
        /// <param name="xTestnetType">Type of Ethereum testnet. Defaults to Sepolia. Valid only for ETH invocations for testnet API Key. For mainnet API Key, this value is ignored. (optional, default to ethereum-sepolia)</param>
        /// <returns>SignatureId</returns>
        public SignatureId Erc20Mint(ChainMintErc20KMS chainMintErc20KMS, string xTestnetType = default(string))
        {
            var localVarResponse = Erc20MintWithHttpInfo(chainMintErc20KMS, xTestnetType);

            var exception = ExceptionFactory?.Invoke("Erc20Mint_0", localVarResponse);
            if (exception != null) throw exception;

            return localVarResponse.Data;
        }

        /// <summary>
        /// Mint fungible tokens 2 credits per API call Create new fungible tokens in the smart contract (the contractAddress parameter in the request body) and transfer them to the specified blockchain address (the to parameter in the request body). You can mint new fungible tokens only if the current supply of tokens in the smart contract is lower than the total supply set for this contract. This API is supported for the following blockchains: BNB Smart Chain Celo Ethereum Harmony Klaytn KuCoin Community Chain Polygon XinFin Signing a transaction When minting fungible tokens, you are charged a fee for the transaction, and you must sign the transaction with the private key of the blockchain address from which the fee will be deducted. Providing the private key in the API is not a secure way of signing transactions, because the private key can be stolen or exposed. Your private keys should never leave your security perimeter. You should use the private keys only for testing a solution you are building on the testnet of a blockchain. For signing transactions on the mainnet, we strongly recommend that you use the Tatum Key Management System (KMS) and provide the signature ID instead of the private key in the API. Alternatively, you can use the Tatum JavaScript client.
        /// </summary>
        /// <exception cref="Tatum.CSharp.FungibleTokens.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="chainMintErc20KMS"></param>
        /// <param name="xTestnetType">Type of Ethereum testnet. Defaults to Sepolia. Valid only for ETH invocations for testnet API Key. For mainnet API Key, this value is ignored. (optional, default to ethereum-sepolia)</param>
        /// <returns>ApiResponse of SignatureId</returns>
        public ApiResponse<SignatureId> Erc20MintWithHttpInfo(ChainMintErc20KMS chainMintErc20KMS, string xTestnetType = default(string))
        {
            // verify the required parameter 'chainMintErc20KMS' is set
            if (chainMintErc20KMS == null)
                throw new ApiException(400, "Missing required parameter 'chainMintErc20KMS' when calling FungibleTokensEthApi->Erc20Mint_0");

            var localVarRequestOptions = new RequestOptions();

            var contentTypes = new string[]{
                "application/json"
            };

            // to determine the Accept header
            var accepts = new string[]{
                "application/json"
            };

            var localVarContentType = ClientUtils.SelectHeaderContentType(contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = ClientUtils.SelectHeaderAccept(accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            if (xTestnetType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("x-testnet-type", ClientUtils.ParameterToString(xTestnetType)); // header parameter
            }
            localVarRequestOptions.Data = chainMintErc20KMS;

            // authentication (X-API-Key) required
            if (!string.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("x-api-key")))
            {
                localVarRequestOptions.HeaderParameters.Add("x-api-key", Configuration.GetApiKeyWithPrefix("x-api-key"));
            }

            // make the HTTP request
            var localVarResponse = Client.Post<SignatureId>("/v3/blockchain/token/mint", localVarRequestOptions, Configuration);

            return localVarResponse;
        }

        /// <summary>
        /// Mint fungible tokens 2 credits per API call Create new fungible tokens in the smart contract (the contractAddress parameter in the request body) and transfer them to the specified blockchain address (the to parameter in the request body). You can mint new fungible tokens only if the current supply of tokens in the smart contract is lower than the total supply set for this contract. This API is supported for the following blockchains: BNB Smart Chain Celo Ethereum Harmony Klaytn KuCoin Community Chain Polygon XinFin Signing a transaction When minting fungible tokens, you are charged a fee for the transaction, and you must sign the transaction with the private key of the blockchain address from which the fee will be deducted. Providing the private key in the API is not a secure way of signing transactions, because the private key can be stolen or exposed. Your private keys should never leave your security perimeter. You should use the private keys only for testing a solution you are building on the testnet of a blockchain. For signing transactions on the mainnet, we strongly recommend that you use the Tatum Key Management System (KMS) and provide the signature ID instead of the private key in the API. Alternatively, you can use the Tatum JavaScript client.
        /// </summary>
        /// <exception cref="Tatum.CSharp.FungibleTokens.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="chainMintErc20KMS"></param>
        /// <param name="xTestnetType">Type of Ethereum testnet. Defaults to Sepolia. Valid only for ETH invocations for testnet API Key. For mainnet API Key, this value is ignored. (optional, default to ethereum-sepolia)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of SignatureId</returns>
        public async System.Threading.Tasks.Task<SignatureId> Erc20MintAsync(ChainMintErc20KMS chainMintErc20KMS, string xTestnetType = default(string), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            var localVarResponse = await Erc20MintWithHttpInfoAsync(chainMintErc20KMS, xTestnetType, cancellationToken).ConfigureAwait(false);
            
            var exception = ExceptionFactory?.Invoke("Erc20Mint_0", localVarResponse);
            if (exception != null) throw exception;

            return localVarResponse.Data;
        }

        /// <summary>
        /// Mint fungible tokens 2 credits per API call Create new fungible tokens in the smart contract (the contractAddress parameter in the request body) and transfer them to the specified blockchain address (the to parameter in the request body). You can mint new fungible tokens only if the current supply of tokens in the smart contract is lower than the total supply set for this contract. This API is supported for the following blockchains: BNB Smart Chain Celo Ethereum Harmony Klaytn KuCoin Community Chain Polygon XinFin Signing a transaction When minting fungible tokens, you are charged a fee for the transaction, and you must sign the transaction with the private key of the blockchain address from which the fee will be deducted. Providing the private key in the API is not a secure way of signing transactions, because the private key can be stolen or exposed. Your private keys should never leave your security perimeter. You should use the private keys only for testing a solution you are building on the testnet of a blockchain. For signing transactions on the mainnet, we strongly recommend that you use the Tatum Key Management System (KMS) and provide the signature ID instead of the private key in the API. Alternatively, you can use the Tatum JavaScript client.
        /// </summary>
        /// <exception cref="Tatum.CSharp.FungibleTokens.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="chainMintErc20KMS"></param>
        /// <param name="xTestnetType">Type of Ethereum testnet. Defaults to Sepolia. Valid only for ETH invocations for testnet API Key. For mainnet API Key, this value is ignored. (optional, default to ethereum-sepolia)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (SignatureId)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<SignatureId>> Erc20MintWithHttpInfoAsync(ChainMintErc20KMS chainMintErc20KMS, string xTestnetType = default(string), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            // verify the required parameter 'chainMintErc20KMS' is set
            if (chainMintErc20KMS == null)
                throw new ApiException(400, "Missing required parameter 'chainMintErc20KMS' when calling FungibleTokensEthApi->Erc20Mint_0");

            var localVarRequestOptions = new RequestOptions();

            var contentTypes = new string[]{
                "application/json"
            };

            // to determine the Accept header
            var accepts = new string[]{
                "application/json"
            };


            var localVarContentType = ClientUtils.SelectHeaderContentType(contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = ClientUtils.SelectHeaderAccept(accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            if (xTestnetType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("x-testnet-type", ClientUtils.ParameterToString(xTestnetType)); // header parameter
            }
            localVarRequestOptions.Data = chainMintErc20KMS;

            // authentication (X-API-Key) required
            if (!string.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("x-api-key")))
            {
                localVarRequestOptions.HeaderParameters.Add("x-api-key", Configuration.GetApiKeyWithPrefix("x-api-key"));
            }

            // make the HTTP request

            var localVarResponse = await AsynchronousClient.PostAsync<SignatureId>("/v3/blockchain/token/mint", localVarRequestOptions, Configuration, cancellationToken).ConfigureAwait(false);

            return localVarResponse;
        }

        /// <summary>
        /// Transfer fungible tokens 2 credits per API call Transfer a supply of fungible tokens existing in the smart contract (the contractAddress parameter in the request body) to the specified blockchain address (the to parameter in the request body). Transferring fungible tokens invokes the transfer() method. This API is supported for the following blockchains: Algorand BNB Smart Chain Celo Ethereum Harmony Klaytn KuCoin Community Chain Polygon Solana XinFin Transferring fungible tokens on Algorand On Algorand, the recipient has to agree in advance to receive your fungible tokens because Algorand charges users for storing the tokens on their addresses, and an Algorand blockchain address by default does not receive the tokens unless explicitly agreed. Before transferring the fungible tokens, make sure that the recipient has agreed to receive the NFT to their address. Blockchain-specific APIs to transfer fungible tokens You can also use blockchain-specific APIs for transferring fungible tokens on the following blockchains: BNB Smart Chain Celo Ethereum Harmony KuCoin Community Chain Polygon XinFin Signing a transaction When transferring fungible tokens, you are charged a fee for the transaction, and you must sign the transaction with the private key of the blockchain address from which the fee will be deducted. Providing the private key in the API is not a secure way of signing transactions, because the private key can be stolen or exposed. Your private keys should never leave your security perimeter. You should use the private keys only for testing a solution you are building on the testnet of a blockchain. For signing transactions on the mainnet, we strongly recommend that you use the Tatum Key Management System (KMS) and provide the signature ID instead of the private key in the API. Alternatively, you can use the Tatum JavaScript client.
        /// </summary>
        /// <exception cref="Tatum.CSharp.FungibleTokens.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="chainTransferEthErc20"></param>
        /// <param name="xTestnetType">Type of Ethereum testnet. Defaults to Sepolia. Valid only for ETH invocations for testnet API Key. For mainnet API Key, this value is ignored. (optional, default to ethereum-sepolia)</param>
        /// <returns>TransactionHash</returns>
        public TransactionHash Erc20Transfer(ChainTransferEthErc20 chainTransferEthErc20, string xTestnetType = default(string))
        {
            var localVarResponse = Erc20TransferWithHttpInfo(chainTransferEthErc20, xTestnetType);

            var exception = ExceptionFactory?.Invoke("Erc20Transfer", localVarResponse);
            if (exception != null) throw exception;

            return localVarResponse.Data;
        }

        /// <summary>
        /// Transfer fungible tokens 2 credits per API call Transfer a supply of fungible tokens existing in the smart contract (the contractAddress parameter in the request body) to the specified blockchain address (the to parameter in the request body). Transferring fungible tokens invokes the transfer() method. This API is supported for the following blockchains: Algorand BNB Smart Chain Celo Ethereum Harmony Klaytn KuCoin Community Chain Polygon Solana XinFin Transferring fungible tokens on Algorand On Algorand, the recipient has to agree in advance to receive your fungible tokens because Algorand charges users for storing the tokens on their addresses, and an Algorand blockchain address by default does not receive the tokens unless explicitly agreed. Before transferring the fungible tokens, make sure that the recipient has agreed to receive the NFT to their address. Blockchain-specific APIs to transfer fungible tokens You can also use blockchain-specific APIs for transferring fungible tokens on the following blockchains: BNB Smart Chain Celo Ethereum Harmony KuCoin Community Chain Polygon XinFin Signing a transaction When transferring fungible tokens, you are charged a fee for the transaction, and you must sign the transaction with the private key of the blockchain address from which the fee will be deducted. Providing the private key in the API is not a secure way of signing transactions, because the private key can be stolen or exposed. Your private keys should never leave your security perimeter. You should use the private keys only for testing a solution you are building on the testnet of a blockchain. For signing transactions on the mainnet, we strongly recommend that you use the Tatum Key Management System (KMS) and provide the signature ID instead of the private key in the API. Alternatively, you can use the Tatum JavaScript client.
        /// </summary>
        /// <exception cref="Tatum.CSharp.FungibleTokens.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="chainTransferEthErc20"></param>
        /// <param name="xTestnetType">Type of Ethereum testnet. Defaults to Sepolia. Valid only for ETH invocations for testnet API Key. For mainnet API Key, this value is ignored. (optional, default to ethereum-sepolia)</param>
        /// <returns>ApiResponse of TransactionHash</returns>
        public ApiResponse<TransactionHash> Erc20TransferWithHttpInfo(ChainTransferEthErc20 chainTransferEthErc20, string xTestnetType = default(string))
        {
            // verify the required parameter 'chainTransferEthErc20' is set
            if (chainTransferEthErc20 == null)
                throw new ApiException(400, "Missing required parameter 'chainTransferEthErc20' when calling FungibleTokensEthApi->Erc20Transfer");

            var localVarRequestOptions = new RequestOptions();

            var contentTypes = new string[]{
                "application/json"
            };

            // to determine the Accept header
            var accepts = new string[]{
                "application/json"
            };

            var localVarContentType = ClientUtils.SelectHeaderContentType(contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = ClientUtils.SelectHeaderAccept(accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            if (xTestnetType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("x-testnet-type", ClientUtils.ParameterToString(xTestnetType)); // header parameter
            }
            localVarRequestOptions.Data = chainTransferEthErc20;

            // authentication (X-API-Key) required
            if (!string.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("x-api-key")))
            {
                localVarRequestOptions.HeaderParameters.Add("x-api-key", Configuration.GetApiKeyWithPrefix("x-api-key"));
            }

            // make the HTTP request
            var localVarResponse = Client.Post<TransactionHash>("/v3/blockchain/token/transaction", localVarRequestOptions, Configuration);

            return localVarResponse;
        }

        /// <summary>
        /// Transfer fungible tokens 2 credits per API call Transfer a supply of fungible tokens existing in the smart contract (the contractAddress parameter in the request body) to the specified blockchain address (the to parameter in the request body). Transferring fungible tokens invokes the transfer() method. This API is supported for the following blockchains: Algorand BNB Smart Chain Celo Ethereum Harmony Klaytn KuCoin Community Chain Polygon Solana XinFin Transferring fungible tokens on Algorand On Algorand, the recipient has to agree in advance to receive your fungible tokens because Algorand charges users for storing the tokens on their addresses, and an Algorand blockchain address by default does not receive the tokens unless explicitly agreed. Before transferring the fungible tokens, make sure that the recipient has agreed to receive the NFT to their address. Blockchain-specific APIs to transfer fungible tokens You can also use blockchain-specific APIs for transferring fungible tokens on the following blockchains: BNB Smart Chain Celo Ethereum Harmony KuCoin Community Chain Polygon XinFin Signing a transaction When transferring fungible tokens, you are charged a fee for the transaction, and you must sign the transaction with the private key of the blockchain address from which the fee will be deducted. Providing the private key in the API is not a secure way of signing transactions, because the private key can be stolen or exposed. Your private keys should never leave your security perimeter. You should use the private keys only for testing a solution you are building on the testnet of a blockchain. For signing transactions on the mainnet, we strongly recommend that you use the Tatum Key Management System (KMS) and provide the signature ID instead of the private key in the API. Alternatively, you can use the Tatum JavaScript client.
        /// </summary>
        /// <exception cref="Tatum.CSharp.FungibleTokens.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="chainTransferEthErc20"></param>
        /// <param name="xTestnetType">Type of Ethereum testnet. Defaults to Sepolia. Valid only for ETH invocations for testnet API Key. For mainnet API Key, this value is ignored. (optional, default to ethereum-sepolia)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of TransactionHash</returns>
        public async System.Threading.Tasks.Task<TransactionHash> Erc20TransferAsync(ChainTransferEthErc20 chainTransferEthErc20, string xTestnetType = default(string), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            var localVarResponse = await Erc20TransferWithHttpInfoAsync(chainTransferEthErc20, xTestnetType, cancellationToken).ConfigureAwait(false);
            
            var exception = ExceptionFactory?.Invoke("Erc20Transfer", localVarResponse);
            if (exception != null) throw exception;

            return localVarResponse.Data;
        }

        /// <summary>
        /// Transfer fungible tokens 2 credits per API call Transfer a supply of fungible tokens existing in the smart contract (the contractAddress parameter in the request body) to the specified blockchain address (the to parameter in the request body). Transferring fungible tokens invokes the transfer() method. This API is supported for the following blockchains: Algorand BNB Smart Chain Celo Ethereum Harmony Klaytn KuCoin Community Chain Polygon Solana XinFin Transferring fungible tokens on Algorand On Algorand, the recipient has to agree in advance to receive your fungible tokens because Algorand charges users for storing the tokens on their addresses, and an Algorand blockchain address by default does not receive the tokens unless explicitly agreed. Before transferring the fungible tokens, make sure that the recipient has agreed to receive the NFT to their address. Blockchain-specific APIs to transfer fungible tokens You can also use blockchain-specific APIs for transferring fungible tokens on the following blockchains: BNB Smart Chain Celo Ethereum Harmony KuCoin Community Chain Polygon XinFin Signing a transaction When transferring fungible tokens, you are charged a fee for the transaction, and you must sign the transaction with the private key of the blockchain address from which the fee will be deducted. Providing the private key in the API is not a secure way of signing transactions, because the private key can be stolen or exposed. Your private keys should never leave your security perimeter. You should use the private keys only for testing a solution you are building on the testnet of a blockchain. For signing transactions on the mainnet, we strongly recommend that you use the Tatum Key Management System (KMS) and provide the signature ID instead of the private key in the API. Alternatively, you can use the Tatum JavaScript client.
        /// </summary>
        /// <exception cref="Tatum.CSharp.FungibleTokens.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="chainTransferEthErc20"></param>
        /// <param name="xTestnetType">Type of Ethereum testnet. Defaults to Sepolia. Valid only for ETH invocations for testnet API Key. For mainnet API Key, this value is ignored. (optional, default to ethereum-sepolia)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (TransactionHash)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<TransactionHash>> Erc20TransferWithHttpInfoAsync(ChainTransferEthErc20 chainTransferEthErc20, string xTestnetType = default(string), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            // verify the required parameter 'chainTransferEthErc20' is set
            if (chainTransferEthErc20 == null)
                throw new ApiException(400, "Missing required parameter 'chainTransferEthErc20' when calling FungibleTokensEthApi->Erc20Transfer");

            var localVarRequestOptions = new RequestOptions();

            var contentTypes = new string[]{
                "application/json"
            };

            // to determine the Accept header
            var accepts = new string[]{
                "application/json"
            };


            var localVarContentType = ClientUtils.SelectHeaderContentType(contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = ClientUtils.SelectHeaderAccept(accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            if (xTestnetType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("x-testnet-type", ClientUtils.ParameterToString(xTestnetType)); // header parameter
            }
            localVarRequestOptions.Data = chainTransferEthErc20;

            // authentication (X-API-Key) required
            if (!string.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("x-api-key")))
            {
                localVarRequestOptions.HeaderParameters.Add("x-api-key", Configuration.GetApiKeyWithPrefix("x-api-key"));
            }

            // make the HTTP request

            var localVarResponse = await AsynchronousClient.PostAsync<TransactionHash>("/v3/blockchain/token/transaction", localVarRequestOptions, Configuration, cancellationToken).ConfigureAwait(false);

            return localVarResponse;
        }

        /// <summary>
        /// Transfer fungible tokens 2 credits per API call Transfer a supply of fungible tokens existing in the smart contract (the contractAddress parameter in the request body) to the specified blockchain address (the to parameter in the request body). Transferring fungible tokens invokes the transfer() method. This API is supported for the following blockchains: Algorand BNB Smart Chain Celo Ethereum Harmony Klaytn KuCoin Community Chain Polygon Solana XinFin Transferring fungible tokens on Algorand On Algorand, the recipient has to agree in advance to receive your fungible tokens because Algorand charges users for storing the tokens on their addresses, and an Algorand blockchain address by default does not receive the tokens unless explicitly agreed. Before transferring the fungible tokens, make sure that the recipient has agreed to receive the NFT to their address. Blockchain-specific APIs to transfer fungible tokens You can also use blockchain-specific APIs for transferring fungible tokens on the following blockchains: BNB Smart Chain Celo Ethereum Harmony KuCoin Community Chain Polygon XinFin Signing a transaction When transferring fungible tokens, you are charged a fee for the transaction, and you must sign the transaction with the private key of the blockchain address from which the fee will be deducted. Providing the private key in the API is not a secure way of signing transactions, because the private key can be stolen or exposed. Your private keys should never leave your security perimeter. You should use the private keys only for testing a solution you are building on the testnet of a blockchain. For signing transactions on the mainnet, we strongly recommend that you use the Tatum Key Management System (KMS) and provide the signature ID instead of the private key in the API. Alternatively, you can use the Tatum JavaScript client.
        /// </summary>
        /// <exception cref="Tatum.CSharp.FungibleTokens.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="chainTransferEthErc20KMS"></param>
        /// <param name="xTestnetType">Type of Ethereum testnet. Defaults to Sepolia. Valid only for ETH invocations for testnet API Key. For mainnet API Key, this value is ignored. (optional, default to ethereum-sepolia)</param>
        /// <returns>SignatureId</returns>
        public SignatureId Erc20Transfer(ChainTransferEthErc20KMS chainTransferEthErc20KMS, string xTestnetType = default(string))
        {
            var localVarResponse = Erc20TransferWithHttpInfo(chainTransferEthErc20KMS, xTestnetType);

            var exception = ExceptionFactory?.Invoke("Erc20Transfer_0", localVarResponse);
            if (exception != null) throw exception;

            return localVarResponse.Data;
        }

        /// <summary>
        /// Transfer fungible tokens 2 credits per API call Transfer a supply of fungible tokens existing in the smart contract (the contractAddress parameter in the request body) to the specified blockchain address (the to parameter in the request body). Transferring fungible tokens invokes the transfer() method. This API is supported for the following blockchains: Algorand BNB Smart Chain Celo Ethereum Harmony Klaytn KuCoin Community Chain Polygon Solana XinFin Transferring fungible tokens on Algorand On Algorand, the recipient has to agree in advance to receive your fungible tokens because Algorand charges users for storing the tokens on their addresses, and an Algorand blockchain address by default does not receive the tokens unless explicitly agreed. Before transferring the fungible tokens, make sure that the recipient has agreed to receive the NFT to their address. Blockchain-specific APIs to transfer fungible tokens You can also use blockchain-specific APIs for transferring fungible tokens on the following blockchains: BNB Smart Chain Celo Ethereum Harmony KuCoin Community Chain Polygon XinFin Signing a transaction When transferring fungible tokens, you are charged a fee for the transaction, and you must sign the transaction with the private key of the blockchain address from which the fee will be deducted. Providing the private key in the API is not a secure way of signing transactions, because the private key can be stolen or exposed. Your private keys should never leave your security perimeter. You should use the private keys only for testing a solution you are building on the testnet of a blockchain. For signing transactions on the mainnet, we strongly recommend that you use the Tatum Key Management System (KMS) and provide the signature ID instead of the private key in the API. Alternatively, you can use the Tatum JavaScript client.
        /// </summary>
        /// <exception cref="Tatum.CSharp.FungibleTokens.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="chainTransferEthErc20KMS"></param>
        /// <param name="xTestnetType">Type of Ethereum testnet. Defaults to Sepolia. Valid only for ETH invocations for testnet API Key. For mainnet API Key, this value is ignored. (optional, default to ethereum-sepolia)</param>
        /// <returns>ApiResponse of SignatureId</returns>
        public ApiResponse<SignatureId> Erc20TransferWithHttpInfo(ChainTransferEthErc20KMS chainTransferEthErc20KMS, string xTestnetType = default(string))
        {
            // verify the required parameter 'chainTransferEthErc20KMS' is set
            if (chainTransferEthErc20KMS == null)
                throw new ApiException(400, "Missing required parameter 'chainTransferEthErc20KMS' when calling FungibleTokensEthApi->Erc20Transfer_0");

            var localVarRequestOptions = new RequestOptions();

            var contentTypes = new string[]{
                "application/json"
            };

            // to determine the Accept header
            var accepts = new string[]{
                "application/json"
            };

            var localVarContentType = ClientUtils.SelectHeaderContentType(contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = ClientUtils.SelectHeaderAccept(accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            if (xTestnetType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("x-testnet-type", ClientUtils.ParameterToString(xTestnetType)); // header parameter
            }
            localVarRequestOptions.Data = chainTransferEthErc20KMS;

            // authentication (X-API-Key) required
            if (!string.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("x-api-key")))
            {
                localVarRequestOptions.HeaderParameters.Add("x-api-key", Configuration.GetApiKeyWithPrefix("x-api-key"));
            }

            // make the HTTP request
            var localVarResponse = Client.Post<SignatureId>("/v3/blockchain/token/transaction", localVarRequestOptions, Configuration);

            return localVarResponse;
        }

        /// <summary>
        /// Transfer fungible tokens 2 credits per API call Transfer a supply of fungible tokens existing in the smart contract (the contractAddress parameter in the request body) to the specified blockchain address (the to parameter in the request body). Transferring fungible tokens invokes the transfer() method. This API is supported for the following blockchains: Algorand BNB Smart Chain Celo Ethereum Harmony Klaytn KuCoin Community Chain Polygon Solana XinFin Transferring fungible tokens on Algorand On Algorand, the recipient has to agree in advance to receive your fungible tokens because Algorand charges users for storing the tokens on their addresses, and an Algorand blockchain address by default does not receive the tokens unless explicitly agreed. Before transferring the fungible tokens, make sure that the recipient has agreed to receive the NFT to their address. Blockchain-specific APIs to transfer fungible tokens You can also use blockchain-specific APIs for transferring fungible tokens on the following blockchains: BNB Smart Chain Celo Ethereum Harmony KuCoin Community Chain Polygon XinFin Signing a transaction When transferring fungible tokens, you are charged a fee for the transaction, and you must sign the transaction with the private key of the blockchain address from which the fee will be deducted. Providing the private key in the API is not a secure way of signing transactions, because the private key can be stolen or exposed. Your private keys should never leave your security perimeter. You should use the private keys only for testing a solution you are building on the testnet of a blockchain. For signing transactions on the mainnet, we strongly recommend that you use the Tatum Key Management System (KMS) and provide the signature ID instead of the private key in the API. Alternatively, you can use the Tatum JavaScript client.
        /// </summary>
        /// <exception cref="Tatum.CSharp.FungibleTokens.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="chainTransferEthErc20KMS"></param>
        /// <param name="xTestnetType">Type of Ethereum testnet. Defaults to Sepolia. Valid only for ETH invocations for testnet API Key. For mainnet API Key, this value is ignored. (optional, default to ethereum-sepolia)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of SignatureId</returns>
        public async System.Threading.Tasks.Task<SignatureId> Erc20TransferAsync(ChainTransferEthErc20KMS chainTransferEthErc20KMS, string xTestnetType = default(string), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            var localVarResponse = await Erc20TransferWithHttpInfoAsync(chainTransferEthErc20KMS, xTestnetType, cancellationToken).ConfigureAwait(false);
            
            var exception = ExceptionFactory?.Invoke("Erc20Transfer_0", localVarResponse);
            if (exception != null) throw exception;

            return localVarResponse.Data;
        }

        /// <summary>
        /// Transfer fungible tokens 2 credits per API call Transfer a supply of fungible tokens existing in the smart contract (the contractAddress parameter in the request body) to the specified blockchain address (the to parameter in the request body). Transferring fungible tokens invokes the transfer() method. This API is supported for the following blockchains: Algorand BNB Smart Chain Celo Ethereum Harmony Klaytn KuCoin Community Chain Polygon Solana XinFin Transferring fungible tokens on Algorand On Algorand, the recipient has to agree in advance to receive your fungible tokens because Algorand charges users for storing the tokens on their addresses, and an Algorand blockchain address by default does not receive the tokens unless explicitly agreed. Before transferring the fungible tokens, make sure that the recipient has agreed to receive the NFT to their address. Blockchain-specific APIs to transfer fungible tokens You can also use blockchain-specific APIs for transferring fungible tokens on the following blockchains: BNB Smart Chain Celo Ethereum Harmony KuCoin Community Chain Polygon XinFin Signing a transaction When transferring fungible tokens, you are charged a fee for the transaction, and you must sign the transaction with the private key of the blockchain address from which the fee will be deducted. Providing the private key in the API is not a secure way of signing transactions, because the private key can be stolen or exposed. Your private keys should never leave your security perimeter. You should use the private keys only for testing a solution you are building on the testnet of a blockchain. For signing transactions on the mainnet, we strongly recommend that you use the Tatum Key Management System (KMS) and provide the signature ID instead of the private key in the API. Alternatively, you can use the Tatum JavaScript client.
        /// </summary>
        /// <exception cref="Tatum.CSharp.FungibleTokens.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="chainTransferEthErc20KMS"></param>
        /// <param name="xTestnetType">Type of Ethereum testnet. Defaults to Sepolia. Valid only for ETH invocations for testnet API Key. For mainnet API Key, this value is ignored. (optional, default to ethereum-sepolia)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (SignatureId)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<SignatureId>> Erc20TransferWithHttpInfoAsync(ChainTransferEthErc20KMS chainTransferEthErc20KMS, string xTestnetType = default(string), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            // verify the required parameter 'chainTransferEthErc20KMS' is set
            if (chainTransferEthErc20KMS == null)
                throw new ApiException(400, "Missing required parameter 'chainTransferEthErc20KMS' when calling FungibleTokensEthApi->Erc20Transfer_0");

            var localVarRequestOptions = new RequestOptions();

            var contentTypes = new string[]{
                "application/json"
            };

            // to determine the Accept header
            var accepts = new string[]{
                "application/json"
            };


            var localVarContentType = ClientUtils.SelectHeaderContentType(contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = ClientUtils.SelectHeaderAccept(accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            if (xTestnetType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("x-testnet-type", ClientUtils.ParameterToString(xTestnetType)); // header parameter
            }
            localVarRequestOptions.Data = chainTransferEthErc20KMS;

            // authentication (X-API-Key) required
            if (!string.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("x-api-key")))
            {
                localVarRequestOptions.HeaderParameters.Add("x-api-key", Configuration.GetApiKeyWithPrefix("x-api-key"));
            }

            // make the HTTP request

            var localVarResponse = await AsynchronousClient.PostAsync<SignatureId>("/v3/blockchain/token/transaction", localVarRequestOptions, Configuration, cancellationToken).ConfigureAwait(false);

            return localVarResponse;
        }

    }
}
